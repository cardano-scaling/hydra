-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Haskell API for Cardano, tailored to the Hydra project.
@package hydra-cardano-api
@version 1.1.0

module Hydra.Cardano.Api.NetworkMagic
instance Data.Aeson.Types.ToJSON.ToJSON Ouroboros.Network.Magic.NetworkMagic
instance Data.Aeson.Types.FromJSON.FromJSON Ouroboros.Network.Magic.NetworkMagic
instance Test.QuickCheck.Arbitrary.Arbitrary Ouroboros.Network.Magic.NetworkMagic

module Hydra.Cardano.Api.Prelude

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data () => Proxy (t :: k)
Proxy :: Proxy (t :: k)
class () => Pretty a
pretty :: Pretty a => a -> Doc ann
prettyList :: Pretty a => [a] -> Doc ann
class (Eq VerificationKey keyrole, Show VerificationKey keyrole, SerialiseAsRawBytes Hash keyrole, HasTextEnvelope VerificationKey keyrole, HasTextEnvelope SigningKey keyrole) => Key keyrole where {
    data family VerificationKey keyrole;
    data family SigningKey keyrole;
}
getVerificationKey :: Key keyrole => SigningKey keyrole -> VerificationKey keyrole
deterministicSigningKey :: Key keyrole => AsType keyrole -> Seed -> SigningKey keyrole
deterministicSigningKeySeedSize :: Key keyrole => AsType keyrole -> Word
verificationKeyHash :: Key keyrole => VerificationKey keyrole -> Hash keyrole
data () => Block era
[ByronBlock] :: ByronBlock -> Block ByronEra
[ShelleyBlock] :: forall era. ShelleyBasedEra era -> ShelleyBlock (ConsensusProtocol era) (ShelleyLedgerEra era) -> Block era

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   • Couldn't match type ‘IO’ with ‘StateT s IO’
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a
newtype () => File content (direction :: FileDirection)
File :: FilePath -> File content (direction :: FileDirection)
[unFile] :: File content (direction :: FileDirection) -> FilePath

-- | A monad transformer that adds exceptions to other monads.
--   
--   <tt>ExceptT</tt> constructs a monad parameterized over two things:
--   
--   <ul>
--   <li>e - The exception type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a computation that produces the
--   given value, while <tt>&gt;&gt;=</tt> sequences two subcomputations,
--   exiting on the first exception.
newtype () => ExceptT e (m :: Type -> Type) a
ExceptT :: m (Either e a) -> ExceptT e (m :: Type -> Type) a

-- | The parameterizable exception monad.
--   
--   Computations are either exceptions or normal values.
--   
--   The <a>return</a> function returns a normal value, while
--   <tt>&gt;&gt;=</tt> exits on the first exception. For a variant that
--   continues after an error and collects all the errors, see
--   <a>Errors</a>.
type Except e = ExceptT e Identity

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <tt>Error</tt> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | A handler function to handle previous errors and return to normal
--   execution. A common idiom is:
--   
--   <pre>
--   do { action1; action2; action3 } `catchError` handler
--   </pre>
--   
--   where the <tt>action</tt> functions can call <a>throwError</a>. Note
--   that <tt>handler</tt> and the do-block must have the same return type.
catchError :: MonadError e m => m a -> (e -> m a) -> m a

-- | The class of monad transformers. For any monad <tt>m</tt>, the result
--   <tt>t m</tt> should also be a monad, and <a>lift</a> should be a monad
--   transformation from <tt>m</tt> to <tt>t m</tt>, i.e. it should satisfy
--   the following laws:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
--   
--   Since 0.6.0.0 and for GHC 8.6 and later, the requirement that <tt>t
--   m</tt> be a <a>Monad</a> is enforced by the implication constraint
--   <tt>forall m. <a>Monad</a> m =&gt; <a>Monad</a> (t m)</tt> enabled by
--   the <tt>QuantifiedConstraints</tt> extension.
--   
--   <h3><b>Ambiguity error with GHC 9.0 to 9.2.2</b></h3>
--   
--   These versions of GHC have a bug
--   (<a>https://gitlab.haskell.org/ghc/ghc/-/issues/20582</a>) which
--   causes constraints like
--   
--   <pre>
--   (MonadTrans t, forall m. Monad m =&gt; Monad (t m)) =&gt; ...
--   </pre>
--   
--   to be reported as ambiguous. For transformers 0.6 and later, this can
--   be fixed by removing the second constraint, which is implied by the
--   first.
class forall (m :: Type -> Type). Monad m => Monad t m => MonadTrans (t :: Type -> Type -> Type -> Type)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a
class () => Error e
prettyError :: Error e => e -> Doc ann
data () => Doc ann
data family Body cip
newtype () => LedgerProtocolParameters era
LedgerProtocolParameters :: PParams (ShelleyLedgerEra era) -> LedgerProtocolParameters era
[unLedgerProtocolParameters] :: LedgerProtocolParameters era -> PParams (ShelleyLedgerEra era)
data () => AddressInEra era
[AddressInEra] :: forall addrtype era. AddressTypeInEra addrtype era -> Address addrtype -> AddressInEra era
data () => AddressTypeInEra addrtype era
[ByronAddressInAnyEra] :: forall era. AddressTypeInEra ByronAddr era
[ShelleyAddressInEra] :: forall era. ShelleyBasedEra era -> AddressTypeInEra ShelleyAddr era
data () => BalancedTxBody era
BalancedTxBody :: TxBodyContent BuildTx era -> TxBody era -> TxOut CtxTx era -> Coin -> BalancedTxBody era
data () => KeyWitness era
[ByronKeyWitness] :: TxInWitness -> KeyWitness ByronEra
[ShelleyBootstrapWitness] :: forall era. ShelleyBasedEra era -> BootstrapWitness -> KeyWitness era
[ShelleyKeyWitness] :: forall era. ShelleyBasedEra era -> WitVKey 'Witness -> KeyWitness era
data () => PlutusScript lang
[PlutusScriptSerialised] :: forall lang. ShortByteString -> PlutusScript lang
data () => ReferenceScript era
[ReferenceScript] :: forall era. BabbageEraOnwards era -> ScriptInAnyLang -> ReferenceScript era
[ReferenceScriptNone] :: forall era. ReferenceScript era
data () => Script lang
[SimpleScript] :: !SimpleScript -> Script SimpleScript'
[PlutusScript] :: forall lang. IsPlutusScriptLanguage lang => !PlutusScriptVersion lang -> !PlutusScript lang -> Script lang
data () => ScriptInEra era
[ScriptInEra] :: forall lang era. ScriptLanguageInEra lang era -> Script lang -> ScriptInEra era
data () => ScriptLanguage lang
[SimpleScriptLanguage] :: ScriptLanguage SimpleScript'
[PlutusScriptLanguage] :: forall lang. IsPlutusScriptLanguage lang => PlutusScriptVersion lang -> ScriptLanguage lang
data () => ScriptWitness witctx era
[SimpleScriptWitness] :: forall era witctx. ScriptLanguageInEra SimpleScript' era -> SimpleScriptOrReferenceInput SimpleScript' -> ScriptWitness witctx era
[PlutusScriptWitness] :: forall lang era witctx. IsPlutusScriptLanguage lang => ScriptLanguageInEra lang era -> PlutusScriptVersion lang -> PlutusScriptOrReferenceInput lang -> ScriptDatum witctx -> ScriptRedeemer -> ExecutionUnits -> ScriptWitness witctx era
data () => Tx era
[ShelleyTx] :: forall era. ShelleyBasedEra era -> Tx (ShelleyLedgerEra era) -> Tx era
pattern Tx :: TxBody era -> [KeyWitness era] -> Tx era
data () => TxAuxScripts era
[TxAuxScriptsNone] :: forall era. TxAuxScripts era
[TxAuxScripts] :: forall era. AllegraEraOnwards era -> [ScriptInEra era] -> TxAuxScripts era
data () => TxBody era
[ShelleyTxBody] :: forall era. ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> [Script (ShelleyLedgerEra era)] -> TxBodyScriptData era -> Maybe (TxAuxData (ShelleyLedgerEra era)) -> TxScriptValidity era -> TxBody era
pattern TxBody :: TxBodyContent ViewTx era -> TxBody era
data () => TxBodyContent build era
TxBodyContent :: TxIns build era -> TxInsCollateral era -> TxInsReference build era -> [TxOut CtxTx era] -> TxTotalCollateral era -> TxReturnCollateral CtxTx era -> TxFee era -> TxValidityLowerBound era -> TxValidityUpperBound era -> TxMetadataInEra era -> TxAuxScripts era -> TxExtraKeyWitnesses era -> BuildTxWith build (Maybe (LedgerProtocolParameters era)) -> TxWithdrawals build era -> TxCertificates build era -> TxUpdateProposal era -> TxMintValue build era -> TxScriptValidity era -> Maybe (Featured ConwayEraOnwards era (TxProposalProcedures build era)) -> Maybe (Featured ConwayEraOnwards era (TxVotingProcedures build era)) -> Maybe (Featured ConwayEraOnwards era (Maybe Coin)) -> Maybe (Featured ConwayEraOnwards era Coin) -> TxBodyContent build era
[txIns] :: TxBodyContent build era -> TxIns build era
[txInsCollateral] :: TxBodyContent build era -> TxInsCollateral era
[txInsReference] :: TxBodyContent build era -> TxInsReference build era
[txOuts] :: TxBodyContent build era -> [TxOut CtxTx era]
[txTotalCollateral] :: TxBodyContent build era -> TxTotalCollateral era
[txReturnCollateral] :: TxBodyContent build era -> TxReturnCollateral CtxTx era
[txFee] :: TxBodyContent build era -> TxFee era
[txValidityLowerBound] :: TxBodyContent build era -> TxValidityLowerBound era
[txValidityUpperBound] :: TxBodyContent build era -> TxValidityUpperBound era
[txMetadata] :: TxBodyContent build era -> TxMetadataInEra era
[txAuxScripts] :: TxBodyContent build era -> TxAuxScripts era
[txExtraKeyWits] :: TxBodyContent build era -> TxExtraKeyWitnesses era
[txProtocolParams] :: TxBodyContent build era -> BuildTxWith build (Maybe (LedgerProtocolParameters era))
[txWithdrawals] :: TxBodyContent build era -> TxWithdrawals build era
[txCertificates] :: TxBodyContent build era -> TxCertificates build era
[txUpdateProposal] :: TxBodyContent build era -> TxUpdateProposal era
[txMintValue] :: TxBodyContent build era -> TxMintValue build era
[txScriptValidity] :: TxBodyContent build era -> TxScriptValidity era
[txProposalProcedures] :: TxBodyContent build era -> Maybe (Featured ConwayEraOnwards era (TxProposalProcedures build era))
[txVotingProcedures] :: TxBodyContent build era -> Maybe (Featured ConwayEraOnwards era (TxVotingProcedures build era))
[txCurrentTreasuryValue] :: TxBodyContent build era -> Maybe (Featured ConwayEraOnwards era (Maybe Coin))
[txTreasuryDonation] :: TxBodyContent build era -> Maybe (Featured ConwayEraOnwards era Coin)
data () => TxBodyScriptData era
[TxBodyNoScriptData] :: forall era. TxBodyScriptData era
[TxBodyScriptData] :: forall era. AlonzoEraOnwardsConstraints era => AlonzoEraOnwards era -> TxDats (ShelleyLedgerEra era) -> Redeemers (ShelleyLedgerEra era) -> TxBodyScriptData era
data () => TxExtraKeyWitnesses era
[TxExtraKeyWitnessesNone] :: forall era. TxExtraKeyWitnesses era
[TxExtraKeyWitnesses] :: forall era. AlonzoEraOnwards era -> [Hash PaymentKey] -> TxExtraKeyWitnesses era
data () => TxFee era
[TxFeeExplicit] :: forall era. ShelleyBasedEra era -> Coin -> TxFee era
type TxIns build era = [(TxIn, BuildTxWith build Witness WitCtxTxIn era)]
data () => TxInsCollateral era
[TxInsCollateralNone] :: forall era. TxInsCollateral era
[TxInsCollateral] :: forall era. AlonzoEraOnwards era -> [TxIn] -> TxInsCollateral era
data () => TxInsReference build era
[TxInsReferenceNone] :: forall build era. TxInsReference build era
[TxInsReference] :: forall era build. BabbageEraOnwards era -> [TxIn] -> TxInsReferenceDatums build -> TxInsReference build era
data () => TxMetadataInEra era
[TxMetadataNone] :: forall era. TxMetadataInEra era
[TxMetadataInEra] :: forall era. ShelleyBasedEra era -> TxMetadata -> TxMetadataInEra era
data () => TxMintValue build era
[TxMintNone] :: forall build era. TxMintValue build era
[TxMintValue] :: forall era build. MaryEraOnwards era -> Map PolicyId (PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era)) -> TxMintValue build era
data () => TxOut ctx era
TxOut :: AddressInEra era -> TxOutValue era -> TxOutDatum ctx era -> ReferenceScript era -> TxOut ctx era
data () => TxOutDatum ctx era
[TxOutDatumNone] :: forall ctx era. TxOutDatum ctx era
[TxOutDatumHash] :: forall era ctx. AlonzoEraOnwards era -> Hash ScriptData -> TxOutDatum ctx era
[TxOutSupplementalDatum] :: forall era. AlonzoEraOnwards era -> HashableScriptData -> TxOutDatum CtxTx era
[TxOutDatumInline] :: forall era ctx. BabbageEraOnwards era -> HashableScriptData -> TxOutDatum ctx era
data () => TxScriptValidity era
[TxScriptValidityNone] :: forall era. TxScriptValidity era
[TxScriptValidity] :: forall era. AlonzoEraOnwards era -> ScriptValidity -> TxScriptValidity era
data () => TxValidityLowerBound era
[TxValidityNoLowerBound] :: forall era. TxValidityLowerBound era
[TxValidityLowerBound] :: forall era. AllegraEraOnwards era -> SlotNo -> TxValidityLowerBound era
data () => TxValidityUpperBound era
[TxValidityUpperBound] :: forall era. ShelleyBasedEra era -> Maybe SlotNo -> TxValidityUpperBound era
data () => Witness witctx era
[KeyWitness] :: forall witctx era. KeyWitnessInCtx witctx -> Witness witctx era
[ScriptWitness] :: forall witctx era. ScriptWitnessInCtx witctx -> ScriptWitness witctx era -> Witness witctx era
data () => Address addrtype
[ByronAddress] :: Address -> Address ByronAddr
[ShelleyAddress] :: Network -> PaymentCredential -> StakeReference -> Address ShelleyAddr
data () => BlockHeader
BlockHeader :: !SlotNo -> !Hash BlockHeader -> !BlockNo -> BlockHeader
data () => ChainPoint
ChainPointAtGenesis :: ChainPoint
ChainPoint :: !SlotNo -> !Hash BlockHeader -> ChainPoint
data () => ExecutionUnits
ExecutionUnits :: Natural -> Natural -> ExecutionUnits
[executionSteps] :: ExecutionUnits -> Natural
[executionMemory] :: ExecutionUnits -> Natural
data family Hash keyrole
data () => NetworkId
Mainnet :: NetworkId
Testnet :: !NetworkMagic -> NetworkId
newtype () => NetworkMagic
NetworkMagic :: Word32 -> NetworkMagic
[unNetworkMagic] :: NetworkMagic -> Word32
newtype () => PolicyAssets
PolicyAssets :: Map AssetName Quantity -> PolicyAssets
newtype () => PolicyId
PolicyId :: ScriptHash -> PolicyId
[unPolicyId] :: PolicyId -> ScriptHash
data () => ScriptData
ScriptDataConstructor :: Integer -> [ScriptData] -> ScriptData
ScriptDataMap :: [(ScriptData, ScriptData)] -> ScriptData
ScriptDataList :: [ScriptData] -> ScriptData
ScriptDataNumber :: Integer -> ScriptData
ScriptDataBytes :: ByteString -> ScriptData
data () => ScriptDatum witctx
[ScriptDatumForTxIn] :: Maybe HashableScriptData -> ScriptDatum WitCtxTxIn
[InlineScriptDatum] :: ScriptDatum WitCtxTxIn
[NoScriptDatumForMint] :: ScriptDatum WitCtxMint
[NoScriptDatumForStake] :: ScriptDatum WitCtxStake
newtype () => ScriptHash
ScriptHash :: ScriptHash -> ScriptHash
data () => StakeAddress
[StakeAddress] :: Network -> StakeCredential -> StakeAddress
newtype () => TxId
TxId :: Hash HASH EraIndependentTxBody -> TxId
data () => TxIn
TxIn :: TxId -> TxIx -> TxIn
data () => TxOutValue era
[TxOutValueByron] :: Coin -> TxOutValue ByronEra
[TxOutValueShelleyBased] :: forall era. (Eq (Value (ShelleyLedgerEra era)), Show (Value (ShelleyLedgerEra era))) => ShelleyBasedEra era -> Value (ShelleyLedgerEra era) -> TxOutValue era
data () => Value
data () => ByronAddr
class () => FromJSON a
parseJSON :: FromJSON a => Value -> Parser a
parseJSONList :: FromJSON a => Value -> Parser [a]
omittedField :: FromJSON a => Maybe a
class () => ToJSON a
toJSON :: ToJSON a => a -> Value
toEncoding :: ToJSON a => a -> Encoding
toJSONList :: ToJSON a => [a] -> Value
toEncodingList :: ToJSON a => [a] -> Encoding
omitField :: ToJSON a => a -> Bool
class Typeable a => ToCBOR a
toCBOR :: ToCBOR a => a -> Encoding
encodedSizeExpr :: ToCBOR a => (forall t. ToCBOR t => Proxy t -> Size) -> Proxy a -> Size
encodedListSizeExpr :: ToCBOR a => (forall t. ToCBOR t => Proxy t -> Size) -> Proxy [a] -> Size
data () => AddressAny
AddressByron :: !Address ByronAddr -> AddressAny
AddressShelley :: !Address ShelleyAddr -> AddressAny
data () => PaymentCredential
PaymentCredentialByKey :: Hash PaymentKey -> PaymentCredential
PaymentCredentialByScript :: ScriptHash -> PaymentCredential
class HasTypeProxy addr => SerialiseAddress addr
serialiseAddress :: SerialiseAddress addr => addr -> Text
deserialiseAddress :: SerialiseAddress addr => AsType addr -> Text -> Maybe addr
data () => ShelleyAddr
newtype () => StakeAddressPointer
StakeAddressPointer :: Ptr -> StakeAddressPointer
[unStakeAddressPointer] :: StakeAddressPointer -> Ptr
data () => StakeAddressReference
StakeAddressByValue :: StakeCredential -> StakeAddressReference
StakeAddressByPointer :: StakeAddressPointer -> StakeAddressReference
NoStakeAddress :: StakeAddressReference
data () => StakeCredential
StakeCredentialByKey :: Hash StakeKey -> StakeCredential
StakeCredentialByScript :: ScriptHash -> StakeCredential
data () => BlockInMode
[BlockInMode] :: forall era. CardanoEra era -> Block era -> BlockInMode
data () => ByronBlock
data () => ChainTip
ChainTipAtGenesis :: ChainTip
ChainTip :: !SlotNo -> !Hash BlockHeader -> !BlockNo -> ChainTip
data () => AnchorDataFromCertificateError
InvalidPoolMetadataHashError :: Url -> ByteString -> AnchorDataFromCertificateError
data () => Certificate era
[ShelleyRelatedCertificate] :: forall era. Typeable era => ShelleyToBabbageEra era -> ShelleyTxCert (ShelleyLedgerEra era) -> Certificate era
[ConwayCertificate] :: forall era. Typeable era => ConwayEraOnwards era -> ConwayTxCert (ShelleyLedgerEra era) -> Certificate era
data () => CommitteeColdkeyResignationRequirements era
[CommitteeColdkeyResignationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'ColdCommitteeRole -> Maybe Anchor -> CommitteeColdkeyResignationRequirements era
data () => CommitteeHotKeyAuthorizationRequirements era
[CommitteeHotKeyAuthorizationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'ColdCommitteeRole -> Credential 'HotCommitteeRole -> CommitteeHotKeyAuthorizationRequirements era
data () => DRepMetadataReference
DRepMetadataReference :: Text -> Hash DRepMetadata -> DRepMetadataReference
[drepMetadataURL] :: DRepMetadataReference -> Text
[drepMetadataHash] :: DRepMetadataReference -> Hash DRepMetadata
data () => DRepRegistrationRequirements era
[DRepRegistrationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'DRepRole -> Coin -> DRepRegistrationRequirements era
data () => DRepUnregistrationRequirements era
[DRepUnregistrationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'DRepRole -> Coin -> DRepUnregistrationRequirements era
data () => DRepUpdateRequirements era
[DRepUpdateRequirements] :: forall era. ConwayEraOnwards era -> Credential 'DRepRole -> DRepUpdateRequirements era
data () => GenesisKeyDelegationRequirements era
[GenesisKeyDelegationRequirements] :: forall era. ShelleyToBabbageEra era -> Hash GenesisKey -> Hash GenesisDelegateKey -> Hash VrfKey -> GenesisKeyDelegationRequirements era
data () => MirCertificateRequirements era
[MirCertificateRequirements] :: forall era. ShelleyToBabbageEra era -> MIRPot -> MIRTarget -> MirCertificateRequirements era
type PoolId = Hash StakePoolKey
data () => StakeAddressRequirements era
[StakeAddrRegistrationConway] :: forall era. ConwayEraOnwards era -> Coin -> StakeCredential -> StakeAddressRequirements era
[StakeAddrRegistrationPreConway] :: forall era. ShelleyToBabbageEra era -> StakeCredential -> StakeAddressRequirements era
data () => StakeDelegationRequirements era
[StakeDelegationRequirementsConwayOnwards] :: forall era. ConwayEraOnwards era -> StakeCredential -> Delegatee -> StakeDelegationRequirements era
[StakeDelegationRequirementsPreConway] :: forall era. ShelleyToBabbageEra era -> StakeCredential -> PoolId -> StakeDelegationRequirements era
data () => StakePoolMetadataReference
StakePoolMetadataReference :: Text -> Hash StakePoolMetadata -> StakePoolMetadataReference
[stakePoolMetadataURL] :: StakePoolMetadataReference -> Text
[stakePoolMetadataHash] :: StakePoolMetadataReference -> Hash StakePoolMetadata
data () => StakePoolParameters
StakePoolParameters :: PoolId -> Hash VrfKey -> Coin -> Rational -> StakeAddress -> Coin -> [Hash StakeKey] -> [StakePoolRelay] -> Maybe StakePoolMetadataReference -> StakePoolParameters
[stakePoolId] :: StakePoolParameters -> PoolId
[stakePoolVRF] :: StakePoolParameters -> Hash VrfKey
[stakePoolCost] :: StakePoolParameters -> Coin
[stakePoolMargin] :: StakePoolParameters -> Rational
[stakePoolRewardAccount] :: StakePoolParameters -> StakeAddress
[stakePoolPledge] :: StakePoolParameters -> Coin
[stakePoolOwners] :: StakePoolParameters -> [Hash StakeKey]
[stakePoolRelays] :: StakePoolParameters -> [StakePoolRelay]
[stakePoolMetadata] :: StakePoolParameters -> Maybe StakePoolMetadataReference
data () => StakePoolRegistrationRequirements era
[StakePoolRegistrationRequirementsConwayOnwards] :: forall era. ConwayEraOnwards era -> PoolParams -> StakePoolRegistrationRequirements era
[StakePoolRegistrationRequirementsPreConway] :: forall era. ShelleyToBabbageEra era -> PoolParams -> StakePoolRegistrationRequirements era
data () => StakePoolRelay
StakePoolRelayIp :: Maybe IPv4 -> Maybe IPv6 -> Maybe PortNumber -> StakePoolRelay
StakePoolRelayDnsARecord :: ByteString -> Maybe PortNumber -> StakePoolRelay
StakePoolRelayDnsSrvRecord :: ByteString -> StakePoolRelay
data () => StakePoolRetirementRequirements era
[StakePoolRetirementRequirementsConwayOnwards] :: forall era. ConwayEraOnwards era -> PoolId -> EpochNo -> StakePoolRetirementRequirements era
[StakePoolRetirementRequirementsPreConway] :: forall era. ShelleyToBabbageEra era -> PoolId -> EpochNo -> StakePoolRetirementRequirements era
newtype () => DRepMetadata
DRepMetadata :: ByteString -> DRepMetadata
[unDRepMetadata] :: DRepMetadata -> ByteString
data () => OperationalCertIssueError
OperationalCertKeyMismatch :: VerificationKey StakePoolKey -> VerificationKey StakePoolKey -> OperationalCertIssueError
data () => OperationalCertificate
OperationalCertificate :: !OCert StandardCrypto -> !VerificationKey StakePoolKey -> OperationalCertificate
data () => OperationalCertificateIssueCounter
OperationalCertificateIssueCounter :: !Word64 -> !VerificationKey StakePoolKey -> OperationalCertificateIssueCounter
[opCertIssueCount] :: OperationalCertificateIssueCounter -> !Word64
[opCertIssueColdKey] :: OperationalCertificateIssueCounter -> !VerificationKey StakePoolKey
data () => StakePoolMetadata
StakePoolMetadata :: !Text -> !Text -> !Text -> !Text -> StakePoolMetadata
[stakePoolName] :: StakePoolMetadata -> !Text
[stakePoolDescription] :: StakePoolMetadata -> !Text
[stakePoolTicker] :: StakePoolMetadata -> !Text
[stakePoolHomepage] :: StakePoolMetadata -> !Text
data () => StakePoolMetadataValidationError
StakePoolMetadataJsonDecodeError :: !String -> StakePoolMetadataValidationError
StakePoolMetadataInvalidLengthError :: !Int -> !Int -> StakePoolMetadataValidationError
data () => TxIdInMode
[TxIdInMode] :: forall era. CardanoEra era -> TxId -> TxIdInMode
data () => TxInMode
[TxInMode] :: forall era. ShelleyBasedEra era -> Tx era -> TxInMode
[TxInByronSpecial] :: GenTx ByronBlock -> TxInMode
data () => TxValidationError era
[ByronTxValidationError] :: forall era. ApplyTxErr ByronBlock -> TxValidationError era
[ShelleyTxValidationError] :: forall era. ShelleyBasedEra era -> ApplyTxErr (ShelleyBlock (ConsensusProtocol era) (ShelleyLedgerEra era)) -> TxValidationError era
data () => TxValidationErrorInCardanoMode
[TxValidationErrorInCardanoMode] :: forall era. TxValidationError era -> TxValidationErrorInCardanoMode
[TxValidationEraMismatch] :: EraMismatch -> TxValidationErrorInCardanoMode
type family ChainDepStateProtocol era
type family ConsensusBlockForEra era
type family ConsensusCryptoForBlock block
data () => ConsensusModeParams
[CardanoModeParams] :: EpochSlots -> ConsensusModeParams
type family ConsensusProtocol era
data () => BlockType blk
[ByronBlockType] :: BlockType (HardForkBlock '[ByronBlock])
[ShelleyBlockType] :: BlockType (HardForkBlock '[ShelleyBlock (TPraos StandardCrypto) ShelleyEra])
[CardanoBlockType] :: BlockType (HardForkBlock (CardanoEras StandardCrypto))
class (RunNode blk, IOLike m) => Protocol (m :: Type -> Type) blk where {
    data family ProtocolInfoArgs blk;
}
protocolInfo :: Protocol m blk => ProtocolInfoArgs blk -> (ProtocolInfo blk, m [BlockForging m blk])
class RunNode blk => ProtocolClient blk where {
    data family ProtocolClientInfoArgs blk;
}
protocolClientInfo :: ProtocolClient blk => ProtocolClientInfoArgs blk -> ProtocolClientInfo blk
data family ProtocolClientInfoArgs blk
data family ProtocolInfoArgs blk
data () => SomeBlockType
[SomeBlockType] :: forall blk. BlockType blk -> SomeBlockType
data () => AllegraEra
data () => AlonzoEra
data () => AnyCardanoEra
[AnyCardanoEra] :: forall era. Typeable era => CardanoEra era -> AnyCardanoEra
data () => BabbageEra
data () => ByronEra
data () => CardanoEra era
[ByronEra] :: CardanoEra ByronEra
[ShelleyEra] :: CardanoEra ShelleyEra
[AllegraEra] :: CardanoEra AllegraEra
[MaryEra] :: CardanoEra MaryEra
[AlonzoEra] :: CardanoEra AlonzoEra
[BabbageEra] :: CardanoEra BabbageEra
[ConwayEra] :: CardanoEra ConwayEra
type family CardanoLedgerEra era = (ledgerera :: Type) | ledgerera -> era
data () => ConwayEra
class () => Eon (eon :: Type -> Type)
inEonForEra :: Eon eon => a -> (eon era -> a) -> CardanoEra era -> a
data () => EraInEon (eon :: Type -> Type)
[EraInEon] :: forall era (eon :: Type -> Type). (Typeable era, Typeable (eon era), Eon eon) => eon era -> EraInEon eon
data () => InAnyCardanoEra (thing :: Type -> Type)
[InAnyCardanoEra] :: forall era (thing :: Type -> Type). Typeable era => CardanoEra era -> thing era -> InAnyCardanoEra thing
class HasTypeProxy era => IsCardanoEra era
cardanoEra :: IsCardanoEra era => CardanoEra era
data () => MaryEra
data () => ShelleyEra
class () => ToCardanoEra (eon :: Type -> Type)
toCardanoEra :: ToCardanoEra eon => eon era -> CardanoEra era
data () => AllegraEraOnwards era
[AllegraEraOnwardsAllegra] :: AllegraEraOnwards AllegraEra
[AllegraEraOnwardsMary] :: AllegraEraOnwards MaryEra
[AllegraEraOnwardsAlonzo] :: AllegraEraOnwards AlonzoEra
[AllegraEraOnwardsBabbage] :: AllegraEraOnwards BabbageEra
[AllegraEraOnwardsConway] :: AllegraEraOnwards ConwayEra
type AllegraEraOnwardsConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, AllegraEraTxBody ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
class IsShelleyBasedEra era => IsAllegraBasedEra era
allegraBasedEra :: IsAllegraBasedEra era => AllegraEraOnwards era
data () => AlonzoEraOnwards era
[AlonzoEraOnwardsAlonzo] :: AlonzoEraOnwards AlonzoEra
[AlonzoEraOnwardsBabbage] :: AlonzoEraOnwards BabbageEra
[AlonzoEraOnwardsConway] :: AlonzoEraOnwards ConwayEra
type AlonzoEraOnwardsConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, AlonzoEraPParams ShelleyLedgerEra era, AlonzoEraTx ShelleyLedgerEra era, AlonzoEraTxBody ShelleyLedgerEra era, AlonzoEraTxOut ShelleyLedgerEra era, AlonzoEraTxWits ShelleyLedgerEra era, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, EraUTxO ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, MaryEraTxBody ShelleyLedgerEra era, NativeScript ShelleyLedgerEra era ~ Timelock ShelleyLedgerEra era, EraPlutusContext ShelleyLedgerEra era, Script ShelleyLedgerEra era ~ AlonzoScript ShelleyLedgerEra era, ScriptsNeeded ShelleyLedgerEra era ~ AlonzoScriptsNeeded ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, Value ShelleyLedgerEra era ~ MaryValue, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
class IsMaryBasedEra era => IsAlonzoBasedEra era
alonzoBasedEra :: IsAlonzoBasedEra era => AlonzoEraOnwards era
data () => BabbageEraOnwards era
[BabbageEraOnwardsBabbage] :: BabbageEraOnwards BabbageEra
[BabbageEraOnwardsConway] :: BabbageEraOnwards ConwayEra
type BabbageEraOnwardsConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, AlonzoEraTxOut ShelleyLedgerEra era, BabbageEraPParams ShelleyLedgerEra era, BabbageEraTxBody ShelleyLedgerEra era, BabbageEraTxOut ShelleyLedgerEra era, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, EraUTxO ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, MaryEraTxBody ShelleyLedgerEra era, Script ShelleyLedgerEra era ~ AlonzoScript ShelleyLedgerEra era, ScriptsNeeded ShelleyLedgerEra era ~ AlonzoScriptsNeeded ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, TxOut ShelleyLedgerEra era ~ BabbageTxOut ShelleyLedgerEra era, Value ShelleyLedgerEra era ~ MaryValue, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
class IsAlonzoBasedEra era => IsBabbageBasedEra era
babbageBasedEra :: IsBabbageBasedEra era => BabbageEraOnwards era
data () => ByronToAlonzoEra era
[ByronToAlonzoEraByron] :: ByronToAlonzoEra ByronEra
[ByronToAlonzoEraShelley] :: ByronToAlonzoEra ShelleyEra
[ByronToAlonzoEraAllegra] :: ByronToAlonzoEra AllegraEra
[ByronToAlonzoEraMary] :: ByronToAlonzoEra MaryEra
[ByronToAlonzoEraAlonzo] :: ByronToAlonzoEra AlonzoEra
type ByronToAlonzoEraConstraints era = (IsCardanoEra era, Typeable era)
class () => Convert (f :: a -> Type) (g :: a -> Type)
convert :: forall (era :: a). Convert f g => f era -> g era
data () => ConwayEraOnwards era
[ConwayEraOnwardsConway] :: ConwayEraOnwards ConwayEra
type ConwayEraOnwardsConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, AlonzoEraTxOut ShelleyLedgerEra era, AlonzoEraTxWits ShelleyLedgerEra era, BabbageEraTxBody ShelleyLedgerEra era, ConwayEraGov ShelleyLedgerEra era, ConwayEraPParams ShelleyLedgerEra era, ConwayEraTxBody ShelleyLedgerEra era, ConwayEraTxCert ShelleyLedgerEra era, Era ShelleyLedgerEra era, EraGov ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, EraUTxO ShelleyLedgerEra era, GovState ShelleyLedgerEra era ~ ConwayGovState ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, MaryEraTxBody ShelleyLedgerEra era, Script ShelleyLedgerEra era ~ AlonzoScript ShelleyLedgerEra era, ScriptsNeeded ShelleyLedgerEra era ~ AlonzoScriptsNeeded ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, TxCert ShelleyLedgerEra era ~ ConwayTxCert ShelleyLedgerEra era, Value ShelleyLedgerEra era ~ MaryValue, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
class IsBabbageBasedEra era => IsConwayBasedEra era
conwayBasedEra :: IsConwayBasedEra era => ConwayEraOnwards era
class IsAllegraBasedEra era => IsMaryBasedEra era
maryBasedEra :: IsMaryBasedEra era => MaryEraOnwards era
data () => MaryEraOnwards era
[MaryEraOnwardsMary] :: MaryEraOnwards MaryEra
[MaryEraOnwardsAlonzo] :: MaryEraOnwards AlonzoEra
[MaryEraOnwardsBabbage] :: MaryEraOnwards BabbageEra
[MaryEraOnwardsConway] :: MaryEraOnwards ConwayEra
type MaryEraOnwardsConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, EraUTxO ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, MaryEraTxBody ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, Value ShelleyLedgerEra era ~ MaryValue, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
data () => AnyShelleyBasedEra
[AnyShelleyBasedEra] :: forall era. Typeable era => ShelleyBasedEra era -> AnyShelleyBasedEra
data () => InAnyShelleyBasedEra (thing :: Type -> Type)
[InAnyShelleyBasedEra] :: forall era (thing :: Type -> Type). Typeable era => ShelleyBasedEra era -> thing era -> InAnyShelleyBasedEra thing
class IsCardanoEra era => IsShelleyBasedEra era
shelleyBasedEra :: IsShelleyBasedEra era => ShelleyBasedEra era
data () => ShelleyBasedEra era
[ShelleyBasedEraShelley] :: ShelleyBasedEra ShelleyEra
[ShelleyBasedEraAllegra] :: ShelleyBasedEra AllegraEra
[ShelleyBasedEraMary] :: ShelleyBasedEra MaryEra
[ShelleyBasedEraAlonzo] :: ShelleyBasedEra AlonzoEra
[ShelleyBasedEraBabbage] :: ShelleyBasedEra BabbageEra
[ShelleyBasedEraConway] :: ShelleyBasedEra ConwayEra
type ShelleyBasedEraConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, FromCBOR ChainDepState ConsensusProtocol era, IsCardanoEra era, IsShelleyBasedEra era, ADDRHASH ~ Blake2b_224, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, EraUTxO ShelleyLedgerEra era, EraTxWits ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, ShelleyEraTxCert ShelleyLedgerEra era, FromCBOR ChainDepState ConsensusProtocol era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON PredicateFailure EraRule "LEDGER" ShelleyLedgerEra era, Typeable era, era == ByronEra ~ 'False)
type family ShelleyLedgerEra era = (ledgerera :: Type) | ledgerera -> era
data () => ShelleyEraOnly era
[ShelleyEraOnlyShelley] :: ShelleyEraOnly ShelleyEra
type ShelleyEraOnlyConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, ExactEra ShelleyEra ShelleyLedgerEra era, ExactEra ShelleyEra ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, ProtVerAtMost ShelleyLedgerEra era 2, ProtVerAtMost ShelleyLedgerEra era 6, ProtVerAtMost ShelleyLedgerEra era 8, ShelleyEraTxBody ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, TxCert ShelleyLedgerEra era ~ ShelleyTxCert ShelleyLedgerEra era, Value ShelleyLedgerEra era ~ Coin, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
data () => ShelleyToAllegraEra era
[ShelleyToAllegraEraShelley] :: ShelleyToAllegraEra ShelleyEra
[ShelleyToAllegraEraAllegra] :: ShelleyToAllegraEra AllegraEra
type ShelleyToAllegraEraConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, EraUTxO ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, ProtVerAtMost ShelleyLedgerEra era 4, ProtVerAtMost ShelleyLedgerEra era 6, ProtVerAtMost ShelleyLedgerEra era 8, ShelleyEraTxBody ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, TxCert ShelleyLedgerEra era ~ ShelleyTxCert ShelleyLedgerEra era, Value ShelleyLedgerEra era ~ Coin, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
data () => ShelleyToAlonzoEra era
[ShelleyToAlonzoEraShelley] :: ShelleyToAlonzoEra ShelleyEra
[ShelleyToAlonzoEraAllegra] :: ShelleyToAlonzoEra AllegraEra
[ShelleyToAlonzoEraMary] :: ShelleyToAlonzoEra MaryEra
[ShelleyToAlonzoEraAlonzo] :: ShelleyToAlonzoEra AlonzoEra
type ShelleyToAlonzoEraConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, ProtVerAtMost ShelleyLedgerEra era 6, ProtVerAtMost ShelleyLedgerEra era 8, ShelleyEraTxBody ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, TxCert ShelleyLedgerEra era ~ ShelleyTxCert ShelleyLedgerEra era, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
data () => ShelleyToBabbageEra era
[ShelleyToBabbageEraShelley] :: ShelleyToBabbageEra ShelleyEra
[ShelleyToBabbageEraAllegra] :: ShelleyToBabbageEra AllegraEra
[ShelleyToBabbageEraMary] :: ShelleyToBabbageEra MaryEra
[ShelleyToBabbageEraAlonzo] :: ShelleyToBabbageEra AlonzoEra
[ShelleyToBabbageEraBabbage] :: ShelleyToBabbageEra BabbageEra
type ShelleyToBabbageEraConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, ProtVerAtMost ShelleyLedgerEra era 8, ShelleyEraTxBody ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, TxCert ShelleyLedgerEra era ~ ShelleyTxCert ShelleyLedgerEra era, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
data () => ShelleyToMaryEra era
[ShelleyToMaryEraShelley] :: ShelleyToMaryEra ShelleyEra
[ShelleyToMaryEraAllegra] :: ShelleyToMaryEra AllegraEra
[ShelleyToMaryEraMary] :: ShelleyToMaryEra MaryEra
type ShelleyToMaryEraConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, ProtVerAtMost ShelleyLedgerEra era 4, ProtVerAtMost ShelleyLedgerEra era 6, ProtVerAtMost ShelleyLedgerEra era 8, ShelleyEraTxBody ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, TxCert ShelleyLedgerEra era ~ ShelleyTxCert ShelleyLedgerEra era, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
data () => Featured (eon :: Type -> Type) era a
[Featured] :: forall (eon :: Type -> Type) era a. eon era -> a -> Featured eon era a
data () => ErrorAsException
[ErrorAsException] :: forall e. Error e => e -> ErrorAsException
data () => FileError e
FileError :: FilePath -> e -> FileError e
FileErrorTempFile :: FilePath -> FilePath -> Handle -> FileError e
FileDoesNotExistError :: FilePath -> FileError e
FileIOError :: FilePath -> IOException -> FileError e
type AlonzoGenesisConfig = AlonzoGenesis
type AlonzoGenesisFile = File AlonzoGenesisConfig
type ByronGenesisConfig = Config
type ByronGenesisFile = File ByronGenesisConfig
type ConwayGenesisConfig = ConwayGenesis
type ConwayGenesisFile = File ConwayGenesisConfig
newtype () => GenesisHashAlonzo
GenesisHashAlonzo :: Hash Blake2b_256 ByteString -> GenesisHashAlonzo
[unGenesisHashAlonzo] :: GenesisHashAlonzo -> Hash Blake2b_256 ByteString
newtype () => GenesisHashByron
GenesisHashByron :: Text -> GenesisHashByron
[unGenesisHashByron] :: GenesisHashByron -> Text
newtype () => GenesisHashConway
GenesisHashConway :: Hash Blake2b_256 ByteString -> GenesisHashConway
[unGenesisHashConway] :: GenesisHashConway -> Hash Blake2b_256 ByteString
newtype () => GenesisHashShelley
GenesisHashShelley :: Hash Blake2b_256 ByteString -> GenesisHashShelley
[unGenesisHashShelley] :: GenesisHashShelley -> Hash Blake2b_256 ByteString
data () => ShelleyConfig
ShelleyConfig :: !ShelleyGenesis -> !GenesisHashShelley -> ShelleyConfig
[scConfig] :: ShelleyConfig -> !ShelleyGenesis
[scGenesisHash] :: ShelleyConfig -> !GenesisHashShelley
type ShelleyGenesisConfig = ShelleyConfig
type ShelleyGenesisFile = File ShelleyGenesisConfig
data () => GenesisParameters era
GenesisParameters :: UTCTime -> NetworkId -> Rational -> NonZero Word64 -> EpochSize -> NominalDiffTime -> Int -> Int -> Int -> Coin -> PParams (ShelleyLedgerEra era) -> GenesisParameters era
[protocolParamSystemStart] :: GenesisParameters era -> UTCTime
[protocolParamNetworkId] :: GenesisParameters era -> NetworkId
[protocolParamActiveSlotsCoefficient] :: GenesisParameters era -> Rational
[protocolParamSecurity] :: GenesisParameters era -> NonZero Word64
[protocolParamEpochLength] :: GenesisParameters era -> EpochSize
[protocolParamSlotLength] :: GenesisParameters era -> NominalDiffTime
[protocolParamSlotsPerKESPeriod] :: GenesisParameters era -> Int
[protocolParamMaxKESEvolutions] :: GenesisParameters era -> Int
[protocolParamUpdateQuorum] :: GenesisParameters era -> Int
[protocolParamMaxLovelaceSupply] :: GenesisParameters era -> Coin
[protocolInitialUpdateableProtocolParameters] :: GenesisParameters era -> PParams (ShelleyLedgerEra era)
data () => AnyGovernanceAction
AnyGovernanceAction :: GovAction era -> AnyGovernanceAction
data () => GovernanceAction era
MotionOfNoConfidence :: StrictMaybe (GovPurposeId 'CommitteePurpose (ShelleyLedgerEra era)) -> GovernanceAction era
ProposeNewConstitution :: StrictMaybe (GovPurposeId 'ConstitutionPurpose (ShelleyLedgerEra era)) -> Anchor -> StrictMaybe ScriptHash -> GovernanceAction era
ProposeNewCommittee :: StrictMaybe (GovPurposeId 'CommitteePurpose (ShelleyLedgerEra era)) -> [Credential 'ColdCommitteeRole] -> Map (Credential 'ColdCommitteeRole) EpochNo -> Rational -> GovernanceAction era
InfoAct :: GovernanceAction era
TreasuryWithdrawal :: [(Network, StakeCredential, Coin)] -> !StrictMaybe ScriptHash -> GovernanceAction era
InitiateHardfork :: StrictMaybe (GovPurposeId 'HardForkPurpose (ShelleyLedgerEra era)) -> ProtVer -> GovernanceAction era
UpdatePParams :: StrictMaybe (GovPurposeId 'PParamUpdatePurpose (ShelleyLedgerEra era)) -> PParamsUpdate (ShelleyLedgerEra era) -> !StrictMaybe ScriptHash -> GovernanceAction era
data () => Proposal era
[Proposal] :: forall era. Typeable era => ProposalProcedure (ShelleyLedgerEra era) -> Proposal era
data () => Vote
No :: Vote
Yes :: Vote
Abstain :: Vote
newtype () => VotesMergingConflict era
VotesMergingConflict :: (Voter, [GovActionId]) -> VotesMergingConflict era
newtype () => VotingProcedure era
VotingProcedure :: VotingProcedure (ShelleyLedgerEra era) -> VotingProcedure era
[unVotingProcedure] :: VotingProcedure era -> VotingProcedure (ShelleyLedgerEra era)
newtype () => VotingProcedures era
VotingProcedures :: VotingProcedures (ShelleyLedgerEra era) -> VotingProcedures era
[unVotingProcedures] :: VotingProcedures era -> VotingProcedures (ShelleyLedgerEra era)
newtype () => AnchorDataHash
AnchorDataHash :: SafeHash AnchorData -> AnchorDataHash
[unAnchorDataHash] :: AnchorDataHash -> SafeHash AnchorData
newtype () => AnchorUrl
AnchorUrl :: Url -> AnchorUrl
[unAnchorUrl] :: AnchorUrl -> Url
data () => CIP119
DrepRegistrationMetadata :: CIP119
data () => CIP108
BaseGovActionMetadata :: CIP108
data family Authors cip
data () => GovActionMetadata cip
GovActionMetadata :: HashAlgorithm cip -> Authors cip -> Body cip -> GovActionMetadata cip
[$sel:hashAlgorithm:GovActionMetadata] :: GovActionMetadata cip -> HashAlgorithm cip
[$sel:authors:GovActionMetadata] :: GovActionMetadata cip -> Authors cip
[$sel:body:GovActionMetadata] :: GovActionMetadata cip -> Body cip
data family HashAlgorithm cip
data () => GovernancePoll
GovernancePoll :: Text -> [Text] -> Maybe Word -> GovernancePoll
[govPollQuestion] :: GovernancePoll -> Text
[govPollAnswers] :: GovernancePoll -> [Text]
[govPollNonce] :: GovernancePoll -> Maybe Word
data () => GovernancePollAnswer
GovernancePollAnswer :: Hash GovernancePoll -> Word -> GovernancePollAnswer
[govAnsPoll] :: GovernancePollAnswer -> Hash GovernancePoll
[govAnsChoice] :: GovernancePollAnswer -> Word
data () => GovernancePollError
ErrGovernancePollMismatch :: GovernancePollMismatchError -> GovernancePollError
ErrGovernancePollNoAnswer :: GovernancePollError
ErrGovernancePollUnauthenticated :: GovernancePollError
ErrGovernancePollMalformedAnswer :: DecoderError -> GovernancePollError
ErrGovernancePollInvalidAnswer :: GovernancePollInvalidAnswerError -> GovernancePollError
class Typeable t => HasTypeProxy t where {
    data family AsType t;
}
proxyToAsType :: HasTypeProxy t => Proxy t -> AsType t
data family AsType t
pattern AsByronAddress :: AsType (Address ByronAddr)
pattern AsShelleyAddress :: AsType (Address ShelleyAddr)
pattern AsAllegraTx :: AsType (Tx AllegraEra)
pattern AsAlonzoTx :: AsType (Tx AlonzoEra)
pattern AsByronTxBody :: AsType (TxBody ByronEra)
pattern AsByronWitness :: AsType (KeyWitness ByronEra)
pattern AsMaryTx :: AsType (Tx MaryEra)
pattern AsMaryTxBody :: AsType (TxBody MaryEra)
pattern AsShelleyTxBody :: AsType (TxBody ShelleyEra)
pattern AsShelleyWitness :: AsType (KeyWitness ShelleyEra)
data () => FromSomeType (c :: Type -> Constraint) b
[FromSomeType] :: forall (c :: Type -> Constraint) a b. c a => AsType a -> (a -> b) -> FromSomeType c b
class () => CastHash roleA roleB
castHash :: CastHash roleA roleB => Hash roleA -> Hash roleB
data () => FileDirection
In :: FileDirection
Out :: FileDirection
InOut :: FileDirection
type SocketPath = File Socket 'InOut
data () => AnyStakePoolSigningKey
AnyStakePoolNormalSigningKey :: SigningKey StakePoolKey -> AnyStakePoolSigningKey
AnyStakePoolExtendedSigningKey :: SigningKey StakePoolExtendedKey -> AnyStakePoolSigningKey
data () => AnyStakePoolVerificationKey
AnyStakePoolNormalVerificationKey :: VerificationKey StakePoolKey -> AnyStakePoolVerificationKey
AnyStakePoolExtendedVerificationKey :: VerificationKey StakePoolExtendedKey -> AnyStakePoolVerificationKey
data () => CommitteeColdExtendedKey
data () => CommitteeColdKey
data () => CommitteeHotExtendedKey
data () => CommitteeHotKey
data () => DRepExtendedKey
data () => DRepKey
data () => GenesisDelegateExtendedKey
data () => GenesisDelegateKey
data () => GenesisExtendedKey
data () => GenesisKey
data () => GenesisUTxOKey
data () => PaymentExtendedKey
data () => PaymentKey
data () => StakeExtendedKey
data () => StakeKey
data () => StakePoolExtendedKey
data () => StakePoolKey
class () => CastSigningKeyRole keyroleA keyroleB
castSigningKey :: CastSigningKeyRole keyroleA keyroleB => SigningKey keyroleA -> SigningKey keyroleB
class () => CastVerificationKeyRole keyroleA keyroleB
castVerificationKey :: CastVerificationKeyRole keyroleA keyroleB => VerificationKey keyroleA -> VerificationKey keyroleB
data family SigningKey keyrole
data family VerificationKey keyrole
data () => MnemonicSize
MS12 :: MnemonicSize
MS15 :: MnemonicSize
MS18 :: MnemonicSize
MS21 :: MnemonicSize
MS24 :: MnemonicSize
data () => MnemonicToSigningKeyError
InvalidMnemonicError :: String -> MnemonicToSigningKeyError
InvalidAccountNumberError :: Word32 -> MnemonicToSigningKeyError
InvalidPaymentKeyNoError :: Word32 -> MnemonicToSigningKeyError
data () => KesKey
data () => VrfKey
data () => SomeAddressVerificationKey
AByronVerificationKey :: VerificationKey ByronKey -> SomeAddressVerificationKey
APaymentVerificationKey :: VerificationKey PaymentKey -> SomeAddressVerificationKey
APaymentExtendedVerificationKey :: VerificationKey PaymentExtendedKey -> SomeAddressVerificationKey
AGenesisUTxOVerificationKey :: VerificationKey GenesisUTxOKey -> SomeAddressVerificationKey
AGenesisExtendedVerificationKey :: VerificationKey GenesisExtendedKey -> SomeAddressVerificationKey
AGenesisDelegateExtendedVerificationKey :: VerificationKey GenesisDelegateExtendedKey -> SomeAddressVerificationKey
AKesVerificationKey :: VerificationKey KesKey -> SomeAddressVerificationKey
AVrfVerificationKey :: VerificationKey VrfKey -> SomeAddressVerificationKey
AStakeVerificationKey :: VerificationKey StakeKey -> SomeAddressVerificationKey
AStakeExtendedVerificationKey :: VerificationKey StakeExtendedKey -> SomeAddressVerificationKey
AStakePoolVerificationKey :: VerificationKey StakePoolKey -> SomeAddressVerificationKey
AStakePoolExtendedVerificationKey :: VerificationKey StakePoolExtendedKey -> SomeAddressVerificationKey
ADRepVerificationKey :: VerificationKey DRepKey -> SomeAddressVerificationKey
ADRepExtendedVerificationKey :: VerificationKey DRepExtendedKey -> SomeAddressVerificationKey
ACommitteeColdVerificationKey :: VerificationKey CommitteeColdKey -> SomeAddressVerificationKey
ACommitteeColdExtendedVerificationKey :: VerificationKey CommitteeColdExtendedKey -> SomeAddressVerificationKey
ACommitteeHotVerificationKey :: VerificationKey CommitteeHotKey -> SomeAddressVerificationKey
ACommitteeHotExtendedVerificationKey :: VerificationKey CommitteeHotExtendedKey -> SomeAddressVerificationKey
data () => AnyNewEpochState
[AnyNewEpochState] :: forall era. ShelleyBasedEra era -> NewEpochState (ShelleyLedgerEra era) -> LedgerTables (LedgerState (CardanoBlock StandardCrypto)) ValuesMK -> AnyNewEpochState
data () => ConditionResult
ConditionNotMet :: ConditionResult
ConditionMet :: ConditionResult
data () => Env
Env :: CardanoLedgerConfig StandardCrypto -> CardanoConsensusConfig StandardCrypto -> Env
[envLedgerConfig] :: Env -> CardanoLedgerConfig StandardCrypto
[envConsensusConfig] :: Env -> CardanoConsensusConfig StandardCrypto
data () => FoldBlocksError
FoldBlocksInitialLedgerStateError :: !InitialLedgerStateError -> FoldBlocksError
FoldBlocksApplyBlockError :: !LedgerStateError -> FoldBlocksError
FoldBlocksIOException :: !IOException -> FoldBlocksError
FoldBlocksMuxError :: !Error -> FoldBlocksError
data () => FoldStatus
ContinueFold :: FoldStatus
StopFold :: FoldStatus
DebugFold :: FoldStatus
data () => GenesisConfig
GenesisCardano :: !NodeConfig -> !Config -> !GenesisHashShelley -> !TransitionConfig LatestKnownEra -> GenesisConfig
data () => GenesisConfigError
NEError :: !Text -> GenesisConfigError
NEByronConfig :: !FilePath -> !ConfigurationError -> GenesisConfigError
NEShelleyConfig :: !FilePath -> !Text -> GenesisConfigError
NEAlonzoConfig :: !FilePath -> !Text -> GenesisConfigError
NEConwayConfig :: !FilePath -> !Text -> GenesisConfigError
NECardanoConfig :: !Text -> GenesisConfigError
data () => InitialLedgerStateError
ILSEConfigFile :: Text -> InitialLedgerStateError
ILSEGenesisFile :: GenesisConfigError -> InitialLedgerStateError
ILSELedgerConsensusConfig :: GenesisConfigError -> InitialLedgerStateError
data () => LeadershipError
LeaderErrDecodeLedgerStateFailure :: LeadershipError
LeaderErrDecodeProtocolStateFailure :: (ByteString, DecoderError) -> LeadershipError
LeaderErrDecodeProtocolEpochStateFailure :: DecoderError -> LeadershipError
LeaderErrGenesisSlot :: LeadershipError
LeaderErrStakePoolHasNoStake :: PoolId -> LeadershipError
LeaderErrStakeDistribUnstable :: SlotNo -> SlotNo -> SlotNo -> SlotNo -> LeadershipError
LeaderErrSlotRangeCalculationFailure :: Text -> LeadershipError
LeaderErrCandidateNonceStillEvolving :: LeadershipError
data () => LedgerState
LedgerState :: CardanoLedgerState StandardCrypto EmptyMK -> LedgerTables (LedgerState (HardForkBlock (CardanoEras StandardCrypto))) ValuesMK -> LedgerState
[clsState] :: LedgerState -> CardanoLedgerState StandardCrypto EmptyMK
[clsTables] :: LedgerState -> LedgerTables (LedgerState (HardForkBlock (CardanoEras StandardCrypto))) ValuesMK
pattern LedgerStateAllegra :: LedgerState StandardAllegraBlock EmptyMK -> LedgerState
pattern LedgerStateAlonzo :: LedgerState StandardAlonzoBlock EmptyMK -> LedgerState
pattern LedgerStateBabbage :: LedgerState StandardBabbageBlock EmptyMK -> LedgerState
pattern LedgerStateByron :: LedgerState ByronBlock EmptyMK -> LedgerState
pattern LedgerStateConway :: LedgerState StandardConwayBlock EmptyMK -> LedgerState
pattern LedgerStateMary :: LedgerState StandardMaryBlock EmptyMK -> LedgerState
pattern LedgerStateShelley :: LedgerState StandardShelleyBlock EmptyMK -> LedgerState
data () => LedgerStateError
ApplyBlockHashMismatch :: Text -> LedgerStateError
ApplyBlockError :: CardanoLedgerError StandardCrypto -> LedgerStateError
InvalidRollback :: SlotNo -> ChainPoint -> LedgerStateError
TerminationEpochReached :: EpochNo -> LedgerStateError
UnexpectedLedgerState :: AnyShelleyBasedEra -> NS (Current (Flip LedgerState EmptyMK)) (CardanoEras StandardCrypto) -> LedgerStateError
ByronEraUnsupported :: LedgerStateError
DebugError :: !String -> LedgerStateError
data () => NodeConfig
NodeConfig :: !Maybe Double -> !File ByronGenesisConfig 'In -> !GenesisHashByron -> !File ShelleyGenesisConfig 'In -> !GenesisHashShelley -> !File AlonzoGenesis 'In -> !GenesisHashAlonzo -> !Maybe (File ConwayGenesisConfig 'In) -> !Maybe GenesisHashConway -> !RequiresNetworkMagic -> !ProtocolVersion -> !CardanoHardForkTriggers -> NodeConfig
[ncPBftSignatureThreshold] :: NodeConfig -> !Maybe Double
[ncByronGenesisFile] :: NodeConfig -> !File ByronGenesisConfig 'In
[ncByronGenesisHash] :: NodeConfig -> !GenesisHashByron
[ncShelleyGenesisFile] :: NodeConfig -> !File ShelleyGenesisConfig 'In
[ncShelleyGenesisHash] :: NodeConfig -> !GenesisHashShelley
[ncAlonzoGenesisFile] :: NodeConfig -> !File AlonzoGenesis 'In
[ncAlonzoGenesisHash] :: NodeConfig -> !GenesisHashAlonzo
[ncConwayGenesisFile] :: NodeConfig -> !Maybe (File ConwayGenesisConfig 'In)
[ncConwayGenesisHash] :: NodeConfig -> !Maybe GenesisHashConway
[ncRequiresNetworkMagic] :: NodeConfig -> !RequiresNetworkMagic
[ncByronProtocolVersion] :: NodeConfig -> !ProtocolVersion
[ncHardForkTriggers] :: NodeConfig -> !CardanoHardForkTriggers
type NodeConfigFile = File NodeConfig
data () => ValidationMode
FullValidation :: ValidationMode
QuickValidation :: ValidationMode
data () => AnyProposals
AnyProposals :: Proposals era -> AnyProposals
data () => AnyRatificationState
AnyRatificationState :: RatifyState era -> AnyRatificationState
data () => LedgerEvent
PoolRegistration :: LedgerEvent
PoolReRegistration :: LedgerEvent
IncrementalRewardsDistribution :: EpochNo -> Map StakeCredential (Set Reward) -> LedgerEvent
RewardsDistribution :: EpochNo -> Map StakeCredential (Set Reward) -> LedgerEvent
MIRDistribution :: MIRDistributionDetails -> LedgerEvent
PoolReap :: PoolReapDetails -> LedgerEvent
SuccessfulPlutusScript :: NonEmpty PlutusWithContext -> LedgerEvent
FailedPlutusScript :: NonEmpty PlutusWithContext -> LedgerEvent
NewGovernanceProposals :: TxId -> AnyProposals -> LedgerEvent
RemovedGovernanceVotes :: TxId -> Set (Voter, GovActionId) -> Set (Credential 'DRepRole) -> LedgerEvent
EpochBoundaryRatificationState :: AnyRatificationState -> LedgerEvent
data () => MIRDistributionDetails
MIRDistributionDetails :: Map StakeCredential Coin -> Map StakeCredential Coin -> Coin -> Coin -> MIRDistributionDetails
[mirddReservePayouts] :: MIRDistributionDetails -> Map StakeCredential Coin
[mirddTreasuryPayouts] :: MIRDistributionDetails -> Map StakeCredential Coin
[mirddReservesToTreasury] :: MIRDistributionDetails -> Coin
[mirddTreasuryToReserves] :: MIRDistributionDetails -> Coin
data () => PoolReapDetails
PoolReapDetails :: EpochNo -> Map StakeCredential (Map (Hash StakePoolKey) Coin) -> Map StakeCredential (Map (Hash StakePoolKey) Coin) -> PoolReapDetails
[prdEpochNo] :: PoolReapDetails -> EpochNo
[prdRefunded] :: PoolReapDetails -> Map StakeCredential (Map (Hash StakePoolKey) Coin)
[prdUnclaimed] :: PoolReapDetails -> Map StakeCredential (Map (Hash StakePoolKey) Coin)
type MonadIOTransError e (t :: Type -> Type -> Type -> Type) (m :: Type -> Type) = (MonadIO m, MonadIO t m, MonadCatch m, MonadTrans t, MonadError e t m)
type MonadTransError e (t :: Type -> Type -> Type -> Type) (m :: Type -> Type) = (Monad m, MonadTrans t, MonadError e t m)
data () => AcquiringFailure
AFPointTooOld :: AcquiringFailure
AFPointNotOnChain :: AcquiringFailure
data () => LocalChainSyncClient block point tip (m :: Type -> Type)
NoLocalChainSyncClient :: LocalChainSyncClient block point tip (m :: Type -> Type)
LocalChainSyncClientPipelined :: ChainSyncClientPipelined block point tip m () -> LocalChainSyncClient block point tip (m :: Type -> Type)
LocalChainSyncClient :: ChainSyncClient block point tip m () -> LocalChainSyncClient block point tip (m :: Type -> Type)
data () => LocalNodeClientParams
[LocalNodeClientParamsSingleBlock] :: forall block. (ProtocolClient block, LedgerSupportsProtocol (ShelleyBlock (TPraos StandardCrypto) ShelleyEra)) => ProtocolClientInfoArgs block -> (NodeToClientVersion -> LocalNodeClientProtocolsForBlock block) -> LocalNodeClientParams
[LocalNodeClientParamsCardano] :: forall block. (ProtocolClient block, CardanoHardForkConstraints (ConsensusCryptoForBlock block)) => ProtocolClientInfoArgs block -> (NodeToClientVersion -> LocalNodeClientProtocolsForBlock block) -> LocalNodeClientParams
data () => LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type)
LocalNodeClientProtocols :: LocalChainSyncClient block point tip m -> Maybe (LocalTxSubmissionClient tx txerr m ()) -> Maybe (LocalStateQueryClient block point query m ()) -> Maybe (LocalTxMonitorClient txid tx slot m ()) -> LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type)
[localChainSyncClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> LocalChainSyncClient block point tip m
[localTxSubmissionClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> Maybe (LocalTxSubmissionClient tx txerr m ())
[localStateQueryClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> Maybe (LocalStateQueryClient block point query m ())
[localTxMonitoringClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> Maybe (LocalTxMonitorClient txid tx slot m ())
type LocalNodeClientProtocolsInMode = LocalNodeClientProtocols BlockInMode ChainPoint ChainTip SlotNo TxInMode TxIdInMode TxValidationErrorInCardanoMode QueryInMode IO
data () => LocalNodeConnectInfo
LocalNodeConnectInfo :: ConsensusModeParams -> NetworkId -> SocketPath -> LocalNodeConnectInfo
[localConsensusModeParams] :: LocalNodeConnectInfo -> ConsensusModeParams
[localNodeNetworkId] :: LocalNodeConnectInfo -> NetworkId
[localNodeSocketPath] :: LocalNodeConnectInfo -> SocketPath
data () => LocalTxMonitoringQuery
LocalTxMonitoringQueryTx :: TxIdInMode -> LocalTxMonitoringQuery
LocalTxMonitoringSendNextTx :: LocalTxMonitoringQuery
LocalTxMonitoringMempoolInformation :: LocalTxMonitoringQuery
data () => LocalTxMonitoringResult
LocalTxMonitoringTxExists :: TxId -> SlotNo -> LocalTxMonitoringResult
LocalTxMonitoringTxDoesNotExist :: TxId -> SlotNo -> LocalTxMonitoringResult
LocalTxMonitoringNextTx :: Maybe TxInMode -> SlotNo -> LocalTxMonitoringResult
LocalTxMonitoringMempoolSizeAndCapacity :: MempoolSizeAndCapacity -> SlotNo -> LocalTxMonitoringResult
data () => LocalStateQueryExpr block point (query :: Type -> Type) r (m :: Type -> Type) a
data () => UnsupportedNtcVersionError
UnsupportedNtcVersionError :: !NodeToClientVersion -> ![NodeToClientVersion] -> UnsupportedNtcVersionError
data () => DebugPlutusFailure
DebugPlutusFailure :: EvaluationError -> PlutusWithContext -> ExUnits -> [Text] -> DebugPlutusFailure
[dpfEvaluationError] :: DebugPlutusFailure -> EvaluationError
[dpfScriptWithContext] :: DebugPlutusFailure -> PlutusWithContext
[dpfExecutionUnits] :: DebugPlutusFailure -> ExUnits
[dpfExecutionLogs] :: DebugPlutusFailure -> [Text]
data () => AnyPlutusScriptVersion
[AnyPlutusScriptVersion] :: forall lang. IsPlutusScriptLanguage lang => PlutusScriptVersion lang -> AnyPlutusScriptVersion
data () => AnyScriptLanguage
[AnyScriptLanguage] :: forall lang. ScriptLanguage lang -> AnyScriptLanguage
class () => HasScriptLanguageInEra lang era
scriptLanguageInEra :: HasScriptLanguageInEra lang era => ScriptLanguageInEra lang era
class IsScriptLanguage lang => IsPlutusScriptLanguage lang
plutusScriptVersion :: IsPlutusScriptLanguage lang => PlutusScriptVersion lang
class HasTypeProxy lang => IsScriptLanguage lang
scriptLanguage :: IsScriptLanguage lang => ScriptLanguage lang
class () => IsScriptWitnessInCtx ctx
scriptWitnessInCtx :: IsScriptWitnessInCtx ctx => ScriptWitnessInCtx ctx
data () => KeyWitnessInCtx witctx
[KeyWitnessForSpending] :: KeyWitnessInCtx WitCtxTxIn
[KeyWitnessForStakeAddr] :: KeyWitnessInCtx WitCtxStake
data () => PlutusScriptInEra era lang
[PlutusScriptInEra] :: forall lang era. PlutusScript lang -> PlutusScriptInEra era lang
data () => PlutusScriptOrReferenceInput lang
PScript :: PlutusScript lang -> PlutusScriptOrReferenceInput lang
PReferenceScript :: TxIn -> PlutusScriptOrReferenceInput lang
data () => PlutusScriptV1
data () => PlutusScriptV2
data () => PlutusScriptV3
data () => PlutusScriptVersion lang
[PlutusScriptV1] :: PlutusScriptVersion PlutusScriptV1
[PlutusScriptV2] :: PlutusScriptVersion PlutusScriptV2
[PlutusScriptV3] :: PlutusScriptVersion PlutusScriptV3
data () => ScriptInAnyLang
[ScriptInAnyLang] :: forall lang. ScriptLanguage lang -> Script lang -> ScriptInAnyLang
data () => ScriptLanguageInEra lang era
[SimpleScriptInShelley] :: ScriptLanguageInEra SimpleScript' ShelleyEra
[SimpleScriptInAllegra] :: ScriptLanguageInEra SimpleScript' AllegraEra
[SimpleScriptInMary] :: ScriptLanguageInEra SimpleScript' MaryEra
[SimpleScriptInAlonzo] :: ScriptLanguageInEra SimpleScript' AlonzoEra
[SimpleScriptInBabbage] :: ScriptLanguageInEra SimpleScript' BabbageEra
[SimpleScriptInConway] :: ScriptLanguageInEra SimpleScript' ConwayEra
[PlutusScriptV1InAlonzo] :: ScriptLanguageInEra PlutusScriptV1 AlonzoEra
[PlutusScriptV1InBabbage] :: ScriptLanguageInEra PlutusScriptV1 BabbageEra
[PlutusScriptV1InConway] :: ScriptLanguageInEra PlutusScriptV1 ConwayEra
[PlutusScriptV2InBabbage] :: ScriptLanguageInEra PlutusScriptV2 BabbageEra
[PlutusScriptV2InConway] :: ScriptLanguageInEra PlutusScriptV2 ConwayEra
[PlutusScriptV3InConway] :: ScriptLanguageInEra PlutusScriptV3 ConwayEra
type ScriptRedeemer = HashableScriptData
data () => ScriptWitnessInCtx witctx
[ScriptWitnessForSpending] :: ScriptWitnessInCtx WitCtxTxIn
[ScriptWitnessForMinting] :: ScriptWitnessInCtx WitCtxMint
[ScriptWitnessForStakeAddr] :: ScriptWitnessInCtx WitCtxStake
data () => SimpleScript
RequireSignature :: !Hash PaymentKey -> SimpleScript
RequireTimeBefore :: !SlotNo -> SimpleScript
RequireTimeAfter :: !SlotNo -> SimpleScript
RequireAllOf :: ![SimpleScript] -> SimpleScript
RequireAnyOf :: ![SimpleScript] -> SimpleScript
RequireMOf :: !Int -> ![SimpleScript] -> SimpleScript
data () => SimpleScript'
data () => SimpleScriptOrReferenceInput lang
SScript :: SimpleScript -> SimpleScriptOrReferenceInput lang
SReferenceScript :: TxIn -> SimpleScriptOrReferenceInput lang
class () => ToAlonzoScript lang era
toLedgerScript :: ToAlonzoScript lang era => PlutusScript lang -> AlonzoScript (ShelleyLedgerEra era)
type family ToLedgerPlutusLanguage lang :: Language
data () => WitCtx witctx
[WitCtxTxIn] :: WitCtx WitCtxTxIn
[WitCtxMint] :: WitCtx WitCtxMint
[WitCtxStake] :: WitCtx WitCtxStake
data () => WitCtxMint
data () => WitCtxStake
data () => WitCtxTxIn
data () => HashableScriptData
HashableScriptData :: !ByteString -> !ScriptData -> HashableScriptData
newtype () => ScriptBytesError
ScriptBytesError :: String -> ScriptBytesError
data () => ScriptDataJsonBytesError
ScriptDataJsonBytesErrorValue :: ScriptDataJsonError -> ScriptDataJsonBytesError
ScriptDataJsonBytesErrorInvalid :: ScriptDataRangeError -> ScriptDataJsonBytesError
data () => ScriptDataJsonError
ScriptDataJsonSchemaError :: !Value -> !ScriptDataJsonSchemaError -> ScriptDataJsonError
ScriptDataRangeError :: !Value -> !ScriptDataRangeError -> ScriptDataJsonError
data () => ScriptDataJsonSchema
ScriptDataJsonNoSchema :: ScriptDataJsonSchema
ScriptDataJsonDetailedSchema :: ScriptDataJsonSchema
data () => ScriptDataJsonSchemaError
ScriptDataJsonNullNotAllowed :: ScriptDataJsonSchemaError
ScriptDataJsonBoolNotAllowed :: ScriptDataJsonSchemaError
ScriptDataJsonNumberNotInteger :: !Double -> ScriptDataJsonSchemaError
ScriptDataJsonNotObject :: !Value -> ScriptDataJsonSchemaError
ScriptDataJsonBadObject :: ![(Text, Value)] -> ScriptDataJsonSchemaError
ScriptDataJsonBadMapPair :: !Value -> ScriptDataJsonSchemaError
ScriptDataJsonTypeMismatch :: !Text -> !Value -> ScriptDataJsonSchemaError
newtype () => ScriptDataRangeError
ScriptDataConstructorOutOfRange :: Integer -> ScriptDataRangeError
type Ann = AnsiStyle
newtype () => ShowOf a
ShowOf :: a -> ShowOf a
data () => AlonzoOnwardsPParams ledgerera
AlonzoOnwardsPParams :: StrictMaybe CostModels -> StrictMaybe Prices -> StrictMaybe ExUnits -> StrictMaybe ExUnits -> StrictMaybe Natural -> StrictMaybe Natural -> StrictMaybe Natural -> AlonzoOnwardsPParams ledgerera
[alCostModels] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe CostModels
[alPrices] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe Prices
[alMaxTxExUnits] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe ExUnits
[alMaxBlockExUnits] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe ExUnits
[alMaxValSize] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe Natural
[alCollateralPercentage] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe Natural
[alMaxCollateralInputs] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe Natural
data () => CommonProtocolParametersUpdate
CommonProtocolParametersUpdate :: StrictMaybe Coin -> StrictMaybe Coin -> StrictMaybe Word32 -> StrictMaybe Word32 -> StrictMaybe Word16 -> StrictMaybe Coin -> StrictMaybe Coin -> StrictMaybe EpochInterval -> StrictMaybe Word16 -> StrictMaybe NonNegativeInterval -> StrictMaybe UnitInterval -> StrictMaybe UnitInterval -> StrictMaybe Coin -> CommonProtocolParametersUpdate
[cppMinFeeA] :: CommonProtocolParametersUpdate -> StrictMaybe Coin
[cppMinFeeB] :: CommonProtocolParametersUpdate -> StrictMaybe Coin
[cppMaxBlockBodySize] :: CommonProtocolParametersUpdate -> StrictMaybe Word32
[cppMaxTxSize] :: CommonProtocolParametersUpdate -> StrictMaybe Word32
[cppMaxBlockHeaderSize] :: CommonProtocolParametersUpdate -> StrictMaybe Word16
[cppKeyDeposit] :: CommonProtocolParametersUpdate -> StrictMaybe Coin
[cppPoolDeposit] :: CommonProtocolParametersUpdate -> StrictMaybe Coin
[cppPoolRetireMaxEpoch] :: CommonProtocolParametersUpdate -> StrictMaybe EpochInterval
[cppStakePoolTargetNum] :: CommonProtocolParametersUpdate -> StrictMaybe Word16
[cppPoolPledgeInfluence] :: CommonProtocolParametersUpdate -> StrictMaybe NonNegativeInterval
[cppTreasuryExpansion] :: CommonProtocolParametersUpdate -> StrictMaybe UnitInterval
[cppMonetaryExpansion] :: CommonProtocolParametersUpdate -> StrictMaybe UnitInterval
[cppMinPoolCost] :: CommonProtocolParametersUpdate -> StrictMaybe Coin
newtype () => CostModel
CostModel :: [Int64] -> CostModel
newtype () => CostModels
CostModels :: Map AnyPlutusScriptVersion CostModel -> CostModels
[unCostModels] :: CostModels -> Map AnyPlutusScriptVersion CostModel
newtype () => DeprecatedAfterBabbagePParams ledgerera
DeprecatedAfterBabbagePParams :: StrictMaybe ProtVer -> DeprecatedAfterBabbagePParams ledgerera
newtype () => DeprecatedAfterMaryPParams ledgerera
DeprecatedAfterMaryPParams :: StrictMaybe Coin -> DeprecatedAfterMaryPParams ledgerera
data () => EraBasedProtocolParametersUpdate era
[ShelleyEraBasedProtocolParametersUpdate] :: CommonProtocolParametersUpdate -> DeprecatedAfterMaryPParams ShelleyEra -> DeprecatedAfterBabbagePParams ShelleyEra -> ShelleyToAlonzoPParams ShelleyEra -> EraBasedProtocolParametersUpdate ShelleyEra
[AllegraEraBasedProtocolParametersUpdate] :: CommonProtocolParametersUpdate -> DeprecatedAfterMaryPParams AllegraEra -> ShelleyToAlonzoPParams AllegraEra -> DeprecatedAfterBabbagePParams ShelleyEra -> EraBasedProtocolParametersUpdate AllegraEra
[MaryEraBasedProtocolParametersUpdate] :: CommonProtocolParametersUpdate -> DeprecatedAfterMaryPParams MaryEra -> ShelleyToAlonzoPParams MaryEra -> DeprecatedAfterBabbagePParams ShelleyEra -> EraBasedProtocolParametersUpdate MaryEra
[AlonzoEraBasedProtocolParametersUpdate] :: CommonProtocolParametersUpdate -> ShelleyToAlonzoPParams AlonzoEra -> AlonzoOnwardsPParams AlonzoEra -> DeprecatedAfterBabbagePParams ShelleyEra -> EraBasedProtocolParametersUpdate AlonzoEra
[BabbageEraBasedProtocolParametersUpdate] :: CommonProtocolParametersUpdate -> AlonzoOnwardsPParams BabbageEra -> DeprecatedAfterBabbagePParams ShelleyEra -> IntroducedInBabbagePParams BabbageEra -> EraBasedProtocolParametersUpdate BabbageEra
[ConwayEraBasedProtocolParametersUpdate] :: CommonProtocolParametersUpdate -> AlonzoOnwardsPParams ConwayEra -> IntroducedInBabbagePParams ConwayEra -> IntroducedInConwayPParams (ShelleyLedgerEra ConwayEra) -> EraBasedProtocolParametersUpdate ConwayEra
data () => ExecutionUnitPrices
ExecutionUnitPrices :: Rational -> Rational -> ExecutionUnitPrices
[priceExecutionSteps] :: ExecutionUnitPrices -> Rational
[priceExecutionMemory] :: ExecutionUnitPrices -> Rational
newtype () => IntroducedInBabbagePParams era
IntroducedInBabbagePParams :: StrictMaybe CoinPerByte -> IntroducedInBabbagePParams era
data () => IntroducedInConwayPParams era
IntroducedInConwayPParams :: StrictMaybe PoolVotingThresholds -> StrictMaybe DRepVotingThresholds -> StrictMaybe Natural -> StrictMaybe EpochInterval -> StrictMaybe EpochInterval -> StrictMaybe Coin -> StrictMaybe Coin -> StrictMaybe EpochInterval -> StrictMaybe NonNegativeInterval -> IntroducedInConwayPParams era
[icPoolVotingThresholds] :: IntroducedInConwayPParams era -> StrictMaybe PoolVotingThresholds
[icDRepVotingThresholds] :: IntroducedInConwayPParams era -> StrictMaybe DRepVotingThresholds
[icMinCommitteeSize] :: IntroducedInConwayPParams era -> StrictMaybe Natural
[icCommitteeTermLength] :: IntroducedInConwayPParams era -> StrictMaybe EpochInterval
[icGovActionLifetime] :: IntroducedInConwayPParams era -> StrictMaybe EpochInterval
[icGovActionDeposit] :: IntroducedInConwayPParams era -> StrictMaybe Coin
[icDRepDeposit] :: IntroducedInConwayPParams era -> StrictMaybe Coin
[icDRepActivity] :: IntroducedInConwayPParams era -> StrictMaybe EpochInterval
[icMinFeeRefScriptCostPerByte] :: IntroducedInConwayPParams era -> StrictMaybe NonNegativeInterval
data () => PraosNonce
data () => ProtocolParametersConversionError
PpceOutOfBounds :: !ProtocolParameterName -> !Rational -> ProtocolParametersConversionError
PpceVersionInvalid :: !ProtocolParameterVersion -> ProtocolParametersConversionError
PpceInvalidCostModel :: !CostModel -> !CostModelApplyError -> ProtocolParametersConversionError
PpceMissingParameter :: !ProtocolParameterName -> ProtocolParametersConversionError
data () => ProtocolParametersError
PParamsErrorMissingMinUTxoValue :: !AnyCardanoEra -> ProtocolParametersError
PParamsErrorMissingAlonzoProtocolParameter :: ProtocolParametersError
data () => ProtocolParametersUpdate
ProtocolParametersUpdate :: Maybe (Natural, Natural) -> Maybe Rational -> Maybe (Maybe PraosNonce) -> Maybe Word16 -> Maybe Word32 -> Maybe Word32 -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe EpochInterval -> Maybe Word16 -> Maybe Rational -> Maybe Rational -> Maybe Rational -> Map AnyPlutusScriptVersion CostModel -> Maybe ExecutionUnitPrices -> Maybe ExecutionUnits -> Maybe ExecutionUnits -> Maybe Natural -> Maybe Natural -> Maybe Natural -> Maybe Coin -> ProtocolParametersUpdate
[protocolUpdateProtocolVersion] :: ProtocolParametersUpdate -> Maybe (Natural, Natural)
[protocolUpdateDecentralization] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateExtraPraosEntropy] :: ProtocolParametersUpdate -> Maybe (Maybe PraosNonce)
[protocolUpdateMaxBlockHeaderSize] :: ProtocolParametersUpdate -> Maybe Word16
[protocolUpdateMaxBlockBodySize] :: ProtocolParametersUpdate -> Maybe Word32
[protocolUpdateMaxTxSize] :: ProtocolParametersUpdate -> Maybe Word32
[protocolUpdateTxFeeFixed] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateTxFeePerByte] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateMinUTxOValue] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateStakeAddressDeposit] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateStakePoolDeposit] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateMinPoolCost] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdatePoolRetireMaxEpoch] :: ProtocolParametersUpdate -> Maybe EpochInterval
[protocolUpdateStakePoolTargetNum] :: ProtocolParametersUpdate -> Maybe Word16
[protocolUpdatePoolPledgeInfluence] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateMonetaryExpansion] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateTreasuryCut] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateCostModels] :: ProtocolParametersUpdate -> Map AnyPlutusScriptVersion CostModel
[protocolUpdatePrices] :: ProtocolParametersUpdate -> Maybe ExecutionUnitPrices
[protocolUpdateMaxTxExUnits] :: ProtocolParametersUpdate -> Maybe ExecutionUnits
[protocolUpdateMaxBlockExUnits] :: ProtocolParametersUpdate -> Maybe ExecutionUnits
[protocolUpdateMaxValueSize] :: ProtocolParametersUpdate -> Maybe Natural
[protocolUpdateCollateralPercent] :: ProtocolParametersUpdate -> Maybe Natural
[protocolUpdateMaxCollateralInputs] :: ProtocolParametersUpdate -> Maybe Natural
[protocolUpdateUTxOCostPerByte] :: ProtocolParametersUpdate -> Maybe Coin
data () => ShelleyToAlonzoPParams ledgerera
ShelleyToAlonzoPParams :: StrictMaybe Nonce -> StrictMaybe UnitInterval -> ShelleyToAlonzoPParams ledgerera
data () => UpdateProposal
UpdateProposal :: !Map (Hash GenesisKey) ProtocolParametersUpdate -> !EpochNo -> UpdateProposal
data () => QueryConvenienceError
AcqFailure :: AcquiringFailure -> QueryConvenienceError
QueryEraMismatch :: EraMismatch -> QueryConvenienceError
ByronEraNotSupported :: QueryConvenienceError
QceUnsupportedNtcVersion :: !UnsupportedNtcVersionError -> QueryConvenienceError
QceUnexpectedException :: !SomeException -> QueryConvenienceError
newtype () => TxCurrentTreasuryValue
TxCurrentTreasuryValue :: Coin -> TxCurrentTreasuryValue
[unTxCurrentTreasuryValue] :: TxCurrentTreasuryValue -> Coin
newtype () => DebugLedgerState era
DebugLedgerState :: NewEpochState (ShelleyLedgerEra era) -> DebugLedgerState era
[unDebugLedgerState] :: DebugLedgerState era -> NewEpochState (ShelleyLedgerEra era)
newtype () => DelegationsAndRewards
DelegationsAndRewards :: (Map StakeAddress Coin, Map StakeAddress PoolId) -> DelegationsAndRewards
newtype () => CurrentEpochState era
CurrentEpochState :: EpochState (ShelleyLedgerEra era) -> CurrentEpochState era
data () => EraHistory
[EraHistory] :: forall (xs :: [Type]). CardanoBlock StandardCrypto ~ HardForkBlock xs => Interpreter xs -> EraHistory
newtype () => LedgerEpochInfo
LedgerEpochInfo :: EpochInfo (Either Text) -> LedgerEpochInfo
[unLedgerEpochInfo] :: LedgerEpochInfo -> EpochInfo (Either Text)
newtype () => PoolDistribution era
PoolDistribution :: PoolDistr StandardCrypto -> PoolDistribution era
[unPoolDistr] :: PoolDistribution era -> PoolDistr StandardCrypto
newtype () => PoolState era
PoolState :: PState (ShelleyLedgerEra era) -> PoolState era
newtype () => ProtocolState era
ProtocolState :: Serialised (ChainDepState (ConsensusProtocol era)) -> ProtocolState era
data () => QueryInEra era result
[QueryByronUpdateState] :: QueryInEra ByronEra ByronUpdateState
[QueryInShelleyBasedEra] :: forall era result. ShelleyBasedEra era -> QueryInShelleyBasedEra era result -> QueryInEra era result
data () => QueryInMode result
[QueryCurrentEra] :: QueryInMode AnyCardanoEra
[QueryInEra] :: forall era result1. QueryInEra era result1 -> QueryInMode (Either EraMismatch result1)
[QueryEraHistory] :: QueryInMode EraHistory
[QuerySystemStart] :: QueryInMode SystemStart
[QueryChainBlockNo] :: QueryInMode (WithOrigin BlockNo)
[QueryChainPoint] :: QueryInMode ChainPoint
[QueryLedgerConfig] :: QueryInMode (HardForkLedgerConfig (CardanoEras StandardCrypto))
data () => QueryInShelleyBasedEra era result
[QueryEpoch] :: forall era. QueryInShelleyBasedEra era EpochNo
[QueryGenesisParameters] :: forall era. QueryInShelleyBasedEra era (GenesisParameters ShelleyEra)
[QueryProtocolParameters] :: forall era. QueryInShelleyBasedEra era (PParams (ShelleyLedgerEra era))
[QueryStakeDistribution] :: forall era. QueryInShelleyBasedEra era (Map (Hash StakePoolKey) Rational)
[QueryUTxO] :: forall era. QueryUTxOFilter -> QueryInShelleyBasedEra era (UTxO era)
[QueryStakeAddresses] :: forall era. Set StakeCredential -> NetworkId -> QueryInShelleyBasedEra era (Map StakeAddress Coin, Map StakeAddress PoolId)
[QueryStakePools] :: forall era. QueryInShelleyBasedEra era (Set PoolId)
[QueryStakePoolParameters] :: forall era. Set PoolId -> QueryInShelleyBasedEra era (Map PoolId StakePoolParameters)
[QueryDebugLedgerState] :: forall era. QueryInShelleyBasedEra era (SerialisedDebugLedgerState era)
[QueryProtocolState] :: forall era. QueryInShelleyBasedEra era (ProtocolState era)
[QueryCurrentEpochState] :: forall era. QueryInShelleyBasedEra era (SerialisedCurrentEpochState era)
[QueryPoolState] :: forall era. Maybe (Set PoolId) -> QueryInShelleyBasedEra era (SerialisedPoolState era)
[QueryPoolDistribution] :: forall era. Maybe (Set PoolId) -> QueryInShelleyBasedEra era (SerialisedPoolDistribution era)
[QueryStakeSnapshot] :: forall era. Maybe (Set PoolId) -> QueryInShelleyBasedEra era (SerialisedStakeSnapshots era)
[QueryStakeDelegDeposits] :: forall era. Set StakeCredential -> QueryInShelleyBasedEra era (Map StakeCredential Coin)
[QueryAccountState] :: forall era. QueryInShelleyBasedEra era AccountState
[QueryConstitution] :: forall era. QueryInShelleyBasedEra era (Constitution (ShelleyLedgerEra era))
[QueryGovState] :: forall era. QueryInShelleyBasedEra era (GovState (ShelleyLedgerEra era))
[QueryRatifyState] :: forall era. QueryInShelleyBasedEra era (RatifyState (ShelleyLedgerEra era))
[QueryFuturePParams] :: forall era. QueryInShelleyBasedEra era (Maybe (PParams (ShelleyLedgerEra era)))
[QueryDRepState] :: forall era. Set (Credential 'DRepRole) -> QueryInShelleyBasedEra era (Map (Credential 'DRepRole) DRepState)
[QueryDRepStakeDistr] :: forall era. Set DRep -> QueryInShelleyBasedEra era (Map DRep Coin)
[QuerySPOStakeDistr] :: forall era. Set (KeyHash 'StakePool) -> QueryInShelleyBasedEra era (Map (KeyHash 'StakePool) Coin)
[QueryCommitteeMembersState] :: forall era. Set (Credential 'ColdCommitteeRole) -> Set (Credential 'HotCommitteeRole) -> Set MemberStatus -> QueryInShelleyBasedEra era CommitteeMembersState
[QueryStakeVoteDelegatees] :: forall era. Set StakeCredential -> QueryInShelleyBasedEra era (Map StakeCredential DRep)
[QueryProposals] :: forall era. Set GovActionId -> QueryInShelleyBasedEra era (Seq (GovActionState (ShelleyLedgerEra era)))
[QueryLedgerPeerSnapshot] :: forall era. QueryInShelleyBasedEra era (Serialised LedgerPeerSnapshot)
[QueryStakePoolDefaultVote] :: forall era. KeyHash 'StakePool -> QueryInShelleyBasedEra era DefaultVote
data () => QueryUTxOFilter
QueryUTxOWhole :: QueryUTxOFilter
QueryUTxOByAddress :: Set AddressAny -> QueryUTxOFilter
QueryUTxOByTxIn :: Set TxIn -> QueryUTxOFilter
newtype () => SerialisedCurrentEpochState era
SerialisedCurrentEpochState :: Serialised (EpochState (ShelleyLedgerEra era)) -> SerialisedCurrentEpochState era
newtype () => SerialisedDebugLedgerState era
SerialisedDebugLedgerState :: Serialised (NewEpochState (ShelleyLedgerEra era)) -> SerialisedDebugLedgerState era
newtype () => SerialisedPoolDistribution era
SerialisedPoolDistribution :: Serialised (PoolDistr StandardCrypto) -> SerialisedPoolDistribution era
newtype () => SerialisedPoolState era
SerialisedPoolState :: Serialised (PState (ShelleyLedgerEra era)) -> SerialisedPoolState era
newtype () => SerialisedStakeSnapshots era
SerialisedStakeSnapshots :: Serialised StakeSnapshots -> SerialisedStakeSnapshots era
newtype () => SlotsInEpoch
SlotsInEpoch :: Word64 -> SlotsInEpoch
newtype () => SlotsToEpochEnd
SlotsToEpochEnd :: Word64 -> SlotsToEpochEnd
newtype () => StakeSnapshot era
StakeSnapshot :: StakeSnapshots -> StakeSnapshot era
data () => UTxOInAnyEra
[UTxOInAnyEra] :: forall era. CardanoEra era -> UTxO era -> UTxOInAnyEra
data () => Bech32DecodeError
Bech32DecodingError :: !DecodingError -> Bech32DecodeError
Bech32UnexpectedPrefix :: !Text -> !Set Text -> Bech32DecodeError
Bech32DataPartToBytesError :: !Text -> Bech32DecodeError
Bech32DeserialiseFromBytesError :: !ByteString -> Bech32DecodeError
Bech32WrongPrefix :: !Text -> !Text -> Bech32DecodeError
Bech32UnexpectedHeader :: !Text -> !Text -> Bech32DecodeError
class (HasTypeProxy a, SerialiseAsRawBytes a) => SerialiseAsBech32 a
bech32PrefixFor :: SerialiseAsBech32 a => a -> HumanReadablePart
bech32PrefixesPermitted :: SerialiseAsBech32 a => AsType a -> [HumanReadablePart]
class HasTypeProxy a => SerialiseAsCBOR a
serialiseToCBOR :: SerialiseAsCBOR a => a -> ByteString
deserialiseFromCBOR :: SerialiseAsCBOR a => AsType a -> ByteString -> Either DecoderError a
class (SerialiseAsRawBytes a, HasTypeProxy a) => Cip129 a
cip129Bech32PrefixFor :: Cip129 a => AsType a -> HumanReadablePart
cip129HeaderHexByte :: Cip129 a => a -> ByteString
cip129Bech32PrefixesPermitted :: Cip129 a => AsType a -> [Text]
data () => InputDecodeError
InputTextEnvelopeError :: !TextEnvelopeError -> InputDecodeError
InputBech32DecodeError :: !Bech32DecodeError -> InputDecodeError
InputInvalidError :: InputDecodeError
data () => InputFormat a
[InputFormatBech32] :: forall a. SerialiseAsBech32 a => InputFormat a
[InputFormatHex] :: forall a. SerialiseAsRawBytes a => InputFormat a
[InputFormatTextEnvelope] :: forall a. HasTextEnvelope a => InputFormat a
newtype () => JsonDecodeError
JsonDecodeError :: String -> JsonDecodeError
data () => RawBytesHexError
RawBytesHexErrorBase16DecodeFail :: ByteString -> TypeRep -> String -> RawBytesHexError
RawBytesHexErrorRawBytesDecodeFail :: ByteString -> TypeRep -> SerialiseAsRawBytesError -> RawBytesHexError
class (HasTypeProxy a, Typeable a) => SerialiseAsRawBytes a
serialiseToRawBytes :: SerialiseAsRawBytes a => a -> ByteString
deserialiseFromRawBytes :: SerialiseAsRawBytes a => AsType a -> ByteString -> Either SerialiseAsRawBytesError a
newtype () => SerialiseAsRawBytesError
SerialiseAsRawBytesError :: String -> SerialiseAsRawBytesError
[unSerialiseAsRawBytesError] :: SerialiseAsRawBytesError -> String
newtype () => UsingBech32 a
UsingBech32 :: a -> UsingBech32 a
newtype () => UsingRawBytes a
UsingRawBytes :: a -> UsingRawBytes a
newtype () => UsingRawBytesHex a
UsingRawBytesHex :: a -> UsingRawBytesHex a
class SerialiseAsCBOR a => HasTextEnvelope a
textEnvelopeType :: HasTextEnvelope a => AsType a -> TextEnvelopeType
textEnvelopeDefaultDescr :: HasTextEnvelope a => a -> TextEnvelopeDescr
data () => TextEnvelope
TextEnvelope :: !TextEnvelopeType -> !TextEnvelopeDescr -> !ByteString -> TextEnvelope
[teType] :: TextEnvelope -> !TextEnvelopeType
[teDescription] :: TextEnvelope -> !TextEnvelopeDescr
[teRawCBOR] :: TextEnvelope -> !ByteString
newtype () => TextEnvelopeDescr
TextEnvelopeDescr :: String -> TextEnvelopeDescr
data () => TextEnvelopeError
TextEnvelopeTypeError :: ![TextEnvelopeType] -> !TextEnvelopeType -> TextEnvelopeError
TextEnvelopeDecodeError :: !DecoderError -> TextEnvelopeError
TextEnvelopeAesonDecodeError :: !String -> TextEnvelopeError
newtype () => TextEnvelopeType
TextEnvelopeType :: String -> TextEnvelopeType
data () => FromSomeTypeCDDL c b
[FromCDDLTx] :: forall b. Text -> (InAnyShelleyBasedEra Tx -> b) -> FromSomeTypeCDDL TextEnvelope b
[FromCDDLWitness] :: forall b. Text -> (InAnyShelleyBasedEra KeyWitness -> b) -> FromSomeTypeCDDL TextEnvelope b
data () => TextEnvelopeCddlError
TextEnvelopeCddlErrCBORDecodingError :: DecoderError -> TextEnvelopeCddlError
TextEnvelopeCddlAesonDecodeError :: FilePath -> String -> TextEnvelopeCddlError
TextEnvelopeCddlUnknownKeyWitness :: TextEnvelopeCddlError
TextEnvelopeCddlTypeError :: [Text] -> Text -> TextEnvelopeCddlError
TextEnvelopeCddlErrUnknownType :: Text -> TextEnvelopeCddlError
TextEnvelopeCddlErrByronKeyWitnessUnsupported :: TextEnvelopeCddlError
data () => AnyScriptWitness era
[AnyScriptWitness] :: forall witctx era. Typeable witctx => ScriptWitness witctx era -> AnyScriptWitness era
data () => ScriptWitnessIndex
ScriptWitnessIndexTxIn :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexMint :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexCertificate :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexWithdrawal :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexVoting :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexProposing :: !Word32 -> ScriptWitnessIndex
data () => TxBodyError
TxBodyPlutusScriptDecodeError :: DecoderError -> TxBodyError
TxBodyEmptyTxIns :: TxBodyError
TxBodyEmptyTxInsCollateral :: TxBodyError
TxBodyEmptyTxOuts :: TxBodyError
TxBodyOutputError :: !TxOutputError -> TxBodyError
TxBodyMetadataError :: ![(Word64, TxMetadataRangeError)] -> TxBodyError
TxBodyInIxOverflow :: !TxIn -> TxBodyError
TxBodyMissingProtocolParams :: TxBodyError
TxBodyProtocolParamsConversionError :: !ProtocolParametersConversionError -> TxBodyError
data () => TxCertificates build era
[TxCertificatesNone] :: forall build era. TxCertificates build era
[TxCertificates] :: forall era build. ShelleyBasedEra era -> OMap (Certificate era) (BuildTxWith build (Maybe (StakeCredential, Witness WitCtxStake era))) -> TxCertificates build era
type TxInsReferenceDatums build = BuildTxWith build Set HashableScriptData
data () => TxProposalProcedures build era
[TxProposalProceduresNone] :: forall build era. TxProposalProcedures build era
[TxProposalProcedures] :: forall era build. EraPParams (ShelleyLedgerEra era) => OMap (ProposalProcedure (ShelleyLedgerEra era)) (BuildTxWith build (Maybe (ScriptWitness WitCtxStake era))) -> TxProposalProcedures build era
data () => TxReturnCollateral ctx era
[TxReturnCollateralNone] :: forall ctx era. TxReturnCollateral ctx era
[TxReturnCollateral] :: forall era ctx. BabbageEraOnwards era -> TxOut ctx era -> TxReturnCollateral ctx era
data () => TxTotalCollateral era
[TxTotalCollateralNone] :: forall era. TxTotalCollateral era
[TxTotalCollateral] :: forall era. BabbageEraOnwards era -> Coin -> TxTotalCollateral era
data () => TxUpdateProposal era
[TxUpdateProposalNone] :: forall era. TxUpdateProposal era
[TxUpdateProposal] :: forall era. ShelleyToBabbageEra era -> UpdateProposal -> TxUpdateProposal era
data () => TxVotingProcedures build era
[TxVotingProceduresNone] :: forall build era. TxVotingProcedures build era
[TxVotingProcedures] :: forall era build. VotingProcedures (ShelleyLedgerEra era) -> BuildTxWith build (Map Voter (ScriptWitness WitCtxStake era)) -> TxVotingProcedures build era
data () => TxWithdrawals build era
[TxWithdrawalsNone] :: forall build era. TxWithdrawals build era
[TxWithdrawals] :: forall era build. ShelleyBasedEra era -> [(StakeAddress, Coin, BuildTxWith build (Witness WitCtxStake era))] -> TxWithdrawals build era
newtype () => LedgerTxBody era
LedgerTxBody :: TxBody (ShelleyLedgerEra era) -> LedgerTxBody era
[unTxBody] :: LedgerTxBody era -> TxBody (ShelleyLedgerEra era)
data () => BuildTx
data () => BuildTxWith build a
[ViewTx] :: forall a. BuildTxWith ViewTx a
[BuildTxWith] :: forall a. a -> BuildTxWith BuildTx a
data () => ViewTx
newtype () => ScriptLockedTxInsError
ScriptLockedTxIns :: [TxIn] -> ScriptLockedTxInsError
data () => TxInsExistError
TxInsDoNotExist :: [TxIn] -> TxInsExistError
EmptyUTxO :: TxInsExistError
data () => AutoBalanceError era
AutoBalanceEstimationError :: TxFeeEstimationError era -> AutoBalanceError era
AutoBalanceCalculationError :: TxBodyErrorAutoBalance era -> AutoBalanceError era
data () => FeeEstimationMode era
CalculateWithSpendableUTxO :: UTxO era -> SystemStart -> LedgerEpochInfo -> Maybe Word -> FeeEstimationMode era
EstimateWithoutSpendableUTxO :: Coin -> Value -> Map ScriptWitnessIndex ExecutionUnits -> RequiredShelleyKeyWitnesses -> RequiredByronKeyWitnesses -> TotalReferenceScriptsSize -> FeeEstimationMode era
newtype () => RequiredByronKeyWitnesses
RequiredByronKeyWitnesses :: Int -> RequiredByronKeyWitnesses
[unRequiredByronKeyWitnesses] :: RequiredByronKeyWitnesses -> Int
newtype () => RequiredShelleyKeyWitnesses
RequiredShelleyKeyWitnesses :: Int -> RequiredShelleyKeyWitnesses
[unRequiredShelleyKeyWitnesses] :: RequiredShelleyKeyWitnesses -> Int
data () => ResolvablePointers
[ResolvablePointers] :: forall era. (Era (ShelleyLedgerEra era), Show (PlutusPurpose AsIx (ShelleyLedgerEra era)), Show (PlutusPurpose AsItem (ShelleyLedgerEra era)), Show (PlutusScript (ShelleyLedgerEra era))) => ShelleyBasedEra era -> !Map (PlutusPurpose AsIx (ShelleyLedgerEra era)) (PlutusPurpose AsItem (ShelleyLedgerEra era), Maybe (PlutusScriptBytes, Language), ScriptHash) -> ResolvablePointers
data () => ScriptExecutionError
ScriptErrorMissingTxIn :: TxIn -> ScriptExecutionError
ScriptErrorTxInWithoutDatum :: TxIn -> ScriptExecutionError
ScriptErrorWrongDatum :: Hash ScriptData -> ScriptExecutionError
ScriptErrorEvaluationFailed :: DebugPlutusFailure -> ScriptExecutionError
ScriptErrorExecutionUnitsOverflow :: ScriptExecutionError
ScriptErrorNotPlutusWitnessedTxIn :: ScriptWitnessIndex -> ScriptHash -> ScriptExecutionError
ScriptErrorRedeemerPointsToUnknownScriptHash :: ScriptWitnessIndex -> ScriptExecutionError
ScriptErrorMissingScript :: ScriptWitnessIndex -> ResolvablePointers -> ScriptExecutionError
ScriptErrorMissingCostModel :: Language -> ScriptExecutionError
ScriptErrorTranslationError :: ContextError (ShelleyLedgerEra era) -> ScriptExecutionError
newtype () => TotalReferenceScriptsSize
TotalReferenceScriptsSize :: Int -> TotalReferenceScriptsSize
[unTotalReferenceScriptsSize] :: TotalReferenceScriptsSize -> Int
data () => TransactionValidityError era
[TransactionValidityIntervalError] :: forall era. PastHorizonException -> TransactionValidityError era
[TransactionValidityCostModelError] :: forall era. Map AnyPlutusScriptVersion CostModel -> String -> TransactionValidityError era
data () => TxBodyErrorAutoBalance era
TxBodyError :: TxBodyError -> TxBodyErrorAutoBalance era
TxBodyScriptExecutionError :: [(ScriptWitnessIndex, ScriptExecutionError)] -> TxBodyErrorAutoBalance era
TxBodyScriptBadScriptValidity :: TxBodyErrorAutoBalance era
TxBodyErrorBalanceNegative :: Coin -> MultiAsset -> TxBodyErrorAutoBalance era
TxBodyErrorAdaBalanceTooSmall :: TxOutInAnyEra -> Coin -> Coin -> TxBodyErrorAutoBalance era
TxBodyErrorByronEraNotSupported :: TxBodyErrorAutoBalance era
TxBodyErrorMissingParamMinUTxO :: TxBodyErrorAutoBalance era
TxBodyErrorMinUTxONotMet :: TxOutInAnyEra -> Coin -> TxBodyErrorAutoBalance era
TxBodyErrorNonAdaAssetsUnbalanced :: Value -> TxBodyErrorAutoBalance era
TxBodyErrorScriptWitnessIndexMissingFromExecUnitsMap :: ScriptWitnessIndex -> Map ScriptWitnessIndex ExecutionUnits -> TxBodyErrorAutoBalance era
data () => TxFeeEstimationError era
TxFeeEstimationTransactionTranslationError :: TransactionValidityError era -> TxFeeEstimationError era
TxFeeEstimationScriptExecutionError :: TxBodyErrorAutoBalance era -> TxFeeEstimationError era
TxFeeEstimationBalanceError :: TxBodyErrorAutoBalance era -> TxFeeEstimationError era
TxFeeEstimationxBodyError :: TxBodyError -> TxFeeEstimationError era
TxFeeEstimationFinalConstructionError :: TxBodyError -> TxFeeEstimationError era
TxFeeEstimationOnlyMaryOnwardsSupportedError :: TxFeeEstimationError era
data () => CtxTx
data () => CtxUTxO
data () => TxOutInAnyEra
[TxOutInAnyEra] :: forall era. CardanoEra era -> TxOut CtxTx era -> TxOutInAnyEra
data () => TxOutputError
TxOutputNegative :: !Quantity -> !TxOutInAnyEra -> TxOutputError
TxOutputOverflow :: !Quantity -> !TxOutInAnyEra -> TxOutputError
data () => ScriptValidity
ScriptInvalid :: ScriptValidity
ScriptValid :: ScriptValidity
data () => ShelleySigningKey
ShelleyNormalSigningKey :: SignKeyDSIGN DSIGN -> ShelleySigningKey
ShelleyExtendedSigningKey :: XPrv -> ShelleySigningKey
data () => ShelleyWitnessSigningKey
WitnessPaymentKey :: SigningKey PaymentKey -> ShelleyWitnessSigningKey
WitnessPaymentExtendedKey :: SigningKey PaymentExtendedKey -> ShelleyWitnessSigningKey
WitnessStakeKey :: SigningKey StakeKey -> ShelleyWitnessSigningKey
WitnessStakeExtendedKey :: SigningKey StakeExtendedKey -> ShelleyWitnessSigningKey
WitnessStakePoolKey :: SigningKey StakePoolKey -> ShelleyWitnessSigningKey
WitnessStakePoolExtendedKey :: SigningKey StakePoolExtendedKey -> ShelleyWitnessSigningKey
WitnessGenesisKey :: SigningKey GenesisKey -> ShelleyWitnessSigningKey
WitnessGenesisExtendedKey :: SigningKey GenesisExtendedKey -> ShelleyWitnessSigningKey
WitnessGenesisDelegateKey :: SigningKey GenesisDelegateKey -> ShelleyWitnessSigningKey
WitnessGenesisDelegateExtendedKey :: SigningKey GenesisDelegateExtendedKey -> ShelleyWitnessSigningKey
WitnessGenesisUTxOKey :: SigningKey GenesisUTxOKey -> ShelleyWitnessSigningKey
WitnessCommitteeColdKey :: SigningKey CommitteeColdKey -> ShelleyWitnessSigningKey
WitnessCommitteeColdExtendedKey :: SigningKey CommitteeColdExtendedKey -> ShelleyWitnessSigningKey
WitnessCommitteeHotKey :: SigningKey CommitteeHotKey -> ShelleyWitnessSigningKey
WitnessCommitteeHotExtendedKey :: SigningKey CommitteeHotExtendedKey -> ShelleyWitnessSigningKey
WitnessDRepKey :: SigningKey DRepKey -> ShelleyWitnessSigningKey
WitnessDRepExtendedKey :: SigningKey DRepExtendedKey -> ShelleyWitnessSigningKey
data () => WitnessNetworkIdOrByronAddress
WitnessNetworkId :: !NetworkId -> WitnessNetworkIdOrByronAddress
WitnessByronAddress :: !Address ByronAddr -> WitnessNetworkIdOrByronAddress
newtype () => TxIx
TxIx :: Word -> TxIx
newtype () => TxMetadata
TxMetadata :: Map Word64 TxMetadataValue -> TxMetadata
[unTxMetadata] :: TxMetadata -> Map Word64 TxMetadataValue
data () => TxMetadataJsonError
TxMetadataJsonToplevelNotMap :: TxMetadataJsonError
TxMetadataJsonToplevelBadKey :: !Text -> TxMetadataJsonError
TxMetadataJsonSchemaError :: !Word64 -> !Value -> !TxMetadataJsonSchemaError -> TxMetadataJsonError
TxMetadataRangeError :: !Word64 -> !Value -> !TxMetadataRangeError -> TxMetadataJsonError
data () => TxMetadataJsonSchema
TxMetadataJsonNoSchema :: TxMetadataJsonSchema
TxMetadataJsonDetailedSchema :: TxMetadataJsonSchema
data () => TxMetadataJsonSchemaError
TxMetadataJsonNullNotAllowed :: TxMetadataJsonSchemaError
TxMetadataJsonBoolNotAllowed :: TxMetadataJsonSchemaError
TxMetadataJsonNumberNotInteger :: !Double -> TxMetadataJsonSchemaError
TxMetadataJsonNotObject :: !Value -> TxMetadataJsonSchemaError
TxMetadataJsonBadObject :: ![(Text, Value)] -> TxMetadataJsonSchemaError
TxMetadataJsonBadMapPair :: !Value -> TxMetadataJsonSchemaError
TxMetadataJsonTypeMismatch :: !Text -> !Value -> TxMetadataJsonSchemaError
data () => TxMetadataRangeError
TxMetadataNumberOutOfRange :: !Integer -> TxMetadataRangeError
TxMetadataTextTooLong :: !Int -> TxMetadataRangeError
TxMetadataBytesTooLong :: !Int -> TxMetadataRangeError
data () => TxMetadataValue
TxMetaMap :: [(TxMetadataValue, TxMetadataValue)] -> TxMetadataValue
TxMetaList :: [TxMetadataValue] -> TxMetadataValue
TxMetaNumber :: Integer -> TxMetadataValue
TxMetaBytes :: ByteString -> TxMetadataValue
TxMetaText :: Text -> TxMetadataValue
data () => AssetId
AdaAssetId :: AssetId
AssetId :: !PolicyId -> !AssetName -> AssetId
newtype () => AssetName
UnsafeAssetName :: ByteString -> AssetName
type Lovelace = Coin
newtype () => Quantity
Quantity :: Integer -> Quantity
data () => ValueNestedBundle
ValueNestedBundleAda :: Quantity -> ValueNestedBundle
ValueNestedBundle :: PolicyId -> Map AssetName Quantity -> ValueNestedBundle
newtype () => ValueNestedRep
ValueNestedRep :: [ValueNestedBundle] -> ValueNestedRep
class () => FromJSONKey a
class () => ToJSONKey a
class Typeable a => FromCBOR a
fromCBOR :: FromCBOR a => Decoder s a
label :: FromCBOR a => Proxy a -> Text
data () => CommitteeMembersState
CommitteeMembersState :: !Map (Credential 'ColdCommitteeRole) CommitteeMemberState -> !Maybe UnitInterval -> !EpochNo -> CommitteeMembersState
[csCommittee] :: CommitteeMembersState -> !Map (Credential 'ColdCommitteeRole) CommitteeMemberState
[csThreshold] :: CommitteeMembersState -> !Maybe UnitInterval
[csEpochNo] :: CommitteeMembersState -> !EpochNo
data () => MemberStatus
Active :: MemberStatus
Expired :: MemberStatus
Unrecognized :: MemberStatus
newtype () => EpochSlots
EpochSlots :: Word64 -> EpochSlots
[unEpochSlots] :: EpochSlots -> Word64
data () => ATxAux a
ATxAux :: !Annotated Tx a -> !Annotated TxWitness a -> !a -> ATxAux a
[aTaTx] :: ATxAux a -> !Annotated Tx a
[aTaWitness] :: ATxAux a -> !Annotated TxWitness a
[aTaAnnotation] :: ATxAux a -> !a
class () => Inject t s
inject :: Inject t s => t -> s
newtype () => Coin
Coin :: Integer -> Coin
[unCoin] :: Coin -> Integer
data () => ShelleyGenesis
ShelleyGenesis :: !UTCTime -> !Word32 -> !Network -> !PositiveUnitInterval -> !NonZero Word64 -> !EpochSize -> !Word64 -> !Word64 -> !NominalDiffTimeMicro -> !Word64 -> !Word64 -> !PParams ShelleyEra -> !Map (KeyHash 'Genesis) GenDelegPair -> ListMap Addr Coin -> ShelleyGenesisStaking -> ShelleyGenesis
[sgSystemStart] :: ShelleyGenesis -> !UTCTime
[sgNetworkMagic] :: ShelleyGenesis -> !Word32
[sgNetworkId] :: ShelleyGenesis -> !Network
[sgActiveSlotsCoeff] :: ShelleyGenesis -> !PositiveUnitInterval
[sgSecurityParam] :: ShelleyGenesis -> !NonZero Word64
[sgEpochLength] :: ShelleyGenesis -> !EpochSize
[sgSlotsPerKESPeriod] :: ShelleyGenesis -> !Word64
[sgMaxKESEvolutions] :: ShelleyGenesis -> !Word64
[sgSlotLength] :: ShelleyGenesis -> !NominalDiffTimeMicro
[sgUpdateQuorum] :: ShelleyGenesis -> !Word64
[sgMaxLovelaceSupply] :: ShelleyGenesis -> !Word64
[sgProtocolParams] :: ShelleyGenesis -> !PParams ShelleyEra
[sgGenDelegs] :: ShelleyGenesis -> !Map (KeyHash 'Genesis) GenDelegPair
[sgInitialFunds] :: ShelleyGenesis -> ListMap Addr Coin
[sgStaking] :: ShelleyGenesis -> ShelleyGenesisStaking
data () => ShelleyGenesisStaking
ShelleyGenesisStaking :: ListMap (KeyHash 'StakePool) PoolParams -> ListMap (KeyHash 'Staking) (KeyHash 'StakePool) -> ShelleyGenesisStaking
[sgsPools] :: ShelleyGenesisStaking -> ListMap (KeyHash 'StakePool) PoolParams
[sgsStake] :: ShelleyGenesisStaking -> ListMap (KeyHash 'Staking) (KeyHash 'StakePool)
data () => MIRPot
ReservesMIR :: MIRPot
TreasuryMIR :: MIRPot
data () => MIRTarget
StakeAddressesMIR :: !Map (Credential 'Staking) DeltaCoin -> MIRTarget
SendToOppositePotMIR :: !Coin -> MIRTarget
newtype () => KESPeriod
KESPeriod :: Word -> KESPeriod
[unKESPeriod] :: KESPeriod -> Word
newtype () => BlockNo
BlockNo :: Word64 -> BlockNo
[unBlockNo] :: BlockNo -> Word64
newtype () => EpochNo
EpochNo :: Word64 -> EpochNo
[unEpochNo] :: EpochNo -> Word64
newtype () => EpochSize
EpochSize :: Word64 -> EpochSize
[unEpochSize] :: EpochSize -> Word64
newtype () => SlotNo
SlotNo :: Word64 -> SlotNo
[unSlotNo] :: SlotNo -> Word64
newtype () => SystemStart
SystemStart :: UTCTime -> SystemStart
[getSystemStart] :: SystemStart -> UTCTime
data () => EraMismatch
EraMismatch :: !Text -> !Text -> EraMismatch
[ledgerEraName] :: EraMismatch -> !Text
[otherEraName] :: EraMismatch -> !Text
data () => PastHorizonException
data family GenTx blk
type family ChainDepState p
type family ChainDepState p
class ConsensusProtocol p => PraosProtocolSupportsNode p where {
    type family PraosProtocolSupportsNodeCrypto p;
}
getOpCertCounters :: PraosProtocolSupportsNode p => proxy p -> ChainDepState p -> Map (KeyHash 'BlockIssuer) Word64
type family PraosProtocolSupportsNodeCrypto p
newtype () => Serialised (a :: k)
Serialised :: ByteString -> Serialised (a :: k)
[unSerialised] :: Serialised (a :: k) -> ByteString
data () => NodeToClientVersion
NodeToClientV_16 :: NodeToClientVersion
NodeToClientV_17 :: NodeToClientVersion
NodeToClientV_18 :: NodeToClientVersion
NodeToClientV_19 :: NodeToClientVersion
NodeToClientV_20 :: NodeToClientVersion
data () => LedgerPeerSnapshot
LedgerPeerSnapshotV1 :: (WithOrigin SlotNo, [(AccPoolStake, (PoolStake, NonEmpty RelayAccessPoint))]) -> LedgerPeerSnapshot
pattern LedgerPeerSnapshot :: (WithOrigin SlotNo, [(AccPoolStake, (PoolStake, NonEmpty RelayAccessPoint))]) -> LedgerPeerSnapshot
newtype () => ChainSyncClient header point tip (m :: Type -> Type) a
ChainSyncClient :: m (ClientStIdle header point tip m a) -> ChainSyncClient header point tip (m :: Type -> Type) a
[runChainSyncClient] :: ChainSyncClient header point tip (m :: Type -> Type) a -> m (ClientStIdle header point tip m a)
newtype () => ChainSyncClientPipelined header point tip (m :: Type -> Type) a
ChainSyncClientPipelined :: m (ClientPipelinedStIdle 'Z header point tip m a) -> ChainSyncClientPipelined header point tip (m :: Type -> Type) a
[runChainSyncClientPipelined] :: ChainSyncClientPipelined header point tip (m :: Type -> Type) a -> m (ClientPipelinedStIdle 'Z header point tip m a)
newtype () => LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a
LocalStateQueryClient :: m (ClientStIdle block point query m a) -> LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a
[runLocalStateQueryClient] :: LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a -> m (ClientStIdle block point query m a)
data () => Target point
VolatileTip :: Target point
SpecificPoint :: point -> Target point
ImmutableTip :: Target point
newtype () => LocalTxMonitorClient txid tx slot (m :: Type -> Type) a
LocalTxMonitorClient :: m (ClientStIdle txid tx slot m a) -> LocalTxMonitorClient txid tx slot (m :: Type -> Type) a
[runLocalTxMonitorClient] :: LocalTxMonitorClient txid tx slot (m :: Type -> Type) a -> m (ClientStIdle txid tx slot m a)
data () => MempoolSizeAndCapacity
MempoolSizeAndCapacity :: !Word32 -> !Word32 -> !Word32 -> MempoolSizeAndCapacity
[capacityInBytes] :: MempoolSizeAndCapacity -> !Word32
[sizeInBytes] :: MempoolSizeAndCapacity -> !Word32
[numberOfTxs] :: MempoolSizeAndCapacity -> !Word32
newtype () => LocalTxSubmissionClient tx reject (m :: Type -> Type) a
LocalTxSubmissionClient :: m (LocalTxClientStIdle tx reject m a) -> LocalTxSubmissionClient tx reject (m :: Type -> Type) a
[runLocalTxSubmissionClient] :: LocalTxSubmissionClient tx reject (m :: Type -> Type) a -> m (LocalTxClientStIdle tx reject m a)
data () => SubmitResult reason
SubmitSuccess :: SubmitResult reason
SubmitFail :: reason -> SubmitResult reason
pattern Block :: BlockHeader -> [Tx era] -> Block era
(<+>) :: Doc ann -> Doc ann -> Doc ann
prettyShow :: Pretty a => a -> String
left :: forall (m :: Type -> Type) x a. Monad m => x -> ExceptT x m a
right :: forall (m :: Type -> Type) a x. Monad m => a -> ExceptT x m a

-- | Signal an exception value <tt>e</tt>.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>throwE</a> e) = <a>return</a>
--   (<a>Left</a> e)</pre></li>
--   <li><pre><a>throwE</a> e &gt;&gt;= m = <a>throwE</a> e</pre></li>
--   </ul>
throwE :: forall (m :: Type -> Type) e a. Monad m => e -> ExceptT e m a

-- | Extractor for computations in the exception monad. (The inverse of
--   <a>except</a>).
runExcept :: Except e a -> Either e a

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExcept</a> (<a>mapExcept</a> f m) = f (<a>runExcept</a>
--   m)</pre></li>
--   </ul>
mapExcept :: (Either e a -> Either e' b) -> Except e a -> Except e' b

-- | Transform any exceptions thrown by the computation using the given
--   function (a specialization of <a>withExceptT</a>).
withExcept :: (e -> e') -> Except e a -> Except e' a

-- | The inverse of <a>ExceptT</a>.
runExceptT :: ExceptT e m a -> m (Either e a)

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>mapExceptT</a> f m) = f
--   (<a>runExceptT</a> m)</pre></li>
--   </ul>
mapExceptT :: (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b

-- | Transform any exceptions thrown by the computation using the given
--   function.
withExceptT :: forall (m :: Type -> Type) e e' a. Functor m => (e -> e') -> ExceptT e m a -> ExceptT e' m a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: CallCC m (Either e a) (Either e b) -> CallCC (ExceptT e m) a b

-- | Lifts an <tt><a>Either</a> e</tt> into any <tt><a>MonadError</a>
--   e</tt>.
--   
--   <pre>
--   do { val &lt;- liftEither =&lt;&lt; action1; action2 }
--   </pre>
--   
--   where <tt>action1</tt> returns an <a>Either</a> to represent errors.
liftEither :: MonadError e m => Either e a -> m a
modifyError :: forall e' t (m :: Type -> Type) e a. MonadTransError e' t m => (e -> e') -> ExceptT e m a -> t m a
hsep :: [Doc ann] -> Doc ann

-- | Handle an exception.
--   
--   <ul>
--   <li><pre><a>catchE</a> (<a>lift</a> m) h = <a>lift</a> m</pre></li>
--   <li><pre><a>catchE</a> (<a>throwE</a> e) h = h e</pre></li>
--   </ul>
catchE :: forall (m :: Type -> Type) e a e'. Monad m => ExceptT e m a -> (e -> ExceptT e' m a) -> ExceptT e' m a

-- | Constructor for computations in the exception monad. (The inverse of
--   <a>runExcept</a>).
except :: forall (m :: Type -> Type) e a. Monad m => Either e a -> ExceptT e m a

-- | The same as <tt><a>flip</a> <a>catchE</a></tt>, which is useful in
--   situations where the code for the handler is shorter.
handleE :: forall (m :: Type -> Type) e e' a. Monad m => (e -> ExceptT e' m a) -> ExceptT e m a -> ExceptT e' m a

-- | Similar to <a>catchE</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception was thown, or
--   <tt>(<a>Left</a> ex)</tt> if an exception <tt>ex</tt> was thrown.
tryE :: forall (m :: Type -> Type) e a. Monad m => ExceptT e m a -> ExceptT e m (Either e a)

-- | <tt><a>finallyE</a> a b</tt> executes computation <tt>a</tt> followed
--   by computation <tt>b</tt>, even if <tt>a</tt> exits early by throwing
--   an exception. In the latter case, the exception is re-thrown after
--   <tt>b</tt> has been executed.
finallyE :: forall (m :: Type -> Type) e a. Monad m => ExceptT e m a -> ExceptT e m () -> ExceptT e m a

-- | Lift a <tt>listen</tt> operation to the new monad.
liftListen :: Monad m => Listen w m (Either e a) -> Listen w (ExceptT e m) a

-- | Lift a <tt>pass</tt> operation to the new monad.
liftPass :: Monad m => Pass w m (Either e a) -> Pass w (ExceptT e m) a
hoistMaybe :: forall (m :: Type -> Type) x a. Monad m => x -> Maybe a -> ExceptT x m a
blue :: Doc AnsiStyle -> Doc AnsiStyle
createAndValidateTransactionBody :: ShelleyBasedEra era -> TxBodyContent BuildTx era -> Either TxBodyError (TxBody era)
defaultTxBodyContent :: ShelleyBasedEra era -> TxBodyContent BuildTx era
fromLedgerUTxO :: ShelleyBasedEra era -> UTxO (ShelleyLedgerEra era) -> UTxO era
fromLedgerValue :: ShelleyBasedEra era -> Value (ShelleyLedgerEra era) -> Value
green :: Doc AnsiStyle -> Doc AnsiStyle
makeShelleyKeyWitness :: ShelleyBasedEra era -> TxBody era -> ShelleyWitnessSigningKey -> KeyWitness era
queryEraHistory :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError EraHistory)
queryProtocolParameters :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (PParams (ShelleyLedgerEra era))))
queryStakePools :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Set PoolId)))
querySystemStart :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError SystemStart)
red :: Doc AnsiStyle -> Doc AnsiStyle
signShelleyTransaction :: ShelleyBasedEra era -> TxBody era -> [ShelleyWitnessSigningKey] -> Tx era
toLedgerValue :: MaryEraOnwards era -> Value -> Value (ShelleyLedgerEra era)
anyAddressInEra :: CardanoEra era -> AddressAny -> Either String (AddressInEra era)
anyAddressInShelleyBasedEra :: ShelleyBasedEra era -> AddressAny -> AddressInEra era
byronAddressInEra :: Address ByronAddr -> AddressInEra era
fromShelleyAddr :: ShelleyBasedEra era -> Addr -> AddressInEra era
fromShelleyAddrIsSbe :: ShelleyBasedEra era -> Addr -> AddressInEra era
fromShelleyAddrToAny :: Addr -> AddressAny
fromShelleyPaymentCredential :: PaymentCredential -> PaymentCredential
fromShelleyStakeAddr :: RewardAccount -> StakeAddress
fromShelleyStakeCredential :: StakeCredential -> StakeCredential
fromShelleyStakeReference :: StakeReference -> StakeAddressReference
isKeyAddress :: AddressInEra era -> Bool
makeByronAddress :: NetworkId -> VerificationKey ByronKey -> Address ByronAddr
makeByronAddressInEra :: NetworkId -> VerificationKey ByronKey -> AddressInEra era
makeShelleyAddress :: NetworkId -> PaymentCredential -> StakeAddressReference -> Address ShelleyAddr
makeShelleyAddressInEra :: ShelleyBasedEra era -> NetworkId -> PaymentCredential -> StakeAddressReference -> AddressInEra era
makeStakeAddress :: NetworkId -> StakeCredential -> StakeAddress
parseAddressAny :: SerialiseAddress addr => Parser addr
shelleyAddressInEra :: ShelleyBasedEra era -> Address ShelleyAddr -> AddressInEra era
shelleyPayAddrToPlutusPubKHash :: Address ShelleyAddr -> Maybe PubKeyHash
stakeAddressCredential :: StakeAddress -> StakeCredential
toAddressAny :: Address addr -> AddressAny
toShelleyAddr :: AddressInEra era -> Addr
toShelleyStakeAddr :: StakeAddress -> RewardAccount
toShelleyStakeCredential :: StakeCredential -> StakeCredential
chainPointToHeaderHash :: ChainPoint -> Maybe (Hash BlockHeader)
chainPointToSlotNo :: ChainPoint -> Maybe SlotNo
chainTipToChainPoint :: ChainTip -> ChainPoint
fromConsensusBlock :: CardanoBlock StandardCrypto ~ block => block -> BlockInMode
fromConsensusPoint :: ShelleyCompatible protocol ledgerera => Point (ShelleyBlock protocol ledgerera) -> ChainPoint
fromConsensusPointHF :: forall block (xs :: [Type]). HeaderHash block ~ OneEraHash xs => Point block -> ChainPoint
fromConsensusTip :: CardanoBlock StandardCrypto ~ block => Tip block -> ChainTip
getBlockHeader :: Block era -> BlockHeader
getBlockTxs :: Block era -> [Tx era]
makeChainTip :: WithOrigin BlockNo -> ChainPoint -> ChainTip
toConsensusBlock :: CardanoBlock StandardCrypto ~ block => BlockInMode -> block
toConsensusPoint :: forall ledgerera protocol. ShelleyCompatible protocol ledgerera => ChainPoint -> Point (ShelleyBlock protocol ledgerera)
toConsensusPointHF :: forall block (xs :: [Type]). HeaderHash block ~ OneEraHash xs => ChainPoint -> Point block
fromShelleyCertificate :: ShelleyBasedEra era -> TxCert (ShelleyLedgerEra era) -> Certificate era
fromShelleyPoolParams :: PoolParams -> StakePoolParameters
getAnchorDataFromCertificate :: Certificate era -> Either AnchorDataFromCertificateError (Maybe Anchor)
makeCommitteeColdkeyResignationCertificate :: Typeable era => CommitteeColdkeyResignationRequirements era -> Certificate era
makeCommitteeHotKeyAuthorizationCertificate :: Typeable era => CommitteeHotKeyAuthorizationRequirements era -> Certificate era
makeDrepRegistrationCertificate :: Typeable era => DRepRegistrationRequirements era -> Maybe Anchor -> Certificate era
makeDrepUnregistrationCertificate :: Typeable era => DRepUnregistrationRequirements era -> Certificate era
makeDrepUpdateCertificate :: Typeable era => DRepUpdateRequirements era -> Maybe Anchor -> Certificate era
makeGenesisKeyDelegationCertificate :: Typeable era => GenesisKeyDelegationRequirements era -> Certificate era
makeMIRCertificate :: Typeable era => MirCertificateRequirements era -> Certificate era
makeStakeAddressAndDRepDelegationCertificate :: ConwayEraOnwards era -> StakeCredential -> Delegatee -> Coin -> Certificate era
makeStakeAddressDelegationCertificate :: StakeDelegationRequirements era -> Certificate era
makeStakeAddressRegistrationCertificate :: StakeAddressRequirements era -> Certificate era
makeStakeAddressUnregistrationCertificate :: StakeAddressRequirements era -> Certificate era
makeStakePoolRegistrationCertificate :: StakePoolRegistrationRequirements era -> Certificate era
makeStakePoolRetirementCertificate :: StakePoolRetirementRequirements era -> Certificate era
selectStakeCredentialWitness :: Certificate era -> Maybe StakeCredential
toShelleyCertificate :: Certificate era -> TxCert (ShelleyLedgerEra era)
toShelleyPoolParams :: StakePoolParameters -> PoolParams
hashDRepMetadata :: ByteString -> (DRepMetadata, Hash DRepMetadata)
getHotKey :: OperationalCertificate -> VerificationKey KesKey
getKesPeriod :: OperationalCertificate -> Word
getOpCertCount :: OperationalCertificate -> Word64
issueOperationalCertificate :: VerificationKey KesKey -> Either AnyStakePoolSigningKey (SigningKey GenesisDelegateExtendedKey) -> KESPeriod -> OperationalCertificateIssueCounter -> Either OperationalCertIssueError (OperationalCertificate, OperationalCertificateIssueCounter)
validateAndHashStakePoolMetadata :: ByteString -> Either StakePoolMetadataValidationError (StakePoolMetadata, Hash StakePoolMetadata)
fromConsensusApplyTxErr :: CardanoBlock StandardCrypto ~ block => ApplyTxErr block -> TxValidationErrorInCardanoMode
fromConsensusGenTx :: CardanoBlock StandardCrypto ~ block => GenTx block -> TxInMode
toConsensusGenTx :: CardanoBlock StandardCrypto ~ block => TxInMode -> GenTx block
toConsensusTxId :: CardanoBlock StandardCrypto ~ block => TxIdInMode -> TxId (GenTx block)
fromConsensusEraIndex :: EraIndex (CardanoEras StandardCrypto) -> AnyCardanoEra
toConsensusEraIndex :: forall (xs :: [Type]) era. CardanoBlock StandardCrypto ~ HardForkBlock xs => CardanoEra era -> EraIndex xs
reflBlockType :: BlockType blk -> BlockType blk' -> Maybe (blk :~: blk')
caseByronOrShelleyBasedEra :: a -> (ShelleyBasedEraConstraints era => ShelleyBasedEra era -> a) -> CardanoEra era -> a
caseByronToAlonzoOrBabbageEraOnwards :: (ByronToAlonzoEraConstraints era => ByronToAlonzoEra era -> a) -> (BabbageEraOnwardsConstraints era => BabbageEraOnwards era -> a) -> CardanoEra era -> a
caseShelleyToAllegraOrMaryEraOnwards :: (ShelleyToAllegraEraConstraints era => ShelleyToAllegraEra era -> a) -> (MaryEraOnwardsConstraints era => MaryEraOnwards era -> a) -> ShelleyBasedEra era -> a
caseShelleyToAlonzoOrBabbageEraOnwards :: (ShelleyToAlonzoEraConstraints era => ShelleyToAlonzoEra era -> a) -> (BabbageEraOnwardsConstraints era => BabbageEraOnwards era -> a) -> ShelleyBasedEra era -> a
caseShelleyToBabbageOrConwayEraOnwards :: (ShelleyToBabbageEraConstraints era => ShelleyToBabbageEra era -> a) -> (ConwayEraOnwardsConstraints era => ConwayEraOnwards era -> a) -> ShelleyBasedEra era -> a
caseShelleyToMaryOrAlonzoEraOnwards :: (ShelleyToMaryEraConstraints era => ShelleyToMaryEra era -> a) -> (AlonzoEraOnwardsConstraints era => AlonzoEraOnwards era -> a) -> ShelleyBasedEra era -> a
anyCardanoEra :: CardanoEra era -> AnyCardanoEra
cardanoEraConstraints :: CardanoEra era -> (CardanoEraConstraints era => a) -> a
forEraInEon :: Eon eon => CardanoEra era -> a -> (eon era -> a) -> a
forEraInEonMaybe :: Eon eon => CardanoEra era -> (eon era -> a) -> Maybe a
forEraMaybeEon :: Eon eon => CardanoEra era -> Maybe (eon era)
inAnyCardanoEra :: CardanoEra era -> thing era -> InAnyCardanoEra thing
inEonForEraMaybe :: Eon eon => (eon era -> a) -> CardanoEra era -> Maybe a
maybeEon :: (Eon eon, IsCardanoEra era) => Maybe (eon era)
monoidForEraInEon :: (Eon eon, Monoid a) => CardanoEra era -> (eon era -> a) -> a
monoidForEraInEonA :: (Eon eon, Applicative f, Monoid a) => CardanoEra era -> (eon era -> f a) -> f a
allegraEraOnwardsConstraints :: AllegraEraOnwards era -> (AllegraEraOnwardsConstraints era => a) -> a
allegraEraOnwardsToShelleyBasedEra :: AllegraEraOnwards era -> ShelleyBasedEra era
alonzoEraOnwardsConstraints :: AlonzoEraOnwards era -> (AlonzoEraOnwardsConstraints era => a) -> a
alonzoEraOnwardsToShelleyBasedEra :: AlonzoEraOnwards era -> ShelleyBasedEra era
babbageEraOnwardsConstraints :: BabbageEraOnwards era -> (BabbageEraOnwardsConstraints era => a) -> a
babbageEraOnwardsToShelleyBasedEra :: BabbageEraOnwards era -> ShelleyBasedEra era
byronToAlonzoEraConstraints :: ByronToAlonzoEra era -> (ByronToAlonzoEraConstraints era => a) -> a
conwayEraOnwardsConstraints :: ConwayEraOnwards era -> (ConwayEraOnwardsConstraints era => a) -> a
conwayEraOnwardsToBabbageEraOnwards :: ConwayEraOnwards era -> BabbageEraOnwards era
conwayEraOnwardsToShelleyBasedEra :: ConwayEraOnwards era -> ShelleyBasedEra era
maryEraOnwardsConstraints :: MaryEraOnwards era -> (MaryEraOnwardsConstraints era => a) -> a
maryEraOnwardsToShelleyBasedEra :: MaryEraOnwards era -> ShelleyBasedEra era
eraProtVerLow :: ShelleyBasedEra era -> Version
forShelleyBasedEraInEon :: Eon eon => ShelleyBasedEra era -> a -> (eon era -> a) -> a
forShelleyBasedEraInEonMaybe :: Eon eon => ShelleyBasedEra era -> (eon era -> a) -> Maybe a
forShelleyBasedEraMaybeEon :: Eon eon => ShelleyBasedEra era -> Maybe (eon era)
inAnyShelleyBasedEra :: ShelleyBasedEra era -> thing era -> InAnyShelleyBasedEra thing
inEonForShelleyBasedEra :: Eon eon => a -> (eon era -> a) -> ShelleyBasedEra era -> a
inEonForShelleyBasedEraMaybe :: Eon eon => (eon era -> a) -> ShelleyBasedEra era -> Maybe a
requireShelleyBasedEra :: Applicative m => CardanoEra era -> m (Maybe (ShelleyBasedEra era))
shelleyBasedEraConstraints :: ShelleyBasedEra era -> (ShelleyBasedEraConstraints era => a) -> a
shelleyEraOnlyConstraints :: ShelleyEraOnly era -> (ShelleyEraOnlyConstraints era => a) -> a
shelleyEraOnlyToShelleyBasedEra :: ShelleyEraOnly era -> ShelleyBasedEra era
shelleyToAllegraEraConstraints :: ShelleyToAllegraEra era -> (ShelleyToAllegraEraConstraints era => a) -> a
shelleyToAllegraEraToShelleyBasedEra :: ShelleyToAllegraEra era -> ShelleyBasedEra era
shelleyToAlonzoEraConstraints :: ShelleyToAlonzoEra era -> (ShelleyToAlonzoEraConstraints era => a) -> a
shelleyToAlonzoEraToShelleyBasedEra :: ShelleyToAlonzoEra era -> ShelleyBasedEra era
shelleyToBabbageEraConstraints :: ShelleyToBabbageEra era -> (ShelleyToBabbageEraConstraints era => a) -> a
shelleyToBabbageEraToShelleyBasedEra :: ShelleyToBabbageEra era -> ShelleyBasedEra era
shelleyToMaryEraConstraints :: ShelleyToMaryEra era -> (ShelleyToMaryEraConstraints era => a) -> a
shelleyToMaryEraToShelleyBasedEra :: ShelleyToMaryEra era -> ShelleyBasedEra era
asFeaturedInEra :: forall (eon :: Type -> Type) a era. Eon eon => a -> CardanoEra era -> Maybe (Featured eon era a)
asFeaturedInShelleyBasedEra :: forall (eon :: Type -> Type) a era. Eon eon => a -> ShelleyBasedEra era -> Maybe (Featured eon era a)
mkFeatured :: forall (eon :: Type -> Type) era a. (IsCardanoEra era, Eon eon) => a -> Maybe (Featured eon era a)
unFeatured :: forall (eon :: Type -> Type) era a. Featured eon era a -> a
displayError :: Error a => a -> String
failEitherError :: (MonadFail m, Error e) => Either e a -> m a
fileIOExceptT :: forall (m :: Type -> Type) s e. MonadIO m => FilePath -> (FilePath -> IO s) -> ExceptT (FileError e) m s
throwErrorAsException :: Error e => e -> IO a
alonzoGenesisDefaults :: CardanoEra era -> AlonzoGenesis
conwayGenesisDefaults :: ConwayGenesis
decodeAlonzoGenesis :: forall era t (m :: Type -> Type). MonadTransError String t m => Maybe (CardanoEra era) -> ByteString -> t m AlonzoGenesis
shelleyGenesisDefaults :: ShelleyGenesis
unsafeBoundedRational :: (HasCallStack, Typeable r, BoundedRational r) => Rational -> r
createAnchor :: Url -> ByteString -> Anchor
createGovernanceActionId :: TxId -> Word16 -> GovActionId
createProposalProcedure :: ShelleyBasedEra era -> Network -> Coin -> StakeCredential -> GovernanceAction era -> Anchor -> Proposal era
fromGovernanceAction :: GovAction (ShelleyLedgerEra era) -> GovernanceAction era
fromProposalProcedure :: ShelleyBasedEra era -> Proposal era -> (Coin, StakeCredential, GovernanceAction era)
getAnchorDataFromGovernanceAction :: GovAction (ShelleyLedgerEra era) -> Maybe Anchor
proposalTypeEquality :: (Typeable eraA, Typeable eraB) => ProposalProcedure (ShelleyLedgerEra eraA) -> ProposalProcedure (ShelleyLedgerEra eraB) -> Maybe (eraA :~: eraB)
toGovernanceAction :: ShelleyBasedEra era -> GovernanceAction era -> GovAction (ShelleyLedgerEra era)
createVotingProcedure :: ConwayEraOnwards era -> Vote -> Maybe (Url, Text) -> VotingProcedure era
emptyVotingProcedures :: VotingProcedures era
mergeVotingProcedures :: VotingProcedures era -> VotingProcedures era -> Either (VotesMergingConflict era) (VotingProcedures era)
singletonVotingProcedures :: ConwayEraOnwards era -> Voter -> GovActionId -> VotingProcedure (ShelleyLedgerEra era) -> VotingProcedures era
toVote :: Vote -> Vote
validateGovActionAnchorData :: FromJSON (GovActionMetadata cip) => cip -> ByteString -> Either String ()
hashGovernancePoll :: GovernancePoll -> Hash GovernancePoll
renderGovernancePollError :: GovernancePollError -> Text
verifyPollAnswer :: GovernancePoll -> InAnyShelleyBasedEra Tx -> Either GovernancePollError [Hash PaymentKey]
asType :: HasTypeProxy t => AsType t
renderSafeHashAsHex :: SafeHash tag -> Text
intoFile :: File content 'Out -> content -> (File content 'Out -> stream -> result) -> (content -> stream) -> result
mapFile :: forall content (direction :: FileDirection). (FilePath -> FilePath) -> File content direction -> File content direction
onlyIn :: File content 'InOut -> File content 'In
onlyOut :: File content 'InOut -> File content 'Out
readByteStringFile :: MonadIO m => File content 'In -> m (Either (FileError e) ByteString)
readFileBlocking :: FilePath -> IO ByteString
readLazyByteStringFile :: MonadIO m => File content 'In -> m (Either (FileError e) ByteString)
readTextFile :: MonadIO m => File content 'In -> m (Either (FileError e) Text)
writeByteStringFile :: MonadIO m => File content 'Out -> ByteString -> m (Either (FileError e) ())
writeByteStringFileWithOwnerPermissions :: FilePath -> ByteString -> IO (Either (FileError e) ())
writeByteStringOutput :: MonadIO m => Maybe (File content 'Out) -> ByteString -> m (Either (FileError e) ())
writeLazyByteStringFile :: MonadIO m => File content 'Out -> ByteString -> m (Either (FileError e) ())
writeLazyByteStringFileWithOwnerPermissions :: File content 'Out -> ByteString -> IO (Either (FileError e) ())
writeLazyByteStringOutput :: MonadIO m => Maybe (File content 'Out) -> ByteString -> m (Either (FileError e) ())
writeTextFile :: MonadIO m => File content 'Out -> Text -> m (Either (FileError e) ())
writeTextFileWithOwnerPermissions :: File content 'Out -> Text -> IO (Either (FileError e) ())
writeTextOutput :: MonadIO m => Maybe (File content 'Out) -> Text -> m (Either (FileError e) ())
checkVrfFilePermissions :: forall content (direction :: FileDirection). File content direction -> ExceptT VRFPrivateKeyFilePermissionError IO ()
writeSecrets :: FilePath -> [Char] -> [Char] -> (a -> ByteString) -> [a] -> IO ()
anyStakePoolSigningKeyToVerificationKey :: AnyStakePoolSigningKey -> AnyStakePoolVerificationKey
anyStakePoolVerificationKeyHash :: AnyStakePoolVerificationKey -> Hash StakePoolKey
parseHexHash :: SerialiseAsRawBytes (Hash a) => Parser (Hash a)
generateInsecureSigningKey :: (MonadIO m, Key keyrole, SerialiseAsRawBytes (SigningKey keyrole)) => StdGen -> AsType keyrole -> m (SigningKey keyrole, StdGen)
generateSigningKey :: (MonadIO m, Key keyrole) => AsType keyrole -> m (SigningKey keyrole)
autocompleteMnemonicPrefix :: Text -> Maybe Text
findMnemonicWordsWithPrefix :: Text -> [(Text, Int)]
generateMnemonic :: MonadIO m => MnemonicSize -> m [Text]
signingKeyFromMnemonic :: SigningKeyFromRootKey keyrole => AsType keyrole -> [Text] -> Word32 -> Either MnemonicToSigningKeyError (SigningKey keyrole)
signingKeyFromMnemonicWithPaymentKeyIndex :: IndexedSigningKeyFromRootKey keyrole => AsType keyrole -> [Text] -> Word32 -> Word32 -> Either MnemonicToSigningKeyError (SigningKey keyrole)
signArbitraryBytesKes :: SigningKey KesKey -> Period -> ByteString -> SignedKES (KES StandardCrypto) ByteString
deserialiseAnyVerificationKey :: ByteString -> Either InputDecodeError SomeAddressVerificationKey
deserialiseAnyVerificationKeyBech32 :: ByteString -> Either Bech32DecodeError SomeAddressVerificationKey
deserialiseAnyVerificationKeyTextEnvelope :: ByteString -> Either TextEnvelopeError SomeAddressVerificationKey
mapSomeAddressVerificationKey :: (forall keyrole. Key keyrole => VerificationKey keyrole -> a) -> SomeAddressVerificationKey -> a
renderSomeAddressVerificationKey :: SomeAddressVerificationKey -> Text
applyBlock :: Env -> LedgerState -> ValidationMode -> BlockInMode -> Either LedgerStateError (LedgerState, [LedgerEvent])
applyBlockWithEvents :: Env -> LedgerState -> Bool -> CardanoBlock StandardCrypto -> Either LedgerStateError LedgerStateEvents
chainSyncClientPipelinedWithLedgerState :: forall (m :: Type -> Type) a. Monad m => Env -> LedgerState -> ValidationMode -> ChainSyncClientPipelined (BlockInMode, Either LedgerStateError (LedgerState, [LedgerEvent])) ChainPoint ChainTip m a -> ChainSyncClientPipelined BlockInMode ChainPoint ChainTip m a
chainSyncClientWithLedgerState :: forall (m :: Type -> Type) a. Monad m => Env -> LedgerState -> ValidationMode -> ChainSyncClient (BlockInMode, Either LedgerStateError (LedgerState, [LedgerEvent])) ChainPoint ChainTip m a -> ChainSyncClient BlockInMode ChainPoint ChainTip m a
constructGlobals :: ShelleyGenesis -> EpochInfo (Either Text) -> Globals
currentEpochEligibleLeadershipSlots :: ShelleyBasedEra era -> ShelleyGenesis -> EpochInfo (Either Text) -> PParams (ShelleyLedgerEra era) -> ProtocolState era -> PoolId -> SigningKey VrfKey -> SerialisedPoolDistribution era -> EpochNo -> Either LeadershipError (Set SlotNo)
decodeLedgerState :: Decoder s LedgerState
encodeLedgerState :: LedgerState -> Encoding
envSecurityParam :: Env -> Word64
foldBlocks :: forall a t (m :: Type -> Type). (Show a, MonadIOTransError FoldBlocksError t m) => NodeConfigFile 'In -> SocketPath -> ValidationMode -> a -> (Env -> LedgerState -> [LedgerEvent] -> BlockInMode -> a -> IO (a, FoldStatus)) -> t m a
foldEpochState :: forall t (m :: Type -> Type) s. MonadIOTransError FoldBlocksError t m => NodeConfigFile 'In -> SocketPath -> ValidationMode -> EpochNo -> s -> (AnyNewEpochState -> SlotNo -> BlockNo -> StateT s IO ConditionResult) -> t m (ConditionResult, s)
fromConditionResult :: ConditionResult -> Bool
genesisConfigToEnv :: GenesisConfig -> Either GenesisConfigError Env
getAnyNewEpochState :: ShelleyBasedEra era -> LedgerState -> Either LedgerStateError AnyNewEpochState
getLedgerTablesUTxOValues :: ShelleyBasedEra era -> LedgerTables (LedgerState (CardanoBlock StandardCrypto)) ValuesMK -> Map TxIn (TxOut CtxUTxO era)
initialLedgerState :: forall t (m :: Type -> Type). MonadIOTransError InitialLedgerStateError t m => NodeConfigFile 'In -> t m (Env, LedgerState)
mkProtocolInfoCardano :: GenesisConfig -> (ProtocolInfo (CardanoBlock StandardCrypto), IO [BlockForging IO (CardanoBlock StandardCrypto)])
nextEpochEligibleLeadershipSlots :: ShelleyBasedEra era -> ShelleyGenesis -> SerialisedCurrentEpochState era -> ProtocolState era -> PoolId -> SigningKey VrfKey -> PParams (ShelleyLedgerEra era) -> EpochInfo (Either Text) -> (ChainTip, EpochNo) -> Either LeadershipError (Set SlotNo)
readAlonzoGenesisConfig :: forall t (m :: Type -> Type) era. MonadIOTransError GenesisConfigError t m => Maybe (CardanoEra era) -> NodeConfig -> t m AlonzoGenesis
readByronGenesisConfig :: forall t (m :: Type -> Type). MonadIOTransError GenesisConfigError t m => NodeConfig -> t m Config
readCardanoGenesisConfig :: forall t (m :: Type -> Type) era. MonadIOTransError GenesisConfigError t m => Maybe (CardanoEra era) -> NodeConfig -> t m GenesisConfig
readConwayGenesisConfig :: forall t (m :: Type -> Type). MonadIOTransError GenesisConfigError t m => NodeConfig -> t m ConwayGenesis
readNodeConfig :: (MonadError Text m, MonadIO m) => NodeConfigFile 'In -> m NodeConfig
readShelleyGenesisConfig :: forall t (m :: Type -> Type). MonadIOTransError GenesisConfigError t m => NodeConfig -> t m ShelleyConfig
shelleyPraosNonce :: GenesisHashShelley -> Nonce
toConditionResult :: Bool -> ConditionResult
convertRetiredPoolsMap :: Map StakeCredential (Map (KeyHash 'StakePool) Coin) -> Map StakeCredential (Map (Hash StakePoolKey) Coin)
failEither :: MonadFail m => Either String a -> m a
failEitherWith :: MonadFail m => (e -> String) -> Either e a -> m a
handleIOExceptionsLiftWith :: (MonadIOTransError e' t m, Exception e) => (e -> e') -> m a -> t m a
handleIOExceptionsWith :: (MonadError e' m, MonadCatch m, Exception e) => (e -> e') -> m a -> m a
hoistIOEither :: forall e t (m :: Type -> Type) a. MonadIOTransError e t m => IO (Either e a) -> t m a
liftExceptT :: forall e t (m :: Type -> Type) a. MonadTransError e t m => ExceptT e m a -> t m a
liftMaybe :: MonadError e m => e -> Maybe a -> m a
connectToLocalNode :: MonadIO m => LocalNodeConnectInfo -> LocalNodeClientProtocolsInMode -> m ()
connectToLocalNodeWithVersion :: MonadIO m => LocalNodeConnectInfo -> (NodeToClientVersion -> LocalNodeClientProtocolsInMode) -> m ()
getLocalChainTip :: MonadIO m => LocalNodeConnectInfo -> m ChainTip
mkLocalNodeClientParams :: ConsensusModeParams -> (NodeToClientVersion -> LocalNodeClientProtocolsInMode) -> LocalNodeClientParams
queryNodeLocalState :: LocalNodeConnectInfo -> Target ChainPoint -> QueryInMode result -> ExceptT AcquiringFailure IO result
queryTxMonitoringLocal :: MonadIO m => LocalNodeConnectInfo -> LocalTxMonitoringQuery -> m LocalTxMonitoringResult
submitTxToNodeLocal :: MonadIO m => LocalNodeConnectInfo -> TxInMode -> m (SubmitResult TxValidationErrorInCardanoMode)
toAcquiringFailure :: AcquireFailure -> AcquiringFailure
executeLocalStateQueryExpr :: LocalNodeConnectInfo -> Target ChainPoint -> LocalStateQueryExpr BlockInMode ChainPoint QueryInMode () IO a -> IO (Either AcquiringFailure a)
queryExpr :: QueryInMode a -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError a)
isQuerySupportedInNtcVersion :: Some (Query (CardanoBlock StandardCrypto)) -> NodeToClientVersion -> Either UnsupportedNtcVersionError ()
fromNetworkMagic :: NetworkMagic -> NetworkId
fromShelleyNetwork :: Network -> NetworkMagic -> NetworkId
mainnetNetworkMagic :: NetworkMagic
toByronNetworkMagic :: NetworkId -> NetworkMagic
toByronProtocolMagicId :: NetworkId -> ProtocolMagicId
toByronRequiresNetworkMagic :: NetworkId -> RequiresNetworkMagic
toNetworkMagic :: NetworkId -> NetworkMagic
toShelleyNetwork :: NetworkId -> Network
collectPlutusScriptHashes :: AlonzoEraOnwards era -> Tx era -> UTxO era -> Map ScriptWitnessIndex ScriptHash
renderDebugPlutusFailure :: DebugPlutusFailure -> Text
eraOfScriptInEra :: ScriptInEra era -> ShelleyBasedEra era
eraOfScriptLanguageInEra :: ScriptLanguageInEra lang era -> ShelleyBasedEra era
examplePlutusScriptAlwaysFails :: WitCtx witctx -> PlutusScript PlutusScriptV1
examplePlutusScriptAlwaysSucceeds :: WitCtx witctx -> PlutusScript PlutusScriptV1
fromAllegraTimelock :: AllegraEraScript era => NativeScript era -> SimpleScript
fromAlonzoExUnits :: ExUnits -> ExecutionUnits
fromAlonzoLanguage :: Language -> AnyPlutusScriptVersion
fromShelleyBasedScript :: ShelleyBasedEra era -> Script (ShelleyLedgerEra era) -> ScriptInEra era
fromShelleyMultiSig :: MultiSig (ShelleyLedgerEra ShelleyEra) -> SimpleScript
fromShelleyScriptHash :: ScriptHash -> ScriptHash
fromShelleyScriptToReferenceScript :: ShelleyBasedEra era -> Script (ShelleyLedgerEra era) -> ReferenceScript era
getScriptWitnessReferenceInput :: ScriptWitness witctx era -> Maybe TxIn
getScriptWitnessReferenceInputOrScript :: ScriptWitness witctx era -> Either (ScriptInEra era) TxIn
getScriptWitnessScript :: ScriptWitness witctx era -> Maybe (ScriptInEra era)
hashScript :: Script lang -> ScriptHash
languageOfScriptLanguageInEra :: ScriptLanguageInEra lang era -> ScriptLanguage lang
parseScriptHash :: Parser ScriptHash
refScriptToShelleyScript :: ShelleyBasedEra era -> ReferenceScript era -> StrictMaybe (Script (ShelleyLedgerEra era))
removePlutusScriptDoubleEncoding :: ByteString -> ByteString
sbeToSimpleScriptLanguageInEra :: ShelleyBasedEra era -> ScriptLanguageInEra SimpleScript' era
scriptInEraToRefScript :: ScriptInEra era -> ReferenceScript era
toAllegraTimelock :: (AllegraEraScript era, NativeScript era ~ Timelock era) => SimpleScript -> NativeScript era
toAlonzoExUnits :: ExecutionUnits -> ExUnits
toAlonzoLanguage :: AnyPlutusScriptVersion -> Language
toScriptInAnyLang :: Script lang -> ScriptInAnyLang
toScriptInEra :: ShelleyBasedEra era -> ScriptInAnyLang -> Maybe (ScriptInEra era)
toShelleyMultiSig :: SimpleScript -> Either MultiSigError (MultiSig (ShelleyLedgerEra ShelleyEra))
toShelleyScript :: ScriptInEra era -> Script (ShelleyLedgerEra era)
toShelleyScriptHash :: ScriptHash -> ScriptHash
fromAlonzoData :: Data ledgerera -> HashableScriptData
fromPlutusData :: Data -> ScriptData
getOriginalScriptDataBytes :: HashableScriptData -> ByteString
getScriptData :: HashableScriptData -> ScriptData
hashScriptDataBytes :: HashableScriptData -> Hash ScriptData
parseScriptDataHash :: Parser (Hash ScriptData)
scriptDataFromJson :: ScriptDataJsonSchema -> Value -> Either ScriptDataJsonError HashableScriptData
scriptDataFromJsonDetailedSchema :: Value -> Either ScriptDataJsonSchemaError HashableScriptData
scriptDataJsonToHashable :: ScriptDataJsonSchema -> Value -> Either ScriptDataJsonBytesError HashableScriptData
scriptDataToJson :: ScriptDataJsonSchema -> HashableScriptData -> Value
scriptDataToJsonDetailedSchema :: HashableScriptData -> Value
toAlonzoData :: Era ledgerera => HashableScriptData -> Data ledgerera
toPlutusData :: ScriptData -> Data
unsafeHashableScriptData :: ScriptData -> HashableScriptData
validateScriptData :: ScriptData -> Either ScriptDataRangeError ()
black :: Doc AnsiStyle -> Doc AnsiStyle
cyan :: Doc AnsiStyle -> Doc AnsiStyle
docToLazyText :: Doc AnsiStyle -> Text
docToString :: Doc AnsiStyle -> String
docToText :: Doc AnsiStyle -> Text
magenta :: Doc AnsiStyle -> Doc AnsiStyle
prettyException :: Exception a => a -> Doc ann
pshow :: Show a => a -> Doc ann
textShow :: Show a => a -> Text
white :: Doc AnsiStyle -> Doc AnsiStyle
yellow :: Doc AnsiStyle -> Doc AnsiStyle
createEraBasedProtocolParamUpdate :: ShelleyBasedEra era -> EraBasedProtocolParametersUpdate era -> PParamsUpdate (ShelleyLedgerEra era)
createPParams :: ShelleyBasedEra era -> EraBasedProtocolParametersUpdate era -> PParams (ShelleyLedgerEra era)
fromAlonzoCostModel :: CostModel -> CostModel
fromAlonzoCostModels :: CostModels -> Map AnyPlutusScriptVersion CostModel
fromAlonzoPrices :: Prices -> ExecutionUnitPrices
fromAlonzoScriptLanguage :: Language -> AnyPlutusScriptVersion
fromLedgerPParamsUpdate :: ShelleyBasedEra era -> PParamsUpdate (ShelleyLedgerEra era) -> ProtocolParametersUpdate
fromLedgerProposedPPUpdates :: ShelleyLedgerEra era ~ ledgerera => ShelleyBasedEra era -> ProposedPPUpdates ledgerera -> Map (Hash GenesisKey) ProtocolParametersUpdate
fromLedgerUpdate :: ShelleyLedgerEra era ~ ledgerera => ShelleyBasedEra era -> Update ledgerera -> UpdateProposal
makePraosNonce :: ByteString -> PraosNonce
makeShelleyUpdateProposal :: ProtocolParametersUpdate -> [Hash GenesisKey] -> EpochNo -> UpdateProposal
toAlonzoCostModel :: CostModel -> Language -> Either ProtocolParametersConversionError CostModel
toAlonzoCostModels :: Map AnyPlutusScriptVersion CostModel -> Either ProtocolParametersConversionError CostModels
toAlonzoPrices :: ExecutionUnitPrices -> Either ProtocolParametersConversionError Prices
toAlonzoScriptLanguage :: AnyPlutusScriptVersion -> Language
toLedgerNonce :: Maybe PraosNonce -> Nonce
toLedgerPParamsUpdate :: ShelleyBasedEra era -> ProtocolParametersUpdate -> Either ProtocolParametersConversionError (PParamsUpdate (ShelleyLedgerEra era))
toLedgerProposedPPUpdates :: ShelleyBasedEra era -> Map (Hash GenesisKey) ProtocolParametersUpdate -> Either ProtocolParametersConversionError (ProposedPPUpdates (ShelleyLedgerEra era))
toLedgerUpdate :: ShelleyBasedEra era -> UpdateProposal -> Either ProtocolParametersConversionError (Update (ShelleyLedgerEra era))
determineEra :: LocalNodeConnectInfo -> ExceptT AcquiringFailure IO AnyCardanoEra
executeQueryAnyMode :: LocalNodeConnectInfo -> QueryInMode (Either EraMismatch result) -> ExceptT QueryConvenienceError IO result
executeQueryCardanoMode :: SocketPath -> NetworkId -> QueryInMode (Either EraMismatch result) -> ExceptT QueryConvenienceError IO result
queryStateForBalancedTx :: CardanoEra era -> [TxIn] -> [Certificate era] -> LocalStateQueryExpr block point QueryInMode r IO (Either QueryConvenienceError (UTxO era, LedgerProtocolParameters era, EraHistory, SystemStart, Set PoolId, Map StakeCredential Coin, Map (Credential 'DRepRole) Coin, Maybe (Featured ConwayEraOnwards era TxCurrentTreasuryValue)))
renderQueryConvenienceError :: QueryConvenienceError -> Text
queryAccountState :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch AccountState))
queryChainBlockNo :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (WithOrigin BlockNo))
queryChainPoint :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError ChainPoint)
queryCommitteeMembersState :: ConwayEraOnwards era -> Set (Credential 'ColdCommitteeRole) -> Set (Credential 'HotCommitteeRole) -> Set MemberStatus -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch CommitteeMembersState))
queryConstitution :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Constitution (ShelleyLedgerEra era))))
queryConstitutionHash :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SafeHash AnchorData)))
queryCurrentEpochState :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedCurrentEpochState era)))
queryCurrentEra :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError AnyCardanoEra)
queryDRepStakeDistribution :: ConwayEraOnwards era -> Set DRep -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map DRep Coin)))
queryDRepState :: ConwayEraOnwards era -> Set (Credential 'DRepRole) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map (Credential 'DRepRole) DRepState)))
queryDebugLedgerState :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedDebugLedgerState era)))
queryEpoch :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch EpochNo))
queryFuturePParams :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Maybe (PParams (ShelleyLedgerEra era)))))
queryGenesisParameters :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (GenesisParameters ShelleyEra)))
queryGovState :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (GovState (ShelleyLedgerEra era))))
queryLedgerConfig :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (CardanoLedgerConfig StandardCrypto))
queryLedgerPeerSnapshot :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Serialised LedgerPeerSnapshot)))
queryPoolDistribution :: BabbageEraOnwards era -> Maybe (Set PoolId) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedPoolDistribution era)))
queryPoolState :: BabbageEraOnwards era -> Maybe (Set PoolId) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedPoolState era)))
queryProposals :: ConwayEraOnwards era -> Set GovActionId -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Seq (GovActionState (ShelleyLedgerEra era)))))
queryProtocolState :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (ProtocolState era)))
queryRatifyState :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (RatifyState (ShelleyLedgerEra era))))
querySPOStakeDistribution :: ConwayEraOnwards era -> Set (KeyHash 'StakePool) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map (KeyHash 'StakePool) Coin)))
queryStakeAddresses :: ShelleyBasedEra era -> Set StakeCredential -> NetworkId -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map StakeAddress Coin, Map StakeAddress PoolId)))
queryStakeDelegDeposits :: BabbageEraOnwards era -> Set StakeCredential -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map StakeCredential Coin)))
queryStakeDistribution :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map (Hash StakePoolKey) Rational)))
queryStakePoolDefaultVote :: ConwayEraOnwards era -> KeyHash 'StakePool -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch DefaultVote))
queryStakePoolParameters :: ShelleyBasedEra era -> Set PoolId -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map PoolId StakePoolParameters)))
queryStakeSnapshot :: BabbageEraOnwards era -> Maybe (Set PoolId) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedStakeSnapshots era)))
queryStakeVoteDelegatees :: ConwayEraOnwards era -> Set StakeCredential -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map StakeCredential DRep)))
queryUtxo :: ShelleyBasedEra era -> QueryUTxOFilter -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (UTxO era)))
toDebugLedgerStatePair :: KeyValue e a => ShelleyBasedEra era -> DebugLedgerState era -> [a]
mergeDelegsAndRewards :: DelegationsAndRewards -> [(StakeAddress, Maybe Coin, Maybe PoolId)]
decodeBigLedgerPeerSnapshot :: Serialised LedgerPeerSnapshot -> Either (ByteString, DecoderError) LedgerPeerSnapshot
decodeCurrentEpochState :: ShelleyBasedEra era -> SerialisedCurrentEpochState era -> Either DecoderError (CurrentEpochState era)
decodeDebugLedgerState :: FromCBOR (DebugLedgerState era) => SerialisedDebugLedgerState era -> Either (ByteString, DecoderError) (DebugLedgerState era)
decodePoolDistribution :: ShelleyBasedEra era -> SerialisedPoolDistribution era -> Either DecoderError (PoolDistribution era)
decodePoolState :: (Era (ShelleyLedgerEra era), DecCBOR (PState (ShelleyLedgerEra era))) => SerialisedPoolState era -> Either DecoderError (PoolState era)
decodeProtocolState :: FromCBOR (ChainDepState (ConsensusProtocol era)) => ProtocolState era -> Either (ByteString, DecoderError) (ChainDepState (ConsensusProtocol era))
decodeStakeSnapshot :: SerialisedStakeSnapshots era -> Either DecoderError (StakeSnapshot era)
fromConsensusQueryResult :: (HasCallStack, CardanoBlock StandardCrypto ~ block) => QueryInMode result -> Query block result' -> result' -> result
getProgress :: SlotNo -> EraHistory -> Either PastHorizonException (RelativeTime, SlotLength)
getSlotForRelativeTime :: RelativeTime -> EraHistory -> Either PastHorizonException SlotNo
slotToEpoch :: SlotNo -> EraHistory -> Either PastHorizonException (EpochNo, SlotsInEpoch, SlotsToEpochEnd)
toConsensusQuery :: CardanoBlock StandardCrypto ~ block => QueryInMode result -> Some (Query block)
toLedgerEpochInfo :: EraHistory -> LedgerEpochInfo
deserialiseAnyOfFromBech32 :: [FromSomeType SerialiseAsBech32 b] -> Text -> Either Bech32DecodeError b
deserialiseFromBech32 :: SerialiseAsBech32 a => Text -> Either Bech32DecodeError a
serialiseToBech32 :: SerialiseAsBech32 a => a -> Text
unsafeHumanReadablePartFromText :: HasCallStack => Text -> HumanReadablePart
canonicaliseCborBs :: ByteString -> Either DecoderError ByteString
canonicaliseTerm :: Term -> Term
deserialiseFromBech32Cip129 :: Cip129 a => Text -> Either Bech32DecodeError a
deserialiseGovActionIdFromBech32Cip129 :: Text -> Either Bech32DecodeError GovActionId
serialiseGovActionIdToBech32Cip129 :: GovActionId -> Text
serialiseToBech32Cip129 :: Cip129 a => a -> Text
deserialiseInput :: NonEmpty (InputFormat a) -> ByteString -> Either InputDecodeError a
deserialiseInputAnyOf :: [FromSomeType SerialiseAsBech32 b] -> [FromSomeType HasTextEnvelope b] -> ByteString -> Either InputDecodeError b
readFormattedFile :: NonEmpty (InputFormat a) -> FilePath -> IO (Either (FileError InputDecodeError) a)
readFormattedFileAnyOf :: forall content b. [FromSomeType SerialiseAsBech32 b] -> [FromSomeType HasTextEnvelope b] -> File content 'In -> IO (Either (FileError InputDecodeError) b)
readFormattedFileTextEnvelope :: HasTextEnvelope a => File content 'In -> IO (Either (FileError InputDecodeError) a)
renderInputDecodeError :: InputDecodeError -> Doc ann
deserialiseFromJSON :: FromJSON a => ByteString -> Either JsonDecodeError a
prettyPrintJSON :: ToJSON a => a -> ByteString
readFileJSON :: FromJSON a => FilePath -> IO (Either (FileError JsonDecodeError) a)
serialiseToJSON :: ToJSON a => a -> ByteString
textWithMaxLength :: String -> Int -> Value -> Parser Text
toRationalJSON :: Rational -> Value
writeFileJSON :: ToJSON a => FilePath -> a -> IO (Either (FileError ()) ())
deserialiseFromRawBytesHex :: SerialiseAsRawBytes a => ByteString -> Either RawBytesHexError a
parseRawBytesHex :: SerialiseAsRawBytes a => Parser a
serialiseToRawBytesHex :: SerialiseAsRawBytes a => a -> ByteString
serialiseToRawBytesHexText :: SerialiseAsRawBytes a => a -> Text
deserialiseFromTextEnvelope :: HasTextEnvelope a => TextEnvelope -> Either TextEnvelopeError a
deserialiseFromTextEnvelopeAnyOf :: [FromSomeType HasTextEnvelope b] -> TextEnvelope -> Either TextEnvelopeError b
legacyComparison :: TextEnvelopeType -> TextEnvelopeType -> Bool
readFileTextEnvelope :: HasTextEnvelope a => File content 'In -> IO (Either (FileError TextEnvelopeError) a)
readFileTextEnvelopeAnyOf :: [FromSomeType HasTextEnvelope b] -> File content 'In -> IO (Either (FileError TextEnvelopeError) b)
readTextEnvelopeFromFile :: FilePath -> IO (Either (FileError TextEnvelopeError) TextEnvelope)
readTextEnvelopeOfTypeFromFile :: TextEnvelopeType -> FilePath -> IO (Either (FileError TextEnvelopeError) TextEnvelope)
serialiseTextEnvelope :: TextEnvelope -> ByteString
serialiseToTextEnvelope :: HasTextEnvelope a => Maybe TextEnvelopeDescr -> a -> TextEnvelope
textEnvelopeRawCBOR :: TextEnvelope -> ByteString
textEnvelopeToJSON :: HasTextEnvelope a => Maybe TextEnvelopeDescr -> a -> ByteString
textEnvelopeTypeInEra :: HasTextEnvelope (f era) => CardanoEra era -> AsType (f era) -> TextEnvelopeType
writeFileTextEnvelope :: HasTextEnvelope a => File content 'Out -> Maybe TextEnvelopeDescr -> a -> IO (Either (FileError ()) ())
cddlTypeToEra :: Text -> Either TextEnvelopeCddlError AnyShelleyBasedEra
deserialiseByronTxCddl :: TextEnvelope -> Either TextEnvelopeCddlError (ATxAux ByteString)
deserialiseFromTextEnvelopeCddlAnyOf :: [FromSomeTypeCDDL TextEnvelope b] -> TextEnvelope -> Either TextEnvelopeCddlError b
deserialiseWitnessLedgerCddl :: ShelleyBasedEra era -> TextEnvelope -> Either TextEnvelopeCddlError (KeyWitness era)
readFileTextEnvelopeCddlAnyOf :: [FromSomeTypeCDDL TextEnvelope b] -> FilePath -> IO (Either (FileError TextEnvelopeCddlError) b)
serialiseWitnessLedgerCddl :: ShelleyBasedEra era -> KeyWitness era -> TextEnvelope
serializeByronTx :: ATxAux ByteString -> TextEnvelope
writeByronTxFileTextEnvelopeCddl :: File content 'Out -> ATxAux ByteString -> IO (Either (FileError ()) ())
writeTxFileTextEnvelopeCanonicalCddl :: ShelleyBasedEra era -> File content 'Out -> Tx era -> IO (Either (FileError ()) ())
writeTxFileTextEnvelopeCddl :: ShelleyBasedEra era -> File content 'Out -> Tx era -> IO (Either (FileError ()) ())
writeTxWitnessFileTextEnvelopeCddl :: ShelleyBasedEra era -> File () 'Out -> KeyWitness era -> IO (Either (FileError ()) ())
addTxExtraKeyWits :: IsAlonzoBasedEra era => [Hash PaymentKey] -> TxBodyContent build era -> TxBodyContent build era
addTxIn :: (TxIn, BuildTxWith build (Witness WitCtxTxIn era)) -> TxBodyContent build era -> TxBodyContent build era
addTxInCollateral :: IsAlonzoBasedEra era => TxIn -> TxBodyContent build era -> TxBodyContent build era
addTxInReference :: (Applicative (BuildTxWith build), IsBabbageBasedEra era) => TxIn -> Maybe HashableScriptData -> TxBodyContent build era -> TxBodyContent build era
addTxIns :: TxIns build era -> TxBodyContent build era -> TxBodyContent build era
addTxInsCollateral :: IsAlonzoBasedEra era => [TxIn] -> TxBodyContent build era -> TxBodyContent build era
addTxInsReference :: (Applicative (BuildTxWith build), IsBabbageBasedEra era) => [TxIn] -> Set HashableScriptData -> TxBodyContent build era -> TxBodyContent build era
addTxMintValue :: IsMaryBasedEra era => Map PolicyId (PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era)) -> TxBodyContent build era -> TxBodyContent build era
addTxOut :: TxOut CtxTx era -> TxBodyContent build era -> TxBodyContent build era
addTxOuts :: [TxOut CtxTx era] -> TxBodyContent build era -> TxBodyContent build era
calculateExecutionUnitsLovelace :: Prices -> ExecutionUnits -> Maybe Coin
collectTxBodyScriptWitnessRequirements :: IsShelleyBasedEra era => AlonzoEraOnwards era -> TxBodyContent BuildTx era -> Either TxBodyError (TxScriptWitnessRequirements (ShelleyLedgerEra era))
collectTxBodyScriptWitnesses :: ShelleyBasedEra era -> TxBodyContent BuildTx era -> [(ScriptWitnessIndex, AnyScriptWitness era)]
convCertificates :: ShelleyBasedEra era -> TxCertificates build era -> StrictSeq (TxCert (ShelleyLedgerEra era))
convCollateralTxIns :: TxInsCollateral era -> Set TxIn
convExtraKeyWitnesses :: TxExtraKeyWitnesses era -> Set (KeyHash 'Witness)
convLanguages :: [(ScriptWitnessIndex, AnyScriptWitness era)] -> Set Language
convMintValue :: TxMintValue build era -> MultiAsset
convPParamsToScriptIntegrityHash :: AlonzoEraOnwards era -> BuildTxWith BuildTx (Maybe (LedgerProtocolParameters era)) -> Redeemers (ShelleyLedgerEra era) -> TxDats (ShelleyLedgerEra era) -> Set Language -> StrictMaybe ScriptIntegrityHash
convProposalProcedures :: TxProposalProcedures build era -> OSet (ProposalProcedure (ShelleyLedgerEra era))
convReferenceInputs :: TxInsReference build era -> Set TxIn
convReturnCollateral :: ShelleyBasedEra era -> TxReturnCollateral ctx era -> StrictMaybe (TxOut (ShelleyLedgerEra era))
convScriptData :: ShelleyBasedEra era -> [TxOut CtxTx era] -> [(ScriptWitnessIndex, AnyScriptWitness era)] -> TxBodyScriptData era
convScripts :: ShelleyLedgerEra era ~ ledgerera => [(ScriptWitnessIndex, AnyScriptWitness era)] -> [Script ledgerera]
convTotalCollateral :: TxTotalCollateral era -> StrictMaybe Coin
convTransactionFee :: ShelleyBasedEra era -> TxFee era -> Coin
convTxIns :: TxIns BuildTx era -> Set TxIn
convTxUpdateProposal :: ShelleyBasedEra era -> TxUpdateProposal era -> Either TxBodyError (StrictMaybe (Update (ShelleyLedgerEra era)))
convValidityLowerBound :: TxValidityLowerBound era -> Maybe SlotNo
convValidityUpperBound :: ShelleyBasedEra era -> TxValidityUpperBound era -> Maybe SlotNo
convVotingProcedures :: TxVotingProcedures build era -> VotingProcedures (ShelleyLedgerEra era)
convWithdrawals :: TxWithdrawals build era -> Withdrawals
createTransactionBody :: HasCallStack => ShelleyBasedEra era -> TxBodyContent BuildTx era -> Either TxBodyError (TxBody era)
defaultTxFee :: ShelleyBasedEra era -> TxFee era
defaultTxValidityUpperBound :: ShelleyBasedEra era -> TxValidityUpperBound era
genesisUTxOPseudoTxIn :: NetworkId -> Hash GenesisUTxOKey -> TxIn
getReferenceInputDatumMap :: TxInsReferenceDatums build -> Map (Hash ScriptData) HashableScriptData
getReferenceInputsSizeForTxIds :: ShelleyLedgerEra era ~ ledgerera => BabbageEraOnwards era -> UTxO ledgerera -> Set TxIn -> Int
getScriptIntegrityHash :: BuildTxWith BuildTx (Maybe (LedgerProtocolParameters era)) -> Set Language -> TxBodyScriptData era -> StrictMaybe ScriptIntegrityHash
getTxBodyContent :: TxBody era -> TxBodyContent ViewTx era
getTxId :: TxBody era -> TxId
getTxIdByron :: ATxAux ByteString -> TxId
getTxIdShelley :: EraTxBody (ShelleyLedgerEra era) => ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> TxId
guardShelleyTxInsOverflow :: [TxIn] -> Either TxBodyError ()
indexTxCertificates :: TxCertificates BuildTx era -> [(ScriptWitnessIndex, Certificate era, StakeCredential, Witness WitCtxStake era)]
indexTxIns :: TxIns BuildTx era -> [(ScriptWitnessIndex, TxIn, Witness WitCtxTxIn era)]
indexTxMintValue :: TxMintValue build era -> [(ScriptWitnessIndex, PolicyId, PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era))]
indexTxProposalProcedures :: TxProposalProcedures BuildTx era -> [(ScriptWitnessIndex, ProposalProcedure (ShelleyLedgerEra era), ScriptWitness WitCtxStake era)]
indexTxVotingProcedures :: TxVotingProcedures BuildTx era -> [(ScriptWitnessIndex, Voter, ScriptWitness WitCtxStake era)]
indexTxWithdrawals :: TxWithdrawals BuildTx era -> [(ScriptWitnessIndex, StakeAddress, Coin, Witness WitCtxStake era)]
indexWitnessedTxProposalProcedures :: TxProposalProcedures BuildTx era -> [(ProposalProcedure (ShelleyLedgerEra era), Maybe (ScriptWitnessIndex, ScriptWitness WitCtxStake era))]
makeByronTransactionBody :: TxIns BuildTx ByronEra -> [TxOut CtxTx ByronEra] -> Either TxBodyError (Annotated Tx ByteString)
mkCommonTxBody :: HasCallStack => ShelleyBasedEra era -> TxIns BuildTx era -> [TxOut ctx era] -> TxFee era -> TxWithdrawals build era -> Maybe (TxAuxData (ShelleyLedgerEra era)) -> LedgerTxBody era
mkTxCertificates :: Applicative (BuildTxWith build) => ShelleyBasedEra era -> [(Certificate era, Maybe (ScriptWitness WitCtxStake era))] -> TxCertificates build era
mkTxMintValue :: MaryEraOnwards era -> [(PolicyId, PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era))] -> TxMintValue build era
mkTxProposalProcedures :: forall era build. (Applicative (BuildTxWith build), IsShelleyBasedEra era) => [(ProposalProcedure (ShelleyLedgerEra era), Maybe (ScriptWitness WitCtxStake era))] -> TxProposalProcedures build era
mkTxVotingProcedures :: Applicative (BuildTxWith build) => [(VotingProcedures era, Maybe (ScriptWitness WitCtxStake era))] -> Either (VotesMergingConflict era) (TxVotingProcedures build era)
modTxAuxScripts :: (TxAuxScripts era -> TxAuxScripts era) -> TxBodyContent build era -> TxBodyContent build era
modTxCertificates :: (TxCertificates build era -> TxCertificates build era) -> TxBodyContent build era -> TxBodyContent build era
modTxExtraKeyWits :: (TxExtraKeyWitnesses era -> TxExtraKeyWitnesses era) -> TxBodyContent build era -> TxBodyContent build era
modTxFee :: (TxFee era -> TxFee era) -> TxBodyContent build era -> TxBodyContent build era
modTxIns :: (TxIns build era -> TxIns build era) -> TxBodyContent build era -> TxBodyContent build era
modTxInsCollateral :: (TxInsCollateral era -> TxInsCollateral era) -> TxBodyContent build era -> TxBodyContent build era
modTxInsReference :: (TxInsReference build era -> TxInsReference build era) -> TxBodyContent build era -> TxBodyContent build era
modTxMetadata :: (TxMetadataInEra era -> TxMetadataInEra era) -> TxBodyContent build era -> TxBodyContent build era
modTxMintValue :: (TxMintValue build era -> TxMintValue build era) -> TxBodyContent build era -> TxBodyContent build era
modTxOuts :: ([TxOut CtxTx era] -> [TxOut CtxTx era]) -> TxBodyContent build era -> TxBodyContent build era
modTxReturnCollateral :: (TxReturnCollateral CtxTx era -> TxReturnCollateral CtxTx era) -> TxBodyContent build era -> TxBodyContent build era
modTxScriptValidity :: (TxScriptValidity era -> TxScriptValidity era) -> TxBodyContent build era -> TxBodyContent build era
modTxTotalCollateral :: (TxTotalCollateral era -> TxTotalCollateral era) -> TxBodyContent build era -> TxBodyContent build era
modTxUpdateProposal :: (TxUpdateProposal era -> TxUpdateProposal era) -> TxBodyContent build era -> TxBodyContent build era
modTxValidityLowerBound :: (TxValidityLowerBound era -> TxValidityLowerBound era) -> TxBodyContent build era -> TxBodyContent build era
modTxValidityUpperBound :: (TxValidityUpperBound era -> TxValidityUpperBound era) -> TxBodyContent build era -> TxBodyContent build era
modTxWithdrawals :: (TxWithdrawals build era -> TxWithdrawals build era) -> TxBodyContent build era -> TxBodyContent build era
renderScriptWitnessIndex :: ScriptWitnessIndex -> String
setTxAuxScripts :: TxAuxScripts era -> TxBodyContent build era -> TxBodyContent build era
setTxCertificates :: TxCertificates build era -> TxBodyContent build era -> TxBodyContent build era
setTxCurrentTreasuryValue :: Maybe (Featured ConwayEraOnwards era (Maybe Coin)) -> TxBodyContent build era -> TxBodyContent build era
setTxExtraKeyWits :: TxExtraKeyWitnesses era -> TxBodyContent build era -> TxBodyContent build era
setTxFee :: TxFee era -> TxBodyContent build era -> TxBodyContent build era
setTxIns :: TxIns build era -> TxBodyContent build era -> TxBodyContent build era
setTxInsCollateral :: TxInsCollateral era -> TxBodyContent build era -> TxBodyContent build era
setTxInsReference :: TxInsReference build era -> TxBodyContent build era -> TxBodyContent build era
setTxMetadata :: TxMetadataInEra era -> TxBodyContent build era -> TxBodyContent build era
setTxMintValue :: TxMintValue build era -> TxBodyContent build era -> TxBodyContent build era
setTxOuts :: [TxOut CtxTx era] -> TxBodyContent build era -> TxBodyContent build era
setTxProposalProcedures :: Maybe (Featured ConwayEraOnwards era (TxProposalProcedures build era)) -> TxBodyContent build era -> TxBodyContent build era
setTxProtocolParams :: BuildTxWith build (Maybe (LedgerProtocolParameters era)) -> TxBodyContent build era -> TxBodyContent build era
setTxReturnCollateral :: TxReturnCollateral CtxTx era -> TxBodyContent build era -> TxBodyContent build era
setTxScriptValidity :: TxScriptValidity era -> TxBodyContent build era -> TxBodyContent build era
setTxTotalCollateral :: TxTotalCollateral era -> TxBodyContent build era -> TxBodyContent build era
setTxTreasuryDonation :: Maybe (Featured ConwayEraOnwards era Coin) -> TxBodyContent build era -> TxBodyContent build era
setTxUpdateProposal :: TxUpdateProposal era -> TxBodyContent build era -> TxBodyContent build era
setTxValidityLowerBound :: TxValidityLowerBound era -> TxBodyContent build era -> TxBodyContent build era
setTxValidityUpperBound :: TxValidityUpperBound era -> TxBodyContent build era -> TxBodyContent build era
setTxVotingProcedures :: Maybe (Featured ConwayEraOnwards era (TxVotingProcedures build era)) -> TxBodyContent build era -> TxBodyContent build era
setTxWithdrawals :: TxWithdrawals build era -> TxBodyContent build era -> TxBodyContent build era
subtractTxMintValue :: IsMaryBasedEra era => Map PolicyId (PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era)) -> TxBodyContent build era -> TxBodyContent build era
toAuxiliaryData :: ShelleyBasedEra era -> TxMetadataInEra era -> TxAuxScripts era -> Maybe (TxAuxData (ShelleyLedgerEra era))
toScriptIndex :: AlonzoEraOnwards era -> PlutusPurpose AsIx (ShelleyLedgerEra era) -> ScriptWitnessIndex
txMintValueToValue :: TxMintValue build era -> Value
validateMetadata :: TxMetadataInEra era -> Either TxBodyError ()
validateProtocolParameters :: BuildTxWith BuildTx (Maybe (LedgerProtocolParameters era)) -> Set Language -> Either TxBodyError ()
validateTxIns :: [(TxIn, BuildTxWith BuildTx (Witness WitCtxTxIn era))] -> Either TxBodyError ()
validateTxInsCollateral :: TxInsCollateral era -> Set Language -> Either TxBodyError ()
adaAssetL :: ShelleyBasedEra era -> Lens' (Value (ShelleyLedgerEra era)) Coin
certsTxBodyL :: ShelleyBasedEra era -> Lens' (LedgerTxBody era) (StrictSeq (TxCert (ShelleyLedgerEra era)))
collateralInputsTxBodyL :: AlonzoEraOnwards era -> Lens' (LedgerTxBody era) (Set TxIn)
collateralReturnTxBodyL :: BabbageEraOnwards era -> Lens' (LedgerTxBody era) (StrictMaybe (TxOut (ShelleyLedgerEra era)))
currentTreasuryValueTxBodyL :: ConwayEraOnwards era -> Lens' (LedgerTxBody era) (StrictMaybe Coin)
invalidBeforeStrictL :: Lens' ValidityInterval (StrictMaybe SlotNo)
invalidBeforeTxBodyL :: AllegraEraOnwards era -> Lens' (LedgerTxBody era) (Maybe SlotNo)
invalidHereAfterStrictL :: Lens' ValidityInterval (StrictMaybe SlotNo)
invalidHereAfterTxBodyL :: ShelleyBasedEra era -> Lens' (LedgerTxBody era) (Maybe SlotNo)
mintTxBodyL :: MaryEraOnwards era -> Lens' (LedgerTxBody era) MultiAsset
mkAdaOnlyTxOut :: ShelleyBasedEra era -> Addr -> Coin -> TxOut (ShelleyLedgerEra era)
mkAdaValue :: ShelleyBasedEra era -> Coin -> Value (ShelleyLedgerEra era)
multiAssetL :: MaryEraOnwards era -> Lens' MaryValue MultiAsset
proposalProceduresTxBodyL :: ConwayEraOnwards era -> Lens' (LedgerTxBody era) (OSet (ProposalProcedure (ShelleyLedgerEra era)))
referenceInputsTxBodyL :: BabbageEraOnwards era -> Lens' (LedgerTxBody era) (Set TxIn)
reqSignerHashesTxBodyL :: AlonzoEraOnwards era -> Lens' (LedgerTxBody era) (Set (KeyHash 'Witness))
scriptIntegrityHashTxBodyL :: AlonzoEraOnwards era -> Lens' (LedgerTxBody era) (StrictMaybe ScriptIntegrityHash)
strictMaybeL :: forall a f. Functor f => (Maybe a -> f (Maybe a)) -> StrictMaybe a -> f (StrictMaybe a)
totalCollateralTxBodyL :: BabbageEraOnwards era -> Lens' (LedgerTxBody era) (StrictMaybe Coin)
treasuryDonationTxBodyL :: ConwayEraOnwards era -> Lens' (LedgerTxBody era) Coin
ttlAsInvalidHereAfterTxBodyL :: ShelleyEraOnly era -> Lens' (LedgerTxBody era) (Maybe SlotNo)
txBodyL :: forall era f. Functor f => (TxBody (ShelleyLedgerEra era) -> f (TxBody (ShelleyLedgerEra era))) -> LedgerTxBody era -> f (LedgerTxBody era)
updateTxBodyL :: ShelleyToBabbageEra era -> Lens' (LedgerTxBody era) (StrictMaybe (Update (ShelleyLedgerEra era)))
valueTxOutAdaAssetL :: ShelleyBasedEra era -> Lens' (TxOut (ShelleyLedgerEra era)) Coin
valueTxOutL :: ShelleyBasedEra era -> Lens' (TxOut (ShelleyLedgerEra era)) (Value (ShelleyLedgerEra era))
votingProceduresTxBodyL :: ConwayEraOnwards era -> Lens' (LedgerTxBody era) (VotingProcedures (ShelleyLedgerEra era))
buildTxWithToMaybe :: BuildTxWith build a -> Maybe a
constructBalancedTx :: ShelleyBasedEra era -> TxBodyContent BuildTx era -> AddressInEra era -> Maybe Word -> UTxO era -> LedgerProtocolParameters era -> LedgerEpochInfo -> SystemStart -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> [ShelleyWitnessSigningKey] -> Either (TxBodyErrorAutoBalance era) (Tx era)
notScriptLockedTxIns :: [TxIn] -> UTxO era -> Either ScriptLockedTxInsError ()
renderNotScriptLockedTxInsError :: ScriptLockedTxInsError -> Text
renderTxInsExistError :: TxInsExistError -> Text
txInsExistInUTxO :: [TxIn] -> UTxO era -> Either TxInsExistError ()
calcReturnAndTotalCollateral :: AlonzoEraPParams (ShelleyLedgerEra era) => BabbageEraOnwards era -> Coin -> PParams (ShelleyLedgerEra era) -> TxInsCollateral era -> TxReturnCollateral CtxTx era -> TxTotalCollateral era -> AddressInEra era -> Value (ShelleyLedgerEra era) -> (TxReturnCollateral CtxTx era, TxTotalCollateral era)
calculateMinTxFee :: ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> UTxO era -> TxBody era -> Word -> Coin
calculateMinimumUTxO :: HasCallStack => ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> TxOut CtxTx era -> Coin
estimateBalancedTxBody :: HasCallStack => MaryEraOnwards era -> TxBodyContent BuildTx era -> PParams (ShelleyLedgerEra era) -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> Map ScriptWitnessIndex ExecutionUnits -> Coin -> Int -> Int -> Int -> AddressInEra era -> Value -> Either (TxFeeEstimationError era) (BalancedTxBody era)
estimateOrCalculateBalancedTxBody :: ShelleyBasedEra era -> FeeEstimationMode era -> PParams (ShelleyLedgerEra era) -> TxBodyContent BuildTx era -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> AddressInEra era -> Either (AutoBalanceError era) (BalancedTxBody era)
estimateTransactionKeyWitnessCount :: TxBodyContent BuildTx era -> Word
evaluateTransactionBalance :: ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> UTxO era -> TxBody era -> TxOutValue era
evaluateTransactionExecutionUnits :: CardanoEra era -> SystemStart -> LedgerEpochInfo -> LedgerProtocolParameters era -> UTxO era -> TxBody era -> Map ScriptWitnessIndex (Either ScriptExecutionError (EvalTxExecutionUnitsLog, ExecutionUnits))
evaluateTransactionExecutionUnitsShelley :: ShelleyBasedEra era -> SystemStart -> LedgerEpochInfo -> LedgerProtocolParameters era -> UTxO era -> Tx (ShelleyLedgerEra era) -> Map ScriptWitnessIndex (Either ScriptExecutionError (EvalTxExecutionUnitsLog, ExecutionUnits))
evaluateTransactionFee :: ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> TxBody era -> Word -> Word -> Int -> Coin
handleExUnitsErrors :: ScriptValidity -> Map ScriptWitnessIndex ScriptExecutionError -> Map ScriptWitnessIndex ExecutionUnits -> Either (TxBodyErrorAutoBalance era) (Map ScriptWitnessIndex ExecutionUnits)
makeTransactionBodyAutoBalance :: HasCallStack => ShelleyBasedEra era -> SystemStart -> LedgerEpochInfo -> LedgerProtocolParameters era -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> UTxO era -> TxBodyContent BuildTx era -> AddressInEra era -> Maybe Word -> Either (TxBodyErrorAutoBalance era) (BalancedTxBody era)
substituteExecutionUnits :: Map ScriptWitnessIndex ExecutionUnits -> TxBodyContent BuildTx era -> Either (TxBodyErrorAutoBalance era) (TxBodyContent BuildTx era)
convTxOuts :: forall ctx era ledgerera. (HasCallStack, ShelleyLedgerEra era ~ ledgerera) => ShelleyBasedEra era -> [TxOut ctx era] -> StrictSeq (TxOut ledgerera)
fromCtxUTxOTxOut :: TxOut CtxUTxO era -> TxOut CtxTx era
fromLedgerTxOuts :: ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> TxBodyScriptData era -> [TxOut CtxTx era]
fromShelleyTxOut :: ShelleyBasedEra era -> TxOut (ShelleyLedgerEra era) -> TxOut ctx era
lovelaceToTxOutValue :: ShelleyBasedEra era -> Coin -> TxOutValue era
prettyRenderTxOut :: TxOutInAnyEra -> Text
scriptDataToInlineDatum :: Era ledgerera => HashableScriptData -> Datum ledgerera
toCtxUTxOTxOut :: TxOut CtxTx era -> TxOut CtxUTxO era
toShelleyTxOut :: (HasCallStack, ShelleyLedgerEra era ~ ledgerera) => ShelleyBasedEra era -> TxOut CtxUTxO era -> TxOut ledgerera
toShelleyTxOutAny :: forall ctx era ledgerera. (HasCallStack, ShelleyLedgerEra era ~ ledgerera) => ShelleyBasedEra era -> TxOut ctx era -> TxOut ledgerera
txOutInAnyEra :: CardanoEra era -> TxOut CtxTx era -> TxOutInAnyEra
txOutValueToLovelace :: TxOutValue era -> Coin
txOutValueToValue :: TxOutValue era -> Value
validateTxOuts :: ShelleyBasedEra era -> [TxOut CtxTx era] -> Either TxOutputError ()
getByronTxBody :: ATxAux ByteString -> Annotated Tx ByteString
getShelleyKeyWitnessVerificationKey :: ShelleySigningKey -> VKey 'Witness
getTxBody :: Tx era -> TxBody era
getTxBodyAndWitnesses :: Tx era -> (TxBody era, [KeyWitness era])
getTxWitnesses :: Tx era -> [KeyWitness era]
getTxWitnessesByron :: ATxAux ByteString -> [KeyWitness ByronEra]
isValidToScriptValidity :: IsValid -> ScriptValidity
makeByronKeyWitness :: IsByronKey key => NetworkId -> Annotated Tx ByteString -> SigningKey key -> KeyWitness ByronEra
makeShelleyBasedBootstrapWitness :: ShelleyBasedEra era -> WitnessNetworkIdOrByronAddress -> TxBody (ShelleyLedgerEra era) -> SigningKey ByronKey -> KeyWitness era
makeShelleyBootstrapWitness :: ShelleyBasedEra era -> WitnessNetworkIdOrByronAddress -> TxBody era -> SigningKey ByronKey -> KeyWitness era
makeShelleyKeyWitness' :: ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> ShelleyWitnessSigningKey -> KeyWitness era
makeShelleySignature :: SignableRepresentation tosign => tosign -> ShelleySigningKey -> SignedDSIGN DSIGN tosign
makeSignedByronTransaction :: [KeyWitness era] -> Annotated Tx ByteString -> ATxAux ByteString
makeSignedTransaction :: [KeyWitness era] -> TxBody era -> Tx era
makeSignedTransaction' :: CardanoEra era -> [KeyWitness era] -> TxBody era -> Tx era
scriptValidityToIsValid :: ScriptValidity -> IsValid
selectTxDatums :: TxBodyScriptData era -> Map DataHash (Data (ShelleyLedgerEra era))
signByronTransaction :: NetworkId -> Annotated Tx ByteString -> [SigningKey ByronKey] -> ATxAux ByteString
toShelleySigningKey :: ShelleyWitnessSigningKey -> ShelleySigningKey
txScriptValidityToIsValid :: TxScriptValidity era -> IsValid
txScriptValidityToScriptValidity :: TxScriptValidity era -> ScriptValidity
fromByronTxIn :: TxIn -> TxIn
fromShelleyTxId :: TxId -> TxId
fromShelleyTxIn :: TxIn -> TxIn
parseTxId :: Parser TxId
parseTxIn :: Parser TxIn
parseTxIx :: Parser TxIx
renderTxIn :: TxIn -> Text
toByronTxId :: TxId -> TxId
toShelleyTxId :: TxId -> TxId
toShelleyTxIn :: TxIn -> TxIn
fromShelleyMetadata :: Map Word64 Metadatum -> Map Word64 TxMetadataValue
fromShelleyMetadatum :: Metadatum -> TxMetadataValue
makeTransactionMetadata :: Map Word64 TxMetadataValue -> TxMetadata
mergeTransactionMetadata :: (TxMetadataValue -> TxMetadataValue -> TxMetadataValue) -> TxMetadata -> TxMetadata -> TxMetadata
metaBytesChunks :: ByteString -> TxMetadataValue
metaTextChunks :: Text -> TxMetadataValue
metadataFromJson :: TxMetadataJsonSchema -> Value -> Either TxMetadataJsonError TxMetadata
metadataToJson :: TxMetadataJsonSchema -> TxMetadata -> Value
metadataValueFromJsonNoSchema :: Value -> Either TxMetadataJsonSchemaError TxMetadataValue
metadataValueToJsonNoSchema :: TxMetadataValue -> Value
pBytes :: Parser ByteString
pSigned :: Parser Integer
pUnsigned :: Parser Integer
parseAll :: Parser a -> Text -> Maybe a
toShelleyMetadata :: Map Word64 TxMetadataValue -> Map Word64 Metadatum
toShelleyMetadatum :: TxMetadataValue -> Metadatum
validateTxMetadata :: TxMetadata -> Either [(Word64, TxMetadataRangeError)] ()
unUTxO :: UTxO era -> Map TxIn (TxOut CtxUTxO era)
allPositive :: Value -> Bool
calcMinimumDeposit :: Value -> Lovelace -> Lovelace
filterValue :: (AssetId -> Bool) -> Value -> Value
fromByronLovelace :: Lovelace -> Lovelace
fromMaryValue :: MaryValue -> Value
fromMultiAsset :: MultiAsset -> Value
fromShelleyDeltaLovelace :: DeltaCoin -> Lovelace
lovelaceToQuantity :: Lovelace -> Quantity
lovelaceToValue :: Lovelace -> Value
multiAssetToPolicyAssets :: MultiAsset -> Map PolicyId PolicyAssets
negateLedgerValue :: ShelleyBasedEra era -> Value (ShelleyLedgerEra era) -> Value (ShelleyLedgerEra era)
negateValue :: Value -> Value
parseAssetId :: Parser AssetId
parseAssetName :: Parser AssetName
parsePolicyId :: Parser PolicyId
parseQuantity :: Parser Quantity
policyAssetsToValue :: PolicyId -> PolicyAssets -> Value
quantityToLovelace :: Quantity -> Lovelace
renderMultiAsset :: MultiAsset -> Text
renderMultiAssetPretty :: MultiAsset -> Text
renderValue :: Value -> Text
renderValuePretty :: Value -> Text
scriptPolicyId :: Script lang -> PolicyId
selectAsset :: Value -> AssetId -> Quantity
selectLovelace :: Value -> Lovelace
toByronLovelace :: Lovelace -> Maybe Lovelace
toMaryValue :: Value -> MaryValue
valueFromList :: [(AssetId, Quantity)] -> Value
valueFromNestedRep :: ValueNestedRep -> Value
valueToList :: Value -> [(AssetId, Quantity)]
valueToLovelace :: Value -> Maybe Lovelace
valueToNestedRep :: Value -> ValueNestedRep
valueToPolicyAssets :: Value -> Map PolicyId PolicyAssets
parseMintingMultiAssetValue :: MaryEraOnwards era -> Parser MultiAsset
parseTxOutMultiAssetValue :: Parser Value
parseUTxOValue :: Parser Value
invalidBeforeL :: Lens' ValidityInterval (Maybe SlotNo)
invalidHereAfterL :: Lens' ValidityInterval (Maybe SlotNo)
interpreterToEpochInfo :: forall (xs :: [Type]). Interpreter xs -> EpochInfo (Except PastHorizonException)
unsafeExtendSafeZone :: forall (xs :: [Type]). Interpreter xs -> Interpreter xs
byronIdTx :: ATxAux ByteString -> TxId
vsep :: [Doc ann] -> Doc ann
bimapExceptT :: forall (m :: Type -> Type) x y a b. Functor m => (x -> y) -> (a -> b) -> ExceptT x m a -> ExceptT y m b
bracketExceptT :: forall (m :: Type -> Type) e a b c. Monad m => ExceptT e m a -> (a -> ExceptT e m b) -> (a -> ExceptT e m c) -> ExceptT e m c
bracketExceptionT :: forall (m :: Type -> Type) e a c b. MonadMask m => ExceptT e m a -> (a -> ExceptT e m c) -> (a -> ExceptT e m b) -> ExceptT e m b
catchExceptT :: (MonadCatch m, Exception e) => m a -> (e -> x) -> ExceptT x m a
catchIOExceptT :: forall (m :: Type -> Type) a x. MonadIO m => IO a -> (IOException -> x) -> ExceptT x m a
catchLeftT :: forall (m :: Type -> Type) e a. Monad m => ExceptT e m a -> (e -> ExceptT e m a) -> ExceptT e m a
catchesExceptT :: (Foldable f, MonadCatch m) => m a -> f (Handler m x) -> ExceptT x m a
exceptT :: Monad m => (x -> m b) -> (a -> m b) -> ExceptT x m a -> m b
firstExceptT :: forall (m :: Type -> Type) x y a. Functor m => (x -> y) -> ExceptT x m a -> ExceptT y m a
handleExceptT :: (MonadCatch m, Exception e) => (e -> x) -> m a -> ExceptT x m a
handleIOExceptT :: forall (m :: Type -> Type) x a. MonadIO m => (IOException -> x) -> IO a -> ExceptT x m a
handleLeftT :: forall (m :: Type -> Type) e a. Monad m => (e -> ExceptT e m a) -> ExceptT e m a -> ExceptT e m a
handlesExceptT :: (Foldable f, MonadCatch m) => f (Handler m x) -> m a -> ExceptT x m a
hoistEither :: forall (m :: Type -> Type) x a. Monad m => Either x a -> ExceptT x m a
hoistExceptT :: (forall b. () => m b -> n b) -> ExceptT x m a -> ExceptT x n a
hushM :: Monad m => Either e a -> (e -> m ()) -> m (Maybe a)
newExceptT :: m (Either x a) -> ExceptT x m a
onLeft :: forall e x (m :: Type -> Type) a. Monad m => (e -> ExceptT x m a) -> ExceptT x m (Either e a) -> ExceptT x m a
onNothing :: forall x (m :: Type -> Type) a. Monad m => ExceptT x m a -> ExceptT x m (Maybe a) -> ExceptT x m a
secondExceptT :: forall (m :: Type -> Type) a b x. Functor m => (a -> b) -> ExceptT x m a -> ExceptT x m b
txId :: HasTxId tx => tx -> TxId tx
condense :: Condense a => a -> String
class () => FromJSON a
parseJSON :: FromJSON a => Value -> Parser a
parseJSONList :: FromJSON a => Value -> Parser [a]
omittedField :: FromJSON a => Maybe a
class () => ToJSON a
toJSON :: ToJSON a => a -> Value
toEncoding :: ToJSON a => a -> Encoding
toJSONList :: ToJSON a => [a] -> Value
toEncodingList :: ToJSON a => [a] -> Encoding
omitField :: ToJSON a => a -> Bool

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = ?callStack :: CallStack

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data () => Proxy (t :: k)
Proxy :: Proxy (t :: k)

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class () => Typeable (a :: k)
newtype () => UTxO era
UTxO :: Map TxIn (TxOut CtxUTxO era) -> UTxO era
type Era = ConwayEra

-- | Currently supported ledger era.
type LedgerEra = ShelleyLedgerEra Era

-- | Associated version for the fixed <a>LedgerEra</a>.
ledgerEraVersion :: Version

-- | A space efficient, packed, unboxed Unicode text type.
data () => Text

-- | Decode a <a>ByteString</a> containing UTF-8 encoded text that is known
--   to be valid.
--   
--   If the input contains any invalid UTF-8 data, an exception will be
--   thrown that cannot be caught in pure code. For more control over the
--   handling of invalid data, use <a>decodeUtf8'</a> or
--   <a>decodeUtf8With</a>.
--   
--   This is a partial function: it checks that input is a well-formed
--   UTF-8 sequence and copies buffer or throws an error otherwise.
decodeUtf8 :: ByteString -> Text

-- | Encode text using UTF-8 encoding.
encodeUtf8 :: Text -> ByteString

-- | <i>O(n)</i> Convert a lazy <a>ByteString</a> into a strict
--   <a>ByteString</a>.
--   
--   Note that this is an <i>expensive</i> operation that forces the whole
--   lazy ByteString into memory and then copies all the data. If possible,
--   try to avoid converting back and forth between strict and lazy
--   bytestrings.
toStrict :: ByteString -> ByteString

-- | <i>O(1)</i> Convert a strict <a>ByteString</a> into a lazy
--   <a>ByteString</a>.
fromStrict :: ByteString -> ByteString

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data () => ByteString

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
--   
--   The <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which
--   prefers values from the left operand. If <tt>m1</tt> maps a key
--   <tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key
--   to a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;
--   m2</tt> maps <tt>k</tt> to <tt>a1</tt>.
data () => Map k a

-- | A set of values <tt>a</tt>.
data () => Set a

-- | Interpret some raw <a>ByteString</a> as a particular <a>Hash</a>.
--   
--   NOTE: This throws if byte string has a length different that the
--   expected target digest length.
unsafeHashFromBytes :: (HasCallStack, HashAlgorithm hash) => ByteString -> Hash hash a
class () => Arbitrary a
arbitrary :: Arbitrary a => Gen a
shrink :: Arbitrary a => a -> [a]
data () => Gen a

module Hydra.Cardano.Api.PolicyAssets
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Api.Value.Internal.PolicyAssets
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Api.Value.Internal.PolicyAssets

module Hydra.Cardano.Api.NetworkId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Api.Network.Internal.NetworkId.NetworkId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Api.Network.Internal.NetworkId.NetworkId
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Api.Network.Internal.NetworkId.NetworkId

module Hydra.Cardano.Api.Hash

-- | Convert a cardano-api <a>Hash</a> into a plutus <tt>PubKeyHash</tt>
toPlutusKeyHash :: Hash PaymentKey -> PubKeyHash

-- | Convert a cardano-api <a>Hash</a> into a cardano-ledger
--   <tt>KeyHash</tt>
toLedgerKeyHash :: Hash PaymentKey -> KeyHash 'Witness

-- | Unsafe wrap some bytes as a 'Hash PaymentKey'.
--   
--   Pre-condition: the input bytestring MUST be of length 28.
unsafePaymentKeyHashFromBytes :: HasCallStack => ByteString -> Hash PaymentKey

-- | Unsafe wrap some bytes as a 'Hash ScriptData', relying on the fact
--   that Plutus is using Blake2b_256 for hashing data (according to
--   'cardano-ledger').
--   
--   Pre-condition: the input bytestring MUST be of length 32.
unsafeScriptDataHashFromBytes :: HasCallStack => ByteString -> Hash ScriptData
unsafeCastHash :: (SerialiseAsCBOR (Hash a), SerialiseAsCBOR (Hash b), HasCallStack) => Hash a -> Hash b

module Hydra.Cardano.Api.ExecutionUnits

-- | Convert a cardano-api <a>ExecutionUnits</a> into a cardano-ledger
--   <tt>ExUnits</tt>
toLedgerExUnits :: ExecutionUnits -> ExUnits

module Hydra.Cardano.Api.BlockHeader

-- | Fully arbitrary block header with completely random hash.
genBlockHeader :: Gen BlockHeader

-- | Generate a random block header with completely random hash, but at a
--   certain slot.
genBlockHeaderAt :: SlotNo -> Gen BlockHeader

-- | Generate a random block header hash.
genBlockHeaderHash :: Gen (Hash BlockHeader)
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Api.Block.BlockHeader

module Hydra.Cardano.Api.ChainPoint

-- | Get the chain point corresponding to a given <a>BlockHeader</a>.
getChainPoint :: BlockHeader -> ChainPoint

-- | Generate a chain point with a likely invalid block header hash.
genChainPoint :: Gen ChainPoint

-- | Generate a chain point at given slot with a likely invalid block
--   header hash.
genChainPointAt :: SlotNo -> Gen ChainPoint
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Api.Block.ChainPoint

module Hydra.Cardano.Api.AddressInEra

-- | Construct a Shelley-style address from a verification key. This
--   address has no stake rights.
--   
--   TODO: <a>NetworkId</a> here is an annoying API because it requires a
--   network magic for testnet addresses. Nevertheless, the network magic
--   is only needed for Byron addresses; Shelley addresses use a different
--   kind of network discriminant which is currently fully captured as
--   'Mainnet | Testnet'.
--   
--   So, it would be a slightly better DX to use Mainnet | Testnet as an
--   interface here since we are only constructing Shelley addresses.
mkVkAddress :: IsShelleyBasedEra era => NetworkId -> VerificationKey PaymentKey -> AddressInEra era

-- | Construct a Shelley-style address from a Plutus script. This address
--   has no stake rights.
mkScriptAddress :: forall lang era. (IsShelleyBasedEra era, IsPlutusScriptLanguage lang) => NetworkId -> PlutusScript lang -> AddressInEra era

-- | From a ledger <tt>Addr</tt> to an api <a>AddressInEra</a>
fromLedgerAddr :: IsShelleyBasedEra era => Addr -> AddressInEra era

-- | From an api <a>AddressInEra</a> to a ledger <tt>Addr</tt>
toLedgerAddr :: AddressInEra era -> Addr

-- | Convert a plutus <a>Address</a> to an api <a>AddressInEra</a>. NOTE:
--   Requires the <tt>Network</tt> discriminator (Testnet or Mainnet)
--   because Plutus addresses are stripped off it.
fromPlutusAddress :: IsShelleyBasedEra era => Network -> Address -> AddressInEra era

module Hydra.Cardano.Api.Address
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Api.Address.Address Cardano.Api.Address.ByronAddr)

module Hydra.Cardano.Api.ReferenceScript

-- | Construct a <a>ReferenceScript</a> from any given Plutus script.
mkScriptRef :: IsPlutusScriptLanguage lang => PlutusScript lang -> ReferenceScript Era

module Hydra.Cardano.Api.ScriptData

-- | Data-types that can be marshalled into a generic <a>ScriptData</a>
--   structure.
type ToScriptData a = ToData a

-- | Data-types that can be unmarshalled from a generic <a>ScriptData</a>
--   structure.
type FromScriptData a = FromData a

-- | Serialise some type into a generic script data.
toScriptData :: ToScriptData a => a -> HashableScriptData

-- | Deserialise some generic script data into some type.
fromScriptData :: FromScriptData a => HashableScriptData -> Maybe a

-- | Get the <a>HashableScriptData</a> associated to the a <a>TxOut</a>.
--   Note that this requires the <a>CtxTx</a> context.
txOutScriptData :: TxOut CtxTx era -> Maybe HashableScriptData

-- | Convert a cardano-ledger script <tt>Data</tt> into a cardano-api
--   <a>ScriptDatum</a>.
fromLedgerData :: Data era -> HashableScriptData

-- | Convert a cardano-api script data into a cardano-ledger script
--   <tt>Data</tt>. XXX: This is a partial function. Ideally it would fall
--   back to the <a>Data</a> portion in <a>HashableScriptData</a>.
toLedgerData :: Era era => HashableScriptData -> Data era

module Hydra.Cardano.Api.ScriptDatum

-- | Construct a <a>ScriptDatum</a> for use as transaction witness.
mkScriptDatum :: ToScriptData a => a -> ScriptDatum WitCtxTxIn

module Hydra.Cardano.Api.ScriptHash

-- | Like <a>hashScript</a>, but for a <a>ScriptInAnyLang</a>.
hashScriptInAnyLang :: ScriptInAnyLang -> ScriptHash

module Hydra.Cardano.Api.PolicyId

-- | Convert Cardano api <a>PolicyId</a> to Cardano ledger
--   <tt>PolicyID</tt>.
toLedgerPolicyID :: PolicyId -> PolicyID

-- | Convert Cardano api <a>PolicyId</a> to Plutus <a>CurrencySymbol</a>.
toPlutusCurrencySymbol :: PolicyId -> CurrencySymbol

-- | Convert a plutus <a>CurrencySymbol</a> into a cardano-api
--   <a>PolicyId</a>.
fromPlutusCurrencySymbol :: MonadFail m => CurrencySymbol -> m PolicyId
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Api.Value.Internal.PolicyId

module Hydra.Cardano.Api.StakeAddress

-- | Construct a stake address from a Plutus script.
mkScriptStakeAddress :: forall lang. IsPlutusScriptLanguage lang => NetworkId -> PlutusScript lang -> StakeAddress

module Hydra.Cardano.Api.TxId

-- | Convert a cardano-api <a>TxId</a> into a cardano-ledger <a>TxId</a>.
toLedgerTxId :: TxId -> TxId
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Api.Tx.Internal.TxIn.TxId
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Api.Tx.Internal.TxIn.TxId

module Hydra.Cardano.Api.TxIn

-- | Create a <a>TxIn</a> (a.k.a UTXO) from a transaction and output index.
mkTxIn :: Tx era -> Word -> TxIn

-- | Attach some verification-key witness to a <a>TxIn</a>.
withWitness :: TxIn -> (TxIn, BuildTxWith BuildTx (Witness WitCtxTxIn Era))

-- | Access inputs of a transaction, as an ordered list.
txIns' :: Tx era -> [TxIn]

-- | Access inputs of a transaction, as an ordered set.
txInputSet :: Tx era -> Set TxIn

-- | Convert a cardano-ledger <a>TxIn</a> into a cardano-api <a>TxIn</a>
fromLedgerTxIn :: TxIn -> TxIn

-- | Convert a cardano-api <a>TxIn</a> into a cardano-ledger <a>TxIn</a>
toLedgerTxIn :: TxIn -> TxIn

-- | Convert a plutus' <tt>TxOutRef</tt> into a cardano-api <a>TxIn</a>
fromPlutusTxOutRef :: TxOutRef -> TxIn

-- | Convert a cardano-api <a>TxIn</a> into a plutus <tt>TxOutRef</tt>.
toPlutusTxOutRef :: TxIn -> TxOutRef

-- | A more random generator than the 'Arbitrary TxIn' from cardano-ledger.
--   NOTE: This is using the Cardano ledger's deserialization framework
--   using the latest protocol version via <a>maxBound</a>.
genTxIn :: Gen TxIn
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Api.Tx.Internal.TxIn.TxIn

module Hydra.Cardano.Api.TxBody

-- | Find and deserialise from <a>ScriptData</a>, a redeemer from the
--   transaction associated to the given input.
findRedeemerSpending :: FromData a => Tx Era -> TxIn -> Maybe a
lookupRedeemer :: FromData a => PlutusPurpose AsIx LedgerEra -> TxBodyScriptData Era -> Maybe a

module Hydra.Cardano.Api.Tx

-- | Sign transaction using the provided secret key It only works for tx
--   not containing scripts. You can't sign a script utxo with this.
signTx :: IsShelleyBasedEra era => SigningKey PaymentKey -> Tx era -> Tx era

-- | Create a transaction spending all given <a>UTxO</a>.
txSpendingUTxO :: UTxO Era -> Tx Era

-- | Convert a cardano-ledger's <a>Tx</a> in the Babbage era into a
--   cardano-api <a>Tx</a>.
fromLedgerTx :: IsShelleyBasedEra era => Tx (ShelleyLedgerEra era) -> Tx era

-- | Get the UTxO that are produced by some transaction. XXX: Defined here
--   to avoid cyclic module dependency
utxoProducedByTx :: Tx Era -> UTxO Era

-- | Convert a cardano-api <a>Tx</a> into a matching cardano-ledger
--   <a>Tx</a>.
toLedgerTx :: Tx era -> Tx (ShelleyLedgerEra era)
data () => Tx era

module Hydra.Cardano.Api.TxOutDatum

-- | Construct a <a>TxOutDatum</a> as a <a>ScriptData</a> hash from some
--   serialisable data.
mkTxOutDatumHash :: forall era a ctx. (ToScriptData a, IsAlonzoBasedEra era) => a -> TxOutDatum ctx era

-- | Construct an inline <a>TxOutDatum</a> from some serialisable data.
mkTxOutDatumInline :: forall era a ctx. (ToScriptData a, IsBabbageBasedEra era) => a -> TxOutDatum ctx era

module Hydra.Cardano.Api.TxOutValue

-- | Inject some <a>Value</a> into a <a>TxOutValue</a>
mkTxOutValue :: forall era. IsMaryBasedEra era => Value -> TxOutValue era

module Hydra.Cardano.Api.UTxO

-- | Construct a UTxO from a transaction. This constructs artificial
--   <a>TxIn</a> (a.k.a output reference) from the transaction itself,
--   zipping them to the outputs they correspond to.
utxoFromTx :: Tx Era -> UTxO Era

-- | Resolve tx inputs in a given UTxO
resolveInputsUTxO :: UTxO Era -> Tx Era -> UTxO Era

module Hydra.Cardano.Api.ValidityInterval
toLedgerValidityInterval :: (TxValidityLowerBound era, TxValidityUpperBound era) -> ValidityInterval
fromLedgerValidityInterval :: ValidityInterval -> (TxValidityLowerBound Era, TxValidityUpperBound Era)
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Api.Tx.Internal.Body.TxValidityLowerBound Hydra.Cardano.Api.Prelude.Era)
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Api.Tx.Internal.Body.TxValidityUpperBound Hydra.Cardano.Api.Prelude.Era)

module Hydra.Cardano.Api.Value

-- | Calculate minimum ada as <a>Value</a> for a <a>TxOut</a>. NOTE: This
--   function can throw although you can't tell from the signature.
--   <a>toLedgerValue</a> can error out with _Illegal Value in TxOut_
minUTxOValue :: PParams LedgerEra -> TxOut CtxTx Era -> Value

-- | Count number of assets in a <a>Value</a>.
valueSize :: Value -> Int

-- | Convert a cardano-ledger <a>Value</a> into a cardano-api <a>Value</a>.
fromLedgerValue :: MaryValue -> Value

-- | Convert a cardano-ledger <tt>MultiAsset</tt> into a cardano-api
--   <a>Value</a>. The cardano-api currently does not have an asset-only
--   type. So this conversion will construct a <a>Value</a> with no
--   <a>AdaAssetId</a> entry in it.
fromLedgerMultiAsset :: MultiAsset -> Value

-- | Convert a cardano-api <a>Value</a> into a cardano-ledger <a>Value</a>.
toLedgerValue :: Value -> MaryValue

-- | Convert a plutus <a>Value</a> into a cardano-api <a>Value</a>.
fromPlutusValue :: Value -> Maybe Value

module Hydra.Cardano.Api.TxOut
txOuts' :: Tx era -> [TxOut CtxTx era]

-- | Modify a <a>TxOut</a> to set the minimum ada on the value.
setMinUTxOValue :: PParams LedgerEra -> TxOut CtxUTxO Era -> TxOut ctx Era

-- | Automatically balance a given output with the minimum required amount.
--   Number of assets, presence of datum and/or reference scripts may
--   affect this minimum value.
mkTxOutAutoBalance :: PParams LedgerEra -> AddressInEra Era -> Value -> TxOutDatum CtxTx Era -> ReferenceScript Era -> TxOut CtxTx Era

-- | Alter the address of a <a>TxOut</a> with the given transformation.
modifyTxOutAddress :: (AddressInEra era -> AddressInEra era) -> TxOut ctx era -> TxOut ctx era

-- | Alter the value of a <a>TxOut</a> with the given transformation.
modifyTxOutValue :: IsMaryBasedEra era => (Value -> Value) -> TxOut ctx era -> TxOut ctx era

-- | Alter the datum of a <a>TxOut</a> with the given transformation.
modifyTxOutDatum :: (TxOutDatum ctx0 era -> TxOutDatum ctx1 era) -> TxOut ctx0 era -> TxOut ctx1 era

-- | Find first <a>TxOut</a> which pays to given address and also return
--   the corresponding <a>TxIn</a> to reference it.
findTxOutByAddress :: AddressInEra era -> Tx era -> Maybe (TxIn, TxOut CtxTx era)

-- | Find a single script output in some <a>UTxO</a>
findTxOutByScript :: forall lang. IsPlutusScriptLanguage lang => UTxO Era -> PlutusScript lang -> Maybe (TxIn, TxOut CtxUTxO Era)

-- | Predicate to find or filter <a>TxOut</a> owned by a key. This is
--   better than comparing the full address as it does not require a
--   network discriminator.
isVkTxOut :: forall ctx era. VerificationKey PaymentKey -> TxOut ctx era -> Bool

-- | Predicate to find or filter <a>TxOut</a> which are governed by some
--   script. This is better than comparing the full address as it does not
--   require a network discriminator.
isScriptTxOut :: forall lang ctx era. IsPlutusScriptLanguage lang => PlutusScript lang -> TxOut ctx era -> Bool

-- | Convert a cardano-ledger <a>TxOut</a> into a cardano-api <a>TxOut</a>
fromLedgerTxOut :: IsShelleyBasedEra era => TxOut (ShelleyLedgerEra era) -> TxOut ctx era

-- | Convert a cardano-api <a>TxOut</a> into a cardano-ledger <a>TxOut</a>
toLedgerTxOut :: IsShelleyBasedEra era => TxOut CtxUTxO era -> TxOut (ShelleyLedgerEra era)

-- | Convert a plutus <a>TxOut</a> into a cardano-api <a>TxOut</a>. NOTE:
--   Reference scripts are not resolvable right now. NOTE: Requires the
--   <tt>Network</tt> discriminator (Testnet or Mainnet) because Plutus
--   addresses are stripped off it.
fromPlutusTxOut :: forall era. IsBabbageBasedEra era => Network -> TxOut -> Maybe (TxOut CtxUTxO era)

-- | Convert a cardano-api <a>TxOut</a> into a plutus <a>TxOut</a>. Returns
--   <a>Nothing</a> if a byron address is used in the given <a>TxOut</a>.
toPlutusTxOut :: HasCallStack => TxOut CtxUTxO Era -> Maybe TxOut

module Hydra.Cardano.Api.Witness

-- | Construct a full script witness from a datum, a redeemer and a full
--   <a>Script</a>. That witness has no execution budget.
mkScriptWitness :: forall ctx era lang. (IsPlutusScriptLanguage lang, HasScriptLanguageInEra lang era) => PlutusScript lang -> ScriptDatum ctx -> ScriptRedeemer -> ScriptWitness ctx era

-- | Construct a reference script witness, only referring to a <a>TxIn</a>
--   which is expected to contain the given script (only required to
--   satisfy types).
mkScriptReference :: forall ctx era lang. (IsPlutusScriptLanguage lang, HasScriptLanguageInEra lang era) => TxIn -> PlutusScript lang -> ScriptDatum ctx -> ScriptRedeemer -> ScriptWitness ctx era


-- | A Haskell API for Cardano, tailored to the Hydra project.
--   
--   This package provides a wrapper around the <tt>cardano-ledger</tt>,
--   <tt>cardano-api</tt> and <tt>plutus</tt> libraries with extra
--   utilities and function commonly used across the Hydra project.
--   
--   NOTE: We always use the **latest era** available in our codebase, so
--   to ease type signatures and notations, we specialize any type of the
--   <tt>cardano-api</tt> normally parameterized by an era to the latest
--   era <a>Era</a>. As a consequence, we've defined pattern synonyms for
--   most constructors in the <tt>cardano-api</tt> to also get rid of era
--   witnesses.
--   
--   NOTE: This module also uses the **latest plutus version** available
--   (currently <a>PlutusScriptVersion</a>). So make sure that you give it
--   a plutus script of the right version (e.g. when compiling and
--   serializing plutus-tx).
module Hydra.Cardano.Api
type Era = ConwayEra

-- | Currently supported ledger era.
type LedgerEra = ShelleyLedgerEra Era

-- | Associated version for the fixed <a>LedgerEra</a>.
ledgerEraVersion :: Version
newtype () => LedgerProtocolParameters era
LedgerProtocolParameters :: PParams (ShelleyLedgerEra era) -> LedgerProtocolParameters era
[unLedgerProtocolParameters] :: LedgerProtocolParameters era -> PParams (ShelleyLedgerEra era)
type AddressInEra = AddressInEra Era
type AddressTypeInEra addrType = AddressTypeInEra addrType Era
type BalancedTxBody = BalancedTxBody Era
type KeyWitness = KeyWitness Era
type PlutusScript = PlutusScript PlutusScriptV3
type ReferenceScript = ReferenceScript Era
type Script = Script PlutusScriptV3
type ScriptInEra = ScriptInEra Era
type ScriptLanguage = ScriptLanguage PlutusScriptV3
type ScriptWitness witCtx = ScriptWitness witCtx Era
type Tx = Tx Era
type TxAuxScripts = TxAuxScripts Era
type TxBody = TxBody Era
type TxBodyContent build = TxBodyContent build Era
type TxBodyScriptData = TxBodyScriptData Era
type TxExtraKeyWitnesses = TxExtraKeyWitnesses Era
type TxFee = TxFee Era
type TxIns build = [(TxIn, BuildTxWith build (Witness WitCtxTxIn Era))]
type TxInsCollateral = TxInsCollateral Era
type TxInsReference build = TxInsReference build Era
type TxMetadataInEra = TxMetadataInEra Era
type TxMintValue build = TxMintValue build Era
type TxOut ctx = TxOut ctx Era
type TxOutDatum ctx = TxOutDatum ctx Era
type TxScriptValidity = TxScriptValidity Era
type TxValidityLowerBound = TxValidityLowerBound Era
type TxValidityUpperBound = TxValidityUpperBound Era
type UTxO = UTxO Era
type Witness witCtx = Witness witCtx Era
pattern BalancedTxBody :: TxBodyContent BuildTx -> TxBody -> TxOut CtxTx -> Coin -> BalancedTxBody
pattern KeyWitness :: KeyWitnessInCtx ctx -> Witness ctx
pattern PlutusScript :: PlutusScript -> Script
pattern PlutusScriptSerialised :: ShortByteString -> PlutusScript
pattern ReferenceScript :: ScriptInAnyLang -> ReferenceScript
pattern ScriptWitness :: ScriptWitnessInCtx ctx -> ScriptWitness ctx -> Witness ctx
pattern Tx :: TxBody -> [KeyWitness] -> Tx
pattern TxAuxScripts :: [ScriptInEra] -> TxAuxScripts
pattern TxBodyContent :: TxIns build -> TxInsCollateral -> TxInsReference build -> [TxOut CtxTx] -> TxTotalCollateral Era -> TxReturnCollateral CtxTx Era -> TxFee -> TxValidityLowerBound -> TxValidityUpperBound -> TxMetadataInEra -> TxAuxScripts -> TxExtraKeyWitnesses -> BuildTxWith build (Maybe (LedgerProtocolParameters Era)) -> TxWithdrawals build Era -> TxCertificates build Era -> TxUpdateProposal Era -> TxMintValue build -> TxScriptValidity -> Maybe (Featured ConwayEraOnwards Era (TxProposalProcedures build Era)) -> Maybe (Featured ConwayEraOnwards Era (TxVotingProcedures build Era)) -> Maybe (Featured ConwayEraOnwards Era (Maybe Coin)) -> Maybe (Featured ConwayEraOnwards Era Coin) -> TxBodyContent build
pattern TxBodyScriptData :: TxDats (ShelleyLedgerEra Era) -> Redeemers (ShelleyLedgerEra Era) -> TxBodyScriptData
pattern TxExtraKeyWitnesses :: [Hash PaymentKey] -> TxExtraKeyWitnesses
pattern TxInsCollateral :: [TxIn] -> TxInsCollateral
pattern TxInsReference :: [TxIn] -> TxInsReferenceDatums build -> TxInsReference build
pattern TxMetadataInEra :: TxMetadata -> TxMetadataInEra
pattern TxMintValue :: Map PolicyId (PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint)) -> TxMintValue build

-- | TxOut specialized for <a>Era</a>
pattern TxOut :: AddressInEra -> Value -> TxOutDatum ctx -> ReferenceScript -> TxOut ctx
pattern TxScriptValidity :: ScriptValidity -> TxScriptValidity
pattern TxValidityLowerBound :: SlotNo -> TxValidityLowerBound
pattern TxValidityUpperBound :: SlotNo -> TxValidityUpperBound
pattern UTxO :: Map TxIn (TxOut CtxUTxO) -> UTxO
pattern ByronAddressInAnyEra :: AddressTypeInEra ByronAddr
pattern ShelleyAddressInEra :: Address ShelleyAddr -> AddressInEra
pattern PlutusScriptLanguage :: ScriptLanguage
pattern PlutusScriptWitness :: PlutusScript -> ScriptDatum witctx -> ScriptRedeemer -> ExecutionUnits -> ScriptWitness witctx
pattern ReferenceScriptNone :: ReferenceScript Era
pattern TxAuxScriptsNone :: TxAuxScripts
pattern TxExtraKeyWitnessesNone :: TxExtraKeyWitnesses
pattern TxFeeExplicit :: Coin -> TxFee
pattern TxInsCollateralNone :: TxInsCollateral
pattern TxInsReferenceNone :: TxInsReference build
pattern TxMetadataNone :: TxMetadataInEra
pattern TxValidityNoLowerBound :: TxValidityLowerBound
pattern TxOutDatumHash :: Hash ScriptData -> TxOutDatum ctx
pattern TxOutDatumInline :: HashableScriptData -> TxOutDatum ctx
pattern TxOutDatumNone :: TxOutDatum ctx
pattern TxOutSupplementalDatum :: HashableScriptData -> TxOutDatum CtxTx
pattern ShelleyBootstrapWitness :: BootstrapWitness -> KeyWitness
pattern ShelleyKeyWitness :: WitVKey 'Witness -> KeyWitness
pattern ShelleyTxBody :: TxBody LedgerEra -> [Script LedgerEra] -> TxBodyScriptData -> Maybe (AlonzoTxAuxData LedgerEra) -> TxScriptValidity -> TxBody
pattern TxBodyNoScriptData :: TxBodyScriptData
pattern TxScriptValidityNone :: TxScriptValidity
pattern ByronAddressInEra :: Address ByronAddr -> AddressInEra
pattern ShelleyAddressInAnyEra :: AddressTypeInEra ShelleyAddr
pattern TxMintValueNone :: TxMintValue build
pattern TxValidityNoUpperBound :: TxValidityUpperBound
upperBound :: TxValidityUpperBound -> SlotNo
lowerBound :: TxValidityLowerBound -> SlotNo
createAndValidateTransactionBody :: TxBodyContent BuildTx -> Either TxBodyError TxBody
defaultTxBodyContent :: TxBodyContent BuildTx
makeShelleyKeyWitness :: TxBody -> ShelleyWitnessSigningKey -> KeyWitness
signShelleyTransaction :: TxBody -> [ShelleyWitnessSigningKey] -> Tx
txAuxScripts :: TxBodyContent build -> TxAuxScripts
txCertificates :: TxBodyContent build -> TxCertificates build Era
txCurrentTreasuryValue :: TxBodyContent build -> Maybe (Featured ConwayEraOnwards Era (Maybe Coin))
txExtraKeyWits :: TxBodyContent build -> TxExtraKeyWitnesses
txFee :: TxBodyContent build -> TxFee
txIns :: TxBodyContent build -> TxIns build
txInsCollateral :: TxBodyContent build -> TxInsCollateral
txInsReference :: TxBodyContent build -> TxInsReference build
txMetadata :: TxBodyContent build -> TxMetadataInEra
txMintValue :: TxBodyContent build -> TxMintValue build
txOuts :: TxBodyContent build -> [TxOut CtxTx]
txProposalProcedures :: TxBodyContent build -> Maybe (Featured ConwayEraOnwards Era (TxProposalProcedures build Era))
txProtocolParams :: TxBodyContent build -> BuildTxWith build (Maybe (LedgerProtocolParameters Era))
txReturnCollateral :: TxBodyContent build -> TxReturnCollateral CtxTx Era
txScriptValidity :: TxBodyContent build -> TxScriptValidity
txTotalCollateral :: TxBodyContent build -> TxTotalCollateral Era
txTreasuryDonation :: TxBodyContent build -> Maybe (Featured ConwayEraOnwards Era Coin)
txUpdateProposal :: TxBodyContent build -> TxUpdateProposal Era
txValidityLowerBound :: TxBodyContent build -> TxValidityLowerBound
txValidityUpperBound :: TxBodyContent build -> TxValidityUpperBound
txVotingProcedures :: TxBodyContent build -> Maybe (Featured ConwayEraOnwards Era (TxVotingProcedures build Era))
txWithdrawals :: TxBodyContent build -> TxWithdrawals build Era
utxo :: UTxO -> Map TxIn (TxOut CtxUTxO)
txBody :: Tx -> TxBody
plutusScript :: Script -> PlutusScript
address :: AddressInEra -> Address ShelleyAddr
scriptData :: TxInsReference build -> TxInsReferenceDatums build
txOutAddress :: TxOut ctx -> AddressInEra
txOutValue :: TxOut ctx -> Value
txOutDatum :: TxOut ctx -> TxOutDatum ctx
txOutReferenceScript :: TxOut ctx -> ReferenceScript
byronAddress :: AddressInEra -> Address ByronAddr
balancedTxBodyContent :: BalancedTxBody -> TxBodyContent BuildTx
balancedTxBody :: BalancedTxBody -> TxBody
balancedTxChangeOutput :: BalancedTxBody -> TxOut CtxTx
balancedTxFee :: BalancedTxBody -> Coin
shelleyBootstrapWitness :: KeyWitness -> BootstrapWitness
shelleyKeyWitness :: KeyWitness -> WitVKey 'Witness
plutusScriptSerialised :: PlutusScript -> ShortByteString
plutusScriptWitnessScript :: ScriptWitness witctx -> PlutusScript
plutusScriptWitnessDatum :: ScriptWitness witctx -> ScriptDatum witctx
plutusScriptWitnessRedeemer :: ScriptWitness witctx -> ScriptRedeemer
plutusScriptWitnessExecutionUnits :: ScriptWitness witctx -> ExecutionUnits
txKeyWitnesses :: Tx -> [KeyWitness]
txBodyLedgerTxBody :: TxBody -> TxBody LedgerEra
txBodyScripts :: TxBody -> [Script LedgerEra]
txBodyScriptData :: TxBody -> TxBodyScriptData
txBodyAuxiliaryData :: TxBody -> Maybe (AlonzoTxAuxData LedgerEra)
txBodyScriptValidity :: TxBody -> TxScriptValidity
txAuxScripts' :: TxAuxScripts -> [ScriptInEra]
txBodyScriptDatums :: TxBodyScriptData -> TxDats (ShelleyLedgerEra Era)
txBodyScriptRedeemers :: TxBodyScriptData -> Redeemers (ShelleyLedgerEra Era)
txExtraKeyWitnesses :: TxExtraKeyWitnesses -> [Hash PaymentKey]
txFeeExplicit :: TxFee -> Coin
txInsReference' :: TxInsReference build -> [TxIn]
txInsCollateral' :: TxInsCollateral -> [TxIn]
txMetadataInEra :: TxMetadataInEra -> TxMetadata
txMintValueInEra :: TxMintValue build -> Map PolicyId (PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint))
referenceScript :: ReferenceScript -> ScriptInAnyLang
txOutDatumHash :: TxOutDatum ctx -> Hash ScriptData
txOutDatumScriptData :: TxOutDatum CtxTx -> HashableScriptData
txOutDatumInlineScriptData :: TxOutDatum ctx -> HashableScriptData
txScriptValidity' :: TxScriptValidity -> ScriptValidity

-- | Data-types that can be marshalled into a generic <a>ScriptData</a>
--   structure.
type ToScriptData a = ToData a

-- | Data-types that can be unmarshalled from a generic <a>ScriptData</a>
--   structure.
type FromScriptData a = FromData a

-- | Convert a cardano-ledger <a>Value</a> into a cardano-api <a>Value</a>.
fromLedgerValue :: MaryValue -> Value

-- | Convert a cardano-api <a>Value</a> into a cardano-ledger <a>Value</a>.
toLedgerValue :: Value -> MaryValue

-- | Construct a Shelley-style address from a verification key. This
--   address has no stake rights.
--   
--   TODO: <a>NetworkId</a> here is an annoying API because it requires a
--   network magic for testnet addresses. Nevertheless, the network magic
--   is only needed for Byron addresses; Shelley addresses use a different
--   kind of network discriminant which is currently fully captured as
--   'Mainnet | Testnet'.
--   
--   So, it would be a slightly better DX to use Mainnet | Testnet as an
--   interface here since we are only constructing Shelley addresses.
mkVkAddress :: IsShelleyBasedEra era => NetworkId -> VerificationKey PaymentKey -> AddressInEra era

-- | Fully arbitrary block header with completely random hash.
genBlockHeader :: Gen BlockHeader

-- | Generate a random block header hash.
genBlockHeaderHash :: Gen (Hash BlockHeader)

-- | Get the chain point corresponding to a given <a>BlockHeader</a>.
getChainPoint :: BlockHeader -> ChainPoint

-- | Convert a cardano-api <a>ExecutionUnits</a> into a cardano-ledger
--   <tt>ExUnits</tt>
toLedgerExUnits :: ExecutionUnits -> ExUnits

-- | Convert a cardano-api <a>Hash</a> into a plutus <tt>PubKeyHash</tt>
toPlutusKeyHash :: Hash PaymentKey -> PubKeyHash

-- | Convert a cardano-ledger script <tt>Data</tt> into a cardano-api
--   <a>ScriptDatum</a>.
fromLedgerData :: Data era -> HashableScriptData

-- | Construct a <a>ReferenceScript</a> from any given Plutus script.
mkScriptRef :: IsPlutusScriptLanguage lang => PlutusScript lang -> ReferenceScript Era

-- | Serialise some type into a generic script data.
toScriptData :: ToScriptData a => a -> HashableScriptData

-- | Construct a <a>ScriptDatum</a> for use as transaction witness.
mkScriptDatum :: ToScriptData a => a -> ScriptDatum WitCtxTxIn

-- | Like <a>hashScript</a>, but for a <a>ScriptInAnyLang</a>.
hashScriptInAnyLang :: ScriptInAnyLang -> ScriptHash

-- | Construct a stake address from a Plutus script.
mkScriptStakeAddress :: forall lang. IsPlutusScriptLanguage lang => NetworkId -> PlutusScript lang -> StakeAddress

-- | Create a <a>TxIn</a> (a.k.a UTXO) from a transaction and output index.
mkTxIn :: Tx era -> Word -> TxIn

-- | Convert a cardano-api <a>TxIn</a> into a cardano-ledger <a>TxIn</a>
toLedgerTxIn :: TxIn -> TxIn

-- | Sign transaction using the provided secret key It only works for tx
--   not containing scripts. You can't sign a script utxo with this.
signTx :: IsShelleyBasedEra era => SigningKey PaymentKey -> Tx era -> Tx era

-- | Find and deserialise from <a>ScriptData</a>, a redeemer from the
--   transaction associated to the given input.
findRedeemerSpending :: FromData a => Tx Era -> TxIn -> Maybe a

-- | Inject some <a>Value</a> into a <a>TxOutValue</a>
mkTxOutValue :: forall era. IsMaryBasedEra era => Value -> TxOutValue era

-- | Convert a plutus <a>Address</a> to an api <a>AddressInEra</a>. NOTE:
--   Requires the <tt>Network</tt> discriminator (Testnet or Mainnet)
--   because Plutus addresses are stripped off it.
fromPlutusAddress :: IsShelleyBasedEra era => Network -> Address -> AddressInEra era

-- | Unsafe wrap some bytes as a 'Hash ScriptData', relying on the fact
--   that Plutus is using Blake2b_256 for hashing data (according to
--   'cardano-ledger').
--   
--   Pre-condition: the input bytestring MUST be of length 32.
unsafeScriptDataHashFromBytes :: HasCallStack => ByteString -> Hash ScriptData

-- | Convert a plutus <a>Value</a> into a cardano-api <a>Value</a>.
fromPlutusValue :: Value -> Maybe Value

-- | Calculate minimum ada as <a>Value</a> for a <a>TxOut</a>. NOTE: This
--   function can throw although you can't tell from the signature.
--   <a>toLedgerValue</a> can error out with _Illegal Value in TxOut_
minUTxOValue :: PParams LedgerEra -> TxOut CtxTx Era -> Value
txOuts' :: Tx era -> [TxOut CtxTx era]

-- | Construct a <a>TxOutDatum</a> as a <a>ScriptData</a> hash from some
--   serialisable data.
mkTxOutDatumHash :: forall era a ctx. (ToScriptData a, IsAlonzoBasedEra era) => a -> TxOutDatum ctx era

-- | Convert a cardano-api <a>TxId</a> into a cardano-ledger <a>TxId</a>.
toLedgerTxId :: TxId -> TxId

-- | Access inputs of a transaction, as an ordered list.
txIns' :: Tx era -> [TxIn]

-- | Construct a UTxO from a transaction. This constructs artificial
--   <a>TxIn</a> (a.k.a output reference) from the transaction itself,
--   zipping them to the outputs they correspond to.
utxoFromTx :: Tx Era -> UTxO Era
toLedgerValidityInterval :: (TxValidityLowerBound era, TxValidityUpperBound era) -> ValidityInterval

-- | Convert a plutus <a>CurrencySymbol</a> into a cardano-api
--   <a>PolicyId</a>.
fromPlutusCurrencySymbol :: MonadFail m => CurrencySymbol -> m PolicyId

-- | Construct a full script witness from a datum, a redeemer and a full
--   <a>Script</a>. That witness has no execution budget.
mkScriptWitness :: forall ctx era lang. (IsPlutusScriptLanguage lang, HasScriptLanguageInEra lang era) => PlutusScript lang -> ScriptDatum ctx -> ScriptRedeemer -> ScriptWitness ctx era
lookupRedeemer :: FromData a => PlutusPurpose AsIx LedgerEra -> TxBodyScriptData Era -> Maybe a

-- | Convert a cardano-api <a>Hash</a> into a cardano-ledger
--   <tt>KeyHash</tt>
toLedgerKeyHash :: Hash PaymentKey -> KeyHash 'Witness

-- | Unsafe wrap some bytes as a 'Hash PaymentKey'.
--   
--   Pre-condition: the input bytestring MUST be of length 28.
unsafePaymentKeyHashFromBytes :: HasCallStack => ByteString -> Hash PaymentKey
unsafeCastHash :: (SerialiseAsCBOR (Hash a), SerialiseAsCBOR (Hash b), HasCallStack) => Hash a -> Hash b

-- | Generate a random block header with completely random hash, but at a
--   certain slot.
genBlockHeaderAt :: SlotNo -> Gen BlockHeader

-- | Generate a chain point with a likely invalid block header hash.
genChainPoint :: Gen ChainPoint

-- | Generate a chain point at given slot with a likely invalid block
--   header hash.
genChainPointAt :: SlotNo -> Gen ChainPoint

-- | Construct a Shelley-style address from a Plutus script. This address
--   has no stake rights.
mkScriptAddress :: forall lang era. (IsShelleyBasedEra era, IsPlutusScriptLanguage lang) => NetworkId -> PlutusScript lang -> AddressInEra era

-- | From a ledger <tt>Addr</tt> to an api <a>AddressInEra</a>
fromLedgerAddr :: IsShelleyBasedEra era => Addr -> AddressInEra era

-- | From an api <a>AddressInEra</a> to a ledger <tt>Addr</tt>
toLedgerAddr :: AddressInEra era -> Addr

-- | A more random generator than the 'Arbitrary TxIn' from cardano-ledger.
--   NOTE: This is using the Cardano ledger's deserialization framework
--   using the latest protocol version via <a>maxBound</a>.
genTxIn :: Gen TxIn

-- | Deserialise some generic script data into some type.
fromScriptData :: FromScriptData a => HashableScriptData -> Maybe a

-- | Get the <a>HashableScriptData</a> associated to the a <a>TxOut</a>.
--   Note that this requires the <a>CtxTx</a> context.
txOutScriptData :: TxOut CtxTx era -> Maybe HashableScriptData

-- | Convert a cardano-api script data into a cardano-ledger script
--   <tt>Data</tt>. XXX: This is a partial function. Ideally it would fall
--   back to the <a>Data</a> portion in <a>HashableScriptData</a>.
toLedgerData :: Era era => HashableScriptData -> Data era

-- | Convert Cardano api <a>PolicyId</a> to Cardano ledger
--   <tt>PolicyID</tt>.
toLedgerPolicyID :: PolicyId -> PolicyID

-- | Convert Cardano api <a>PolicyId</a> to Plutus <a>CurrencySymbol</a>.
toPlutusCurrencySymbol :: PolicyId -> CurrencySymbol

-- | Attach some verification-key witness to a <a>TxIn</a>.
withWitness :: TxIn -> (TxIn, BuildTxWith BuildTx (Witness WitCtxTxIn Era))

-- | Access inputs of a transaction, as an ordered set.
txInputSet :: Tx era -> Set TxIn

-- | Convert a cardano-ledger <a>TxIn</a> into a cardano-api <a>TxIn</a>
fromLedgerTxIn :: TxIn -> TxIn

-- | Convert a plutus' <tt>TxOutRef</tt> into a cardano-api <a>TxIn</a>
fromPlutusTxOutRef :: TxOutRef -> TxIn

-- | Convert a cardano-api <a>TxIn</a> into a plutus <tt>TxOutRef</tt>.
toPlutusTxOutRef :: TxIn -> TxOutRef

-- | Create a transaction spending all given <a>UTxO</a>.
txSpendingUTxO :: UTxO Era -> Tx Era

-- | Convert a cardano-ledger's <a>Tx</a> in the Babbage era into a
--   cardano-api <a>Tx</a>.
fromLedgerTx :: IsShelleyBasedEra era => Tx (ShelleyLedgerEra era) -> Tx era

-- | Get the UTxO that are produced by some transaction. XXX: Defined here
--   to avoid cyclic module dependency
utxoProducedByTx :: Tx Era -> UTxO Era

-- | Convert a cardano-api <a>Tx</a> into a matching cardano-ledger
--   <a>Tx</a>.
toLedgerTx :: Tx era -> Tx (ShelleyLedgerEra era)

-- | Construct an inline <a>TxOutDatum</a> from some serialisable data.
mkTxOutDatumInline :: forall era a ctx. (ToScriptData a, IsBabbageBasedEra era) => a -> TxOutDatum ctx era

-- | Resolve tx inputs in a given UTxO
resolveInputsUTxO :: UTxO Era -> Tx Era -> UTxO Era
fromLedgerValidityInterval :: ValidityInterval -> (TxValidityLowerBound Era, TxValidityUpperBound Era)

-- | Count number of assets in a <a>Value</a>.
valueSize :: Value -> Int

-- | Convert a cardano-ledger <tt>MultiAsset</tt> into a cardano-api
--   <a>Value</a>. The cardano-api currently does not have an asset-only
--   type. So this conversion will construct a <a>Value</a> with no
--   <a>AdaAssetId</a> entry in it.
fromLedgerMultiAsset :: MultiAsset -> Value

-- | Modify a <a>TxOut</a> to set the minimum ada on the value.
setMinUTxOValue :: PParams LedgerEra -> TxOut CtxUTxO Era -> TxOut ctx Era

-- | Convert a cardano-ledger <a>TxOut</a> into a cardano-api <a>TxOut</a>
fromLedgerTxOut :: IsShelleyBasedEra era => TxOut (ShelleyLedgerEra era) -> TxOut ctx era

-- | Convert a cardano-api <a>TxOut</a> into a cardano-ledger <a>TxOut</a>
toLedgerTxOut :: IsShelleyBasedEra era => TxOut CtxUTxO era -> TxOut (ShelleyLedgerEra era)

-- | Automatically balance a given output with the minimum required amount.
--   Number of assets, presence of datum and/or reference scripts may
--   affect this minimum value.
mkTxOutAutoBalance :: PParams LedgerEra -> AddressInEra Era -> Value -> TxOutDatum CtxTx Era -> ReferenceScript Era -> TxOut CtxTx Era

-- | Alter the value of a <a>TxOut</a> with the given transformation.
modifyTxOutValue :: IsMaryBasedEra era => (Value -> Value) -> TxOut ctx era -> TxOut ctx era

-- | Alter the address of a <a>TxOut</a> with the given transformation.
modifyTxOutAddress :: (AddressInEra era -> AddressInEra era) -> TxOut ctx era -> TxOut ctx era

-- | Alter the datum of a <a>TxOut</a> with the given transformation.
modifyTxOutDatum :: (TxOutDatum ctx0 era -> TxOutDatum ctx1 era) -> TxOut ctx0 era -> TxOut ctx1 era

-- | Find first <a>TxOut</a> which pays to given address and also return
--   the corresponding <a>TxIn</a> to reference it.
findTxOutByAddress :: AddressInEra era -> Tx era -> Maybe (TxIn, TxOut CtxTx era)

-- | Find a single script output in some <a>UTxO</a>
findTxOutByScript :: forall lang. IsPlutusScriptLanguage lang => UTxO Era -> PlutusScript lang -> Maybe (TxIn, TxOut CtxUTxO Era)

-- | Predicate to find or filter <a>TxOut</a> owned by a key. This is
--   better than comparing the full address as it does not require a
--   network discriminator.
isVkTxOut :: forall ctx era. VerificationKey PaymentKey -> TxOut ctx era -> Bool

-- | Predicate to find or filter <a>TxOut</a> which are governed by some
--   script. This is better than comparing the full address as it does not
--   require a network discriminator.
isScriptTxOut :: forall lang ctx era. IsPlutusScriptLanguage lang => PlutusScript lang -> TxOut ctx era -> Bool

-- | Convert a plutus <a>TxOut</a> into a cardano-api <a>TxOut</a>. NOTE:
--   Reference scripts are not resolvable right now. NOTE: Requires the
--   <tt>Network</tt> discriminator (Testnet or Mainnet) because Plutus
--   addresses are stripped off it.
fromPlutusTxOut :: forall era. IsBabbageBasedEra era => Network -> TxOut -> Maybe (TxOut CtxUTxO era)

-- | Convert a cardano-api <a>TxOut</a> into a plutus <a>TxOut</a>. Returns
--   <a>Nothing</a> if a byron address is used in the given <a>TxOut</a>.
toPlutusTxOut :: HasCallStack => TxOut CtxUTxO Era -> Maybe TxOut

-- | Construct a reference script witness, only referring to a <a>TxIn</a>
--   which is expected to contain the given script (only required to
--   satisfy types).
mkScriptReference :: forall ctx era lang. (IsPlutusScriptLanguage lang, HasScriptLanguageInEra lang era) => TxIn -> PlutusScript lang -> ScriptDatum ctx -> ScriptRedeemer -> ScriptWitness ctx era

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data () => Proxy (t :: k)
Proxy :: Proxy (t :: k)
class () => Pretty a
pretty :: Pretty a => a -> Doc ann
prettyList :: Pretty a => [a] -> Doc ann
class (Eq VerificationKey keyrole, Show VerificationKey keyrole, SerialiseAsRawBytes Hash keyrole, HasTextEnvelope VerificationKey keyrole, HasTextEnvelope SigningKey keyrole) => Key keyrole where {
    data family VerificationKey keyrole;
    data family SigningKey keyrole;
}
getVerificationKey :: Key keyrole => SigningKey keyrole -> VerificationKey keyrole
deterministicSigningKey :: Key keyrole => AsType keyrole -> Seed -> SigningKey keyrole
deterministicSigningKeySeedSize :: Key keyrole => AsType keyrole -> Word
verificationKeyHash :: Key keyrole => VerificationKey keyrole -> Hash keyrole
data () => Block era
[ByronBlock] :: ByronBlock -> Block ByronEra
[ShelleyBlock] :: forall era. ShelleyBasedEra era -> ShelleyBlock (ConsensusProtocol era) (ShelleyLedgerEra era) -> Block era

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   • Couldn't match type ‘IO’ with ‘StateT s IO’
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a
newtype () => File content (direction :: FileDirection)
File :: FilePath -> File content (direction :: FileDirection)
[unFile] :: File content (direction :: FileDirection) -> FilePath

-- | A monad transformer that adds exceptions to other monads.
--   
--   <tt>ExceptT</tt> constructs a monad parameterized over two things:
--   
--   <ul>
--   <li>e - The exception type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a computation that produces the
--   given value, while <tt>&gt;&gt;=</tt> sequences two subcomputations,
--   exiting on the first exception.
newtype () => ExceptT e (m :: Type -> Type) a
ExceptT :: m (Either e a) -> ExceptT e (m :: Type -> Type) a

-- | The parameterizable exception monad.
--   
--   Computations are either exceptions or normal values.
--   
--   The <a>return</a> function returns a normal value, while
--   <tt>&gt;&gt;=</tt> exits on the first exception. For a variant that
--   continues after an error and collects all the errors, see
--   <a>Errors</a>.
type Except e = ExceptT e Identity

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <tt>Error</tt> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | A handler function to handle previous errors and return to normal
--   execution. A common idiom is:
--   
--   <pre>
--   do { action1; action2; action3 } `catchError` handler
--   </pre>
--   
--   where the <tt>action</tt> functions can call <a>throwError</a>. Note
--   that <tt>handler</tt> and the do-block must have the same return type.
catchError :: MonadError e m => m a -> (e -> m a) -> m a

-- | The class of monad transformers. For any monad <tt>m</tt>, the result
--   <tt>t m</tt> should also be a monad, and <a>lift</a> should be a monad
--   transformation from <tt>m</tt> to <tt>t m</tt>, i.e. it should satisfy
--   the following laws:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
--   
--   Since 0.6.0.0 and for GHC 8.6 and later, the requirement that <tt>t
--   m</tt> be a <a>Monad</a> is enforced by the implication constraint
--   <tt>forall m. <a>Monad</a> m =&gt; <a>Monad</a> (t m)</tt> enabled by
--   the <tt>QuantifiedConstraints</tt> extension.
--   
--   <h3><b>Ambiguity error with GHC 9.0 to 9.2.2</b></h3>
--   
--   These versions of GHC have a bug
--   (<a>https://gitlab.haskell.org/ghc/ghc/-/issues/20582</a>) which
--   causes constraints like
--   
--   <pre>
--   (MonadTrans t, forall m. Monad m =&gt; Monad (t m)) =&gt; ...
--   </pre>
--   
--   to be reported as ambiguous. For transformers 0.6 and later, this can
--   be fixed by removing the second constraint, which is implied by the
--   first.
class forall (m :: Type -> Type). Monad m => Monad t m => MonadTrans (t :: Type -> Type -> Type -> Type)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a
class () => Error e
prettyError :: Error e => e -> Doc ann
data () => Doc ann
data family Body cip
newtype () => LedgerProtocolParameters era
LedgerProtocolParameters :: PParams (ShelleyLedgerEra era) -> LedgerProtocolParameters era
[unLedgerProtocolParameters] :: LedgerProtocolParameters era -> PParams (ShelleyLedgerEra era)
data () => PParams era
data () => Address addrtype
[ByronAddress] :: Address -> Address ByronAddr
[ShelleyAddress] :: Network -> PaymentCredential -> StakeReference -> Address ShelleyAddr
data () => BlockHeader
BlockHeader :: !SlotNo -> !Hash BlockHeader -> !BlockNo -> BlockHeader
data () => ChainPoint
ChainPointAtGenesis :: ChainPoint
ChainPoint :: !SlotNo -> !Hash BlockHeader -> ChainPoint
data () => ExecutionUnits
ExecutionUnits :: Natural -> Natural -> ExecutionUnits
[executionSteps] :: ExecutionUnits -> Natural
[executionMemory] :: ExecutionUnits -> Natural
data family Hash keyrole
data () => NetworkId
Mainnet :: NetworkId
Testnet :: !NetworkMagic -> NetworkId
newtype () => NetworkMagic
NetworkMagic :: Word32 -> NetworkMagic
[unNetworkMagic] :: NetworkMagic -> Word32
newtype () => PolicyAssets
PolicyAssets :: Map AssetName Quantity -> PolicyAssets
newtype () => PolicyId
PolicyId :: ScriptHash -> PolicyId
[unPolicyId] :: PolicyId -> ScriptHash
data () => ScriptData
ScriptDataConstructor :: Integer -> [ScriptData] -> ScriptData
ScriptDataMap :: [(ScriptData, ScriptData)] -> ScriptData
ScriptDataList :: [ScriptData] -> ScriptData
ScriptDataNumber :: Integer -> ScriptData
ScriptDataBytes :: ByteString -> ScriptData
data () => ScriptDatum witctx
[ScriptDatumForTxIn] :: Maybe HashableScriptData -> ScriptDatum WitCtxTxIn
[InlineScriptDatum] :: ScriptDatum WitCtxTxIn
[NoScriptDatumForMint] :: ScriptDatum WitCtxMint
[NoScriptDatumForStake] :: ScriptDatum WitCtxStake
newtype () => ScriptHash
ScriptHash :: ScriptHash -> ScriptHash
data () => StakeAddress
[StakeAddress] :: Network -> StakeCredential -> StakeAddress
newtype () => TxId
TxId :: Hash HASH EraIndependentTxBody -> TxId
data () => TxIn
TxIn :: TxId -> TxIx -> TxIn
data () => TxOutValue era
[TxOutValueByron] :: Coin -> TxOutValue ByronEra
[TxOutValueShelleyBased] :: forall era. (Eq (Value (ShelleyLedgerEra era)), Show (Value (ShelleyLedgerEra era))) => ShelleyBasedEra era -> Value (ShelleyLedgerEra era) -> TxOutValue era
data () => Value
data () => Network
data () => ByronAddr
class () => FromJSON a
parseJSON :: FromJSON a => Value -> Parser a
parseJSONList :: FromJSON a => Value -> Parser [a]
omittedField :: FromJSON a => Maybe a
class () => ToJSON a
toJSON :: ToJSON a => a -> Value
toEncoding :: ToJSON a => a -> Encoding
toJSONList :: ToJSON a => [a] -> Value
toEncodingList :: ToJSON a => [a] -> Encoding
omitField :: ToJSON a => a -> Bool
class Typeable a => ToCBOR a
toCBOR :: ToCBOR a => a -> Encoding
encodedSizeExpr :: ToCBOR a => (forall t. ToCBOR t => Proxy t -> Size) -> Proxy a -> Size
encodedListSizeExpr :: ToCBOR a => (forall t. ToCBOR t => Proxy t -> Size) -> Proxy [a] -> Size
data () => AddressAny
AddressByron :: !Address ByronAddr -> AddressAny
AddressShelley :: !Address ShelleyAddr -> AddressAny
data () => PaymentCredential
PaymentCredentialByKey :: Hash PaymentKey -> PaymentCredential
PaymentCredentialByScript :: ScriptHash -> PaymentCredential
class HasTypeProxy addr => SerialiseAddress addr
serialiseAddress :: SerialiseAddress addr => addr -> Text
deserialiseAddress :: SerialiseAddress addr => AsType addr -> Text -> Maybe addr
data () => ShelleyAddr
newtype () => StakeAddressPointer
StakeAddressPointer :: Ptr -> StakeAddressPointer
[unStakeAddressPointer] :: StakeAddressPointer -> Ptr
data () => StakeAddressReference
StakeAddressByValue :: StakeCredential -> StakeAddressReference
StakeAddressByPointer :: StakeAddressPointer -> StakeAddressReference
NoStakeAddress :: StakeAddressReference
data () => StakeCredential
StakeCredentialByKey :: Hash StakeKey -> StakeCredential
StakeCredentialByScript :: ScriptHash -> StakeCredential
data () => BlockInMode
[BlockInMode] :: forall era. CardanoEra era -> Block era -> BlockInMode
data () => ByronBlock
data () => ChainTip
ChainTipAtGenesis :: ChainTip
ChainTip :: !SlotNo -> !Hash BlockHeader -> !BlockNo -> ChainTip
data () => AnchorDataFromCertificateError
InvalidPoolMetadataHashError :: Url -> ByteString -> AnchorDataFromCertificateError
data () => Certificate era
[ShelleyRelatedCertificate] :: forall era. Typeable era => ShelleyToBabbageEra era -> ShelleyTxCert (ShelleyLedgerEra era) -> Certificate era
[ConwayCertificate] :: forall era. Typeable era => ConwayEraOnwards era -> ConwayTxCert (ShelleyLedgerEra era) -> Certificate era
data () => CommitteeColdkeyResignationRequirements era
[CommitteeColdkeyResignationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'ColdCommitteeRole -> Maybe Anchor -> CommitteeColdkeyResignationRequirements era
data () => CommitteeHotKeyAuthorizationRequirements era
[CommitteeHotKeyAuthorizationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'ColdCommitteeRole -> Credential 'HotCommitteeRole -> CommitteeHotKeyAuthorizationRequirements era
data () => DRepMetadataReference
DRepMetadataReference :: Text -> Hash DRepMetadata -> DRepMetadataReference
[drepMetadataURL] :: DRepMetadataReference -> Text
[drepMetadataHash] :: DRepMetadataReference -> Hash DRepMetadata
data () => DRepRegistrationRequirements era
[DRepRegistrationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'DRepRole -> Coin -> DRepRegistrationRequirements era
data () => DRepUnregistrationRequirements era
[DRepUnregistrationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'DRepRole -> Coin -> DRepUnregistrationRequirements era
data () => DRepUpdateRequirements era
[DRepUpdateRequirements] :: forall era. ConwayEraOnwards era -> Credential 'DRepRole -> DRepUpdateRequirements era
data () => GenesisKeyDelegationRequirements era
[GenesisKeyDelegationRequirements] :: forall era. ShelleyToBabbageEra era -> Hash GenesisKey -> Hash GenesisDelegateKey -> Hash VrfKey -> GenesisKeyDelegationRequirements era
data () => MirCertificateRequirements era
[MirCertificateRequirements] :: forall era. ShelleyToBabbageEra era -> MIRPot -> MIRTarget -> MirCertificateRequirements era
type PoolId = Hash StakePoolKey
data () => StakeAddressRequirements era
[StakeAddrRegistrationConway] :: forall era. ConwayEraOnwards era -> Coin -> StakeCredential -> StakeAddressRequirements era
[StakeAddrRegistrationPreConway] :: forall era. ShelleyToBabbageEra era -> StakeCredential -> StakeAddressRequirements era
data () => StakeDelegationRequirements era
[StakeDelegationRequirementsConwayOnwards] :: forall era. ConwayEraOnwards era -> StakeCredential -> Delegatee -> StakeDelegationRequirements era
[StakeDelegationRequirementsPreConway] :: forall era. ShelleyToBabbageEra era -> StakeCredential -> PoolId -> StakeDelegationRequirements era
data () => StakePoolMetadataReference
StakePoolMetadataReference :: Text -> Hash StakePoolMetadata -> StakePoolMetadataReference
[stakePoolMetadataURL] :: StakePoolMetadataReference -> Text
[stakePoolMetadataHash] :: StakePoolMetadataReference -> Hash StakePoolMetadata
data () => StakePoolParameters
StakePoolParameters :: PoolId -> Hash VrfKey -> Coin -> Rational -> StakeAddress -> Coin -> [Hash StakeKey] -> [StakePoolRelay] -> Maybe StakePoolMetadataReference -> StakePoolParameters
[stakePoolId] :: StakePoolParameters -> PoolId
[stakePoolVRF] :: StakePoolParameters -> Hash VrfKey
[stakePoolCost] :: StakePoolParameters -> Coin
[stakePoolMargin] :: StakePoolParameters -> Rational
[stakePoolRewardAccount] :: StakePoolParameters -> StakeAddress
[stakePoolPledge] :: StakePoolParameters -> Coin
[stakePoolOwners] :: StakePoolParameters -> [Hash StakeKey]
[stakePoolRelays] :: StakePoolParameters -> [StakePoolRelay]
[stakePoolMetadata] :: StakePoolParameters -> Maybe StakePoolMetadataReference
data () => StakePoolRegistrationRequirements era
[StakePoolRegistrationRequirementsConwayOnwards] :: forall era. ConwayEraOnwards era -> PoolParams -> StakePoolRegistrationRequirements era
[StakePoolRegistrationRequirementsPreConway] :: forall era. ShelleyToBabbageEra era -> PoolParams -> StakePoolRegistrationRequirements era
data () => StakePoolRelay
StakePoolRelayIp :: Maybe IPv4 -> Maybe IPv6 -> Maybe PortNumber -> StakePoolRelay
StakePoolRelayDnsARecord :: ByteString -> Maybe PortNumber -> StakePoolRelay
StakePoolRelayDnsSrvRecord :: ByteString -> StakePoolRelay
data () => StakePoolRetirementRequirements era
[StakePoolRetirementRequirementsConwayOnwards] :: forall era. ConwayEraOnwards era -> PoolId -> EpochNo -> StakePoolRetirementRequirements era
[StakePoolRetirementRequirementsPreConway] :: forall era. ShelleyToBabbageEra era -> PoolId -> EpochNo -> StakePoolRetirementRequirements era
newtype () => DRepMetadata
DRepMetadata :: ByteString -> DRepMetadata
[unDRepMetadata] :: DRepMetadata -> ByteString
data () => OperationalCertIssueError
OperationalCertKeyMismatch :: VerificationKey StakePoolKey -> VerificationKey StakePoolKey -> OperationalCertIssueError
data () => OperationalCertificate
OperationalCertificate :: !OCert StandardCrypto -> !VerificationKey StakePoolKey -> OperationalCertificate
data () => OperationalCertificateIssueCounter
OperationalCertificateIssueCounter :: !Word64 -> !VerificationKey StakePoolKey -> OperationalCertificateIssueCounter
[opCertIssueCount] :: OperationalCertificateIssueCounter -> !Word64
[opCertIssueColdKey] :: OperationalCertificateIssueCounter -> !VerificationKey StakePoolKey
data () => StakePoolMetadata
StakePoolMetadata :: !Text -> !Text -> !Text -> !Text -> StakePoolMetadata
[stakePoolName] :: StakePoolMetadata -> !Text
[stakePoolDescription] :: StakePoolMetadata -> !Text
[stakePoolTicker] :: StakePoolMetadata -> !Text
[stakePoolHomepage] :: StakePoolMetadata -> !Text
data () => StakePoolMetadataValidationError
StakePoolMetadataJsonDecodeError :: !String -> StakePoolMetadataValidationError
StakePoolMetadataInvalidLengthError :: !Int -> !Int -> StakePoolMetadataValidationError
data () => TxIdInMode
[TxIdInMode] :: forall era. CardanoEra era -> TxId -> TxIdInMode
data () => TxInMode
[TxInMode] :: forall era. ShelleyBasedEra era -> Tx era -> TxInMode
[TxInByronSpecial] :: GenTx ByronBlock -> TxInMode
data () => TxValidationError era
[ByronTxValidationError] :: forall era. ApplyTxErr ByronBlock -> TxValidationError era
[ShelleyTxValidationError] :: forall era. ShelleyBasedEra era -> ApplyTxErr (ShelleyBlock (ConsensusProtocol era) (ShelleyLedgerEra era)) -> TxValidationError era
data () => TxValidationErrorInCardanoMode
[TxValidationErrorInCardanoMode] :: forall era. TxValidationError era -> TxValidationErrorInCardanoMode
[TxValidationEraMismatch] :: EraMismatch -> TxValidationErrorInCardanoMode
type family ChainDepStateProtocol era
type family ConsensusBlockForEra era
type family ConsensusCryptoForBlock block
data () => ConsensusModeParams
[CardanoModeParams] :: EpochSlots -> ConsensusModeParams
type family ConsensusProtocol era
data () => BlockType blk
[ByronBlockType] :: BlockType (HardForkBlock '[ByronBlock])
[ShelleyBlockType] :: BlockType (HardForkBlock '[ShelleyBlock (TPraos StandardCrypto) ShelleyEra])
[CardanoBlockType] :: BlockType (HardForkBlock (CardanoEras StandardCrypto))
class (RunNode blk, IOLike m) => Protocol (m :: Type -> Type) blk where {
    data family ProtocolInfoArgs blk;
}
protocolInfo :: Protocol m blk => ProtocolInfoArgs blk -> (ProtocolInfo blk, m [BlockForging m blk])
class RunNode blk => ProtocolClient blk where {
    data family ProtocolClientInfoArgs blk;
}
protocolClientInfo :: ProtocolClient blk => ProtocolClientInfoArgs blk -> ProtocolClientInfo blk
data family ProtocolClientInfoArgs blk
data family ProtocolInfoArgs blk
data () => SomeBlockType
[SomeBlockType] :: forall blk. BlockType blk -> SomeBlockType
data () => AllegraEra
data () => AlonzoEra
data () => AnyCardanoEra
[AnyCardanoEra] :: forall era. Typeable era => CardanoEra era -> AnyCardanoEra
data () => BabbageEra
data () => ByronEra
data () => CardanoEra era
[ByronEra] :: CardanoEra ByronEra
[ShelleyEra] :: CardanoEra ShelleyEra
[AllegraEra] :: CardanoEra AllegraEra
[MaryEra] :: CardanoEra MaryEra
[AlonzoEra] :: CardanoEra AlonzoEra
[BabbageEra] :: CardanoEra BabbageEra
[ConwayEra] :: CardanoEra ConwayEra
type family CardanoLedgerEra era = (ledgerera :: Type) | ledgerera -> era
data () => ConwayEra
class () => Eon (eon :: Type -> Type)
inEonForEra :: Eon eon => a -> (eon era -> a) -> CardanoEra era -> a
data () => EraInEon (eon :: Type -> Type)
[EraInEon] :: forall era (eon :: Type -> Type). (Typeable era, Typeable (eon era), Eon eon) => eon era -> EraInEon eon
data () => InAnyCardanoEra (thing :: Type -> Type)
[InAnyCardanoEra] :: forall era (thing :: Type -> Type). Typeable era => CardanoEra era -> thing era -> InAnyCardanoEra thing
class HasTypeProxy era => IsCardanoEra era
cardanoEra :: IsCardanoEra era => CardanoEra era
data () => MaryEra
data () => ShelleyEra
class () => ToCardanoEra (eon :: Type -> Type)
toCardanoEra :: ToCardanoEra eon => eon era -> CardanoEra era
data () => AllegraEraOnwards era
[AllegraEraOnwardsAllegra] :: AllegraEraOnwards AllegraEra
[AllegraEraOnwardsMary] :: AllegraEraOnwards MaryEra
[AllegraEraOnwardsAlonzo] :: AllegraEraOnwards AlonzoEra
[AllegraEraOnwardsBabbage] :: AllegraEraOnwards BabbageEra
[AllegraEraOnwardsConway] :: AllegraEraOnwards ConwayEra
type AllegraEraOnwardsConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, AllegraEraTxBody ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
class IsShelleyBasedEra era => IsAllegraBasedEra era
allegraBasedEra :: IsAllegraBasedEra era => AllegraEraOnwards era
data () => AlonzoEraOnwards era
[AlonzoEraOnwardsAlonzo] :: AlonzoEraOnwards AlonzoEra
[AlonzoEraOnwardsBabbage] :: AlonzoEraOnwards BabbageEra
[AlonzoEraOnwardsConway] :: AlonzoEraOnwards ConwayEra
type AlonzoEraOnwardsConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, AlonzoEraPParams ShelleyLedgerEra era, AlonzoEraTx ShelleyLedgerEra era, AlonzoEraTxBody ShelleyLedgerEra era, AlonzoEraTxOut ShelleyLedgerEra era, AlonzoEraTxWits ShelleyLedgerEra era, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, EraUTxO ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, MaryEraTxBody ShelleyLedgerEra era, NativeScript ShelleyLedgerEra era ~ Timelock ShelleyLedgerEra era, EraPlutusContext ShelleyLedgerEra era, Script ShelleyLedgerEra era ~ AlonzoScript ShelleyLedgerEra era, ScriptsNeeded ShelleyLedgerEra era ~ AlonzoScriptsNeeded ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, Value ShelleyLedgerEra era ~ MaryValue, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
class IsMaryBasedEra era => IsAlonzoBasedEra era
alonzoBasedEra :: IsAlonzoBasedEra era => AlonzoEraOnwards era
data () => BabbageEraOnwards era
[BabbageEraOnwardsBabbage] :: BabbageEraOnwards BabbageEra
[BabbageEraOnwardsConway] :: BabbageEraOnwards ConwayEra
type BabbageEraOnwardsConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, AlonzoEraTxOut ShelleyLedgerEra era, BabbageEraPParams ShelleyLedgerEra era, BabbageEraTxBody ShelleyLedgerEra era, BabbageEraTxOut ShelleyLedgerEra era, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, EraUTxO ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, MaryEraTxBody ShelleyLedgerEra era, Script ShelleyLedgerEra era ~ AlonzoScript ShelleyLedgerEra era, ScriptsNeeded ShelleyLedgerEra era ~ AlonzoScriptsNeeded ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, TxOut ShelleyLedgerEra era ~ BabbageTxOut ShelleyLedgerEra era, Value ShelleyLedgerEra era ~ MaryValue, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
class IsAlonzoBasedEra era => IsBabbageBasedEra era
babbageBasedEra :: IsBabbageBasedEra era => BabbageEraOnwards era
data () => ByronToAlonzoEra era
[ByronToAlonzoEraByron] :: ByronToAlonzoEra ByronEra
[ByronToAlonzoEraShelley] :: ByronToAlonzoEra ShelleyEra
[ByronToAlonzoEraAllegra] :: ByronToAlonzoEra AllegraEra
[ByronToAlonzoEraMary] :: ByronToAlonzoEra MaryEra
[ByronToAlonzoEraAlonzo] :: ByronToAlonzoEra AlonzoEra
type ByronToAlonzoEraConstraints era = (IsCardanoEra era, Typeable era)
class () => Convert (f :: a -> Type) (g :: a -> Type)
convert :: forall (era :: a). Convert f g => f era -> g era
data () => ConwayEraOnwards era
[ConwayEraOnwardsConway] :: ConwayEraOnwards ConwayEra
type ConwayEraOnwardsConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, AlonzoEraTxOut ShelleyLedgerEra era, AlonzoEraTxWits ShelleyLedgerEra era, BabbageEraTxBody ShelleyLedgerEra era, ConwayEraGov ShelleyLedgerEra era, ConwayEraPParams ShelleyLedgerEra era, ConwayEraTxBody ShelleyLedgerEra era, ConwayEraTxCert ShelleyLedgerEra era, Era ShelleyLedgerEra era, EraGov ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, EraUTxO ShelleyLedgerEra era, GovState ShelleyLedgerEra era ~ ConwayGovState ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, MaryEraTxBody ShelleyLedgerEra era, Script ShelleyLedgerEra era ~ AlonzoScript ShelleyLedgerEra era, ScriptsNeeded ShelleyLedgerEra era ~ AlonzoScriptsNeeded ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, TxCert ShelleyLedgerEra era ~ ConwayTxCert ShelleyLedgerEra era, Value ShelleyLedgerEra era ~ MaryValue, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
class IsBabbageBasedEra era => IsConwayBasedEra era
conwayBasedEra :: IsConwayBasedEra era => ConwayEraOnwards era
class IsAllegraBasedEra era => IsMaryBasedEra era
maryBasedEra :: IsMaryBasedEra era => MaryEraOnwards era
data () => MaryEraOnwards era
[MaryEraOnwardsMary] :: MaryEraOnwards MaryEra
[MaryEraOnwardsAlonzo] :: MaryEraOnwards AlonzoEra
[MaryEraOnwardsBabbage] :: MaryEraOnwards BabbageEra
[MaryEraOnwardsConway] :: MaryEraOnwards ConwayEra
type MaryEraOnwardsConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, EraUTxO ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, MaryEraTxBody ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, Value ShelleyLedgerEra era ~ MaryValue, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
data () => AnyShelleyBasedEra
[AnyShelleyBasedEra] :: forall era. Typeable era => ShelleyBasedEra era -> AnyShelleyBasedEra
data () => InAnyShelleyBasedEra (thing :: Type -> Type)
[InAnyShelleyBasedEra] :: forall era (thing :: Type -> Type). Typeable era => ShelleyBasedEra era -> thing era -> InAnyShelleyBasedEra thing
class IsCardanoEra era => IsShelleyBasedEra era
shelleyBasedEra :: IsShelleyBasedEra era => ShelleyBasedEra era
data () => ShelleyBasedEra era
[ShelleyBasedEraShelley] :: ShelleyBasedEra ShelleyEra
[ShelleyBasedEraAllegra] :: ShelleyBasedEra AllegraEra
[ShelleyBasedEraMary] :: ShelleyBasedEra MaryEra
[ShelleyBasedEraAlonzo] :: ShelleyBasedEra AlonzoEra
[ShelleyBasedEraBabbage] :: ShelleyBasedEra BabbageEra
[ShelleyBasedEraConway] :: ShelleyBasedEra ConwayEra
type ShelleyBasedEraConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, FromCBOR ChainDepState ConsensusProtocol era, IsCardanoEra era, IsShelleyBasedEra era, ADDRHASH ~ Blake2b_224, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, EraUTxO ShelleyLedgerEra era, EraTxWits ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, ShelleyEraTxCert ShelleyLedgerEra era, FromCBOR ChainDepState ConsensusProtocol era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON PredicateFailure EraRule "LEDGER" ShelleyLedgerEra era, Typeable era, era == ByronEra ~ 'False)
type family ShelleyLedgerEra era = (ledgerera :: Type) | ledgerera -> era
data () => ShelleyEraOnly era
[ShelleyEraOnlyShelley] :: ShelleyEraOnly ShelleyEra
type ShelleyEraOnlyConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, ExactEra ShelleyEra ShelleyLedgerEra era, ExactEra ShelleyEra ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, ProtVerAtMost ShelleyLedgerEra era 2, ProtVerAtMost ShelleyLedgerEra era 6, ProtVerAtMost ShelleyLedgerEra era 8, ShelleyEraTxBody ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, TxCert ShelleyLedgerEra era ~ ShelleyTxCert ShelleyLedgerEra era, Value ShelleyLedgerEra era ~ Coin, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
data () => ShelleyToAllegraEra era
[ShelleyToAllegraEraShelley] :: ShelleyToAllegraEra ShelleyEra
[ShelleyToAllegraEraAllegra] :: ShelleyToAllegraEra AllegraEra
type ShelleyToAllegraEraConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, EraUTxO ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, ProtVerAtMost ShelleyLedgerEra era 4, ProtVerAtMost ShelleyLedgerEra era 6, ProtVerAtMost ShelleyLedgerEra era 8, ShelleyEraTxBody ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, TxCert ShelleyLedgerEra era ~ ShelleyTxCert ShelleyLedgerEra era, Value ShelleyLedgerEra era ~ Coin, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
data () => ShelleyToAlonzoEra era
[ShelleyToAlonzoEraShelley] :: ShelleyToAlonzoEra ShelleyEra
[ShelleyToAlonzoEraAllegra] :: ShelleyToAlonzoEra AllegraEra
[ShelleyToAlonzoEraMary] :: ShelleyToAlonzoEra MaryEra
[ShelleyToAlonzoEraAlonzo] :: ShelleyToAlonzoEra AlonzoEra
type ShelleyToAlonzoEraConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, ProtVerAtMost ShelleyLedgerEra era 6, ProtVerAtMost ShelleyLedgerEra era 8, ShelleyEraTxBody ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, TxCert ShelleyLedgerEra era ~ ShelleyTxCert ShelleyLedgerEra era, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
data () => ShelleyToBabbageEra era
[ShelleyToBabbageEraShelley] :: ShelleyToBabbageEra ShelleyEra
[ShelleyToBabbageEraAllegra] :: ShelleyToBabbageEra AllegraEra
[ShelleyToBabbageEraMary] :: ShelleyToBabbageEra MaryEra
[ShelleyToBabbageEraAlonzo] :: ShelleyToBabbageEra AlonzoEra
[ShelleyToBabbageEraBabbage] :: ShelleyToBabbageEra BabbageEra
type ShelleyToBabbageEraConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, ProtVerAtMost ShelleyLedgerEra era 8, ShelleyEraTxBody ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, TxCert ShelleyLedgerEra era ~ ShelleyTxCert ShelleyLedgerEra era, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
data () => ShelleyToMaryEra era
[ShelleyToMaryEraShelley] :: ShelleyToMaryEra ShelleyEra
[ShelleyToMaryEraAllegra] :: ShelleyToMaryEra AllegraEra
[ShelleyToMaryEraMary] :: ShelleyToMaryEra MaryEra
type ShelleyToMaryEraConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, ProtVerAtMost ShelleyLedgerEra era 4, ProtVerAtMost ShelleyLedgerEra era 6, ProtVerAtMost ShelleyLedgerEra era 8, ShelleyEraTxBody ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, TxCert ShelleyLedgerEra era ~ ShelleyTxCert ShelleyLedgerEra era, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
data () => Featured (eon :: Type -> Type) era a
[Featured] :: forall (eon :: Type -> Type) era a. eon era -> a -> Featured eon era a
data () => ErrorAsException
[ErrorAsException] :: forall e. Error e => e -> ErrorAsException
data () => FileError e
FileError :: FilePath -> e -> FileError e
FileErrorTempFile :: FilePath -> FilePath -> Handle -> FileError e
FileDoesNotExistError :: FilePath -> FileError e
FileIOError :: FilePath -> IOException -> FileError e
type AlonzoGenesisConfig = AlonzoGenesis
type AlonzoGenesisFile = File AlonzoGenesisConfig
type ByronGenesisConfig = Config
type ByronGenesisFile = File ByronGenesisConfig
type ConwayGenesisConfig = ConwayGenesis
type ConwayGenesisFile = File ConwayGenesisConfig
newtype () => GenesisHashAlonzo
GenesisHashAlonzo :: Hash Blake2b_256 ByteString -> GenesisHashAlonzo
[unGenesisHashAlonzo] :: GenesisHashAlonzo -> Hash Blake2b_256 ByteString
newtype () => GenesisHashByron
GenesisHashByron :: Text -> GenesisHashByron
[unGenesisHashByron] :: GenesisHashByron -> Text
newtype () => GenesisHashConway
GenesisHashConway :: Hash Blake2b_256 ByteString -> GenesisHashConway
[unGenesisHashConway] :: GenesisHashConway -> Hash Blake2b_256 ByteString
newtype () => GenesisHashShelley
GenesisHashShelley :: Hash Blake2b_256 ByteString -> GenesisHashShelley
[unGenesisHashShelley] :: GenesisHashShelley -> Hash Blake2b_256 ByteString
data () => ShelleyConfig
ShelleyConfig :: !ShelleyGenesis -> !GenesisHashShelley -> ShelleyConfig
[scConfig] :: ShelleyConfig -> !ShelleyGenesis
[scGenesisHash] :: ShelleyConfig -> !GenesisHashShelley
type ShelleyGenesisConfig = ShelleyConfig
type ShelleyGenesisFile = File ShelleyGenesisConfig
data () => GenesisParameters era
GenesisParameters :: UTCTime -> NetworkId -> Rational -> NonZero Word64 -> EpochSize -> NominalDiffTime -> Int -> Int -> Int -> Coin -> PParams (ShelleyLedgerEra era) -> GenesisParameters era
[protocolParamSystemStart] :: GenesisParameters era -> UTCTime
[protocolParamNetworkId] :: GenesisParameters era -> NetworkId
[protocolParamActiveSlotsCoefficient] :: GenesisParameters era -> Rational
[protocolParamSecurity] :: GenesisParameters era -> NonZero Word64
[protocolParamEpochLength] :: GenesisParameters era -> EpochSize
[protocolParamSlotLength] :: GenesisParameters era -> NominalDiffTime
[protocolParamSlotsPerKESPeriod] :: GenesisParameters era -> Int
[protocolParamMaxKESEvolutions] :: GenesisParameters era -> Int
[protocolParamUpdateQuorum] :: GenesisParameters era -> Int
[protocolParamMaxLovelaceSupply] :: GenesisParameters era -> Coin
[protocolInitialUpdateableProtocolParameters] :: GenesisParameters era -> PParams (ShelleyLedgerEra era)
data () => AnyGovernanceAction
AnyGovernanceAction :: GovAction era -> AnyGovernanceAction
data () => GovernanceAction era
MotionOfNoConfidence :: StrictMaybe (GovPurposeId 'CommitteePurpose (ShelleyLedgerEra era)) -> GovernanceAction era
ProposeNewConstitution :: StrictMaybe (GovPurposeId 'ConstitutionPurpose (ShelleyLedgerEra era)) -> Anchor -> StrictMaybe ScriptHash -> GovernanceAction era
ProposeNewCommittee :: StrictMaybe (GovPurposeId 'CommitteePurpose (ShelleyLedgerEra era)) -> [Credential 'ColdCommitteeRole] -> Map (Credential 'ColdCommitteeRole) EpochNo -> Rational -> GovernanceAction era
InfoAct :: GovernanceAction era
TreasuryWithdrawal :: [(Network, StakeCredential, Coin)] -> !StrictMaybe ScriptHash -> GovernanceAction era
InitiateHardfork :: StrictMaybe (GovPurposeId 'HardForkPurpose (ShelleyLedgerEra era)) -> ProtVer -> GovernanceAction era
UpdatePParams :: StrictMaybe (GovPurposeId 'PParamUpdatePurpose (ShelleyLedgerEra era)) -> PParamsUpdate (ShelleyLedgerEra era) -> !StrictMaybe ScriptHash -> GovernanceAction era
data () => Proposal era
[Proposal] :: forall era. Typeable era => ProposalProcedure (ShelleyLedgerEra era) -> Proposal era
data () => Vote
No :: Vote
Yes :: Vote
Abstain :: Vote
newtype () => VotesMergingConflict era
VotesMergingConflict :: (Voter, [GovActionId]) -> VotesMergingConflict era
newtype () => VotingProcedure era
VotingProcedure :: VotingProcedure (ShelleyLedgerEra era) -> VotingProcedure era
[unVotingProcedure] :: VotingProcedure era -> VotingProcedure (ShelleyLedgerEra era)
newtype () => VotingProcedures era
VotingProcedures :: VotingProcedures (ShelleyLedgerEra era) -> VotingProcedures era
[unVotingProcedures] :: VotingProcedures era -> VotingProcedures (ShelleyLedgerEra era)
newtype () => AnchorDataHash
AnchorDataHash :: SafeHash AnchorData -> AnchorDataHash
[unAnchorDataHash] :: AnchorDataHash -> SafeHash AnchorData
newtype () => AnchorUrl
AnchorUrl :: Url -> AnchorUrl
[unAnchorUrl] :: AnchorUrl -> Url
data () => CIP119
DrepRegistrationMetadata :: CIP119
data () => CIP108
BaseGovActionMetadata :: CIP108
data family Authors cip
data () => GovActionMetadata cip
GovActionMetadata :: HashAlgorithm cip -> Authors cip -> Body cip -> GovActionMetadata cip
[$sel:hashAlgorithm:GovActionMetadata] :: GovActionMetadata cip -> HashAlgorithm cip
[$sel:authors:GovActionMetadata] :: GovActionMetadata cip -> Authors cip
[$sel:body:GovActionMetadata] :: GovActionMetadata cip -> Body cip
data family HashAlgorithm cip
data () => GovernancePoll
GovernancePoll :: Text -> [Text] -> Maybe Word -> GovernancePoll
[govPollQuestion] :: GovernancePoll -> Text
[govPollAnswers] :: GovernancePoll -> [Text]
[govPollNonce] :: GovernancePoll -> Maybe Word
data () => GovernancePollAnswer
GovernancePollAnswer :: Hash GovernancePoll -> Word -> GovernancePollAnswer
[govAnsPoll] :: GovernancePollAnswer -> Hash GovernancePoll
[govAnsChoice] :: GovernancePollAnswer -> Word
data () => GovernancePollError
ErrGovernancePollMismatch :: GovernancePollMismatchError -> GovernancePollError
ErrGovernancePollNoAnswer :: GovernancePollError
ErrGovernancePollUnauthenticated :: GovernancePollError
ErrGovernancePollMalformedAnswer :: DecoderError -> GovernancePollError
ErrGovernancePollInvalidAnswer :: GovernancePollInvalidAnswerError -> GovernancePollError
class Typeable t => HasTypeProxy t where {
    data family AsType t;
}
proxyToAsType :: HasTypeProxy t => Proxy t -> AsType t
data family AsType t
pattern AsByronAddress :: AsType (Address ByronAddr)
pattern AsShelleyAddress :: AsType (Address ShelleyAddr)
pattern AsAllegraTx :: AsType (Tx AllegraEra)
pattern AsAlonzoTx :: AsType (Tx AlonzoEra)
pattern AsByronTxBody :: AsType (TxBody ByronEra)
pattern AsByronWitness :: AsType (KeyWitness ByronEra)
pattern AsMaryTx :: AsType (Tx MaryEra)
pattern AsMaryTxBody :: AsType (TxBody MaryEra)
pattern AsShelleyTxBody :: AsType (TxBody ShelleyEra)
pattern AsShelleyWitness :: AsType (KeyWitness ShelleyEra)
data () => FromSomeType (c :: Type -> Constraint) b
[FromSomeType] :: forall (c :: Type -> Constraint) a b. c a => AsType a -> (a -> b) -> FromSomeType c b
class () => CastHash roleA roleB
castHash :: CastHash roleA roleB => Hash roleA -> Hash roleB
data () => FileDirection
In :: FileDirection
Out :: FileDirection
InOut :: FileDirection
type SocketPath = File Socket 'InOut
data () => AnyStakePoolSigningKey
AnyStakePoolNormalSigningKey :: SigningKey StakePoolKey -> AnyStakePoolSigningKey
AnyStakePoolExtendedSigningKey :: SigningKey StakePoolExtendedKey -> AnyStakePoolSigningKey
data () => AnyStakePoolVerificationKey
AnyStakePoolNormalVerificationKey :: VerificationKey StakePoolKey -> AnyStakePoolVerificationKey
AnyStakePoolExtendedVerificationKey :: VerificationKey StakePoolExtendedKey -> AnyStakePoolVerificationKey
data () => CommitteeColdExtendedKey
data () => CommitteeColdKey
data () => CommitteeHotExtendedKey
data () => CommitteeHotKey
data () => DRepExtendedKey
data () => DRepKey
data () => GenesisDelegateExtendedKey
data () => GenesisDelegateKey
data () => GenesisExtendedKey
data () => GenesisKey
data () => GenesisUTxOKey
data () => PaymentExtendedKey
data () => PaymentKey
data () => StakeExtendedKey
data () => StakeKey
data () => StakePoolExtendedKey
data () => StakePoolKey
class () => CastSigningKeyRole keyroleA keyroleB
castSigningKey :: CastSigningKeyRole keyroleA keyroleB => SigningKey keyroleA -> SigningKey keyroleB
class () => CastVerificationKeyRole keyroleA keyroleB
castVerificationKey :: CastVerificationKeyRole keyroleA keyroleB => VerificationKey keyroleA -> VerificationKey keyroleB
data family SigningKey keyrole
data family VerificationKey keyrole
data () => MnemonicSize
MS12 :: MnemonicSize
MS15 :: MnemonicSize
MS18 :: MnemonicSize
MS21 :: MnemonicSize
MS24 :: MnemonicSize
data () => MnemonicToSigningKeyError
InvalidMnemonicError :: String -> MnemonicToSigningKeyError
InvalidAccountNumberError :: Word32 -> MnemonicToSigningKeyError
InvalidPaymentKeyNoError :: Word32 -> MnemonicToSigningKeyError
data () => KesKey
data () => VrfKey
data () => SomeAddressVerificationKey
AByronVerificationKey :: VerificationKey ByronKey -> SomeAddressVerificationKey
APaymentVerificationKey :: VerificationKey PaymentKey -> SomeAddressVerificationKey
APaymentExtendedVerificationKey :: VerificationKey PaymentExtendedKey -> SomeAddressVerificationKey
AGenesisUTxOVerificationKey :: VerificationKey GenesisUTxOKey -> SomeAddressVerificationKey
AGenesisExtendedVerificationKey :: VerificationKey GenesisExtendedKey -> SomeAddressVerificationKey
AGenesisDelegateExtendedVerificationKey :: VerificationKey GenesisDelegateExtendedKey -> SomeAddressVerificationKey
AKesVerificationKey :: VerificationKey KesKey -> SomeAddressVerificationKey
AVrfVerificationKey :: VerificationKey VrfKey -> SomeAddressVerificationKey
AStakeVerificationKey :: VerificationKey StakeKey -> SomeAddressVerificationKey
AStakeExtendedVerificationKey :: VerificationKey StakeExtendedKey -> SomeAddressVerificationKey
AStakePoolVerificationKey :: VerificationKey StakePoolKey -> SomeAddressVerificationKey
AStakePoolExtendedVerificationKey :: VerificationKey StakePoolExtendedKey -> SomeAddressVerificationKey
ADRepVerificationKey :: VerificationKey DRepKey -> SomeAddressVerificationKey
ADRepExtendedVerificationKey :: VerificationKey DRepExtendedKey -> SomeAddressVerificationKey
ACommitteeColdVerificationKey :: VerificationKey CommitteeColdKey -> SomeAddressVerificationKey
ACommitteeColdExtendedVerificationKey :: VerificationKey CommitteeColdExtendedKey -> SomeAddressVerificationKey
ACommitteeHotVerificationKey :: VerificationKey CommitteeHotKey -> SomeAddressVerificationKey
ACommitteeHotExtendedVerificationKey :: VerificationKey CommitteeHotExtendedKey -> SomeAddressVerificationKey
data () => AnyNewEpochState
[AnyNewEpochState] :: forall era. ShelleyBasedEra era -> NewEpochState (ShelleyLedgerEra era) -> LedgerTables (LedgerState (CardanoBlock StandardCrypto)) ValuesMK -> AnyNewEpochState
data () => ConditionResult
ConditionNotMet :: ConditionResult
ConditionMet :: ConditionResult
data () => Env
Env :: CardanoLedgerConfig StandardCrypto -> CardanoConsensusConfig StandardCrypto -> Env
[envLedgerConfig] :: Env -> CardanoLedgerConfig StandardCrypto
[envConsensusConfig] :: Env -> CardanoConsensusConfig StandardCrypto
data () => FoldBlocksError
FoldBlocksInitialLedgerStateError :: !InitialLedgerStateError -> FoldBlocksError
FoldBlocksApplyBlockError :: !LedgerStateError -> FoldBlocksError
FoldBlocksIOException :: !IOException -> FoldBlocksError
FoldBlocksMuxError :: !Error -> FoldBlocksError
data () => FoldStatus
ContinueFold :: FoldStatus
StopFold :: FoldStatus
DebugFold :: FoldStatus
data () => GenesisConfig
GenesisCardano :: !NodeConfig -> !Config -> !GenesisHashShelley -> !TransitionConfig LatestKnownEra -> GenesisConfig
data () => GenesisConfigError
NEError :: !Text -> GenesisConfigError
NEByronConfig :: !FilePath -> !ConfigurationError -> GenesisConfigError
NEShelleyConfig :: !FilePath -> !Text -> GenesisConfigError
NEAlonzoConfig :: !FilePath -> !Text -> GenesisConfigError
NEConwayConfig :: !FilePath -> !Text -> GenesisConfigError
NECardanoConfig :: !Text -> GenesisConfigError
data () => InitialLedgerStateError
ILSEConfigFile :: Text -> InitialLedgerStateError
ILSEGenesisFile :: GenesisConfigError -> InitialLedgerStateError
ILSELedgerConsensusConfig :: GenesisConfigError -> InitialLedgerStateError
data () => LeadershipError
LeaderErrDecodeLedgerStateFailure :: LeadershipError
LeaderErrDecodeProtocolStateFailure :: (ByteString, DecoderError) -> LeadershipError
LeaderErrDecodeProtocolEpochStateFailure :: DecoderError -> LeadershipError
LeaderErrGenesisSlot :: LeadershipError
LeaderErrStakePoolHasNoStake :: PoolId -> LeadershipError
LeaderErrStakeDistribUnstable :: SlotNo -> SlotNo -> SlotNo -> SlotNo -> LeadershipError
LeaderErrSlotRangeCalculationFailure :: Text -> LeadershipError
LeaderErrCandidateNonceStillEvolving :: LeadershipError
data () => LedgerState
LedgerState :: CardanoLedgerState StandardCrypto EmptyMK -> LedgerTables (LedgerState (HardForkBlock (CardanoEras StandardCrypto))) ValuesMK -> LedgerState
[clsState] :: LedgerState -> CardanoLedgerState StandardCrypto EmptyMK
[clsTables] :: LedgerState -> LedgerTables (LedgerState (HardForkBlock (CardanoEras StandardCrypto))) ValuesMK
pattern LedgerStateAllegra :: LedgerState StandardAllegraBlock EmptyMK -> LedgerState
pattern LedgerStateAlonzo :: LedgerState StandardAlonzoBlock EmptyMK -> LedgerState
pattern LedgerStateBabbage :: LedgerState StandardBabbageBlock EmptyMK -> LedgerState
pattern LedgerStateByron :: LedgerState ByronBlock EmptyMK -> LedgerState
pattern LedgerStateConway :: LedgerState StandardConwayBlock EmptyMK -> LedgerState
pattern LedgerStateMary :: LedgerState StandardMaryBlock EmptyMK -> LedgerState
pattern LedgerStateShelley :: LedgerState StandardShelleyBlock EmptyMK -> LedgerState
data () => LedgerStateError
ApplyBlockHashMismatch :: Text -> LedgerStateError
ApplyBlockError :: CardanoLedgerError StandardCrypto -> LedgerStateError
InvalidRollback :: SlotNo -> ChainPoint -> LedgerStateError
TerminationEpochReached :: EpochNo -> LedgerStateError
UnexpectedLedgerState :: AnyShelleyBasedEra -> NS (Current (Flip LedgerState EmptyMK)) (CardanoEras StandardCrypto) -> LedgerStateError
ByronEraUnsupported :: LedgerStateError
DebugError :: !String -> LedgerStateError
data () => NodeConfig
NodeConfig :: !Maybe Double -> !File ByronGenesisConfig 'In -> !GenesisHashByron -> !File ShelleyGenesisConfig 'In -> !GenesisHashShelley -> !File AlonzoGenesis 'In -> !GenesisHashAlonzo -> !Maybe (File ConwayGenesisConfig 'In) -> !Maybe GenesisHashConway -> !RequiresNetworkMagic -> !ProtocolVersion -> !CardanoHardForkTriggers -> NodeConfig
[ncPBftSignatureThreshold] :: NodeConfig -> !Maybe Double
[ncByronGenesisFile] :: NodeConfig -> !File ByronGenesisConfig 'In
[ncByronGenesisHash] :: NodeConfig -> !GenesisHashByron
[ncShelleyGenesisFile] :: NodeConfig -> !File ShelleyGenesisConfig 'In
[ncShelleyGenesisHash] :: NodeConfig -> !GenesisHashShelley
[ncAlonzoGenesisFile] :: NodeConfig -> !File AlonzoGenesis 'In
[ncAlonzoGenesisHash] :: NodeConfig -> !GenesisHashAlonzo
[ncConwayGenesisFile] :: NodeConfig -> !Maybe (File ConwayGenesisConfig 'In)
[ncConwayGenesisHash] :: NodeConfig -> !Maybe GenesisHashConway
[ncRequiresNetworkMagic] :: NodeConfig -> !RequiresNetworkMagic
[ncByronProtocolVersion] :: NodeConfig -> !ProtocolVersion
[ncHardForkTriggers] :: NodeConfig -> !CardanoHardForkTriggers
type NodeConfigFile = File NodeConfig
data () => ValidationMode
FullValidation :: ValidationMode
QuickValidation :: ValidationMode
data () => AnyProposals
AnyProposals :: Proposals era -> AnyProposals
data () => AnyRatificationState
AnyRatificationState :: RatifyState era -> AnyRatificationState
data () => LedgerEvent
PoolRegistration :: LedgerEvent
PoolReRegistration :: LedgerEvent
IncrementalRewardsDistribution :: EpochNo -> Map StakeCredential (Set Reward) -> LedgerEvent
RewardsDistribution :: EpochNo -> Map StakeCredential (Set Reward) -> LedgerEvent
MIRDistribution :: MIRDistributionDetails -> LedgerEvent
PoolReap :: PoolReapDetails -> LedgerEvent
SuccessfulPlutusScript :: NonEmpty PlutusWithContext -> LedgerEvent
FailedPlutusScript :: NonEmpty PlutusWithContext -> LedgerEvent
NewGovernanceProposals :: TxId -> AnyProposals -> LedgerEvent
RemovedGovernanceVotes :: TxId -> Set (Voter, GovActionId) -> Set (Credential 'DRepRole) -> LedgerEvent
EpochBoundaryRatificationState :: AnyRatificationState -> LedgerEvent
data () => MIRDistributionDetails
MIRDistributionDetails :: Map StakeCredential Coin -> Map StakeCredential Coin -> Coin -> Coin -> MIRDistributionDetails
[mirddReservePayouts] :: MIRDistributionDetails -> Map StakeCredential Coin
[mirddTreasuryPayouts] :: MIRDistributionDetails -> Map StakeCredential Coin
[mirddReservesToTreasury] :: MIRDistributionDetails -> Coin
[mirddTreasuryToReserves] :: MIRDistributionDetails -> Coin
data () => PoolReapDetails
PoolReapDetails :: EpochNo -> Map StakeCredential (Map (Hash StakePoolKey) Coin) -> Map StakeCredential (Map (Hash StakePoolKey) Coin) -> PoolReapDetails
[prdEpochNo] :: PoolReapDetails -> EpochNo
[prdRefunded] :: PoolReapDetails -> Map StakeCredential (Map (Hash StakePoolKey) Coin)
[prdUnclaimed] :: PoolReapDetails -> Map StakeCredential (Map (Hash StakePoolKey) Coin)
type MonadIOTransError e (t :: Type -> Type -> Type -> Type) (m :: Type -> Type) = (MonadIO m, MonadIO t m, MonadCatch m, MonadTrans t, MonadError e t m)
type MonadTransError e (t :: Type -> Type -> Type -> Type) (m :: Type -> Type) = (Monad m, MonadTrans t, MonadError e t m)
data () => AcquiringFailure
AFPointTooOld :: AcquiringFailure
AFPointNotOnChain :: AcquiringFailure
data () => LocalChainSyncClient block point tip (m :: Type -> Type)
NoLocalChainSyncClient :: LocalChainSyncClient block point tip (m :: Type -> Type)
LocalChainSyncClientPipelined :: ChainSyncClientPipelined block point tip m () -> LocalChainSyncClient block point tip (m :: Type -> Type)
LocalChainSyncClient :: ChainSyncClient block point tip m () -> LocalChainSyncClient block point tip (m :: Type -> Type)
data () => LocalNodeClientParams
[LocalNodeClientParamsSingleBlock] :: forall block. (ProtocolClient block, LedgerSupportsProtocol (ShelleyBlock (TPraos StandardCrypto) ShelleyEra)) => ProtocolClientInfoArgs block -> (NodeToClientVersion -> LocalNodeClientProtocolsForBlock block) -> LocalNodeClientParams
[LocalNodeClientParamsCardano] :: forall block. (ProtocolClient block, CardanoHardForkConstraints (ConsensusCryptoForBlock block)) => ProtocolClientInfoArgs block -> (NodeToClientVersion -> LocalNodeClientProtocolsForBlock block) -> LocalNodeClientParams
data () => LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type)
LocalNodeClientProtocols :: LocalChainSyncClient block point tip m -> Maybe (LocalTxSubmissionClient tx txerr m ()) -> Maybe (LocalStateQueryClient block point query m ()) -> Maybe (LocalTxMonitorClient txid tx slot m ()) -> LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type)
[localChainSyncClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> LocalChainSyncClient block point tip m
[localTxSubmissionClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> Maybe (LocalTxSubmissionClient tx txerr m ())
[localStateQueryClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> Maybe (LocalStateQueryClient block point query m ())
[localTxMonitoringClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> Maybe (LocalTxMonitorClient txid tx slot m ())
type LocalNodeClientProtocolsInMode = LocalNodeClientProtocols BlockInMode ChainPoint ChainTip SlotNo TxInMode TxIdInMode TxValidationErrorInCardanoMode QueryInMode IO
data () => LocalNodeConnectInfo
LocalNodeConnectInfo :: ConsensusModeParams -> NetworkId -> SocketPath -> LocalNodeConnectInfo
[localConsensusModeParams] :: LocalNodeConnectInfo -> ConsensusModeParams
[localNodeNetworkId] :: LocalNodeConnectInfo -> NetworkId
[localNodeSocketPath] :: LocalNodeConnectInfo -> SocketPath
data () => LocalTxMonitoringQuery
LocalTxMonitoringQueryTx :: TxIdInMode -> LocalTxMonitoringQuery
LocalTxMonitoringSendNextTx :: LocalTxMonitoringQuery
LocalTxMonitoringMempoolInformation :: LocalTxMonitoringQuery
data () => LocalTxMonitoringResult
LocalTxMonitoringTxExists :: TxId -> SlotNo -> LocalTxMonitoringResult
LocalTxMonitoringTxDoesNotExist :: TxId -> SlotNo -> LocalTxMonitoringResult
LocalTxMonitoringNextTx :: Maybe TxInMode -> SlotNo -> LocalTxMonitoringResult
LocalTxMonitoringMempoolSizeAndCapacity :: MempoolSizeAndCapacity -> SlotNo -> LocalTxMonitoringResult
data () => LocalStateQueryExpr block point (query :: Type -> Type) r (m :: Type -> Type) a
data () => UnsupportedNtcVersionError
UnsupportedNtcVersionError :: !NodeToClientVersion -> ![NodeToClientVersion] -> UnsupportedNtcVersionError
data () => DebugPlutusFailure
DebugPlutusFailure :: EvaluationError -> PlutusWithContext -> ExUnits -> [Text] -> DebugPlutusFailure
[dpfEvaluationError] :: DebugPlutusFailure -> EvaluationError
[dpfScriptWithContext] :: DebugPlutusFailure -> PlutusWithContext
[dpfExecutionUnits] :: DebugPlutusFailure -> ExUnits
[dpfExecutionLogs] :: DebugPlutusFailure -> [Text]
data () => AnyPlutusScriptVersion
[AnyPlutusScriptVersion] :: forall lang. IsPlutusScriptLanguage lang => PlutusScriptVersion lang -> AnyPlutusScriptVersion
data () => AnyScriptLanguage
[AnyScriptLanguage] :: forall lang. ScriptLanguage lang -> AnyScriptLanguage
class () => HasScriptLanguageInEra lang era
scriptLanguageInEra :: HasScriptLanguageInEra lang era => ScriptLanguageInEra lang era
class IsScriptLanguage lang => IsPlutusScriptLanguage lang
plutusScriptVersion :: IsPlutusScriptLanguage lang => PlutusScriptVersion lang
class HasTypeProxy lang => IsScriptLanguage lang
scriptLanguage :: IsScriptLanguage lang => ScriptLanguage lang
class () => IsScriptWitnessInCtx ctx
scriptWitnessInCtx :: IsScriptWitnessInCtx ctx => ScriptWitnessInCtx ctx
data () => KeyWitnessInCtx witctx
[KeyWitnessForSpending] :: KeyWitnessInCtx WitCtxTxIn
[KeyWitnessForStakeAddr] :: KeyWitnessInCtx WitCtxStake
data () => PlutusScriptInEra era lang
[PlutusScriptInEra] :: forall lang era. PlutusScript lang -> PlutusScriptInEra era lang
data () => PlutusScriptOrReferenceInput lang
PScript :: PlutusScript lang -> PlutusScriptOrReferenceInput lang
PReferenceScript :: TxIn -> PlutusScriptOrReferenceInput lang
data () => PlutusScriptV1
data () => PlutusScriptV2
data () => PlutusScriptV3
data () => PlutusScriptVersion lang
[PlutusScriptV1] :: PlutusScriptVersion PlutusScriptV1
[PlutusScriptV2] :: PlutusScriptVersion PlutusScriptV2
[PlutusScriptV3] :: PlutusScriptVersion PlutusScriptV3
data () => ScriptInAnyLang
[ScriptInAnyLang] :: forall lang. ScriptLanguage lang -> Script lang -> ScriptInAnyLang
data () => ScriptLanguageInEra lang era
[SimpleScriptInShelley] :: ScriptLanguageInEra SimpleScript' ShelleyEra
[SimpleScriptInAllegra] :: ScriptLanguageInEra SimpleScript' AllegraEra
[SimpleScriptInMary] :: ScriptLanguageInEra SimpleScript' MaryEra
[SimpleScriptInAlonzo] :: ScriptLanguageInEra SimpleScript' AlonzoEra
[SimpleScriptInBabbage] :: ScriptLanguageInEra SimpleScript' BabbageEra
[SimpleScriptInConway] :: ScriptLanguageInEra SimpleScript' ConwayEra
[PlutusScriptV1InAlonzo] :: ScriptLanguageInEra PlutusScriptV1 AlonzoEra
[PlutusScriptV1InBabbage] :: ScriptLanguageInEra PlutusScriptV1 BabbageEra
[PlutusScriptV1InConway] :: ScriptLanguageInEra PlutusScriptV1 ConwayEra
[PlutusScriptV2InBabbage] :: ScriptLanguageInEra PlutusScriptV2 BabbageEra
[PlutusScriptV2InConway] :: ScriptLanguageInEra PlutusScriptV2 ConwayEra
[PlutusScriptV3InConway] :: ScriptLanguageInEra PlutusScriptV3 ConwayEra
type ScriptRedeemer = HashableScriptData
data () => ScriptWitnessInCtx witctx
[ScriptWitnessForSpending] :: ScriptWitnessInCtx WitCtxTxIn
[ScriptWitnessForMinting] :: ScriptWitnessInCtx WitCtxMint
[ScriptWitnessForStakeAddr] :: ScriptWitnessInCtx WitCtxStake
data () => SimpleScript
RequireSignature :: !Hash PaymentKey -> SimpleScript
RequireTimeBefore :: !SlotNo -> SimpleScript
RequireTimeAfter :: !SlotNo -> SimpleScript
RequireAllOf :: ![SimpleScript] -> SimpleScript
RequireAnyOf :: ![SimpleScript] -> SimpleScript
RequireMOf :: !Int -> ![SimpleScript] -> SimpleScript
data () => SimpleScript'
data () => SimpleScriptOrReferenceInput lang
SScript :: SimpleScript -> SimpleScriptOrReferenceInput lang
SReferenceScript :: TxIn -> SimpleScriptOrReferenceInput lang
class () => ToAlonzoScript lang era
toLedgerScript :: ToAlonzoScript lang era => PlutusScript lang -> AlonzoScript (ShelleyLedgerEra era)
type family ToLedgerPlutusLanguage lang :: Language
data () => WitCtx witctx
[WitCtxTxIn] :: WitCtx WitCtxTxIn
[WitCtxMint] :: WitCtx WitCtxMint
[WitCtxStake] :: WitCtx WitCtxStake
data () => WitCtxMint
data () => WitCtxStake
data () => WitCtxTxIn
data () => HashableScriptData
HashableScriptData :: !ByteString -> !ScriptData -> HashableScriptData
newtype () => ScriptBytesError
ScriptBytesError :: String -> ScriptBytesError
data () => ScriptDataJsonBytesError
ScriptDataJsonBytesErrorValue :: ScriptDataJsonError -> ScriptDataJsonBytesError
ScriptDataJsonBytesErrorInvalid :: ScriptDataRangeError -> ScriptDataJsonBytesError
data () => ScriptDataJsonError
ScriptDataJsonSchemaError :: !Value -> !ScriptDataJsonSchemaError -> ScriptDataJsonError
ScriptDataRangeError :: !Value -> !ScriptDataRangeError -> ScriptDataJsonError
data () => ScriptDataJsonSchema
ScriptDataJsonNoSchema :: ScriptDataJsonSchema
ScriptDataJsonDetailedSchema :: ScriptDataJsonSchema
data () => ScriptDataJsonSchemaError
ScriptDataJsonNullNotAllowed :: ScriptDataJsonSchemaError
ScriptDataJsonBoolNotAllowed :: ScriptDataJsonSchemaError
ScriptDataJsonNumberNotInteger :: !Double -> ScriptDataJsonSchemaError
ScriptDataJsonNotObject :: !Value -> ScriptDataJsonSchemaError
ScriptDataJsonBadObject :: ![(Text, Value)] -> ScriptDataJsonSchemaError
ScriptDataJsonBadMapPair :: !Value -> ScriptDataJsonSchemaError
ScriptDataJsonTypeMismatch :: !Text -> !Value -> ScriptDataJsonSchemaError
newtype () => ScriptDataRangeError
ScriptDataConstructorOutOfRange :: Integer -> ScriptDataRangeError
type Ann = AnsiStyle
newtype () => ShowOf a
ShowOf :: a -> ShowOf a
data () => AlonzoOnwardsPParams ledgerera
AlonzoOnwardsPParams :: StrictMaybe CostModels -> StrictMaybe Prices -> StrictMaybe ExUnits -> StrictMaybe ExUnits -> StrictMaybe Natural -> StrictMaybe Natural -> StrictMaybe Natural -> AlonzoOnwardsPParams ledgerera
[alCostModels] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe CostModels
[alPrices] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe Prices
[alMaxTxExUnits] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe ExUnits
[alMaxBlockExUnits] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe ExUnits
[alMaxValSize] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe Natural
[alCollateralPercentage] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe Natural
[alMaxCollateralInputs] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe Natural
data () => CommonProtocolParametersUpdate
CommonProtocolParametersUpdate :: StrictMaybe Coin -> StrictMaybe Coin -> StrictMaybe Word32 -> StrictMaybe Word32 -> StrictMaybe Word16 -> StrictMaybe Coin -> StrictMaybe Coin -> StrictMaybe EpochInterval -> StrictMaybe Word16 -> StrictMaybe NonNegativeInterval -> StrictMaybe UnitInterval -> StrictMaybe UnitInterval -> StrictMaybe Coin -> CommonProtocolParametersUpdate
[cppMinFeeA] :: CommonProtocolParametersUpdate -> StrictMaybe Coin
[cppMinFeeB] :: CommonProtocolParametersUpdate -> StrictMaybe Coin
[cppMaxBlockBodySize] :: CommonProtocolParametersUpdate -> StrictMaybe Word32
[cppMaxTxSize] :: CommonProtocolParametersUpdate -> StrictMaybe Word32
[cppMaxBlockHeaderSize] :: CommonProtocolParametersUpdate -> StrictMaybe Word16
[cppKeyDeposit] :: CommonProtocolParametersUpdate -> StrictMaybe Coin
[cppPoolDeposit] :: CommonProtocolParametersUpdate -> StrictMaybe Coin
[cppPoolRetireMaxEpoch] :: CommonProtocolParametersUpdate -> StrictMaybe EpochInterval
[cppStakePoolTargetNum] :: CommonProtocolParametersUpdate -> StrictMaybe Word16
[cppPoolPledgeInfluence] :: CommonProtocolParametersUpdate -> StrictMaybe NonNegativeInterval
[cppTreasuryExpansion] :: CommonProtocolParametersUpdate -> StrictMaybe UnitInterval
[cppMonetaryExpansion] :: CommonProtocolParametersUpdate -> StrictMaybe UnitInterval
[cppMinPoolCost] :: CommonProtocolParametersUpdate -> StrictMaybe Coin
newtype () => CostModel
CostModel :: [Int64] -> CostModel
newtype () => CostModels
CostModels :: Map AnyPlutusScriptVersion CostModel -> CostModels
[unCostModels] :: CostModels -> Map AnyPlutusScriptVersion CostModel
newtype () => DeprecatedAfterBabbagePParams ledgerera
DeprecatedAfterBabbagePParams :: StrictMaybe ProtVer -> DeprecatedAfterBabbagePParams ledgerera
newtype () => DeprecatedAfterMaryPParams ledgerera
DeprecatedAfterMaryPParams :: StrictMaybe Coin -> DeprecatedAfterMaryPParams ledgerera
data () => EraBasedProtocolParametersUpdate era
[ShelleyEraBasedProtocolParametersUpdate] :: CommonProtocolParametersUpdate -> DeprecatedAfterMaryPParams ShelleyEra -> DeprecatedAfterBabbagePParams ShelleyEra -> ShelleyToAlonzoPParams ShelleyEra -> EraBasedProtocolParametersUpdate ShelleyEra
[AllegraEraBasedProtocolParametersUpdate] :: CommonProtocolParametersUpdate -> DeprecatedAfterMaryPParams AllegraEra -> ShelleyToAlonzoPParams AllegraEra -> DeprecatedAfterBabbagePParams ShelleyEra -> EraBasedProtocolParametersUpdate AllegraEra
[MaryEraBasedProtocolParametersUpdate] :: CommonProtocolParametersUpdate -> DeprecatedAfterMaryPParams MaryEra -> ShelleyToAlonzoPParams MaryEra -> DeprecatedAfterBabbagePParams ShelleyEra -> EraBasedProtocolParametersUpdate MaryEra
[AlonzoEraBasedProtocolParametersUpdate] :: CommonProtocolParametersUpdate -> ShelleyToAlonzoPParams AlonzoEra -> AlonzoOnwardsPParams AlonzoEra -> DeprecatedAfterBabbagePParams ShelleyEra -> EraBasedProtocolParametersUpdate AlonzoEra
[BabbageEraBasedProtocolParametersUpdate] :: CommonProtocolParametersUpdate -> AlonzoOnwardsPParams BabbageEra -> DeprecatedAfterBabbagePParams ShelleyEra -> IntroducedInBabbagePParams BabbageEra -> EraBasedProtocolParametersUpdate BabbageEra
[ConwayEraBasedProtocolParametersUpdate] :: CommonProtocolParametersUpdate -> AlonzoOnwardsPParams ConwayEra -> IntroducedInBabbagePParams ConwayEra -> IntroducedInConwayPParams (ShelleyLedgerEra ConwayEra) -> EraBasedProtocolParametersUpdate ConwayEra
data () => ExecutionUnitPrices
ExecutionUnitPrices :: Rational -> Rational -> ExecutionUnitPrices
[priceExecutionSteps] :: ExecutionUnitPrices -> Rational
[priceExecutionMemory] :: ExecutionUnitPrices -> Rational
newtype () => IntroducedInBabbagePParams era
IntroducedInBabbagePParams :: StrictMaybe CoinPerByte -> IntroducedInBabbagePParams era
data () => IntroducedInConwayPParams era
IntroducedInConwayPParams :: StrictMaybe PoolVotingThresholds -> StrictMaybe DRepVotingThresholds -> StrictMaybe Natural -> StrictMaybe EpochInterval -> StrictMaybe EpochInterval -> StrictMaybe Coin -> StrictMaybe Coin -> StrictMaybe EpochInterval -> StrictMaybe NonNegativeInterval -> IntroducedInConwayPParams era
[icPoolVotingThresholds] :: IntroducedInConwayPParams era -> StrictMaybe PoolVotingThresholds
[icDRepVotingThresholds] :: IntroducedInConwayPParams era -> StrictMaybe DRepVotingThresholds
[icMinCommitteeSize] :: IntroducedInConwayPParams era -> StrictMaybe Natural
[icCommitteeTermLength] :: IntroducedInConwayPParams era -> StrictMaybe EpochInterval
[icGovActionLifetime] :: IntroducedInConwayPParams era -> StrictMaybe EpochInterval
[icGovActionDeposit] :: IntroducedInConwayPParams era -> StrictMaybe Coin
[icDRepDeposit] :: IntroducedInConwayPParams era -> StrictMaybe Coin
[icDRepActivity] :: IntroducedInConwayPParams era -> StrictMaybe EpochInterval
[icMinFeeRefScriptCostPerByte] :: IntroducedInConwayPParams era -> StrictMaybe NonNegativeInterval
data () => PraosNonce
data () => ProtocolParametersConversionError
PpceOutOfBounds :: !ProtocolParameterName -> !Rational -> ProtocolParametersConversionError
PpceVersionInvalid :: !ProtocolParameterVersion -> ProtocolParametersConversionError
PpceInvalidCostModel :: !CostModel -> !CostModelApplyError -> ProtocolParametersConversionError
PpceMissingParameter :: !ProtocolParameterName -> ProtocolParametersConversionError
data () => ProtocolParametersError
PParamsErrorMissingMinUTxoValue :: !AnyCardanoEra -> ProtocolParametersError
PParamsErrorMissingAlonzoProtocolParameter :: ProtocolParametersError
data () => ProtocolParametersUpdate
ProtocolParametersUpdate :: Maybe (Natural, Natural) -> Maybe Rational -> Maybe (Maybe PraosNonce) -> Maybe Word16 -> Maybe Word32 -> Maybe Word32 -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe EpochInterval -> Maybe Word16 -> Maybe Rational -> Maybe Rational -> Maybe Rational -> Map AnyPlutusScriptVersion CostModel -> Maybe ExecutionUnitPrices -> Maybe ExecutionUnits -> Maybe ExecutionUnits -> Maybe Natural -> Maybe Natural -> Maybe Natural -> Maybe Coin -> ProtocolParametersUpdate
[protocolUpdateProtocolVersion] :: ProtocolParametersUpdate -> Maybe (Natural, Natural)
[protocolUpdateDecentralization] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateExtraPraosEntropy] :: ProtocolParametersUpdate -> Maybe (Maybe PraosNonce)
[protocolUpdateMaxBlockHeaderSize] :: ProtocolParametersUpdate -> Maybe Word16
[protocolUpdateMaxBlockBodySize] :: ProtocolParametersUpdate -> Maybe Word32
[protocolUpdateMaxTxSize] :: ProtocolParametersUpdate -> Maybe Word32
[protocolUpdateTxFeeFixed] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateTxFeePerByte] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateMinUTxOValue] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateStakeAddressDeposit] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateStakePoolDeposit] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateMinPoolCost] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdatePoolRetireMaxEpoch] :: ProtocolParametersUpdate -> Maybe EpochInterval
[protocolUpdateStakePoolTargetNum] :: ProtocolParametersUpdate -> Maybe Word16
[protocolUpdatePoolPledgeInfluence] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateMonetaryExpansion] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateTreasuryCut] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateCostModels] :: ProtocolParametersUpdate -> Map AnyPlutusScriptVersion CostModel
[protocolUpdatePrices] :: ProtocolParametersUpdate -> Maybe ExecutionUnitPrices
[protocolUpdateMaxTxExUnits] :: ProtocolParametersUpdate -> Maybe ExecutionUnits
[protocolUpdateMaxBlockExUnits] :: ProtocolParametersUpdate -> Maybe ExecutionUnits
[protocolUpdateMaxValueSize] :: ProtocolParametersUpdate -> Maybe Natural
[protocolUpdateCollateralPercent] :: ProtocolParametersUpdate -> Maybe Natural
[protocolUpdateMaxCollateralInputs] :: ProtocolParametersUpdate -> Maybe Natural
[protocolUpdateUTxOCostPerByte] :: ProtocolParametersUpdate -> Maybe Coin
data () => ShelleyToAlonzoPParams ledgerera
ShelleyToAlonzoPParams :: StrictMaybe Nonce -> StrictMaybe UnitInterval -> ShelleyToAlonzoPParams ledgerera
data () => UpdateProposal
UpdateProposal :: !Map (Hash GenesisKey) ProtocolParametersUpdate -> !EpochNo -> UpdateProposal
data () => QueryConvenienceError
AcqFailure :: AcquiringFailure -> QueryConvenienceError
QueryEraMismatch :: EraMismatch -> QueryConvenienceError
ByronEraNotSupported :: QueryConvenienceError
QceUnsupportedNtcVersion :: !UnsupportedNtcVersionError -> QueryConvenienceError
QceUnexpectedException :: !SomeException -> QueryConvenienceError
newtype () => TxCurrentTreasuryValue
TxCurrentTreasuryValue :: Coin -> TxCurrentTreasuryValue
[unTxCurrentTreasuryValue] :: TxCurrentTreasuryValue -> Coin
newtype () => DebugLedgerState era
DebugLedgerState :: NewEpochState (ShelleyLedgerEra era) -> DebugLedgerState era
[unDebugLedgerState] :: DebugLedgerState era -> NewEpochState (ShelleyLedgerEra era)
newtype () => DelegationsAndRewards
DelegationsAndRewards :: (Map StakeAddress Coin, Map StakeAddress PoolId) -> DelegationsAndRewards
newtype () => CurrentEpochState era
CurrentEpochState :: EpochState (ShelleyLedgerEra era) -> CurrentEpochState era
data () => EraHistory
[EraHistory] :: forall (xs :: [Type]). CardanoBlock StandardCrypto ~ HardForkBlock xs => Interpreter xs -> EraHistory
newtype () => LedgerEpochInfo
LedgerEpochInfo :: EpochInfo (Either Text) -> LedgerEpochInfo
[unLedgerEpochInfo] :: LedgerEpochInfo -> EpochInfo (Either Text)
newtype () => PoolDistribution era
PoolDistribution :: PoolDistr StandardCrypto -> PoolDistribution era
[unPoolDistr] :: PoolDistribution era -> PoolDistr StandardCrypto
newtype () => PoolState era
PoolState :: PState (ShelleyLedgerEra era) -> PoolState era
newtype () => ProtocolState era
ProtocolState :: Serialised (ChainDepState (ConsensusProtocol era)) -> ProtocolState era
data () => QueryInEra era result
[QueryByronUpdateState] :: QueryInEra ByronEra ByronUpdateState
[QueryInShelleyBasedEra] :: forall era result. ShelleyBasedEra era -> QueryInShelleyBasedEra era result -> QueryInEra era result
data () => QueryInMode result
[QueryCurrentEra] :: QueryInMode AnyCardanoEra
[QueryInEra] :: forall era result1. QueryInEra era result1 -> QueryInMode (Either EraMismatch result1)
[QueryEraHistory] :: QueryInMode EraHistory
[QuerySystemStart] :: QueryInMode SystemStart
[QueryChainBlockNo] :: QueryInMode (WithOrigin BlockNo)
[QueryChainPoint] :: QueryInMode ChainPoint
[QueryLedgerConfig] :: QueryInMode (HardForkLedgerConfig (CardanoEras StandardCrypto))
data () => QueryInShelleyBasedEra era result
[QueryEpoch] :: forall era. QueryInShelleyBasedEra era EpochNo
[QueryGenesisParameters] :: forall era. QueryInShelleyBasedEra era (GenesisParameters ShelleyEra)
[QueryProtocolParameters] :: forall era. QueryInShelleyBasedEra era (PParams (ShelleyLedgerEra era))
[QueryStakeDistribution] :: forall era. QueryInShelleyBasedEra era (Map (Hash StakePoolKey) Rational)
[QueryUTxO] :: forall era. QueryUTxOFilter -> QueryInShelleyBasedEra era (UTxO era)
[QueryStakeAddresses] :: forall era. Set StakeCredential -> NetworkId -> QueryInShelleyBasedEra era (Map StakeAddress Coin, Map StakeAddress PoolId)
[QueryStakePools] :: forall era. QueryInShelleyBasedEra era (Set PoolId)
[QueryStakePoolParameters] :: forall era. Set PoolId -> QueryInShelleyBasedEra era (Map PoolId StakePoolParameters)
[QueryDebugLedgerState] :: forall era. QueryInShelleyBasedEra era (SerialisedDebugLedgerState era)
[QueryProtocolState] :: forall era. QueryInShelleyBasedEra era (ProtocolState era)
[QueryCurrentEpochState] :: forall era. QueryInShelleyBasedEra era (SerialisedCurrentEpochState era)
[QueryPoolState] :: forall era. Maybe (Set PoolId) -> QueryInShelleyBasedEra era (SerialisedPoolState era)
[QueryPoolDistribution] :: forall era. Maybe (Set PoolId) -> QueryInShelleyBasedEra era (SerialisedPoolDistribution era)
[QueryStakeSnapshot] :: forall era. Maybe (Set PoolId) -> QueryInShelleyBasedEra era (SerialisedStakeSnapshots era)
[QueryStakeDelegDeposits] :: forall era. Set StakeCredential -> QueryInShelleyBasedEra era (Map StakeCredential Coin)
[QueryAccountState] :: forall era. QueryInShelleyBasedEra era AccountState
[QueryConstitution] :: forall era. QueryInShelleyBasedEra era (Constitution (ShelleyLedgerEra era))
[QueryGovState] :: forall era. QueryInShelleyBasedEra era (GovState (ShelleyLedgerEra era))
[QueryRatifyState] :: forall era. QueryInShelleyBasedEra era (RatifyState (ShelleyLedgerEra era))
[QueryFuturePParams] :: forall era. QueryInShelleyBasedEra era (Maybe (PParams (ShelleyLedgerEra era)))
[QueryDRepState] :: forall era. Set (Credential 'DRepRole) -> QueryInShelleyBasedEra era (Map (Credential 'DRepRole) DRepState)
[QueryDRepStakeDistr] :: forall era. Set DRep -> QueryInShelleyBasedEra era (Map DRep Coin)
[QuerySPOStakeDistr] :: forall era. Set (KeyHash 'StakePool) -> QueryInShelleyBasedEra era (Map (KeyHash 'StakePool) Coin)
[QueryCommitteeMembersState] :: forall era. Set (Credential 'ColdCommitteeRole) -> Set (Credential 'HotCommitteeRole) -> Set MemberStatus -> QueryInShelleyBasedEra era CommitteeMembersState
[QueryStakeVoteDelegatees] :: forall era. Set StakeCredential -> QueryInShelleyBasedEra era (Map StakeCredential DRep)
[QueryProposals] :: forall era. Set GovActionId -> QueryInShelleyBasedEra era (Seq (GovActionState (ShelleyLedgerEra era)))
[QueryLedgerPeerSnapshot] :: forall era. QueryInShelleyBasedEra era (Serialised LedgerPeerSnapshot)
[QueryStakePoolDefaultVote] :: forall era. KeyHash 'StakePool -> QueryInShelleyBasedEra era DefaultVote
data () => QueryUTxOFilter
QueryUTxOWhole :: QueryUTxOFilter
QueryUTxOByAddress :: Set AddressAny -> QueryUTxOFilter
QueryUTxOByTxIn :: Set TxIn -> QueryUTxOFilter
newtype () => SerialisedCurrentEpochState era
SerialisedCurrentEpochState :: Serialised (EpochState (ShelleyLedgerEra era)) -> SerialisedCurrentEpochState era
newtype () => SerialisedDebugLedgerState era
SerialisedDebugLedgerState :: Serialised (NewEpochState (ShelleyLedgerEra era)) -> SerialisedDebugLedgerState era
newtype () => SerialisedPoolDistribution era
SerialisedPoolDistribution :: Serialised (PoolDistr StandardCrypto) -> SerialisedPoolDistribution era
newtype () => SerialisedPoolState era
SerialisedPoolState :: Serialised (PState (ShelleyLedgerEra era)) -> SerialisedPoolState era
newtype () => SerialisedStakeSnapshots era
SerialisedStakeSnapshots :: Serialised StakeSnapshots -> SerialisedStakeSnapshots era
newtype () => SlotsInEpoch
SlotsInEpoch :: Word64 -> SlotsInEpoch
newtype () => SlotsToEpochEnd
SlotsToEpochEnd :: Word64 -> SlotsToEpochEnd
newtype () => StakeSnapshot era
StakeSnapshot :: StakeSnapshots -> StakeSnapshot era
data () => UTxOInAnyEra
[UTxOInAnyEra] :: forall era. CardanoEra era -> UTxO era -> UTxOInAnyEra
data () => Bech32DecodeError
Bech32DecodingError :: !DecodingError -> Bech32DecodeError
Bech32UnexpectedPrefix :: !Text -> !Set Text -> Bech32DecodeError
Bech32DataPartToBytesError :: !Text -> Bech32DecodeError
Bech32DeserialiseFromBytesError :: !ByteString -> Bech32DecodeError
Bech32WrongPrefix :: !Text -> !Text -> Bech32DecodeError
Bech32UnexpectedHeader :: !Text -> !Text -> Bech32DecodeError
class (HasTypeProxy a, SerialiseAsRawBytes a) => SerialiseAsBech32 a
bech32PrefixFor :: SerialiseAsBech32 a => a -> HumanReadablePart
bech32PrefixesPermitted :: SerialiseAsBech32 a => AsType a -> [HumanReadablePart]
class HasTypeProxy a => SerialiseAsCBOR a
serialiseToCBOR :: SerialiseAsCBOR a => a -> ByteString
deserialiseFromCBOR :: SerialiseAsCBOR a => AsType a -> ByteString -> Either DecoderError a
class (SerialiseAsRawBytes a, HasTypeProxy a) => Cip129 a
cip129Bech32PrefixFor :: Cip129 a => AsType a -> HumanReadablePart
cip129HeaderHexByte :: Cip129 a => a -> ByteString
cip129Bech32PrefixesPermitted :: Cip129 a => AsType a -> [Text]
data () => InputDecodeError
InputTextEnvelopeError :: !TextEnvelopeError -> InputDecodeError
InputBech32DecodeError :: !Bech32DecodeError -> InputDecodeError
InputInvalidError :: InputDecodeError
data () => InputFormat a
[InputFormatBech32] :: forall a. SerialiseAsBech32 a => InputFormat a
[InputFormatHex] :: forall a. SerialiseAsRawBytes a => InputFormat a
[InputFormatTextEnvelope] :: forall a. HasTextEnvelope a => InputFormat a
newtype () => JsonDecodeError
JsonDecodeError :: String -> JsonDecodeError
data () => RawBytesHexError
RawBytesHexErrorBase16DecodeFail :: ByteString -> TypeRep -> String -> RawBytesHexError
RawBytesHexErrorRawBytesDecodeFail :: ByteString -> TypeRep -> SerialiseAsRawBytesError -> RawBytesHexError
class (HasTypeProxy a, Typeable a) => SerialiseAsRawBytes a
serialiseToRawBytes :: SerialiseAsRawBytes a => a -> ByteString
deserialiseFromRawBytes :: SerialiseAsRawBytes a => AsType a -> ByteString -> Either SerialiseAsRawBytesError a
newtype () => SerialiseAsRawBytesError
SerialiseAsRawBytesError :: String -> SerialiseAsRawBytesError
[unSerialiseAsRawBytesError] :: SerialiseAsRawBytesError -> String
newtype () => UsingBech32 a
UsingBech32 :: a -> UsingBech32 a
newtype () => UsingRawBytes a
UsingRawBytes :: a -> UsingRawBytes a
newtype () => UsingRawBytesHex a
UsingRawBytesHex :: a -> UsingRawBytesHex a
class SerialiseAsCBOR a => HasTextEnvelope a
textEnvelopeType :: HasTextEnvelope a => AsType a -> TextEnvelopeType
textEnvelopeDefaultDescr :: HasTextEnvelope a => a -> TextEnvelopeDescr
data () => TextEnvelope
TextEnvelope :: !TextEnvelopeType -> !TextEnvelopeDescr -> !ByteString -> TextEnvelope
[teType] :: TextEnvelope -> !TextEnvelopeType
[teDescription] :: TextEnvelope -> !TextEnvelopeDescr
[teRawCBOR] :: TextEnvelope -> !ByteString
newtype () => TextEnvelopeDescr
TextEnvelopeDescr :: String -> TextEnvelopeDescr
data () => TextEnvelopeError
TextEnvelopeTypeError :: ![TextEnvelopeType] -> !TextEnvelopeType -> TextEnvelopeError
TextEnvelopeDecodeError :: !DecoderError -> TextEnvelopeError
TextEnvelopeAesonDecodeError :: !String -> TextEnvelopeError
newtype () => TextEnvelopeType
TextEnvelopeType :: String -> TextEnvelopeType
data () => FromSomeTypeCDDL c b
[FromCDDLTx] :: forall b. Text -> (InAnyShelleyBasedEra Tx -> b) -> FromSomeTypeCDDL TextEnvelope b
[FromCDDLWitness] :: forall b. Text -> (InAnyShelleyBasedEra KeyWitness -> b) -> FromSomeTypeCDDL TextEnvelope b
data () => TextEnvelopeCddlError
TextEnvelopeCddlErrCBORDecodingError :: DecoderError -> TextEnvelopeCddlError
TextEnvelopeCddlAesonDecodeError :: FilePath -> String -> TextEnvelopeCddlError
TextEnvelopeCddlUnknownKeyWitness :: TextEnvelopeCddlError
TextEnvelopeCddlTypeError :: [Text] -> Text -> TextEnvelopeCddlError
TextEnvelopeCddlErrUnknownType :: Text -> TextEnvelopeCddlError
TextEnvelopeCddlErrByronKeyWitnessUnsupported :: TextEnvelopeCddlError
data () => AnyScriptWitness era
[AnyScriptWitness] :: forall witctx era. Typeable witctx => ScriptWitness witctx era -> AnyScriptWitness era
data () => ScriptWitnessIndex
ScriptWitnessIndexTxIn :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexMint :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexCertificate :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexWithdrawal :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexVoting :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexProposing :: !Word32 -> ScriptWitnessIndex
data () => TxBodyError
TxBodyPlutusScriptDecodeError :: DecoderError -> TxBodyError
TxBodyEmptyTxIns :: TxBodyError
TxBodyEmptyTxInsCollateral :: TxBodyError
TxBodyEmptyTxOuts :: TxBodyError
TxBodyOutputError :: !TxOutputError -> TxBodyError
TxBodyMetadataError :: ![(Word64, TxMetadataRangeError)] -> TxBodyError
TxBodyInIxOverflow :: !TxIn -> TxBodyError
TxBodyMissingProtocolParams :: TxBodyError
TxBodyProtocolParamsConversionError :: !ProtocolParametersConversionError -> TxBodyError
data () => TxCertificates build era
[TxCertificatesNone] :: forall build era. TxCertificates build era
[TxCertificates] :: forall era build. ShelleyBasedEra era -> OMap (Certificate era) (BuildTxWith build (Maybe (StakeCredential, Witness WitCtxStake era))) -> TxCertificates build era
type TxInsReferenceDatums build = BuildTxWith build Set HashableScriptData
data () => TxProposalProcedures build era
[TxProposalProceduresNone] :: forall build era. TxProposalProcedures build era
[TxProposalProcedures] :: forall era build. EraPParams (ShelleyLedgerEra era) => OMap (ProposalProcedure (ShelleyLedgerEra era)) (BuildTxWith build (Maybe (ScriptWitness WitCtxStake era))) -> TxProposalProcedures build era
data () => TxReturnCollateral ctx era
[TxReturnCollateralNone] :: forall ctx era. TxReturnCollateral ctx era
[TxReturnCollateral] :: forall era ctx. BabbageEraOnwards era -> TxOut ctx era -> TxReturnCollateral ctx era
data () => TxTotalCollateral era
[TxTotalCollateralNone] :: forall era. TxTotalCollateral era
[TxTotalCollateral] :: forall era. BabbageEraOnwards era -> Coin -> TxTotalCollateral era
data () => TxUpdateProposal era
[TxUpdateProposalNone] :: forall era. TxUpdateProposal era
[TxUpdateProposal] :: forall era. ShelleyToBabbageEra era -> UpdateProposal -> TxUpdateProposal era
data () => TxVotingProcedures build era
[TxVotingProceduresNone] :: forall build era. TxVotingProcedures build era
[TxVotingProcedures] :: forall era build. VotingProcedures (ShelleyLedgerEra era) -> BuildTxWith build (Map Voter (ScriptWitness WitCtxStake era)) -> TxVotingProcedures build era
data () => TxWithdrawals build era
[TxWithdrawalsNone] :: forall build era. TxWithdrawals build era
[TxWithdrawals] :: forall era build. ShelleyBasedEra era -> [(StakeAddress, Coin, BuildTxWith build (Witness WitCtxStake era))] -> TxWithdrawals build era
newtype () => LedgerTxBody era
LedgerTxBody :: TxBody (ShelleyLedgerEra era) -> LedgerTxBody era
[unTxBody] :: LedgerTxBody era -> TxBody (ShelleyLedgerEra era)
data () => BuildTx
data () => BuildTxWith build a
[ViewTx] :: forall a. BuildTxWith ViewTx a
[BuildTxWith] :: forall a. a -> BuildTxWith BuildTx a
data () => ViewTx
newtype () => ScriptLockedTxInsError
ScriptLockedTxIns :: [TxIn] -> ScriptLockedTxInsError
data () => TxInsExistError
TxInsDoNotExist :: [TxIn] -> TxInsExistError
EmptyUTxO :: TxInsExistError
data () => AutoBalanceError era
AutoBalanceEstimationError :: TxFeeEstimationError era -> AutoBalanceError era
AutoBalanceCalculationError :: TxBodyErrorAutoBalance era -> AutoBalanceError era
data () => FeeEstimationMode era
CalculateWithSpendableUTxO :: UTxO era -> SystemStart -> LedgerEpochInfo -> Maybe Word -> FeeEstimationMode era
EstimateWithoutSpendableUTxO :: Coin -> Value -> Map ScriptWitnessIndex ExecutionUnits -> RequiredShelleyKeyWitnesses -> RequiredByronKeyWitnesses -> TotalReferenceScriptsSize -> FeeEstimationMode era
newtype () => RequiredByronKeyWitnesses
RequiredByronKeyWitnesses :: Int -> RequiredByronKeyWitnesses
[unRequiredByronKeyWitnesses] :: RequiredByronKeyWitnesses -> Int
newtype () => RequiredShelleyKeyWitnesses
RequiredShelleyKeyWitnesses :: Int -> RequiredShelleyKeyWitnesses
[unRequiredShelleyKeyWitnesses] :: RequiredShelleyKeyWitnesses -> Int
data () => ResolvablePointers
[ResolvablePointers] :: forall era. (Era (ShelleyLedgerEra era), Show (PlutusPurpose AsIx (ShelleyLedgerEra era)), Show (PlutusPurpose AsItem (ShelleyLedgerEra era)), Show (PlutusScript (ShelleyLedgerEra era))) => ShelleyBasedEra era -> !Map (PlutusPurpose AsIx (ShelleyLedgerEra era)) (PlutusPurpose AsItem (ShelleyLedgerEra era), Maybe (PlutusScriptBytes, Language), ScriptHash) -> ResolvablePointers
data () => ScriptExecutionError
ScriptErrorMissingTxIn :: TxIn -> ScriptExecutionError
ScriptErrorTxInWithoutDatum :: TxIn -> ScriptExecutionError
ScriptErrorWrongDatum :: Hash ScriptData -> ScriptExecutionError
ScriptErrorEvaluationFailed :: DebugPlutusFailure -> ScriptExecutionError
ScriptErrorExecutionUnitsOverflow :: ScriptExecutionError
ScriptErrorNotPlutusWitnessedTxIn :: ScriptWitnessIndex -> ScriptHash -> ScriptExecutionError
ScriptErrorRedeemerPointsToUnknownScriptHash :: ScriptWitnessIndex -> ScriptExecutionError
ScriptErrorMissingScript :: ScriptWitnessIndex -> ResolvablePointers -> ScriptExecutionError
ScriptErrorMissingCostModel :: Language -> ScriptExecutionError
ScriptErrorTranslationError :: ContextError (ShelleyLedgerEra era) -> ScriptExecutionError
newtype () => TotalReferenceScriptsSize
TotalReferenceScriptsSize :: Int -> TotalReferenceScriptsSize
[unTotalReferenceScriptsSize] :: TotalReferenceScriptsSize -> Int
data () => TransactionValidityError era
[TransactionValidityIntervalError] :: forall era. PastHorizonException -> TransactionValidityError era
[TransactionValidityCostModelError] :: forall era. Map AnyPlutusScriptVersion CostModel -> String -> TransactionValidityError era
data () => TxBodyErrorAutoBalance era
TxBodyError :: TxBodyError -> TxBodyErrorAutoBalance era
TxBodyScriptExecutionError :: [(ScriptWitnessIndex, ScriptExecutionError)] -> TxBodyErrorAutoBalance era
TxBodyScriptBadScriptValidity :: TxBodyErrorAutoBalance era
TxBodyErrorBalanceNegative :: Coin -> MultiAsset -> TxBodyErrorAutoBalance era
TxBodyErrorAdaBalanceTooSmall :: TxOutInAnyEra -> Coin -> Coin -> TxBodyErrorAutoBalance era
TxBodyErrorByronEraNotSupported :: TxBodyErrorAutoBalance era
TxBodyErrorMissingParamMinUTxO :: TxBodyErrorAutoBalance era
TxBodyErrorMinUTxONotMet :: TxOutInAnyEra -> Coin -> TxBodyErrorAutoBalance era
TxBodyErrorNonAdaAssetsUnbalanced :: Value -> TxBodyErrorAutoBalance era
TxBodyErrorScriptWitnessIndexMissingFromExecUnitsMap :: ScriptWitnessIndex -> Map ScriptWitnessIndex ExecutionUnits -> TxBodyErrorAutoBalance era
data () => TxFeeEstimationError era
TxFeeEstimationTransactionTranslationError :: TransactionValidityError era -> TxFeeEstimationError era
TxFeeEstimationScriptExecutionError :: TxBodyErrorAutoBalance era -> TxFeeEstimationError era
TxFeeEstimationBalanceError :: TxBodyErrorAutoBalance era -> TxFeeEstimationError era
TxFeeEstimationxBodyError :: TxBodyError -> TxFeeEstimationError era
TxFeeEstimationFinalConstructionError :: TxBodyError -> TxFeeEstimationError era
TxFeeEstimationOnlyMaryOnwardsSupportedError :: TxFeeEstimationError era
data () => CtxTx
data () => CtxUTxO
data () => TxOutInAnyEra
[TxOutInAnyEra] :: forall era. CardanoEra era -> TxOut CtxTx era -> TxOutInAnyEra
data () => TxOutputError
TxOutputNegative :: !Quantity -> !TxOutInAnyEra -> TxOutputError
TxOutputOverflow :: !Quantity -> !TxOutInAnyEra -> TxOutputError
data () => ScriptValidity
ScriptInvalid :: ScriptValidity
ScriptValid :: ScriptValidity
data () => ShelleySigningKey
ShelleyNormalSigningKey :: SignKeyDSIGN DSIGN -> ShelleySigningKey
ShelleyExtendedSigningKey :: XPrv -> ShelleySigningKey
data () => ShelleyWitnessSigningKey
WitnessPaymentKey :: SigningKey PaymentKey -> ShelleyWitnessSigningKey
WitnessPaymentExtendedKey :: SigningKey PaymentExtendedKey -> ShelleyWitnessSigningKey
WitnessStakeKey :: SigningKey StakeKey -> ShelleyWitnessSigningKey
WitnessStakeExtendedKey :: SigningKey StakeExtendedKey -> ShelleyWitnessSigningKey
WitnessStakePoolKey :: SigningKey StakePoolKey -> ShelleyWitnessSigningKey
WitnessStakePoolExtendedKey :: SigningKey StakePoolExtendedKey -> ShelleyWitnessSigningKey
WitnessGenesisKey :: SigningKey GenesisKey -> ShelleyWitnessSigningKey
WitnessGenesisExtendedKey :: SigningKey GenesisExtendedKey -> ShelleyWitnessSigningKey
WitnessGenesisDelegateKey :: SigningKey GenesisDelegateKey -> ShelleyWitnessSigningKey
WitnessGenesisDelegateExtendedKey :: SigningKey GenesisDelegateExtendedKey -> ShelleyWitnessSigningKey
WitnessGenesisUTxOKey :: SigningKey GenesisUTxOKey -> ShelleyWitnessSigningKey
WitnessCommitteeColdKey :: SigningKey CommitteeColdKey -> ShelleyWitnessSigningKey
WitnessCommitteeColdExtendedKey :: SigningKey CommitteeColdExtendedKey -> ShelleyWitnessSigningKey
WitnessCommitteeHotKey :: SigningKey CommitteeHotKey -> ShelleyWitnessSigningKey
WitnessCommitteeHotExtendedKey :: SigningKey CommitteeHotExtendedKey -> ShelleyWitnessSigningKey
WitnessDRepKey :: SigningKey DRepKey -> ShelleyWitnessSigningKey
WitnessDRepExtendedKey :: SigningKey DRepExtendedKey -> ShelleyWitnessSigningKey
data () => WitnessNetworkIdOrByronAddress
WitnessNetworkId :: !NetworkId -> WitnessNetworkIdOrByronAddress
WitnessByronAddress :: !Address ByronAddr -> WitnessNetworkIdOrByronAddress
newtype () => TxIx
TxIx :: Word -> TxIx
newtype () => TxMetadata
TxMetadata :: Map Word64 TxMetadataValue -> TxMetadata
[unTxMetadata] :: TxMetadata -> Map Word64 TxMetadataValue
data () => TxMetadataJsonError
TxMetadataJsonToplevelNotMap :: TxMetadataJsonError
TxMetadataJsonToplevelBadKey :: !Text -> TxMetadataJsonError
TxMetadataJsonSchemaError :: !Word64 -> !Value -> !TxMetadataJsonSchemaError -> TxMetadataJsonError
TxMetadataRangeError :: !Word64 -> !Value -> !TxMetadataRangeError -> TxMetadataJsonError
data () => TxMetadataJsonSchema
TxMetadataJsonNoSchema :: TxMetadataJsonSchema
TxMetadataJsonDetailedSchema :: TxMetadataJsonSchema
data () => TxMetadataJsonSchemaError
TxMetadataJsonNullNotAllowed :: TxMetadataJsonSchemaError
TxMetadataJsonBoolNotAllowed :: TxMetadataJsonSchemaError
TxMetadataJsonNumberNotInteger :: !Double -> TxMetadataJsonSchemaError
TxMetadataJsonNotObject :: !Value -> TxMetadataJsonSchemaError
TxMetadataJsonBadObject :: ![(Text, Value)] -> TxMetadataJsonSchemaError
TxMetadataJsonBadMapPair :: !Value -> TxMetadataJsonSchemaError
TxMetadataJsonTypeMismatch :: !Text -> !Value -> TxMetadataJsonSchemaError
data () => TxMetadataRangeError
TxMetadataNumberOutOfRange :: !Integer -> TxMetadataRangeError
TxMetadataTextTooLong :: !Int -> TxMetadataRangeError
TxMetadataBytesTooLong :: !Int -> TxMetadataRangeError
data () => TxMetadataValue
TxMetaMap :: [(TxMetadataValue, TxMetadataValue)] -> TxMetadataValue
TxMetaList :: [TxMetadataValue] -> TxMetadataValue
TxMetaNumber :: Integer -> TxMetadataValue
TxMetaBytes :: ByteString -> TxMetadataValue
TxMetaText :: Text -> TxMetadataValue
data () => AssetId
AdaAssetId :: AssetId
AssetId :: !PolicyId -> !AssetName -> AssetId
newtype () => AssetName
UnsafeAssetName :: ByteString -> AssetName
type Lovelace = Coin
newtype () => Quantity
Quantity :: Integer -> Quantity
data () => ValueNestedBundle
ValueNestedBundleAda :: Quantity -> ValueNestedBundle
ValueNestedBundle :: PolicyId -> Map AssetName Quantity -> ValueNestedBundle
newtype () => ValueNestedRep
ValueNestedRep :: [ValueNestedBundle] -> ValueNestedRep
class () => FromJSONKey a
class () => ToJSONKey a
class Typeable a => FromCBOR a
fromCBOR :: FromCBOR a => Decoder s a
label :: FromCBOR a => Proxy a -> Text
data () => CommitteeMembersState
CommitteeMembersState :: !Map (Credential 'ColdCommitteeRole) CommitteeMemberState -> !Maybe UnitInterval -> !EpochNo -> CommitteeMembersState
[csCommittee] :: CommitteeMembersState -> !Map (Credential 'ColdCommitteeRole) CommitteeMemberState
[csThreshold] :: CommitteeMembersState -> !Maybe UnitInterval
[csEpochNo] :: CommitteeMembersState -> !EpochNo
data () => MemberStatus
Active :: MemberStatus
Expired :: MemberStatus
Unrecognized :: MemberStatus
newtype () => EpochSlots
EpochSlots :: Word64 -> EpochSlots
[unEpochSlots] :: EpochSlots -> Word64
data () => ATxAux a
ATxAux :: !Annotated Tx a -> !Annotated TxWitness a -> !a -> ATxAux a
[aTaTx] :: ATxAux a -> !Annotated Tx a
[aTaWitness] :: ATxAux a -> !Annotated TxWitness a
[aTaAnnotation] :: ATxAux a -> !a
class () => Inject t s
inject :: Inject t s => t -> s
newtype () => Coin
Coin :: Integer -> Coin
[unCoin] :: Coin -> Integer
data () => ShelleyGenesis
ShelleyGenesis :: !UTCTime -> !Word32 -> !Network -> !PositiveUnitInterval -> !NonZero Word64 -> !EpochSize -> !Word64 -> !Word64 -> !NominalDiffTimeMicro -> !Word64 -> !Word64 -> !PParams ShelleyEra -> !Map (KeyHash 'Genesis) GenDelegPair -> ListMap Addr Coin -> ShelleyGenesisStaking -> ShelleyGenesis
[sgSystemStart] :: ShelleyGenesis -> !UTCTime
[sgNetworkMagic] :: ShelleyGenesis -> !Word32
[sgNetworkId] :: ShelleyGenesis -> !Network
[sgActiveSlotsCoeff] :: ShelleyGenesis -> !PositiveUnitInterval
[sgSecurityParam] :: ShelleyGenesis -> !NonZero Word64
[sgEpochLength] :: ShelleyGenesis -> !EpochSize
[sgSlotsPerKESPeriod] :: ShelleyGenesis -> !Word64
[sgMaxKESEvolutions] :: ShelleyGenesis -> !Word64
[sgSlotLength] :: ShelleyGenesis -> !NominalDiffTimeMicro
[sgUpdateQuorum] :: ShelleyGenesis -> !Word64
[sgMaxLovelaceSupply] :: ShelleyGenesis -> !Word64
[sgProtocolParams] :: ShelleyGenesis -> !PParams ShelleyEra
[sgGenDelegs] :: ShelleyGenesis -> !Map (KeyHash 'Genesis) GenDelegPair
[sgInitialFunds] :: ShelleyGenesis -> ListMap Addr Coin
[sgStaking] :: ShelleyGenesis -> ShelleyGenesisStaking
data () => ShelleyGenesisStaking
ShelleyGenesisStaking :: ListMap (KeyHash 'StakePool) PoolParams -> ListMap (KeyHash 'Staking) (KeyHash 'StakePool) -> ShelleyGenesisStaking
[sgsPools] :: ShelleyGenesisStaking -> ListMap (KeyHash 'StakePool) PoolParams
[sgsStake] :: ShelleyGenesisStaking -> ListMap (KeyHash 'Staking) (KeyHash 'StakePool)
data () => MIRPot
ReservesMIR :: MIRPot
TreasuryMIR :: MIRPot
data () => MIRTarget
StakeAddressesMIR :: !Map (Credential 'Staking) DeltaCoin -> MIRTarget
SendToOppositePotMIR :: !Coin -> MIRTarget
newtype () => KESPeriod
KESPeriod :: Word -> KESPeriod
[unKESPeriod] :: KESPeriod -> Word
newtype () => BlockNo
BlockNo :: Word64 -> BlockNo
[unBlockNo] :: BlockNo -> Word64
newtype () => EpochNo
EpochNo :: Word64 -> EpochNo
[unEpochNo] :: EpochNo -> Word64
newtype () => EpochSize
EpochSize :: Word64 -> EpochSize
[unEpochSize] :: EpochSize -> Word64
newtype () => SlotNo
SlotNo :: Word64 -> SlotNo
[unSlotNo] :: SlotNo -> Word64
newtype () => SystemStart
SystemStart :: UTCTime -> SystemStart
[getSystemStart] :: SystemStart -> UTCTime
data () => EraMismatch
EraMismatch :: !Text -> !Text -> EraMismatch
[ledgerEraName] :: EraMismatch -> !Text
[otherEraName] :: EraMismatch -> !Text
data () => PastHorizonException
data family GenTx blk
type family ChainDepState p
type family ChainDepState p
class ConsensusProtocol p => PraosProtocolSupportsNode p where {
    type family PraosProtocolSupportsNodeCrypto p;
}
getOpCertCounters :: PraosProtocolSupportsNode p => proxy p -> ChainDepState p -> Map (KeyHash 'BlockIssuer) Word64
type family PraosProtocolSupportsNodeCrypto p
newtype () => Serialised (a :: k)
Serialised :: ByteString -> Serialised (a :: k)
[unSerialised] :: Serialised (a :: k) -> ByteString
data () => NodeToClientVersion
NodeToClientV_16 :: NodeToClientVersion
NodeToClientV_17 :: NodeToClientVersion
NodeToClientV_18 :: NodeToClientVersion
NodeToClientV_19 :: NodeToClientVersion
NodeToClientV_20 :: NodeToClientVersion
data () => LedgerPeerSnapshot
LedgerPeerSnapshotV1 :: (WithOrigin SlotNo, [(AccPoolStake, (PoolStake, NonEmpty RelayAccessPoint))]) -> LedgerPeerSnapshot
pattern LedgerPeerSnapshot :: (WithOrigin SlotNo, [(AccPoolStake, (PoolStake, NonEmpty RelayAccessPoint))]) -> LedgerPeerSnapshot
newtype () => ChainSyncClient header point tip (m :: Type -> Type) a
ChainSyncClient :: m (ClientStIdle header point tip m a) -> ChainSyncClient header point tip (m :: Type -> Type) a
[runChainSyncClient] :: ChainSyncClient header point tip (m :: Type -> Type) a -> m (ClientStIdle header point tip m a)
newtype () => ChainSyncClientPipelined header point tip (m :: Type -> Type) a
ChainSyncClientPipelined :: m (ClientPipelinedStIdle 'Z header point tip m a) -> ChainSyncClientPipelined header point tip (m :: Type -> Type) a
[runChainSyncClientPipelined] :: ChainSyncClientPipelined header point tip (m :: Type -> Type) a -> m (ClientPipelinedStIdle 'Z header point tip m a)
newtype () => LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a
LocalStateQueryClient :: m (ClientStIdle block point query m a) -> LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a
[runLocalStateQueryClient] :: LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a -> m (ClientStIdle block point query m a)
data () => Target point
VolatileTip :: Target point
SpecificPoint :: point -> Target point
ImmutableTip :: Target point
newtype () => LocalTxMonitorClient txid tx slot (m :: Type -> Type) a
LocalTxMonitorClient :: m (ClientStIdle txid tx slot m a) -> LocalTxMonitorClient txid tx slot (m :: Type -> Type) a
[runLocalTxMonitorClient] :: LocalTxMonitorClient txid tx slot (m :: Type -> Type) a -> m (ClientStIdle txid tx slot m a)
data () => MempoolSizeAndCapacity
MempoolSizeAndCapacity :: !Word32 -> !Word32 -> !Word32 -> MempoolSizeAndCapacity
[capacityInBytes] :: MempoolSizeAndCapacity -> !Word32
[sizeInBytes] :: MempoolSizeAndCapacity -> !Word32
[numberOfTxs] :: MempoolSizeAndCapacity -> !Word32
newtype () => LocalTxSubmissionClient tx reject (m :: Type -> Type) a
LocalTxSubmissionClient :: m (LocalTxClientStIdle tx reject m a) -> LocalTxSubmissionClient tx reject (m :: Type -> Type) a
[runLocalTxSubmissionClient] :: LocalTxSubmissionClient tx reject (m :: Type -> Type) a -> m (LocalTxClientStIdle tx reject m a)
data () => SubmitResult reason
SubmitSuccess :: SubmitResult reason
SubmitFail :: reason -> SubmitResult reason
pattern Block :: BlockHeader -> [Tx era] -> Block era
prettyShow :: Pretty a => a -> String
left :: forall (m :: Type -> Type) x a. Monad m => x -> ExceptT x m a
right :: forall (m :: Type -> Type) a x. Monad m => a -> ExceptT x m a

-- | Signal an exception value <tt>e</tt>.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>throwE</a> e) = <a>return</a>
--   (<a>Left</a> e)</pre></li>
--   <li><pre><a>throwE</a> e &gt;&gt;= m = <a>throwE</a> e</pre></li>
--   </ul>
throwE :: forall (m :: Type -> Type) e a. Monad m => e -> ExceptT e m a

-- | Extractor for computations in the exception monad. (The inverse of
--   <a>except</a>).
runExcept :: Except e a -> Either e a

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExcept</a> (<a>mapExcept</a> f m) = f (<a>runExcept</a>
--   m)</pre></li>
--   </ul>
mapExcept :: (Either e a -> Either e' b) -> Except e a -> Except e' b

-- | Transform any exceptions thrown by the computation using the given
--   function (a specialization of <a>withExceptT</a>).
withExcept :: (e -> e') -> Except e a -> Except e' a

-- | The inverse of <a>ExceptT</a>.
runExceptT :: ExceptT e m a -> m (Either e a)

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>mapExceptT</a> f m) = f
--   (<a>runExceptT</a> m)</pre></li>
--   </ul>
mapExceptT :: (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b

-- | Transform any exceptions thrown by the computation using the given
--   function.
withExceptT :: forall (m :: Type -> Type) e e' a. Functor m => (e -> e') -> ExceptT e m a -> ExceptT e' m a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: CallCC m (Either e a) (Either e b) -> CallCC (ExceptT e m) a b

-- | Lifts an <tt><a>Either</a> e</tt> into any <tt><a>MonadError</a>
--   e</tt>.
--   
--   <pre>
--   do { val &lt;- liftEither =&lt;&lt; action1; action2 }
--   </pre>
--   
--   where <tt>action1</tt> returns an <a>Either</a> to represent errors.
liftEither :: MonadError e m => Either e a -> m a
modifyError :: forall e' t (m :: Type -> Type) e a. MonadTransError e' t m => (e -> e') -> ExceptT e m a -> t m a
hsep :: [Doc ann] -> Doc ann

-- | Handle an exception.
--   
--   <ul>
--   <li><pre><a>catchE</a> (<a>lift</a> m) h = <a>lift</a> m</pre></li>
--   <li><pre><a>catchE</a> (<a>throwE</a> e) h = h e</pre></li>
--   </ul>
catchE :: forall (m :: Type -> Type) e a e'. Monad m => ExceptT e m a -> (e -> ExceptT e' m a) -> ExceptT e' m a

-- | Constructor for computations in the exception monad. (The inverse of
--   <a>runExcept</a>).
except :: forall (m :: Type -> Type) e a. Monad m => Either e a -> ExceptT e m a

-- | The same as <tt><a>flip</a> <a>catchE</a></tt>, which is useful in
--   situations where the code for the handler is shorter.
handleE :: forall (m :: Type -> Type) e e' a. Monad m => (e -> ExceptT e' m a) -> ExceptT e m a -> ExceptT e' m a

-- | Similar to <a>catchE</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception was thown, or
--   <tt>(<a>Left</a> ex)</tt> if an exception <tt>ex</tt> was thrown.
tryE :: forall (m :: Type -> Type) e a. Monad m => ExceptT e m a -> ExceptT e m (Either e a)

-- | <tt><a>finallyE</a> a b</tt> executes computation <tt>a</tt> followed
--   by computation <tt>b</tt>, even if <tt>a</tt> exits early by throwing
--   an exception. In the latter case, the exception is re-thrown after
--   <tt>b</tt> has been executed.
finallyE :: forall (m :: Type -> Type) e a. Monad m => ExceptT e m a -> ExceptT e m () -> ExceptT e m a

-- | Lift a <tt>listen</tt> operation to the new monad.
liftListen :: Monad m => Listen w m (Either e a) -> Listen w (ExceptT e m) a

-- | Lift a <tt>pass</tt> operation to the new monad.
liftPass :: Monad m => Pass w m (Either e a) -> Pass w (ExceptT e m) a
hoistMaybe :: forall (m :: Type -> Type) x a. Monad m => x -> Maybe a -> ExceptT x m a
anyAddressInEra :: CardanoEra era -> AddressAny -> Either String (AddressInEra era)
anyAddressInShelleyBasedEra :: ShelleyBasedEra era -> AddressAny -> AddressInEra era
byronAddressInEra :: Address ByronAddr -> AddressInEra era
fromShelleyAddr :: ShelleyBasedEra era -> Addr -> AddressInEra era
fromShelleyAddrIsSbe :: ShelleyBasedEra era -> Addr -> AddressInEra era
fromShelleyAddrToAny :: Addr -> AddressAny
fromShelleyPaymentCredential :: PaymentCredential -> PaymentCredential
fromShelleyStakeAddr :: RewardAccount -> StakeAddress
fromShelleyStakeCredential :: StakeCredential -> StakeCredential
fromShelleyStakeReference :: StakeReference -> StakeAddressReference
isKeyAddress :: AddressInEra era -> Bool
makeByronAddress :: NetworkId -> VerificationKey ByronKey -> Address ByronAddr
makeByronAddressInEra :: NetworkId -> VerificationKey ByronKey -> AddressInEra era
makeShelleyAddress :: NetworkId -> PaymentCredential -> StakeAddressReference -> Address ShelleyAddr
makeShelleyAddressInEra :: ShelleyBasedEra era -> NetworkId -> PaymentCredential -> StakeAddressReference -> AddressInEra era
makeStakeAddress :: NetworkId -> StakeCredential -> StakeAddress
parseAddressAny :: SerialiseAddress addr => Parser addr
shelleyAddressInEra :: ShelleyBasedEra era -> Address ShelleyAddr -> AddressInEra era
shelleyPayAddrToPlutusPubKHash :: Address ShelleyAddr -> Maybe PubKeyHash
stakeAddressCredential :: StakeAddress -> StakeCredential
toAddressAny :: Address addr -> AddressAny
toShelleyAddr :: AddressInEra era -> Addr
toShelleyStakeAddr :: StakeAddress -> RewardAccount
toShelleyStakeCredential :: StakeCredential -> StakeCredential
chainPointToHeaderHash :: ChainPoint -> Maybe (Hash BlockHeader)
chainPointToSlotNo :: ChainPoint -> Maybe SlotNo
chainTipToChainPoint :: ChainTip -> ChainPoint
fromConsensusBlock :: CardanoBlock StandardCrypto ~ block => block -> BlockInMode
fromConsensusPoint :: ShelleyCompatible protocol ledgerera => Point (ShelleyBlock protocol ledgerera) -> ChainPoint
fromConsensusPointHF :: forall block (xs :: [Type]). HeaderHash block ~ OneEraHash xs => Point block -> ChainPoint
fromConsensusTip :: CardanoBlock StandardCrypto ~ block => Tip block -> ChainTip
getBlockHeader :: Block era -> BlockHeader
getBlockTxs :: Block era -> [Tx era]
makeChainTip :: WithOrigin BlockNo -> ChainPoint -> ChainTip
toConsensusBlock :: CardanoBlock StandardCrypto ~ block => BlockInMode -> block
toConsensusPoint :: forall ledgerera protocol. ShelleyCompatible protocol ledgerera => ChainPoint -> Point (ShelleyBlock protocol ledgerera)
toConsensusPointHF :: forall block (xs :: [Type]). HeaderHash block ~ OneEraHash xs => ChainPoint -> Point block
fromShelleyCertificate :: ShelleyBasedEra era -> TxCert (ShelleyLedgerEra era) -> Certificate era
fromShelleyPoolParams :: PoolParams -> StakePoolParameters
getAnchorDataFromCertificate :: Certificate era -> Either AnchorDataFromCertificateError (Maybe Anchor)
makeCommitteeColdkeyResignationCertificate :: Typeable era => CommitteeColdkeyResignationRequirements era -> Certificate era
makeCommitteeHotKeyAuthorizationCertificate :: Typeable era => CommitteeHotKeyAuthorizationRequirements era -> Certificate era
makeDrepRegistrationCertificate :: Typeable era => DRepRegistrationRequirements era -> Maybe Anchor -> Certificate era
makeDrepUnregistrationCertificate :: Typeable era => DRepUnregistrationRequirements era -> Certificate era
makeDrepUpdateCertificate :: Typeable era => DRepUpdateRequirements era -> Maybe Anchor -> Certificate era
makeGenesisKeyDelegationCertificate :: Typeable era => GenesisKeyDelegationRequirements era -> Certificate era
makeMIRCertificate :: Typeable era => MirCertificateRequirements era -> Certificate era
makeStakeAddressAndDRepDelegationCertificate :: ConwayEraOnwards era -> StakeCredential -> Delegatee -> Coin -> Certificate era
makeStakeAddressDelegationCertificate :: StakeDelegationRequirements era -> Certificate era
makeStakeAddressRegistrationCertificate :: StakeAddressRequirements era -> Certificate era
makeStakeAddressUnregistrationCertificate :: StakeAddressRequirements era -> Certificate era
makeStakePoolRegistrationCertificate :: StakePoolRegistrationRequirements era -> Certificate era
makeStakePoolRetirementCertificate :: StakePoolRetirementRequirements era -> Certificate era
selectStakeCredentialWitness :: Certificate era -> Maybe StakeCredential
toShelleyCertificate :: Certificate era -> TxCert (ShelleyLedgerEra era)
toShelleyPoolParams :: StakePoolParameters -> PoolParams
hashDRepMetadata :: ByteString -> (DRepMetadata, Hash DRepMetadata)
getHotKey :: OperationalCertificate -> VerificationKey KesKey
getKesPeriod :: OperationalCertificate -> Word
getOpCertCount :: OperationalCertificate -> Word64
issueOperationalCertificate :: VerificationKey KesKey -> Either AnyStakePoolSigningKey (SigningKey GenesisDelegateExtendedKey) -> KESPeriod -> OperationalCertificateIssueCounter -> Either OperationalCertIssueError (OperationalCertificate, OperationalCertificateIssueCounter)
validateAndHashStakePoolMetadata :: ByteString -> Either StakePoolMetadataValidationError (StakePoolMetadata, Hash StakePoolMetadata)
fromConsensusApplyTxErr :: CardanoBlock StandardCrypto ~ block => ApplyTxErr block -> TxValidationErrorInCardanoMode
fromConsensusGenTx :: CardanoBlock StandardCrypto ~ block => GenTx block -> TxInMode
toConsensusGenTx :: CardanoBlock StandardCrypto ~ block => TxInMode -> GenTx block
toConsensusTxId :: CardanoBlock StandardCrypto ~ block => TxIdInMode -> TxId (GenTx block)
fromConsensusEraIndex :: EraIndex (CardanoEras StandardCrypto) -> AnyCardanoEra
toConsensusEraIndex :: forall (xs :: [Type]) era. CardanoBlock StandardCrypto ~ HardForkBlock xs => CardanoEra era -> EraIndex xs
reflBlockType :: BlockType blk -> BlockType blk' -> Maybe (blk :~: blk')
caseByronOrShelleyBasedEra :: a -> (ShelleyBasedEraConstraints era => ShelleyBasedEra era -> a) -> CardanoEra era -> a
caseByronToAlonzoOrBabbageEraOnwards :: (ByronToAlonzoEraConstraints era => ByronToAlonzoEra era -> a) -> (BabbageEraOnwardsConstraints era => BabbageEraOnwards era -> a) -> CardanoEra era -> a
caseShelleyToAllegraOrMaryEraOnwards :: (ShelleyToAllegraEraConstraints era => ShelleyToAllegraEra era -> a) -> (MaryEraOnwardsConstraints era => MaryEraOnwards era -> a) -> ShelleyBasedEra era -> a
caseShelleyToAlonzoOrBabbageEraOnwards :: (ShelleyToAlonzoEraConstraints era => ShelleyToAlonzoEra era -> a) -> (BabbageEraOnwardsConstraints era => BabbageEraOnwards era -> a) -> ShelleyBasedEra era -> a
caseShelleyToBabbageOrConwayEraOnwards :: (ShelleyToBabbageEraConstraints era => ShelleyToBabbageEra era -> a) -> (ConwayEraOnwardsConstraints era => ConwayEraOnwards era -> a) -> ShelleyBasedEra era -> a
caseShelleyToMaryOrAlonzoEraOnwards :: (ShelleyToMaryEraConstraints era => ShelleyToMaryEra era -> a) -> (AlonzoEraOnwardsConstraints era => AlonzoEraOnwards era -> a) -> ShelleyBasedEra era -> a
anyCardanoEra :: CardanoEra era -> AnyCardanoEra
cardanoEraConstraints :: CardanoEra era -> (CardanoEraConstraints era => a) -> a
forEraInEon :: Eon eon => CardanoEra era -> a -> (eon era -> a) -> a
forEraInEonMaybe :: Eon eon => CardanoEra era -> (eon era -> a) -> Maybe a
forEraMaybeEon :: Eon eon => CardanoEra era -> Maybe (eon era)
inAnyCardanoEra :: CardanoEra era -> thing era -> InAnyCardanoEra thing
inEonForEraMaybe :: Eon eon => (eon era -> a) -> CardanoEra era -> Maybe a
maybeEon :: (Eon eon, IsCardanoEra era) => Maybe (eon era)
monoidForEraInEon :: (Eon eon, Monoid a) => CardanoEra era -> (eon era -> a) -> a
monoidForEraInEonA :: (Eon eon, Applicative f, Monoid a) => CardanoEra era -> (eon era -> f a) -> f a
allegraEraOnwardsConstraints :: AllegraEraOnwards era -> (AllegraEraOnwardsConstraints era => a) -> a
allegraEraOnwardsToShelleyBasedEra :: AllegraEraOnwards era -> ShelleyBasedEra era
alonzoEraOnwardsConstraints :: AlonzoEraOnwards era -> (AlonzoEraOnwardsConstraints era => a) -> a
alonzoEraOnwardsToShelleyBasedEra :: AlonzoEraOnwards era -> ShelleyBasedEra era
babbageEraOnwardsConstraints :: BabbageEraOnwards era -> (BabbageEraOnwardsConstraints era => a) -> a
babbageEraOnwardsToShelleyBasedEra :: BabbageEraOnwards era -> ShelleyBasedEra era
byronToAlonzoEraConstraints :: ByronToAlonzoEra era -> (ByronToAlonzoEraConstraints era => a) -> a
conwayEraOnwardsConstraints :: ConwayEraOnwards era -> (ConwayEraOnwardsConstraints era => a) -> a
conwayEraOnwardsToBabbageEraOnwards :: ConwayEraOnwards era -> BabbageEraOnwards era
conwayEraOnwardsToShelleyBasedEra :: ConwayEraOnwards era -> ShelleyBasedEra era
maryEraOnwardsConstraints :: MaryEraOnwards era -> (MaryEraOnwardsConstraints era => a) -> a
maryEraOnwardsToShelleyBasedEra :: MaryEraOnwards era -> ShelleyBasedEra era
eraProtVerLow :: ShelleyBasedEra era -> Version
forShelleyBasedEraInEon :: Eon eon => ShelleyBasedEra era -> a -> (eon era -> a) -> a
forShelleyBasedEraInEonMaybe :: Eon eon => ShelleyBasedEra era -> (eon era -> a) -> Maybe a
forShelleyBasedEraMaybeEon :: Eon eon => ShelleyBasedEra era -> Maybe (eon era)
inAnyShelleyBasedEra :: ShelleyBasedEra era -> thing era -> InAnyShelleyBasedEra thing
inEonForShelleyBasedEra :: Eon eon => a -> (eon era -> a) -> ShelleyBasedEra era -> a
inEonForShelleyBasedEraMaybe :: Eon eon => (eon era -> a) -> ShelleyBasedEra era -> Maybe a
requireShelleyBasedEra :: Applicative m => CardanoEra era -> m (Maybe (ShelleyBasedEra era))
shelleyBasedEraConstraints :: ShelleyBasedEra era -> (ShelleyBasedEraConstraints era => a) -> a
shelleyEraOnlyConstraints :: ShelleyEraOnly era -> (ShelleyEraOnlyConstraints era => a) -> a
shelleyEraOnlyToShelleyBasedEra :: ShelleyEraOnly era -> ShelleyBasedEra era
shelleyToAllegraEraConstraints :: ShelleyToAllegraEra era -> (ShelleyToAllegraEraConstraints era => a) -> a
shelleyToAllegraEraToShelleyBasedEra :: ShelleyToAllegraEra era -> ShelleyBasedEra era
shelleyToAlonzoEraConstraints :: ShelleyToAlonzoEra era -> (ShelleyToAlonzoEraConstraints era => a) -> a
shelleyToAlonzoEraToShelleyBasedEra :: ShelleyToAlonzoEra era -> ShelleyBasedEra era
shelleyToBabbageEraConstraints :: ShelleyToBabbageEra era -> (ShelleyToBabbageEraConstraints era => a) -> a
shelleyToBabbageEraToShelleyBasedEra :: ShelleyToBabbageEra era -> ShelleyBasedEra era
shelleyToMaryEraConstraints :: ShelleyToMaryEra era -> (ShelleyToMaryEraConstraints era => a) -> a
shelleyToMaryEraToShelleyBasedEra :: ShelleyToMaryEra era -> ShelleyBasedEra era
asFeaturedInEra :: forall (eon :: Type -> Type) a era. Eon eon => a -> CardanoEra era -> Maybe (Featured eon era a)
asFeaturedInShelleyBasedEra :: forall (eon :: Type -> Type) a era. Eon eon => a -> ShelleyBasedEra era -> Maybe (Featured eon era a)
mkFeatured :: forall (eon :: Type -> Type) era a. (IsCardanoEra era, Eon eon) => a -> Maybe (Featured eon era a)
unFeatured :: forall (eon :: Type -> Type) era a. Featured eon era a -> a
displayError :: Error a => a -> String
failEitherError :: (MonadFail m, Error e) => Either e a -> m a
fileIOExceptT :: forall (m :: Type -> Type) s e. MonadIO m => FilePath -> (FilePath -> IO s) -> ExceptT (FileError e) m s
throwErrorAsException :: Error e => e -> IO a
alonzoGenesisDefaults :: CardanoEra era -> AlonzoGenesis
conwayGenesisDefaults :: ConwayGenesis
decodeAlonzoGenesis :: forall era t (m :: Type -> Type). MonadTransError String t m => Maybe (CardanoEra era) -> ByteString -> t m AlonzoGenesis
shelleyGenesisDefaults :: ShelleyGenesis
unsafeBoundedRational :: (HasCallStack, Typeable r, BoundedRational r) => Rational -> r
createAnchor :: Url -> ByteString -> Anchor
createGovernanceActionId :: TxId -> Word16 -> GovActionId
createProposalProcedure :: ShelleyBasedEra era -> Network -> Coin -> StakeCredential -> GovernanceAction era -> Anchor -> Proposal era
fromGovernanceAction :: GovAction (ShelleyLedgerEra era) -> GovernanceAction era
fromProposalProcedure :: ShelleyBasedEra era -> Proposal era -> (Coin, StakeCredential, GovernanceAction era)
getAnchorDataFromGovernanceAction :: GovAction (ShelleyLedgerEra era) -> Maybe Anchor
proposalTypeEquality :: (Typeable eraA, Typeable eraB) => ProposalProcedure (ShelleyLedgerEra eraA) -> ProposalProcedure (ShelleyLedgerEra eraB) -> Maybe (eraA :~: eraB)
toGovernanceAction :: ShelleyBasedEra era -> GovernanceAction era -> GovAction (ShelleyLedgerEra era)
createVotingProcedure :: ConwayEraOnwards era -> Vote -> Maybe (Url, Text) -> VotingProcedure era
emptyVotingProcedures :: VotingProcedures era
mergeVotingProcedures :: VotingProcedures era -> VotingProcedures era -> Either (VotesMergingConflict era) (VotingProcedures era)
singletonVotingProcedures :: ConwayEraOnwards era -> Voter -> GovActionId -> VotingProcedure (ShelleyLedgerEra era) -> VotingProcedures era
toVote :: Vote -> Vote
validateGovActionAnchorData :: FromJSON (GovActionMetadata cip) => cip -> ByteString -> Either String ()
hashGovernancePoll :: GovernancePoll -> Hash GovernancePoll
renderGovernancePollError :: GovernancePollError -> Text
verifyPollAnswer :: GovernancePoll -> InAnyShelleyBasedEra Tx -> Either GovernancePollError [Hash PaymentKey]
asType :: HasTypeProxy t => AsType t
renderSafeHashAsHex :: SafeHash tag -> Text
intoFile :: File content 'Out -> content -> (File content 'Out -> stream -> result) -> (content -> stream) -> result
mapFile :: forall content (direction :: FileDirection). (FilePath -> FilePath) -> File content direction -> File content direction
onlyIn :: File content 'InOut -> File content 'In
onlyOut :: File content 'InOut -> File content 'Out
readByteStringFile :: MonadIO m => File content 'In -> m (Either (FileError e) ByteString)
readFileBlocking :: FilePath -> IO ByteString
readLazyByteStringFile :: MonadIO m => File content 'In -> m (Either (FileError e) ByteString)
readTextFile :: MonadIO m => File content 'In -> m (Either (FileError e) Text)
writeByteStringFile :: MonadIO m => File content 'Out -> ByteString -> m (Either (FileError e) ())
writeByteStringFileWithOwnerPermissions :: FilePath -> ByteString -> IO (Either (FileError e) ())
writeByteStringOutput :: MonadIO m => Maybe (File content 'Out) -> ByteString -> m (Either (FileError e) ())
writeLazyByteStringFile :: MonadIO m => File content 'Out -> ByteString -> m (Either (FileError e) ())
writeLazyByteStringFileWithOwnerPermissions :: File content 'Out -> ByteString -> IO (Either (FileError e) ())
writeLazyByteStringOutput :: MonadIO m => Maybe (File content 'Out) -> ByteString -> m (Either (FileError e) ())
writeTextFile :: MonadIO m => File content 'Out -> Text -> m (Either (FileError e) ())
writeTextFileWithOwnerPermissions :: File content 'Out -> Text -> IO (Either (FileError e) ())
writeTextOutput :: MonadIO m => Maybe (File content 'Out) -> Text -> m (Either (FileError e) ())
checkVrfFilePermissions :: forall content (direction :: FileDirection). File content direction -> ExceptT VRFPrivateKeyFilePermissionError IO ()
writeSecrets :: FilePath -> [Char] -> [Char] -> (a -> ByteString) -> [a] -> IO ()
anyStakePoolSigningKeyToVerificationKey :: AnyStakePoolSigningKey -> AnyStakePoolVerificationKey
anyStakePoolVerificationKeyHash :: AnyStakePoolVerificationKey -> Hash StakePoolKey
parseHexHash :: SerialiseAsRawBytes (Hash a) => Parser (Hash a)
generateInsecureSigningKey :: (MonadIO m, Key keyrole, SerialiseAsRawBytes (SigningKey keyrole)) => StdGen -> AsType keyrole -> m (SigningKey keyrole, StdGen)
generateSigningKey :: (MonadIO m, Key keyrole) => AsType keyrole -> m (SigningKey keyrole)
autocompleteMnemonicPrefix :: Text -> Maybe Text
findMnemonicWordsWithPrefix :: Text -> [(Text, Int)]
generateMnemonic :: MonadIO m => MnemonicSize -> m [Text]
signingKeyFromMnemonic :: SigningKeyFromRootKey keyrole => AsType keyrole -> [Text] -> Word32 -> Either MnemonicToSigningKeyError (SigningKey keyrole)
signingKeyFromMnemonicWithPaymentKeyIndex :: IndexedSigningKeyFromRootKey keyrole => AsType keyrole -> [Text] -> Word32 -> Word32 -> Either MnemonicToSigningKeyError (SigningKey keyrole)
signArbitraryBytesKes :: SigningKey KesKey -> Period -> ByteString -> SignedKES (KES StandardCrypto) ByteString
deserialiseAnyVerificationKey :: ByteString -> Either InputDecodeError SomeAddressVerificationKey
deserialiseAnyVerificationKeyBech32 :: ByteString -> Either Bech32DecodeError SomeAddressVerificationKey
deserialiseAnyVerificationKeyTextEnvelope :: ByteString -> Either TextEnvelopeError SomeAddressVerificationKey
mapSomeAddressVerificationKey :: (forall keyrole. Key keyrole => VerificationKey keyrole -> a) -> SomeAddressVerificationKey -> a
renderSomeAddressVerificationKey :: SomeAddressVerificationKey -> Text
applyBlock :: Env -> LedgerState -> ValidationMode -> BlockInMode -> Either LedgerStateError (LedgerState, [LedgerEvent])
applyBlockWithEvents :: Env -> LedgerState -> Bool -> CardanoBlock StandardCrypto -> Either LedgerStateError LedgerStateEvents
chainSyncClientPipelinedWithLedgerState :: forall (m :: Type -> Type) a. Monad m => Env -> LedgerState -> ValidationMode -> ChainSyncClientPipelined (BlockInMode, Either LedgerStateError (LedgerState, [LedgerEvent])) ChainPoint ChainTip m a -> ChainSyncClientPipelined BlockInMode ChainPoint ChainTip m a
chainSyncClientWithLedgerState :: forall (m :: Type -> Type) a. Monad m => Env -> LedgerState -> ValidationMode -> ChainSyncClient (BlockInMode, Either LedgerStateError (LedgerState, [LedgerEvent])) ChainPoint ChainTip m a -> ChainSyncClient BlockInMode ChainPoint ChainTip m a
constructGlobals :: ShelleyGenesis -> EpochInfo (Either Text) -> Globals
currentEpochEligibleLeadershipSlots :: ShelleyBasedEra era -> ShelleyGenesis -> EpochInfo (Either Text) -> PParams (ShelleyLedgerEra era) -> ProtocolState era -> PoolId -> SigningKey VrfKey -> SerialisedPoolDistribution era -> EpochNo -> Either LeadershipError (Set SlotNo)
decodeLedgerState :: Decoder s LedgerState
encodeLedgerState :: LedgerState -> Encoding
envSecurityParam :: Env -> Word64
foldBlocks :: forall a t (m :: Type -> Type). (Show a, MonadIOTransError FoldBlocksError t m) => NodeConfigFile 'In -> SocketPath -> ValidationMode -> a -> (Env -> LedgerState -> [LedgerEvent] -> BlockInMode -> a -> IO (a, FoldStatus)) -> t m a
foldEpochState :: forall t (m :: Type -> Type) s. MonadIOTransError FoldBlocksError t m => NodeConfigFile 'In -> SocketPath -> ValidationMode -> EpochNo -> s -> (AnyNewEpochState -> SlotNo -> BlockNo -> StateT s IO ConditionResult) -> t m (ConditionResult, s)
fromConditionResult :: ConditionResult -> Bool
genesisConfigToEnv :: GenesisConfig -> Either GenesisConfigError Env
getAnyNewEpochState :: ShelleyBasedEra era -> LedgerState -> Either LedgerStateError AnyNewEpochState
getLedgerTablesUTxOValues :: ShelleyBasedEra era -> LedgerTables (LedgerState (CardanoBlock StandardCrypto)) ValuesMK -> Map TxIn (TxOut CtxUTxO era)
initialLedgerState :: forall t (m :: Type -> Type). MonadIOTransError InitialLedgerStateError t m => NodeConfigFile 'In -> t m (Env, LedgerState)
mkProtocolInfoCardano :: GenesisConfig -> (ProtocolInfo (CardanoBlock StandardCrypto), IO [BlockForging IO (CardanoBlock StandardCrypto)])
nextEpochEligibleLeadershipSlots :: ShelleyBasedEra era -> ShelleyGenesis -> SerialisedCurrentEpochState era -> ProtocolState era -> PoolId -> SigningKey VrfKey -> PParams (ShelleyLedgerEra era) -> EpochInfo (Either Text) -> (ChainTip, EpochNo) -> Either LeadershipError (Set SlotNo)
readAlonzoGenesisConfig :: forall t (m :: Type -> Type) era. MonadIOTransError GenesisConfigError t m => Maybe (CardanoEra era) -> NodeConfig -> t m AlonzoGenesis
readByronGenesisConfig :: forall t (m :: Type -> Type). MonadIOTransError GenesisConfigError t m => NodeConfig -> t m Config
readCardanoGenesisConfig :: forall t (m :: Type -> Type) era. MonadIOTransError GenesisConfigError t m => Maybe (CardanoEra era) -> NodeConfig -> t m GenesisConfig
readConwayGenesisConfig :: forall t (m :: Type -> Type). MonadIOTransError GenesisConfigError t m => NodeConfig -> t m ConwayGenesis
readNodeConfig :: (MonadError Text m, MonadIO m) => NodeConfigFile 'In -> m NodeConfig
readShelleyGenesisConfig :: forall t (m :: Type -> Type). MonadIOTransError GenesisConfigError t m => NodeConfig -> t m ShelleyConfig
shelleyPraosNonce :: GenesisHashShelley -> Nonce
toConditionResult :: Bool -> ConditionResult
convertRetiredPoolsMap :: Map StakeCredential (Map (KeyHash 'StakePool) Coin) -> Map StakeCredential (Map (Hash StakePoolKey) Coin)
failEither :: MonadFail m => Either String a -> m a
failEitherWith :: MonadFail m => (e -> String) -> Either e a -> m a
handleIOExceptionsLiftWith :: (MonadIOTransError e' t m, Exception e) => (e -> e') -> m a -> t m a
handleIOExceptionsWith :: (MonadError e' m, MonadCatch m, Exception e) => (e -> e') -> m a -> m a
hoistIOEither :: forall e t (m :: Type -> Type) a. MonadIOTransError e t m => IO (Either e a) -> t m a
liftExceptT :: forall e t (m :: Type -> Type) a. MonadTransError e t m => ExceptT e m a -> t m a
liftMaybe :: MonadError e m => e -> Maybe a -> m a
connectToLocalNode :: MonadIO m => LocalNodeConnectInfo -> LocalNodeClientProtocolsInMode -> m ()
connectToLocalNodeWithVersion :: MonadIO m => LocalNodeConnectInfo -> (NodeToClientVersion -> LocalNodeClientProtocolsInMode) -> m ()
getLocalChainTip :: MonadIO m => LocalNodeConnectInfo -> m ChainTip
mkLocalNodeClientParams :: ConsensusModeParams -> (NodeToClientVersion -> LocalNodeClientProtocolsInMode) -> LocalNodeClientParams
queryNodeLocalState :: LocalNodeConnectInfo -> Target ChainPoint -> QueryInMode result -> ExceptT AcquiringFailure IO result
queryTxMonitoringLocal :: MonadIO m => LocalNodeConnectInfo -> LocalTxMonitoringQuery -> m LocalTxMonitoringResult
submitTxToNodeLocal :: MonadIO m => LocalNodeConnectInfo -> TxInMode -> m (SubmitResult TxValidationErrorInCardanoMode)
toAcquiringFailure :: AcquireFailure -> AcquiringFailure
executeLocalStateQueryExpr :: LocalNodeConnectInfo -> Target ChainPoint -> LocalStateQueryExpr BlockInMode ChainPoint QueryInMode () IO a -> IO (Either AcquiringFailure a)
queryExpr :: QueryInMode a -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError a)
isQuerySupportedInNtcVersion :: Some (Query (CardanoBlock StandardCrypto)) -> NodeToClientVersion -> Either UnsupportedNtcVersionError ()
fromNetworkMagic :: NetworkMagic -> NetworkId
fromShelleyNetwork :: Network -> NetworkMagic -> NetworkId
mainnetNetworkMagic :: NetworkMagic
toByronNetworkMagic :: NetworkId -> NetworkMagic
toByronProtocolMagicId :: NetworkId -> ProtocolMagicId
toByronRequiresNetworkMagic :: NetworkId -> RequiresNetworkMagic
toNetworkMagic :: NetworkId -> NetworkMagic
toShelleyNetwork :: NetworkId -> Network
collectPlutusScriptHashes :: AlonzoEraOnwards era -> Tx era -> UTxO era -> Map ScriptWitnessIndex ScriptHash
renderDebugPlutusFailure :: DebugPlutusFailure -> Text
eraOfScriptInEra :: ScriptInEra era -> ShelleyBasedEra era
eraOfScriptLanguageInEra :: ScriptLanguageInEra lang era -> ShelleyBasedEra era
examplePlutusScriptAlwaysFails :: WitCtx witctx -> PlutusScript PlutusScriptV1
examplePlutusScriptAlwaysSucceeds :: WitCtx witctx -> PlutusScript PlutusScriptV1
fromAllegraTimelock :: AllegraEraScript era => NativeScript era -> SimpleScript
fromAlonzoExUnits :: ExUnits -> ExecutionUnits
fromAlonzoLanguage :: Language -> AnyPlutusScriptVersion
fromShelleyBasedScript :: ShelleyBasedEra era -> Script (ShelleyLedgerEra era) -> ScriptInEra era
fromShelleyMultiSig :: MultiSig (ShelleyLedgerEra ShelleyEra) -> SimpleScript
fromShelleyScriptHash :: ScriptHash -> ScriptHash
fromShelleyScriptToReferenceScript :: ShelleyBasedEra era -> Script (ShelleyLedgerEra era) -> ReferenceScript era
getScriptWitnessReferenceInput :: ScriptWitness witctx era -> Maybe TxIn
getScriptWitnessReferenceInputOrScript :: ScriptWitness witctx era -> Either (ScriptInEra era) TxIn
getScriptWitnessScript :: ScriptWitness witctx era -> Maybe (ScriptInEra era)
hashScript :: Script lang -> ScriptHash
languageOfScriptLanguageInEra :: ScriptLanguageInEra lang era -> ScriptLanguage lang
parseScriptHash :: Parser ScriptHash
refScriptToShelleyScript :: ShelleyBasedEra era -> ReferenceScript era -> StrictMaybe (Script (ShelleyLedgerEra era))
removePlutusScriptDoubleEncoding :: ByteString -> ByteString
sbeToSimpleScriptLanguageInEra :: ShelleyBasedEra era -> ScriptLanguageInEra SimpleScript' era
scriptInEraToRefScript :: ScriptInEra era -> ReferenceScript era
toAllegraTimelock :: (AllegraEraScript era, NativeScript era ~ Timelock era) => SimpleScript -> NativeScript era
toAlonzoExUnits :: ExecutionUnits -> ExUnits
toAlonzoLanguage :: AnyPlutusScriptVersion -> Language
toScriptInAnyLang :: Script lang -> ScriptInAnyLang
toScriptInEra :: ShelleyBasedEra era -> ScriptInAnyLang -> Maybe (ScriptInEra era)
toShelleyMultiSig :: SimpleScript -> Either MultiSigError (MultiSig (ShelleyLedgerEra ShelleyEra))
toShelleyScript :: ScriptInEra era -> Script (ShelleyLedgerEra era)
toShelleyScriptHash :: ScriptHash -> ScriptHash
fromAlonzoData :: Data ledgerera -> HashableScriptData
fromPlutusData :: Data -> ScriptData
getOriginalScriptDataBytes :: HashableScriptData -> ByteString
getScriptData :: HashableScriptData -> ScriptData
hashScriptDataBytes :: HashableScriptData -> Hash ScriptData
parseScriptDataHash :: Parser (Hash ScriptData)
scriptDataFromJson :: ScriptDataJsonSchema -> Value -> Either ScriptDataJsonError HashableScriptData
scriptDataFromJsonDetailedSchema :: Value -> Either ScriptDataJsonSchemaError HashableScriptData
scriptDataJsonToHashable :: ScriptDataJsonSchema -> Value -> Either ScriptDataJsonBytesError HashableScriptData
scriptDataToJson :: ScriptDataJsonSchema -> HashableScriptData -> Value
scriptDataToJsonDetailedSchema :: HashableScriptData -> Value
toAlonzoData :: Era ledgerera => HashableScriptData -> Data ledgerera
toPlutusData :: ScriptData -> Data
unsafeHashableScriptData :: ScriptData -> HashableScriptData
validateScriptData :: ScriptData -> Either ScriptDataRangeError ()
black :: Doc AnsiStyle -> Doc AnsiStyle
cyan :: Doc AnsiStyle -> Doc AnsiStyle
docToLazyText :: Doc AnsiStyle -> Text
docToString :: Doc AnsiStyle -> String
docToText :: Doc AnsiStyle -> Text
magenta :: Doc AnsiStyle -> Doc AnsiStyle
prettyException :: Exception a => a -> Doc ann
pshow :: Show a => a -> Doc ann
textShow :: Show a => a -> Text
white :: Doc AnsiStyle -> Doc AnsiStyle
yellow :: Doc AnsiStyle -> Doc AnsiStyle
createEraBasedProtocolParamUpdate :: ShelleyBasedEra era -> EraBasedProtocolParametersUpdate era -> PParamsUpdate (ShelleyLedgerEra era)
createPParams :: ShelleyBasedEra era -> EraBasedProtocolParametersUpdate era -> PParams (ShelleyLedgerEra era)
fromAlonzoCostModel :: CostModel -> CostModel
fromAlonzoCostModels :: CostModels -> Map AnyPlutusScriptVersion CostModel
fromAlonzoPrices :: Prices -> ExecutionUnitPrices
fromAlonzoScriptLanguage :: Language -> AnyPlutusScriptVersion
fromLedgerPParamsUpdate :: ShelleyBasedEra era -> PParamsUpdate (ShelleyLedgerEra era) -> ProtocolParametersUpdate
fromLedgerProposedPPUpdates :: ShelleyLedgerEra era ~ ledgerera => ShelleyBasedEra era -> ProposedPPUpdates ledgerera -> Map (Hash GenesisKey) ProtocolParametersUpdate
fromLedgerUpdate :: ShelleyLedgerEra era ~ ledgerera => ShelleyBasedEra era -> Update ledgerera -> UpdateProposal
makePraosNonce :: ByteString -> PraosNonce
makeShelleyUpdateProposal :: ProtocolParametersUpdate -> [Hash GenesisKey] -> EpochNo -> UpdateProposal
toAlonzoCostModel :: CostModel -> Language -> Either ProtocolParametersConversionError CostModel
toAlonzoCostModels :: Map AnyPlutusScriptVersion CostModel -> Either ProtocolParametersConversionError CostModels
toAlonzoPrices :: ExecutionUnitPrices -> Either ProtocolParametersConversionError Prices
toAlonzoScriptLanguage :: AnyPlutusScriptVersion -> Language
toLedgerNonce :: Maybe PraosNonce -> Nonce
toLedgerPParamsUpdate :: ShelleyBasedEra era -> ProtocolParametersUpdate -> Either ProtocolParametersConversionError (PParamsUpdate (ShelleyLedgerEra era))
toLedgerProposedPPUpdates :: ShelleyBasedEra era -> Map (Hash GenesisKey) ProtocolParametersUpdate -> Either ProtocolParametersConversionError (ProposedPPUpdates (ShelleyLedgerEra era))
toLedgerUpdate :: ShelleyBasedEra era -> UpdateProposal -> Either ProtocolParametersConversionError (Update (ShelleyLedgerEra era))
determineEra :: LocalNodeConnectInfo -> ExceptT AcquiringFailure IO AnyCardanoEra
executeQueryAnyMode :: LocalNodeConnectInfo -> QueryInMode (Either EraMismatch result) -> ExceptT QueryConvenienceError IO result
executeQueryCardanoMode :: SocketPath -> NetworkId -> QueryInMode (Either EraMismatch result) -> ExceptT QueryConvenienceError IO result
queryStateForBalancedTx :: CardanoEra era -> [TxIn] -> [Certificate era] -> LocalStateQueryExpr block point QueryInMode r IO (Either QueryConvenienceError (UTxO era, LedgerProtocolParameters era, EraHistory, SystemStart, Set PoolId, Map StakeCredential Coin, Map (Credential 'DRepRole) Coin, Maybe (Featured ConwayEraOnwards era TxCurrentTreasuryValue)))
renderQueryConvenienceError :: QueryConvenienceError -> Text
queryAccountState :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch AccountState))
queryChainBlockNo :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (WithOrigin BlockNo))
queryChainPoint :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError ChainPoint)
queryCommitteeMembersState :: ConwayEraOnwards era -> Set (Credential 'ColdCommitteeRole) -> Set (Credential 'HotCommitteeRole) -> Set MemberStatus -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch CommitteeMembersState))
queryConstitution :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Constitution (ShelleyLedgerEra era))))
queryConstitutionHash :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SafeHash AnchorData)))
queryCurrentEpochState :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedCurrentEpochState era)))
queryCurrentEra :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError AnyCardanoEra)
queryDRepStakeDistribution :: ConwayEraOnwards era -> Set DRep -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map DRep Coin)))
queryDRepState :: ConwayEraOnwards era -> Set (Credential 'DRepRole) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map (Credential 'DRepRole) DRepState)))
queryDebugLedgerState :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedDebugLedgerState era)))
queryEpoch :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch EpochNo))
queryFuturePParams :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Maybe (PParams (ShelleyLedgerEra era)))))
queryGenesisParameters :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (GenesisParameters ShelleyEra)))
queryGovState :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (GovState (ShelleyLedgerEra era))))
queryLedgerConfig :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (CardanoLedgerConfig StandardCrypto))
queryLedgerPeerSnapshot :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Serialised LedgerPeerSnapshot)))
queryPoolDistribution :: BabbageEraOnwards era -> Maybe (Set PoolId) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedPoolDistribution era)))
queryPoolState :: BabbageEraOnwards era -> Maybe (Set PoolId) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedPoolState era)))
queryProposals :: ConwayEraOnwards era -> Set GovActionId -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Seq (GovActionState (ShelleyLedgerEra era)))))
queryProtocolState :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (ProtocolState era)))
queryRatifyState :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (RatifyState (ShelleyLedgerEra era))))
querySPOStakeDistribution :: ConwayEraOnwards era -> Set (KeyHash 'StakePool) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map (KeyHash 'StakePool) Coin)))
queryStakeAddresses :: ShelleyBasedEra era -> Set StakeCredential -> NetworkId -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map StakeAddress Coin, Map StakeAddress PoolId)))
queryStakeDelegDeposits :: BabbageEraOnwards era -> Set StakeCredential -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map StakeCredential Coin)))
queryStakeDistribution :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map (Hash StakePoolKey) Rational)))
queryStakePoolDefaultVote :: ConwayEraOnwards era -> KeyHash 'StakePool -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch DefaultVote))
queryStakePoolParameters :: ShelleyBasedEra era -> Set PoolId -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map PoolId StakePoolParameters)))
queryStakeSnapshot :: BabbageEraOnwards era -> Maybe (Set PoolId) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedStakeSnapshots era)))
queryStakeVoteDelegatees :: ConwayEraOnwards era -> Set StakeCredential -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map StakeCredential DRep)))
queryUtxo :: ShelleyBasedEra era -> QueryUTxOFilter -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (UTxO era)))
toDebugLedgerStatePair :: KeyValue e a => ShelleyBasedEra era -> DebugLedgerState era -> [a]
mergeDelegsAndRewards :: DelegationsAndRewards -> [(StakeAddress, Maybe Coin, Maybe PoolId)]
decodeBigLedgerPeerSnapshot :: Serialised LedgerPeerSnapshot -> Either (ByteString, DecoderError) LedgerPeerSnapshot
decodeCurrentEpochState :: ShelleyBasedEra era -> SerialisedCurrentEpochState era -> Either DecoderError (CurrentEpochState era)
decodeDebugLedgerState :: FromCBOR (DebugLedgerState era) => SerialisedDebugLedgerState era -> Either (ByteString, DecoderError) (DebugLedgerState era)
decodePoolDistribution :: ShelleyBasedEra era -> SerialisedPoolDistribution era -> Either DecoderError (PoolDistribution era)
decodePoolState :: (Era (ShelleyLedgerEra era), DecCBOR (PState (ShelleyLedgerEra era))) => SerialisedPoolState era -> Either DecoderError (PoolState era)
decodeProtocolState :: FromCBOR (ChainDepState (ConsensusProtocol era)) => ProtocolState era -> Either (ByteString, DecoderError) (ChainDepState (ConsensusProtocol era))
decodeStakeSnapshot :: SerialisedStakeSnapshots era -> Either DecoderError (StakeSnapshot era)
fromConsensusQueryResult :: (HasCallStack, CardanoBlock StandardCrypto ~ block) => QueryInMode result -> Query block result' -> result' -> result
getProgress :: SlotNo -> EraHistory -> Either PastHorizonException (RelativeTime, SlotLength)
getSlotForRelativeTime :: RelativeTime -> EraHistory -> Either PastHorizonException SlotNo
slotToEpoch :: SlotNo -> EraHistory -> Either PastHorizonException (EpochNo, SlotsInEpoch, SlotsToEpochEnd)
toConsensusQuery :: CardanoBlock StandardCrypto ~ block => QueryInMode result -> Some (Query block)
toLedgerEpochInfo :: EraHistory -> LedgerEpochInfo
deserialiseAnyOfFromBech32 :: [FromSomeType SerialiseAsBech32 b] -> Text -> Either Bech32DecodeError b
deserialiseFromBech32 :: SerialiseAsBech32 a => Text -> Either Bech32DecodeError a
serialiseToBech32 :: SerialiseAsBech32 a => a -> Text
unsafeHumanReadablePartFromText :: HasCallStack => Text -> HumanReadablePart
canonicaliseCborBs :: ByteString -> Either DecoderError ByteString
canonicaliseTerm :: Term -> Term
deserialiseFromBech32Cip129 :: Cip129 a => Text -> Either Bech32DecodeError a
deserialiseGovActionIdFromBech32Cip129 :: Text -> Either Bech32DecodeError GovActionId
serialiseGovActionIdToBech32Cip129 :: GovActionId -> Text
serialiseToBech32Cip129 :: Cip129 a => a -> Text
deserialiseInput :: NonEmpty (InputFormat a) -> ByteString -> Either InputDecodeError a
deserialiseInputAnyOf :: [FromSomeType SerialiseAsBech32 b] -> [FromSomeType HasTextEnvelope b] -> ByteString -> Either InputDecodeError b
readFormattedFile :: NonEmpty (InputFormat a) -> FilePath -> IO (Either (FileError InputDecodeError) a)
readFormattedFileAnyOf :: forall content b. [FromSomeType SerialiseAsBech32 b] -> [FromSomeType HasTextEnvelope b] -> File content 'In -> IO (Either (FileError InputDecodeError) b)
readFormattedFileTextEnvelope :: HasTextEnvelope a => File content 'In -> IO (Either (FileError InputDecodeError) a)
renderInputDecodeError :: InputDecodeError -> Doc ann
deserialiseFromJSON :: FromJSON a => ByteString -> Either JsonDecodeError a
prettyPrintJSON :: ToJSON a => a -> ByteString
readFileJSON :: FromJSON a => FilePath -> IO (Either (FileError JsonDecodeError) a)
serialiseToJSON :: ToJSON a => a -> ByteString
textWithMaxLength :: String -> Int -> Value -> Parser Text
toRationalJSON :: Rational -> Value
writeFileJSON :: ToJSON a => FilePath -> a -> IO (Either (FileError ()) ())
deserialiseFromRawBytesHex :: SerialiseAsRawBytes a => ByteString -> Either RawBytesHexError a
parseRawBytesHex :: SerialiseAsRawBytes a => Parser a
serialiseToRawBytesHex :: SerialiseAsRawBytes a => a -> ByteString
serialiseToRawBytesHexText :: SerialiseAsRawBytes a => a -> Text
deserialiseFromTextEnvelope :: HasTextEnvelope a => TextEnvelope -> Either TextEnvelopeError a
deserialiseFromTextEnvelopeAnyOf :: [FromSomeType HasTextEnvelope b] -> TextEnvelope -> Either TextEnvelopeError b
legacyComparison :: TextEnvelopeType -> TextEnvelopeType -> Bool
readFileTextEnvelope :: HasTextEnvelope a => File content 'In -> IO (Either (FileError TextEnvelopeError) a)
readFileTextEnvelopeAnyOf :: [FromSomeType HasTextEnvelope b] -> File content 'In -> IO (Either (FileError TextEnvelopeError) b)
readTextEnvelopeFromFile :: FilePath -> IO (Either (FileError TextEnvelopeError) TextEnvelope)
readTextEnvelopeOfTypeFromFile :: TextEnvelopeType -> FilePath -> IO (Either (FileError TextEnvelopeError) TextEnvelope)
serialiseTextEnvelope :: TextEnvelope -> ByteString
serialiseToTextEnvelope :: HasTextEnvelope a => Maybe TextEnvelopeDescr -> a -> TextEnvelope
textEnvelopeRawCBOR :: TextEnvelope -> ByteString
textEnvelopeToJSON :: HasTextEnvelope a => Maybe TextEnvelopeDescr -> a -> ByteString
textEnvelopeTypeInEra :: HasTextEnvelope (f era) => CardanoEra era -> AsType (f era) -> TextEnvelopeType
writeFileTextEnvelope :: HasTextEnvelope a => File content 'Out -> Maybe TextEnvelopeDescr -> a -> IO (Either (FileError ()) ())
cddlTypeToEra :: Text -> Either TextEnvelopeCddlError AnyShelleyBasedEra
deserialiseByronTxCddl :: TextEnvelope -> Either TextEnvelopeCddlError (ATxAux ByteString)
deserialiseFromTextEnvelopeCddlAnyOf :: [FromSomeTypeCDDL TextEnvelope b] -> TextEnvelope -> Either TextEnvelopeCddlError b
deserialiseWitnessLedgerCddl :: ShelleyBasedEra era -> TextEnvelope -> Either TextEnvelopeCddlError (KeyWitness era)
readFileTextEnvelopeCddlAnyOf :: [FromSomeTypeCDDL TextEnvelope b] -> FilePath -> IO (Either (FileError TextEnvelopeCddlError) b)
serialiseWitnessLedgerCddl :: ShelleyBasedEra era -> KeyWitness era -> TextEnvelope
serializeByronTx :: ATxAux ByteString -> TextEnvelope
writeByronTxFileTextEnvelopeCddl :: File content 'Out -> ATxAux ByteString -> IO (Either (FileError ()) ())
writeTxFileTextEnvelopeCanonicalCddl :: ShelleyBasedEra era -> File content 'Out -> Tx era -> IO (Either (FileError ()) ())
writeTxFileTextEnvelopeCddl :: ShelleyBasedEra era -> File content 'Out -> Tx era -> IO (Either (FileError ()) ())
writeTxWitnessFileTextEnvelopeCddl :: ShelleyBasedEra era -> File () 'Out -> KeyWitness era -> IO (Either (FileError ()) ())
addTxExtraKeyWits :: IsAlonzoBasedEra era => [Hash PaymentKey] -> TxBodyContent build era -> TxBodyContent build era
addTxIn :: (TxIn, BuildTxWith build (Witness WitCtxTxIn era)) -> TxBodyContent build era -> TxBodyContent build era
addTxInCollateral :: IsAlonzoBasedEra era => TxIn -> TxBodyContent build era -> TxBodyContent build era
addTxInReference :: (Applicative (BuildTxWith build), IsBabbageBasedEra era) => TxIn -> Maybe HashableScriptData -> TxBodyContent build era -> TxBodyContent build era
addTxIns :: TxIns build era -> TxBodyContent build era -> TxBodyContent build era
addTxInsCollateral :: IsAlonzoBasedEra era => [TxIn] -> TxBodyContent build era -> TxBodyContent build era
addTxInsReference :: (Applicative (BuildTxWith build), IsBabbageBasedEra era) => [TxIn] -> Set HashableScriptData -> TxBodyContent build era -> TxBodyContent build era
addTxMintValue :: IsMaryBasedEra era => Map PolicyId (PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era)) -> TxBodyContent build era -> TxBodyContent build era
addTxOut :: TxOut CtxTx era -> TxBodyContent build era -> TxBodyContent build era
addTxOuts :: [TxOut CtxTx era] -> TxBodyContent build era -> TxBodyContent build era
calculateExecutionUnitsLovelace :: Prices -> ExecutionUnits -> Maybe Coin
collectTxBodyScriptWitnessRequirements :: IsShelleyBasedEra era => AlonzoEraOnwards era -> TxBodyContent BuildTx era -> Either TxBodyError (TxScriptWitnessRequirements (ShelleyLedgerEra era))
collectTxBodyScriptWitnesses :: ShelleyBasedEra era -> TxBodyContent BuildTx era -> [(ScriptWitnessIndex, AnyScriptWitness era)]
convCertificates :: ShelleyBasedEra era -> TxCertificates build era -> StrictSeq (TxCert (ShelleyLedgerEra era))
convCollateralTxIns :: TxInsCollateral era -> Set TxIn
convExtraKeyWitnesses :: TxExtraKeyWitnesses era -> Set (KeyHash 'Witness)
convLanguages :: [(ScriptWitnessIndex, AnyScriptWitness era)] -> Set Language
convMintValue :: TxMintValue build era -> MultiAsset
convPParamsToScriptIntegrityHash :: AlonzoEraOnwards era -> BuildTxWith BuildTx (Maybe (LedgerProtocolParameters era)) -> Redeemers (ShelleyLedgerEra era) -> TxDats (ShelleyLedgerEra era) -> Set Language -> StrictMaybe ScriptIntegrityHash
convProposalProcedures :: TxProposalProcedures build era -> OSet (ProposalProcedure (ShelleyLedgerEra era))
convReferenceInputs :: TxInsReference build era -> Set TxIn
convReturnCollateral :: ShelleyBasedEra era -> TxReturnCollateral ctx era -> StrictMaybe (TxOut (ShelleyLedgerEra era))
convScriptData :: ShelleyBasedEra era -> [TxOut CtxTx era] -> [(ScriptWitnessIndex, AnyScriptWitness era)] -> TxBodyScriptData era
convScripts :: ShelleyLedgerEra era ~ ledgerera => [(ScriptWitnessIndex, AnyScriptWitness era)] -> [Script ledgerera]
convTotalCollateral :: TxTotalCollateral era -> StrictMaybe Coin
convTransactionFee :: ShelleyBasedEra era -> TxFee era -> Coin
convTxIns :: TxIns BuildTx era -> Set TxIn
convTxUpdateProposal :: ShelleyBasedEra era -> TxUpdateProposal era -> Either TxBodyError (StrictMaybe (Update (ShelleyLedgerEra era)))
convValidityLowerBound :: TxValidityLowerBound era -> Maybe SlotNo
convValidityUpperBound :: ShelleyBasedEra era -> TxValidityUpperBound era -> Maybe SlotNo
convVotingProcedures :: TxVotingProcedures build era -> VotingProcedures (ShelleyLedgerEra era)
convWithdrawals :: TxWithdrawals build era -> Withdrawals
createTransactionBody :: HasCallStack => ShelleyBasedEra era -> TxBodyContent BuildTx era -> Either TxBodyError (TxBody era)
defaultTxFee :: ShelleyBasedEra era -> TxFee era
defaultTxValidityUpperBound :: ShelleyBasedEra era -> TxValidityUpperBound era
genesisUTxOPseudoTxIn :: NetworkId -> Hash GenesisUTxOKey -> TxIn
getReferenceInputDatumMap :: TxInsReferenceDatums build -> Map (Hash ScriptData) HashableScriptData
getReferenceInputsSizeForTxIds :: ShelleyLedgerEra era ~ ledgerera => BabbageEraOnwards era -> UTxO ledgerera -> Set TxIn -> Int
getScriptIntegrityHash :: BuildTxWith BuildTx (Maybe (LedgerProtocolParameters era)) -> Set Language -> TxBodyScriptData era -> StrictMaybe ScriptIntegrityHash
getTxBodyContent :: TxBody era -> TxBodyContent ViewTx era
getTxId :: TxBody era -> TxId
getTxIdByron :: ATxAux ByteString -> TxId
getTxIdShelley :: EraTxBody (ShelleyLedgerEra era) => ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> TxId
guardShelleyTxInsOverflow :: [TxIn] -> Either TxBodyError ()
indexTxCertificates :: TxCertificates BuildTx era -> [(ScriptWitnessIndex, Certificate era, StakeCredential, Witness WitCtxStake era)]
indexTxIns :: TxIns BuildTx era -> [(ScriptWitnessIndex, TxIn, Witness WitCtxTxIn era)]
indexTxMintValue :: TxMintValue build era -> [(ScriptWitnessIndex, PolicyId, PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era))]
indexTxProposalProcedures :: TxProposalProcedures BuildTx era -> [(ScriptWitnessIndex, ProposalProcedure (ShelleyLedgerEra era), ScriptWitness WitCtxStake era)]
indexTxVotingProcedures :: TxVotingProcedures BuildTx era -> [(ScriptWitnessIndex, Voter, ScriptWitness WitCtxStake era)]
indexTxWithdrawals :: TxWithdrawals BuildTx era -> [(ScriptWitnessIndex, StakeAddress, Coin, Witness WitCtxStake era)]
indexWitnessedTxProposalProcedures :: TxProposalProcedures BuildTx era -> [(ProposalProcedure (ShelleyLedgerEra era), Maybe (ScriptWitnessIndex, ScriptWitness WitCtxStake era))]
makeByronTransactionBody :: TxIns BuildTx ByronEra -> [TxOut CtxTx ByronEra] -> Either TxBodyError (Annotated Tx ByteString)
mkCommonTxBody :: HasCallStack => ShelleyBasedEra era -> TxIns BuildTx era -> [TxOut ctx era] -> TxFee era -> TxWithdrawals build era -> Maybe (TxAuxData (ShelleyLedgerEra era)) -> LedgerTxBody era
mkTxCertificates :: Applicative (BuildTxWith build) => ShelleyBasedEra era -> [(Certificate era, Maybe (ScriptWitness WitCtxStake era))] -> TxCertificates build era
mkTxMintValue :: MaryEraOnwards era -> [(PolicyId, PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era))] -> TxMintValue build era
mkTxProposalProcedures :: forall era build. (Applicative (BuildTxWith build), IsShelleyBasedEra era) => [(ProposalProcedure (ShelleyLedgerEra era), Maybe (ScriptWitness WitCtxStake era))] -> TxProposalProcedures build era
mkTxVotingProcedures :: Applicative (BuildTxWith build) => [(VotingProcedures era, Maybe (ScriptWitness WitCtxStake era))] -> Either (VotesMergingConflict era) (TxVotingProcedures build era)
modTxAuxScripts :: (TxAuxScripts era -> TxAuxScripts era) -> TxBodyContent build era -> TxBodyContent build era
modTxCertificates :: (TxCertificates build era -> TxCertificates build era) -> TxBodyContent build era -> TxBodyContent build era
modTxExtraKeyWits :: (TxExtraKeyWitnesses era -> TxExtraKeyWitnesses era) -> TxBodyContent build era -> TxBodyContent build era
modTxFee :: (TxFee era -> TxFee era) -> TxBodyContent build era -> TxBodyContent build era
modTxIns :: (TxIns build era -> TxIns build era) -> TxBodyContent build era -> TxBodyContent build era
modTxInsCollateral :: (TxInsCollateral era -> TxInsCollateral era) -> TxBodyContent build era -> TxBodyContent build era
modTxInsReference :: (TxInsReference build era -> TxInsReference build era) -> TxBodyContent build era -> TxBodyContent build era
modTxMetadata :: (TxMetadataInEra era -> TxMetadataInEra era) -> TxBodyContent build era -> TxBodyContent build era
modTxMintValue :: (TxMintValue build era -> TxMintValue build era) -> TxBodyContent build era -> TxBodyContent build era
modTxOuts :: ([TxOut CtxTx era] -> [TxOut CtxTx era]) -> TxBodyContent build era -> TxBodyContent build era
modTxReturnCollateral :: (TxReturnCollateral CtxTx era -> TxReturnCollateral CtxTx era) -> TxBodyContent build era -> TxBodyContent build era
modTxScriptValidity :: (TxScriptValidity era -> TxScriptValidity era) -> TxBodyContent build era -> TxBodyContent build era
modTxTotalCollateral :: (TxTotalCollateral era -> TxTotalCollateral era) -> TxBodyContent build era -> TxBodyContent build era
modTxUpdateProposal :: (TxUpdateProposal era -> TxUpdateProposal era) -> TxBodyContent build era -> TxBodyContent build era
modTxValidityLowerBound :: (TxValidityLowerBound era -> TxValidityLowerBound era) -> TxBodyContent build era -> TxBodyContent build era
modTxValidityUpperBound :: (TxValidityUpperBound era -> TxValidityUpperBound era) -> TxBodyContent build era -> TxBodyContent build era
modTxWithdrawals :: (TxWithdrawals build era -> TxWithdrawals build era) -> TxBodyContent build era -> TxBodyContent build era
renderScriptWitnessIndex :: ScriptWitnessIndex -> String
setTxAuxScripts :: TxAuxScripts era -> TxBodyContent build era -> TxBodyContent build era
setTxCertificates :: TxCertificates build era -> TxBodyContent build era -> TxBodyContent build era
setTxCurrentTreasuryValue :: Maybe (Featured ConwayEraOnwards era (Maybe Coin)) -> TxBodyContent build era -> TxBodyContent build era
setTxExtraKeyWits :: TxExtraKeyWitnesses era -> TxBodyContent build era -> TxBodyContent build era
setTxFee :: TxFee era -> TxBodyContent build era -> TxBodyContent build era
setTxIns :: TxIns build era -> TxBodyContent build era -> TxBodyContent build era
setTxInsCollateral :: TxInsCollateral era -> TxBodyContent build era -> TxBodyContent build era
setTxInsReference :: TxInsReference build era -> TxBodyContent build era -> TxBodyContent build era
setTxMetadata :: TxMetadataInEra era -> TxBodyContent build era -> TxBodyContent build era
setTxMintValue :: TxMintValue build era -> TxBodyContent build era -> TxBodyContent build era
setTxOuts :: [TxOut CtxTx era] -> TxBodyContent build era -> TxBodyContent build era
setTxProposalProcedures :: Maybe (Featured ConwayEraOnwards era (TxProposalProcedures build era)) -> TxBodyContent build era -> TxBodyContent build era
setTxProtocolParams :: BuildTxWith build (Maybe (LedgerProtocolParameters era)) -> TxBodyContent build era -> TxBodyContent build era
setTxReturnCollateral :: TxReturnCollateral CtxTx era -> TxBodyContent build era -> TxBodyContent build era
setTxScriptValidity :: TxScriptValidity era -> TxBodyContent build era -> TxBodyContent build era
setTxTotalCollateral :: TxTotalCollateral era -> TxBodyContent build era -> TxBodyContent build era
setTxTreasuryDonation :: Maybe (Featured ConwayEraOnwards era Coin) -> TxBodyContent build era -> TxBodyContent build era
setTxUpdateProposal :: TxUpdateProposal era -> TxBodyContent build era -> TxBodyContent build era
setTxValidityLowerBound :: TxValidityLowerBound era -> TxBodyContent build era -> TxBodyContent build era
setTxValidityUpperBound :: TxValidityUpperBound era -> TxBodyContent build era -> TxBodyContent build era
setTxVotingProcedures :: Maybe (Featured ConwayEraOnwards era (TxVotingProcedures build era)) -> TxBodyContent build era -> TxBodyContent build era
setTxWithdrawals :: TxWithdrawals build era -> TxBodyContent build era -> TxBodyContent build era
subtractTxMintValue :: IsMaryBasedEra era => Map PolicyId (PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era)) -> TxBodyContent build era -> TxBodyContent build era
toAuxiliaryData :: ShelleyBasedEra era -> TxMetadataInEra era -> TxAuxScripts era -> Maybe (TxAuxData (ShelleyLedgerEra era))
toScriptIndex :: AlonzoEraOnwards era -> PlutusPurpose AsIx (ShelleyLedgerEra era) -> ScriptWitnessIndex
txMintValueToValue :: TxMintValue build era -> Value
validateMetadata :: TxMetadataInEra era -> Either TxBodyError ()
validateProtocolParameters :: BuildTxWith BuildTx (Maybe (LedgerProtocolParameters era)) -> Set Language -> Either TxBodyError ()
validateTxIns :: [(TxIn, BuildTxWith BuildTx (Witness WitCtxTxIn era))] -> Either TxBodyError ()
validateTxInsCollateral :: TxInsCollateral era -> Set Language -> Either TxBodyError ()
adaAssetL :: ShelleyBasedEra era -> Lens' (Value (ShelleyLedgerEra era)) Coin
certsTxBodyL :: ShelleyBasedEra era -> Lens' (LedgerTxBody era) (StrictSeq (TxCert (ShelleyLedgerEra era)))
collateralInputsTxBodyL :: AlonzoEraOnwards era -> Lens' (LedgerTxBody era) (Set TxIn)
collateralReturnTxBodyL :: BabbageEraOnwards era -> Lens' (LedgerTxBody era) (StrictMaybe (TxOut (ShelleyLedgerEra era)))
currentTreasuryValueTxBodyL :: ConwayEraOnwards era -> Lens' (LedgerTxBody era) (StrictMaybe Coin)
invalidBeforeStrictL :: Lens' ValidityInterval (StrictMaybe SlotNo)
invalidBeforeTxBodyL :: AllegraEraOnwards era -> Lens' (LedgerTxBody era) (Maybe SlotNo)
invalidHereAfterStrictL :: Lens' ValidityInterval (StrictMaybe SlotNo)
invalidHereAfterTxBodyL :: ShelleyBasedEra era -> Lens' (LedgerTxBody era) (Maybe SlotNo)
mintTxBodyL :: MaryEraOnwards era -> Lens' (LedgerTxBody era) MultiAsset
mkAdaOnlyTxOut :: ShelleyBasedEra era -> Addr -> Coin -> TxOut (ShelleyLedgerEra era)
mkAdaValue :: ShelleyBasedEra era -> Coin -> Value (ShelleyLedgerEra era)
multiAssetL :: MaryEraOnwards era -> Lens' MaryValue MultiAsset
proposalProceduresTxBodyL :: ConwayEraOnwards era -> Lens' (LedgerTxBody era) (OSet (ProposalProcedure (ShelleyLedgerEra era)))
referenceInputsTxBodyL :: BabbageEraOnwards era -> Lens' (LedgerTxBody era) (Set TxIn)
reqSignerHashesTxBodyL :: AlonzoEraOnwards era -> Lens' (LedgerTxBody era) (Set (KeyHash 'Witness))
scriptIntegrityHashTxBodyL :: AlonzoEraOnwards era -> Lens' (LedgerTxBody era) (StrictMaybe ScriptIntegrityHash)
strictMaybeL :: forall a f. Functor f => (Maybe a -> f (Maybe a)) -> StrictMaybe a -> f (StrictMaybe a)
totalCollateralTxBodyL :: BabbageEraOnwards era -> Lens' (LedgerTxBody era) (StrictMaybe Coin)
treasuryDonationTxBodyL :: ConwayEraOnwards era -> Lens' (LedgerTxBody era) Coin
ttlAsInvalidHereAfterTxBodyL :: ShelleyEraOnly era -> Lens' (LedgerTxBody era) (Maybe SlotNo)
txBodyL :: forall era f. Functor f => (TxBody (ShelleyLedgerEra era) -> f (TxBody (ShelleyLedgerEra era))) -> LedgerTxBody era -> f (LedgerTxBody era)
updateTxBodyL :: ShelleyToBabbageEra era -> Lens' (LedgerTxBody era) (StrictMaybe (Update (ShelleyLedgerEra era)))
valueTxOutAdaAssetL :: ShelleyBasedEra era -> Lens' (TxOut (ShelleyLedgerEra era)) Coin
valueTxOutL :: ShelleyBasedEra era -> Lens' (TxOut (ShelleyLedgerEra era)) (Value (ShelleyLedgerEra era))
votingProceduresTxBodyL :: ConwayEraOnwards era -> Lens' (LedgerTxBody era) (VotingProcedures (ShelleyLedgerEra era))
buildTxWithToMaybe :: BuildTxWith build a -> Maybe a
constructBalancedTx :: ShelleyBasedEra era -> TxBodyContent BuildTx era -> AddressInEra era -> Maybe Word -> UTxO era -> LedgerProtocolParameters era -> LedgerEpochInfo -> SystemStart -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> [ShelleyWitnessSigningKey] -> Either (TxBodyErrorAutoBalance era) (Tx era)
notScriptLockedTxIns :: [TxIn] -> UTxO era -> Either ScriptLockedTxInsError ()
renderNotScriptLockedTxInsError :: ScriptLockedTxInsError -> Text
renderTxInsExistError :: TxInsExistError -> Text
txInsExistInUTxO :: [TxIn] -> UTxO era -> Either TxInsExistError ()
calcReturnAndTotalCollateral :: AlonzoEraPParams (ShelleyLedgerEra era) => BabbageEraOnwards era -> Coin -> PParams (ShelleyLedgerEra era) -> TxInsCollateral era -> TxReturnCollateral CtxTx era -> TxTotalCollateral era -> AddressInEra era -> Value (ShelleyLedgerEra era) -> (TxReturnCollateral CtxTx era, TxTotalCollateral era)
calculateMinTxFee :: ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> UTxO era -> TxBody era -> Word -> Coin
calculateMinimumUTxO :: HasCallStack => ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> TxOut CtxTx era -> Coin
estimateBalancedTxBody :: HasCallStack => MaryEraOnwards era -> TxBodyContent BuildTx era -> PParams (ShelleyLedgerEra era) -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> Map ScriptWitnessIndex ExecutionUnits -> Coin -> Int -> Int -> Int -> AddressInEra era -> Value -> Either (TxFeeEstimationError era) (BalancedTxBody era)
estimateOrCalculateBalancedTxBody :: ShelleyBasedEra era -> FeeEstimationMode era -> PParams (ShelleyLedgerEra era) -> TxBodyContent BuildTx era -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> AddressInEra era -> Either (AutoBalanceError era) (BalancedTxBody era)
estimateTransactionKeyWitnessCount :: TxBodyContent BuildTx era -> Word
evaluateTransactionBalance :: ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> UTxO era -> TxBody era -> TxOutValue era
evaluateTransactionExecutionUnits :: CardanoEra era -> SystemStart -> LedgerEpochInfo -> LedgerProtocolParameters era -> UTxO era -> TxBody era -> Map ScriptWitnessIndex (Either ScriptExecutionError (EvalTxExecutionUnitsLog, ExecutionUnits))
evaluateTransactionExecutionUnitsShelley :: ShelleyBasedEra era -> SystemStart -> LedgerEpochInfo -> LedgerProtocolParameters era -> UTxO era -> Tx (ShelleyLedgerEra era) -> Map ScriptWitnessIndex (Either ScriptExecutionError (EvalTxExecutionUnitsLog, ExecutionUnits))
evaluateTransactionFee :: ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> TxBody era -> Word -> Word -> Int -> Coin
handleExUnitsErrors :: ScriptValidity -> Map ScriptWitnessIndex ScriptExecutionError -> Map ScriptWitnessIndex ExecutionUnits -> Either (TxBodyErrorAutoBalance era) (Map ScriptWitnessIndex ExecutionUnits)
makeTransactionBodyAutoBalance :: HasCallStack => ShelleyBasedEra era -> SystemStart -> LedgerEpochInfo -> LedgerProtocolParameters era -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> UTxO era -> TxBodyContent BuildTx era -> AddressInEra era -> Maybe Word -> Either (TxBodyErrorAutoBalance era) (BalancedTxBody era)
substituteExecutionUnits :: Map ScriptWitnessIndex ExecutionUnits -> TxBodyContent BuildTx era -> Either (TxBodyErrorAutoBalance era) (TxBodyContent BuildTx era)
convTxOuts :: forall ctx era ledgerera. (HasCallStack, ShelleyLedgerEra era ~ ledgerera) => ShelleyBasedEra era -> [TxOut ctx era] -> StrictSeq (TxOut ledgerera)
fromCtxUTxOTxOut :: TxOut CtxUTxO era -> TxOut CtxTx era
fromLedgerTxOuts :: ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> TxBodyScriptData era -> [TxOut CtxTx era]
fromShelleyTxOut :: ShelleyBasedEra era -> TxOut (ShelleyLedgerEra era) -> TxOut ctx era
lovelaceToTxOutValue :: ShelleyBasedEra era -> Coin -> TxOutValue era
prettyRenderTxOut :: TxOutInAnyEra -> Text
scriptDataToInlineDatum :: Era ledgerera => HashableScriptData -> Datum ledgerera
toCtxUTxOTxOut :: TxOut CtxTx era -> TxOut CtxUTxO era
toShelleyTxOut :: (HasCallStack, ShelleyLedgerEra era ~ ledgerera) => ShelleyBasedEra era -> TxOut CtxUTxO era -> TxOut ledgerera
toShelleyTxOutAny :: forall ctx era ledgerera. (HasCallStack, ShelleyLedgerEra era ~ ledgerera) => ShelleyBasedEra era -> TxOut ctx era -> TxOut ledgerera
txOutInAnyEra :: CardanoEra era -> TxOut CtxTx era -> TxOutInAnyEra
txOutValueToLovelace :: TxOutValue era -> Coin
txOutValueToValue :: TxOutValue era -> Value
validateTxOuts :: ShelleyBasedEra era -> [TxOut CtxTx era] -> Either TxOutputError ()
getByronTxBody :: ATxAux ByteString -> Annotated Tx ByteString
getShelleyKeyWitnessVerificationKey :: ShelleySigningKey -> VKey 'Witness
getTxBody :: Tx era -> TxBody era
getTxBodyAndWitnesses :: Tx era -> (TxBody era, [KeyWitness era])
getTxWitnesses :: Tx era -> [KeyWitness era]
getTxWitnessesByron :: ATxAux ByteString -> [KeyWitness ByronEra]
isValidToScriptValidity :: IsValid -> ScriptValidity
makeByronKeyWitness :: IsByronKey key => NetworkId -> Annotated Tx ByteString -> SigningKey key -> KeyWitness ByronEra
makeShelleyBasedBootstrapWitness :: ShelleyBasedEra era -> WitnessNetworkIdOrByronAddress -> TxBody (ShelleyLedgerEra era) -> SigningKey ByronKey -> KeyWitness era
makeShelleyBootstrapWitness :: ShelleyBasedEra era -> WitnessNetworkIdOrByronAddress -> TxBody era -> SigningKey ByronKey -> KeyWitness era
makeShelleyKeyWitness' :: ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> ShelleyWitnessSigningKey -> KeyWitness era
makeShelleySignature :: SignableRepresentation tosign => tosign -> ShelleySigningKey -> SignedDSIGN DSIGN tosign
makeSignedByronTransaction :: [KeyWitness era] -> Annotated Tx ByteString -> ATxAux ByteString
makeSignedTransaction :: [KeyWitness era] -> TxBody era -> Tx era
makeSignedTransaction' :: CardanoEra era -> [KeyWitness era] -> TxBody era -> Tx era
scriptValidityToIsValid :: ScriptValidity -> IsValid
selectTxDatums :: TxBodyScriptData era -> Map DataHash (Data (ShelleyLedgerEra era))
signByronTransaction :: NetworkId -> Annotated Tx ByteString -> [SigningKey ByronKey] -> ATxAux ByteString
toShelleySigningKey :: ShelleyWitnessSigningKey -> ShelleySigningKey
txScriptValidityToIsValid :: TxScriptValidity era -> IsValid
txScriptValidityToScriptValidity :: TxScriptValidity era -> ScriptValidity
fromByronTxIn :: TxIn -> TxIn
fromShelleyTxId :: TxId -> TxId
fromShelleyTxIn :: TxIn -> TxIn
parseTxId :: Parser TxId
parseTxIn :: Parser TxIn
parseTxIx :: Parser TxIx
renderTxIn :: TxIn -> Text
toByronTxId :: TxId -> TxId
toShelleyTxId :: TxId -> TxId
toShelleyTxIn :: TxIn -> TxIn
fromShelleyMetadata :: Map Word64 Metadatum -> Map Word64 TxMetadataValue
fromShelleyMetadatum :: Metadatum -> TxMetadataValue
makeTransactionMetadata :: Map Word64 TxMetadataValue -> TxMetadata
mergeTransactionMetadata :: (TxMetadataValue -> TxMetadataValue -> TxMetadataValue) -> TxMetadata -> TxMetadata -> TxMetadata
metaBytesChunks :: ByteString -> TxMetadataValue
metaTextChunks :: Text -> TxMetadataValue
metadataFromJson :: TxMetadataJsonSchema -> Value -> Either TxMetadataJsonError TxMetadata
metadataToJson :: TxMetadataJsonSchema -> TxMetadata -> Value
metadataValueFromJsonNoSchema :: Value -> Either TxMetadataJsonSchemaError TxMetadataValue
metadataValueToJsonNoSchema :: TxMetadataValue -> Value
pBytes :: Parser ByteString
pSigned :: Parser Integer
pUnsigned :: Parser Integer
parseAll :: Parser a -> Text -> Maybe a
toShelleyMetadata :: Map Word64 TxMetadataValue -> Map Word64 Metadatum
toShelleyMetadatum :: TxMetadataValue -> Metadatum
validateTxMetadata :: TxMetadata -> Either [(Word64, TxMetadataRangeError)] ()
allPositive :: Value -> Bool
calcMinimumDeposit :: Value -> Lovelace -> Lovelace
filterValue :: (AssetId -> Bool) -> Value -> Value
fromByronLovelace :: Lovelace -> Lovelace
fromMaryValue :: MaryValue -> Value
fromMultiAsset :: MultiAsset -> Value
fromShelleyDeltaLovelace :: DeltaCoin -> Lovelace
lovelaceToQuantity :: Lovelace -> Quantity
lovelaceToValue :: Lovelace -> Value
multiAssetToPolicyAssets :: MultiAsset -> Map PolicyId PolicyAssets
negateLedgerValue :: ShelleyBasedEra era -> Value (ShelleyLedgerEra era) -> Value (ShelleyLedgerEra era)
negateValue :: Value -> Value
parseAssetId :: Parser AssetId
parseAssetName :: Parser AssetName
parsePolicyId :: Parser PolicyId
parseQuantity :: Parser Quantity
policyAssetsToValue :: PolicyId -> PolicyAssets -> Value
quantityToLovelace :: Quantity -> Lovelace
renderMultiAsset :: MultiAsset -> Text
renderMultiAssetPretty :: MultiAsset -> Text
renderValue :: Value -> Text
renderValuePretty :: Value -> Text
scriptPolicyId :: Script lang -> PolicyId
selectAsset :: Value -> AssetId -> Quantity
selectLovelace :: Value -> Lovelace
toByronLovelace :: Lovelace -> Maybe Lovelace
toMaryValue :: Value -> MaryValue
valueFromList :: [(AssetId, Quantity)] -> Value
valueFromNestedRep :: ValueNestedRep -> Value
valueToList :: Value -> [(AssetId, Quantity)]
valueToLovelace :: Value -> Maybe Lovelace
valueToNestedRep :: Value -> ValueNestedRep
valueToPolicyAssets :: Value -> Map PolicyId PolicyAssets
parseMintingMultiAssetValue :: MaryEraOnwards era -> Parser MultiAsset
parseTxOutMultiAssetValue :: Parser Value
parseUTxOValue :: Parser Value
invalidBeforeL :: Lens' ValidityInterval (Maybe SlotNo)
invalidHereAfterL :: Lens' ValidityInterval (Maybe SlotNo)
interpreterToEpochInfo :: forall (xs :: [Type]). Interpreter xs -> EpochInfo (Except PastHorizonException)
unsafeExtendSafeZone :: forall (xs :: [Type]). Interpreter xs -> Interpreter xs
byronIdTx :: ATxAux ByteString -> TxId
vsep :: [Doc ann] -> Doc ann
bimapExceptT :: forall (m :: Type -> Type) x y a b. Functor m => (x -> y) -> (a -> b) -> ExceptT x m a -> ExceptT y m b
bracketExceptT :: forall (m :: Type -> Type) e a b c. Monad m => ExceptT e m a -> (a -> ExceptT e m b) -> (a -> ExceptT e m c) -> ExceptT e m c
bracketExceptionT :: forall (m :: Type -> Type) e a c b. MonadMask m => ExceptT e m a -> (a -> ExceptT e m c) -> (a -> ExceptT e m b) -> ExceptT e m b
catchExceptT :: (MonadCatch m, Exception e) => m a -> (e -> x) -> ExceptT x m a
catchIOExceptT :: forall (m :: Type -> Type) a x. MonadIO m => IO a -> (IOException -> x) -> ExceptT x m a
catchLeftT :: forall (m :: Type -> Type) e a. Monad m => ExceptT e m a -> (e -> ExceptT e m a) -> ExceptT e m a
catchesExceptT :: (Foldable f, MonadCatch m) => m a -> f (Handler m x) -> ExceptT x m a
exceptT :: Monad m => (x -> m b) -> (a -> m b) -> ExceptT x m a -> m b
firstExceptT :: forall (m :: Type -> Type) x y a. Functor m => (x -> y) -> ExceptT x m a -> ExceptT y m a
handleExceptT :: (MonadCatch m, Exception e) => (e -> x) -> m a -> ExceptT x m a
handleIOExceptT :: forall (m :: Type -> Type) x a. MonadIO m => (IOException -> x) -> IO a -> ExceptT x m a
handleLeftT :: forall (m :: Type -> Type) e a. Monad m => (e -> ExceptT e m a) -> ExceptT e m a -> ExceptT e m a
handlesExceptT :: (Foldable f, MonadCatch m) => f (Handler m x) -> m a -> ExceptT x m a
hoistEither :: forall (m :: Type -> Type) x a. Monad m => Either x a -> ExceptT x m a
hoistExceptT :: (forall b. () => m b -> n b) -> ExceptT x m a -> ExceptT x n a
hushM :: Monad m => Either e a -> (e -> m ()) -> m (Maybe a)
newExceptT :: m (Either x a) -> ExceptT x m a
onLeft :: forall e x (m :: Type -> Type) a. Monad m => (e -> ExceptT x m a) -> ExceptT x m (Either e a) -> ExceptT x m a
onNothing :: forall x (m :: Type -> Type) a. Monad m => ExceptT x m a -> ExceptT x m (Maybe a) -> ExceptT x m a
secondExceptT :: forall (m :: Type -> Type) a b x. Functor m => (a -> b) -> ExceptT x m a -> ExceptT x m b
txId :: HasTxId tx => tx -> TxId tx
condense :: Condense a => a -> String


-- | Pretty printing transactions and utxo's
module Hydra.Cardano.Api.Pretty

-- | Obtain a human-readable pretty text representation of a transaction.
renderTx :: Tx -> String
renderUTxO :: (TxIn, TxOut ctx era) -> Text

-- | Like <a>renderTx</a>, but uses the given UTxO to resolve inputs.
renderTxWithUTxO :: UTxO Era -> Tx -> String
