-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Haskell API for Cardano, tailored to the Hydra project.
--   
--   A Haskell API for Cardano, tailored to the Hydra project.
@package hydra-cardano-api
@version 0.22.4


-- | NOTE (1): This module is meant to be imported qualified as
--   <a>UTxO</a>.
--   
--   NOTE (2): This module is name-spaces slightly different from the rest
--   because it is meant to be used as a replacement of the UTxO type of
--   the cardano-api which is not convenient enough to work with. Having it
--   as <a>UTxO</a> causes cyclic imports with other modules also relying
--   on this newtype. So instead, we do 'as if' it was part of the
--   cardano-api in the first place.
module Cardano.Api.UTxO
type Era = ConwayEra
type UTxO = UTxO' (TxOut CtxUTxO Era)

-- | Newtype with phantom types mostly required to work around the poor
--   interface of <a>UTXO</a> and provide <a>Monoid</a> and <a>Foldable</a>
--   instances to make utxo manipulation bareable.
newtype UTxO' out
UTxO :: Map TxIn out -> UTxO' out
[toMap] :: UTxO' out -> Map TxIn out

-- | Create a <a>UTxO</a> from a list of <a>TxIn</a> and <tt>out</tt>
--   pairs.
fromList :: [(TxIn, out)] -> UTxO' out

-- | Create a <a>UTxO</a> from a single unspent transaction output.
singleton :: TxIn -> out -> UTxO' out

-- | Find an <tt>out</tt> for a given <a>TxIn</a>.
resolveTxIn :: TxIn -> UTxO' out -> Maybe out

-- | Turn a <a>UTxO</a> into a list of pairs.
toList :: UTxO' out -> [(TxIn, out)]

-- | Find first <a>UTxO</a> using the output in predicate.
find :: (out -> Bool) -> UTxO' out -> Maybe (TxIn, out)

-- | Find first <a>UTxO</a> using both input and output in predicate.
findBy :: ((TxIn, out) -> Bool) -> UTxO' out -> Maybe (TxIn, out)

-- | Filter UTxO to only include <tt>out</tt>s satisfying given predicate.
filter :: (out -> Bool) -> UTxO' out -> UTxO' out

-- | Get the <a>UTxO</a> domain input's set
inputSet :: UTxO' out -> Set TxIn

-- | Get a human-readable pretty text representation of a UTxO.
render :: (TxIn, TxOut ctx era) -> Text

-- | Remove the right hand side from the left hand side.
difference :: UTxO' out -> UTxO' out -> UTxO' out

-- | Check if the first <a>UTxO</a> contains all **outputs** of the second
--   <a>UTxO</a>. First argument is the <a>UTxO</a> to search in, second
--   argument is the <a>UTxO</a> to search for.
containsOutputs :: UTxO -> UTxO -> Bool
map :: (TxOut CtxUTxO Era -> TxOut CtxUTxO Era) -> UTxO -> UTxO
foldMap :: Monoid m => (TxOut CtxUTxO Era -> m) -> UTxO -> m
txOutputs :: UTxO -> [TxOut CtxUTxO Era]
null :: UTxO -> Bool
size :: UTxO -> Int
totalValue :: UTxO -> Value
totalLovelace :: UTxO -> Coin

-- | Transforms a UTxO containing tx outs from any era into Babbage era.
fromApi :: UTxO era -> UTxO
toApi :: UTxO -> UTxO Era
instance Data.Aeson.Types.FromJSON.FromJSON out => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.UTxO.UTxO' out)
instance Data.Aeson.Types.ToJSON.ToJSON out => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.UTxO.UTxO' out)
instance GHC.Base.Monoid (Cardano.Api.UTxO.UTxO' out)
instance GHC.Base.Semigroup (Cardano.Api.UTxO.UTxO' out)
instance GHC.Show.Show out => GHC.Show.Show (Cardano.Api.UTxO.UTxO' out)
instance GHC.Classes.Eq out => GHC.Classes.Eq (Cardano.Api.UTxO.UTxO' out)

module Hydra.Cardano.Api.NetworkMagic
instance Data.Aeson.Types.ToJSON.ToJSON Ouroboros.Network.Magic.NetworkMagic
instance Data.Aeson.Types.FromJSON.FromJSON Ouroboros.Network.Magic.NetworkMagic
instance Test.QuickCheck.Arbitrary.Arbitrary Ouroboros.Network.Magic.NetworkMagic

module Hydra.Cardano.Api.Prelude
class () => Pretty a
pretty :: Pretty a => a -> Doc ann
prettyList :: Pretty a => [a] -> Doc ann
class (Eq VerificationKey keyrole, Show VerificationKey keyrole, SerialiseAsRawBytes Hash keyrole, HasTextEnvelope VerificationKey keyrole, HasTextEnvelope SigningKey keyrole) => Key keyrole where {
    data family VerificationKey keyrole;
    data family SigningKey keyrole;
}
getVerificationKey :: Key keyrole => SigningKey keyrole -> VerificationKey keyrole
deterministicSigningKey :: Key keyrole => AsType keyrole -> Seed -> SigningKey keyrole
deterministicSigningKeySeedSize :: Key keyrole => AsType keyrole -> Word
verificationKeyHash :: Key keyrole => VerificationKey keyrole -> Hash keyrole
data () => Block era
[ByronBlock] :: ByronBlock -> Block ByronEra
[ShelleyBlock] :: forall era. ShelleyBasedEra era -> ShelleyBlock (ConsensusProtocol era) (ShelleyLedgerEra era) -> Block era

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   • Couldn't match type ‘IO’ with ‘StateT s IO’
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a
newtype () => File content (direction :: FileDirection)
File :: FilePath -> File content (direction :: FileDirection)
[unFile] :: File content (direction :: FileDirection) -> FilePath

-- | A monad transformer that adds exceptions to other monads.
--   
--   <tt>ExceptT</tt> constructs a monad parameterized over two things:
--   
--   <ul>
--   <li>e - The exception type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a computation that produces the
--   given value, while <tt>&gt;&gt;=</tt> sequences two subcomputations,
--   exiting on the first exception.
newtype () => ExceptT e (m :: Type -> Type) a
ExceptT :: m (Either e a) -> ExceptT e (m :: Type -> Type) a

-- | The parameterizable exception monad.
--   
--   Computations are either exceptions or normal values.
--   
--   The <a>return</a> function returns a normal value, while
--   <tt>&gt;&gt;=</tt> exits on the first exception. For a variant that
--   continues after an error and collects all the errors, see
--   <a>Errors</a>.
type Except e = ExceptT e Identity

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <tt>Error</tt> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | A handler function to handle previous errors and return to normal
--   execution. A common idiom is:
--   
--   <pre>
--   do { action1; action2; action3 } `catchError` handler
--   </pre>
--   
--   where the <tt>action</tt> functions can call <a>throwError</a>. Note
--   that <tt>handler</tt> and the do-block must have the same return type.
catchError :: MonadError e m => m a -> (e -> m a) -> m a

-- | The class of monad transformers. For any monad <tt>m</tt>, the result
--   <tt>t m</tt> should also be a monad, and <a>lift</a> should be a monad
--   transformation from <tt>m</tt> to <tt>t m</tt>, i.e. it should satisfy
--   the following laws:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
--   
--   Since 0.6.0.0 and for GHC 8.6 and later, the requirement that <tt>t
--   m</tt> be a <a>Monad</a> is enforced by the implication constraint
--   <tt>forall m. <a>Monad</a> m =&gt; <a>Monad</a> (t m)</tt> enabled by
--   the <tt>QuantifiedConstraints</tt> extension.
--   
--   <h3><b>Ambiguity error with GHC 9.0 to 9.2.2</b></h3>
--   
--   These versions of GHC have a bug
--   (<a>https://gitlab.haskell.org/ghc/ghc/-/issues/20582</a>) which
--   causes constraints like
--   
--   <pre>
--   (MonadTrans t, forall m. Monad m =&gt; Monad (t m)) =&gt; ...
--   </pre>
--   
--   to be reported as ambiguous. For transformers 0.6 and later, this can
--   be fixed by removing the second constraint, which is implied by the
--   first.
class forall (m :: Type -> Type). Monad m => Monad t m => MonadTrans (t :: Type -> Type -> Type -> Type)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a
class () => Error e
prettyError :: Error e => e -> Doc ann
data () => Doc ann
data () => AddressInEra era
[AddressInEra] :: forall addrtype era. AddressTypeInEra addrtype era -> Address addrtype -> AddressInEra era
data () => AddressTypeInEra addrtype era
[ByronAddressInAnyEra] :: forall era. AddressTypeInEra ByronAddr era
[ShelleyAddressInEra] :: forall era. ShelleyBasedEra era -> AddressTypeInEra ShelleyAddr era
data () => BalancedTxBody era
BalancedTxBody :: TxBodyContent BuildTx era -> TxBody era -> TxOut CtxTx era -> Coin -> BalancedTxBody era
data () => KeyWitness era
data () => PlutusScript lang
data () => Script lang
[SimpleScript] :: !SimpleScript -> Script SimpleScript'
[PlutusScript] :: forall lang. IsPlutusScriptLanguage lang => !PlutusScriptVersion lang -> !PlutusScript lang -> Script lang
data () => ScriptInEra era
[ScriptInEra] :: forall lang era. ScriptLanguageInEra lang era -> Script lang -> ScriptInEra era
data () => ScriptLanguage lang
[SimpleScriptLanguage] :: ScriptLanguage SimpleScript'
[PlutusScriptLanguage] :: forall lang. IsPlutusScriptLanguage lang => PlutusScriptVersion lang -> ScriptLanguage lang
data () => ScriptWitness witctx era
[SimpleScriptWitness] :: forall era witctx. ScriptLanguageInEra SimpleScript' era -> SimpleScriptOrReferenceInput SimpleScript' -> ScriptWitness witctx era
[PlutusScriptWitness] :: forall lang era witctx. IsPlutusScriptLanguage lang => ScriptLanguageInEra lang era -> PlutusScriptVersion lang -> PlutusScriptOrReferenceInput lang -> ScriptDatum witctx -> ScriptRedeemer -> ExecutionUnits -> ScriptWitness witctx era
data () => Tx era
pattern Tx :: TxBody era -> [KeyWitness era] -> Tx era
data () => TxAuxScripts era
[TxAuxScriptsNone] :: forall era. TxAuxScripts era
[TxAuxScripts] :: forall era. AllegraEraOnwards era -> [ScriptInEra era] -> TxAuxScripts era
data () => TxBody era
[ShelleyTxBody] :: forall era. ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> [Script (ShelleyLedgerEra era)] -> TxBodyScriptData era -> Maybe (TxAuxData (ShelleyLedgerEra era)) -> TxScriptValidity era -> TxBody era
pattern TxBody :: TxBodyContent ViewTx era -> TxBody era
data () => TxBodyContent build era
TxBodyContent :: TxIns build era -> TxInsCollateral era -> TxInsReference build era -> [TxOut CtxTx era] -> TxTotalCollateral era -> TxReturnCollateral CtxTx era -> TxFee era -> TxValidityLowerBound era -> TxValidityUpperBound era -> TxMetadataInEra era -> TxAuxScripts era -> TxExtraKeyWitnesses era -> BuildTxWith build (Maybe (LedgerProtocolParameters era)) -> TxWithdrawals build era -> TxCertificates build era -> TxUpdateProposal era -> TxMintValue build era -> TxScriptValidity era -> Maybe (Featured ConwayEraOnwards era (TxProposalProcedures build era)) -> Maybe (Featured ConwayEraOnwards era (TxVotingProcedures build era)) -> Maybe (Featured ConwayEraOnwards era (Maybe Coin)) -> Maybe (Featured ConwayEraOnwards era Coin) -> TxBodyContent build era
[txIns] :: TxBodyContent build era -> TxIns build era
[txInsCollateral] :: TxBodyContent build era -> TxInsCollateral era
[txInsReference] :: TxBodyContent build era -> TxInsReference build era
[txOuts] :: TxBodyContent build era -> [TxOut CtxTx era]
[txTotalCollateral] :: TxBodyContent build era -> TxTotalCollateral era
[txReturnCollateral] :: TxBodyContent build era -> TxReturnCollateral CtxTx era
[txFee] :: TxBodyContent build era -> TxFee era
[txValidityLowerBound] :: TxBodyContent build era -> TxValidityLowerBound era
[txValidityUpperBound] :: TxBodyContent build era -> TxValidityUpperBound era
[txMetadata] :: TxBodyContent build era -> TxMetadataInEra era
[txAuxScripts] :: TxBodyContent build era -> TxAuxScripts era
[txExtraKeyWits] :: TxBodyContent build era -> TxExtraKeyWitnesses era
[txProtocolParams] :: TxBodyContent build era -> BuildTxWith build (Maybe (LedgerProtocolParameters era))
[txWithdrawals] :: TxBodyContent build era -> TxWithdrawals build era
[txCertificates] :: TxBodyContent build era -> TxCertificates build era
[txUpdateProposal] :: TxBodyContent build era -> TxUpdateProposal era
[txMintValue] :: TxBodyContent build era -> TxMintValue build era
[txScriptValidity] :: TxBodyContent build era -> TxScriptValidity era
[txProposalProcedures] :: TxBodyContent build era -> Maybe (Featured ConwayEraOnwards era (TxProposalProcedures build era))
[txVotingProcedures] :: TxBodyContent build era -> Maybe (Featured ConwayEraOnwards era (TxVotingProcedures build era))
[txCurrentTreasuryValue] :: TxBodyContent build era -> Maybe (Featured ConwayEraOnwards era (Maybe Coin))
[txTreasuryDonation] :: TxBodyContent build era -> Maybe (Featured ConwayEraOnwards era Coin)
data () => TxBodyScriptData era
[TxBodyNoScriptData] :: forall era. TxBodyScriptData era
[TxBodyScriptData] :: forall era. AlonzoEraOnwardsConstraints era => AlonzoEraOnwards era -> TxDats (ShelleyLedgerEra era) -> Redeemers (ShelleyLedgerEra era) -> TxBodyScriptData era
data () => TxExtraKeyWitnesses era
[TxExtraKeyWitnessesNone] :: forall era. TxExtraKeyWitnesses era
[TxExtraKeyWitnesses] :: forall era. AlonzoEraOnwards era -> [Hash PaymentKey] -> TxExtraKeyWitnesses era
data () => TxFee era
[TxFeeExplicit] :: forall era. ShelleyBasedEra era -> Coin -> TxFee era
type TxIns build era = [(TxIn, BuildTxWith build Witness WitCtxTxIn era)]
data () => TxInsCollateral era
[TxInsCollateralNone] :: forall era. TxInsCollateral era
[TxInsCollateral] :: forall era. AlonzoEraOnwards era -> [TxIn] -> TxInsCollateral era
data () => TxInsReference build era
[TxInsReferenceNone] :: forall build era. TxInsReference build era
[TxInsReference] :: forall era build. BabbageEraOnwards era -> [TxIn] -> TxInsReferenceDatums build -> TxInsReference build era
data () => TxMetadataInEra era
[TxMetadataNone] :: forall era. TxMetadataInEra era
[TxMetadataInEra] :: forall era. ShelleyBasedEra era -> TxMetadata -> TxMetadataInEra era
data () => TxMintValue build era
[TxMintNone] :: forall build era. TxMintValue build era
[TxMintValue] :: forall era build. MaryEraOnwards era -> Map PolicyId (PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era)) -> TxMintValue build era
data () => TxOut ctx era
TxOut :: AddressInEra era -> TxOutValue era -> TxOutDatum ctx era -> ReferenceScript era -> TxOut ctx era
data () => TxOutDatum ctx era
[TxOutDatumNone] :: forall ctx era. TxOutDatum ctx era
[TxOutDatumHash] :: forall era ctx. AlonzoEraOnwards era -> Hash ScriptData -> TxOutDatum ctx era
[TxOutSupplementalDatum] :: forall era. AlonzoEraOnwards era -> HashableScriptData -> TxOutDatum CtxTx era
[TxOutDatumInline] :: forall era ctx. BabbageEraOnwards era -> HashableScriptData -> TxOutDatum ctx era
data () => TxScriptValidity era
[TxScriptValidityNone] :: forall era. TxScriptValidity era
[TxScriptValidity] :: forall era. AlonzoEraOnwards era -> ScriptValidity -> TxScriptValidity era
data () => TxValidityLowerBound era
[TxValidityNoLowerBound] :: forall era. TxValidityLowerBound era
[TxValidityLowerBound] :: forall era. AllegraEraOnwards era -> SlotNo -> TxValidityLowerBound era
data () => TxValidityUpperBound era
[TxValidityUpperBound] :: forall era. ShelleyBasedEra era -> Maybe SlotNo -> TxValidityUpperBound era
data () => Witness witctx era
[KeyWitness] :: forall witctx era. KeyWitnessInCtx witctx -> Witness witctx era
[ScriptWitness] :: forall witctx era. ScriptWitnessInCtx witctx -> ScriptWitness witctx era -> Witness witctx era
data family Hash keyrole
data family SigningKey keyrole
data () => StakeCredential
data family VerificationKey keyrole
data () => Address addrtype
[ByronAddress] :: Address -> Address ByronAddr
[ShelleyAddress] :: Network -> PaymentCredential -> StakeReference -> Address ShelleyAddr
data () => BlockHeader
BlockHeader :: !SlotNo -> !Hash BlockHeader -> !BlockNo -> BlockHeader
data () => ChainPoint
ChainPointAtGenesis :: ChainPoint
ChainPoint :: !SlotNo -> !Hash BlockHeader -> ChainPoint
data () => ExecutionUnits
ExecutionUnits :: Natural -> Natural -> ExecutionUnits
[executionSteps] :: ExecutionUnits -> Natural
[executionMemory] :: ExecutionUnits -> Natural
data () => NetworkId
Mainnet :: NetworkId
Testnet :: !NetworkMagic -> NetworkId
newtype () => NetworkMagic
NetworkMagic :: Word32 -> NetworkMagic
[unNetworkMagic] :: NetworkMagic -> Word32
newtype () => PolicyAssets
PolicyAssets :: Map AssetName Quantity -> PolicyAssets
newtype () => PolicyId
PolicyId :: ScriptHash -> PolicyId
[unPolicyId] :: PolicyId -> ScriptHash
data () => ScriptData
ScriptDataConstructor :: Integer -> [ScriptData] -> ScriptData
ScriptDataMap :: [(ScriptData, ScriptData)] -> ScriptData
ScriptDataList :: [ScriptData] -> ScriptData
ScriptDataNumber :: Integer -> ScriptData
ScriptDataBytes :: ByteString -> ScriptData
data () => ScriptDatum witctx
[ScriptDatumForTxIn] :: Maybe HashableScriptData -> ScriptDatum WitCtxTxIn
[InlineScriptDatum] :: ScriptDatum WitCtxTxIn
[NoScriptDatumForMint] :: ScriptDatum WitCtxMint
[NoScriptDatumForStake] :: ScriptDatum WitCtxStake
newtype () => ScriptHash
ScriptHash :: ScriptHash -> ScriptHash
data () => StakeAddress
newtype () => TxId
TxId :: Hash HASH EraIndependentTxBody -> TxId
data () => TxIn
TxIn :: TxId -> TxIx -> TxIn
data () => TxOutValue era
[TxOutValueByron] :: Coin -> TxOutValue ByronEra
[TxOutValueShelleyBased] :: forall era. (Eq (Value (ShelleyLedgerEra era)), Show (Value (ShelleyLedgerEra era))) => ShelleyBasedEra era -> Value (ShelleyLedgerEra era) -> TxOutValue era
data () => Value
data () => ByronAddr
class () => FromJSON a
class () => ToJSON a
class Typeable a => FromCBOR a
class Typeable a => ToCBOR a
data () => ConwayEra
data () => CtxUTxO
data () => AddressAny
AddressByron :: !Address ByronAddr -> AddressAny
AddressShelley :: !Address ShelleyAddr -> AddressAny
data () => PaymentCredential
PaymentCredentialByKey :: Hash PaymentKey -> PaymentCredential
PaymentCredentialByScript :: ScriptHash -> PaymentCredential
class HasTypeProxy addr => SerialiseAddress addr
serialiseAddress :: SerialiseAddress addr => addr -> Text
deserialiseAddress :: SerialiseAddress addr => AsType addr -> Text -> Maybe addr
data () => ShelleyAddr
newtype () => StakeAddressPointer
StakeAddressPointer :: Ptr -> StakeAddressPointer
[unStakeAddressPointer] :: StakeAddressPointer -> Ptr
data () => StakeAddressReference
StakeAddressByValue :: StakeCredential -> StakeAddressReference
StakeAddressByPointer :: StakeAddressPointer -> StakeAddressReference
NoStakeAddress :: StakeAddressReference
newtype () => AnchorDataHash
AnchorDataHash :: SafeHash AnchorData -> AnchorDataHash
[unAnchorDataHash] :: AnchorDataHash -> SafeHash AnchorData
newtype () => AnchorUrl
AnchorUrl :: Url -> AnchorUrl
[unAnchorUrl] :: AnchorUrl -> Url
data () => BlockInMode
[BlockInMode] :: forall era. CardanoEra era -> Block era -> BlockInMode
data () => ChainTip
ChainTipAtGenesis :: ChainTip
ChainTip :: !SlotNo -> !Hash BlockHeader -> !BlockNo -> ChainTip
class (SerialiseAsRawBytes a, HasTypeProxy a) => Cip129 a
cip129Bech32PrefixFor :: Cip129 a => AsType a -> HumanReadablePart
cip129HeaderHexByte :: Cip129 a => a -> ByteString
cip129Bech32PrefixesPermitted :: Cip129 a => AsType a -> [Text]
data () => AnchorDataFromCertificateError
InvalidPoolMetadataHashError :: Url -> ByteString -> AnchorDataFromCertificateError
data () => Certificate era
[ShelleyRelatedCertificate] :: forall era. Typeable era => ShelleyToBabbageEra era -> ShelleyTxCert (ShelleyLedgerEra era) -> Certificate era
[ConwayCertificate] :: forall era. Typeable era => ConwayEraOnwards era -> ConwayTxCert (ShelleyLedgerEra era) -> Certificate era
data () => CommitteeColdkeyResignationRequirements era
[CommitteeColdkeyResignationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'ColdCommitteeRole -> Maybe Anchor -> CommitteeColdkeyResignationRequirements era
data () => CommitteeHotKeyAuthorizationRequirements era
[CommitteeHotKeyAuthorizationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'ColdCommitteeRole -> Credential 'HotCommitteeRole -> CommitteeHotKeyAuthorizationRequirements era
data () => DRepMetadataReference
data () => DRepRegistrationRequirements era
[DRepRegistrationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'DRepRole -> Coin -> DRepRegistrationRequirements era
data () => DRepUnregistrationRequirements era
[DRepUnregistrationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'DRepRole -> Coin -> DRepUnregistrationRequirements era
data () => DRepUpdateRequirements era
[DRepUpdateRequirements] :: forall era. ConwayEraOnwards era -> Credential 'DRepRole -> DRepUpdateRequirements era
data () => GenesisKeyDelegationRequirements era
[GenesisKeyDelegationRequirements] :: forall era. ShelleyToBabbageEra era -> Hash GenesisKey -> Hash GenesisDelegateKey -> Hash VrfKey -> GenesisKeyDelegationRequirements era
data () => MirCertificateRequirements era
[MirCertificateRequirements] :: forall era. ShelleyToBabbageEra era -> MIRPot -> MIRTarget -> MirCertificateRequirements era
data () => StakeAddressRequirements era
[StakeAddrRegistrationConway] :: forall era. ConwayEraOnwards era -> Coin -> StakeCredential -> StakeAddressRequirements era
[StakeAddrRegistrationPreConway] :: forall era. ShelleyToBabbageEra era -> StakeCredential -> StakeAddressRequirements era
data () => StakeDelegationRequirements era
[StakeDelegationRequirementsConwayOnwards] :: forall era. ConwayEraOnwards era -> StakeCredential -> Delegatee -> StakeDelegationRequirements era
[StakeDelegationRequirementsPreConway] :: forall era. ShelleyToBabbageEra era -> StakeCredential -> PoolId -> StakeDelegationRequirements era
data () => StakePoolMetadataReference
data () => StakePoolParameters
data () => StakePoolRegistrationRequirements era
[StakePoolRegistrationRequirementsConwayOnwards] :: forall era. ConwayEraOnwards era -> PoolParams -> StakePoolRegistrationRequirements era
[StakePoolRegistrationRequirementsPreConway] :: forall era. ShelleyToBabbageEra era -> PoolParams -> StakePoolRegistrationRequirements era
data () => StakePoolRelay
data () => StakePoolRetirementRequirements era
[StakePoolRetirementRequirementsConwayOnwards] :: forall era. ConwayEraOnwards era -> PoolId -> EpochNo -> StakePoolRetirementRequirements era
[StakePoolRetirementRequirementsPreConway] :: forall era. ShelleyToBabbageEra era -> PoolId -> EpochNo -> StakePoolRetirementRequirements era
newtype () => ScriptLockedTxInsError
ScriptLockedTxIns :: [TxIn] -> ScriptLockedTxInsError
data () => TxInsExistError
TxInsDoNotExist :: [TxIn] -> TxInsExistError
EmptyUTxO :: TxInsExistError
data () => QueryConvenienceError
AcqFailure :: AcquiringFailure -> QueryConvenienceError
QueryEraMismatch :: EraMismatch -> QueryConvenienceError
ByronEraNotSupported :: QueryConvenienceError
QceUnsupportedNtcVersion :: !UnsupportedNtcVersionError -> QueryConvenienceError
QceUnexpectedException :: !SomeException -> QueryConvenienceError
newtype () => TxCurrentTreasuryValue
TxCurrentTreasuryValue :: Coin -> TxCurrentTreasuryValue
[unTxCurrentTreasuryValue] :: TxCurrentTreasuryValue -> Coin
data () => DRepMetadata
data () => InputDecodeError
InputTextEnvelopeError :: !TextEnvelopeError -> InputDecodeError
InputBech32DecodeError :: !Bech32DecodeError -> InputDecodeError
InputInvalidError :: InputDecodeError
data () => InputFormat a
[InputFormatBech32] :: forall a. SerialiseAsBech32 a => InputFormat a
[InputFormatHex] :: forall a. SerialiseAsRawBytes a => InputFormat a
[InputFormatTextEnvelope] :: forall a. HasTextEnvelope a => InputFormat a
data () => SomeAddressVerificationKey
AByronVerificationKey :: VerificationKey ByronKey -> SomeAddressVerificationKey
APaymentVerificationKey :: VerificationKey PaymentKey -> SomeAddressVerificationKey
APaymentExtendedVerificationKey :: VerificationKey PaymentExtendedKey -> SomeAddressVerificationKey
AGenesisUTxOVerificationKey :: VerificationKey GenesisUTxOKey -> SomeAddressVerificationKey
AGenesisExtendedVerificationKey :: VerificationKey GenesisExtendedKey -> SomeAddressVerificationKey
AGenesisDelegateExtendedVerificationKey :: VerificationKey GenesisDelegateExtendedKey -> SomeAddressVerificationKey
AKesVerificationKey :: VerificationKey KesKey -> SomeAddressVerificationKey
AVrfVerificationKey :: VerificationKey VrfKey -> SomeAddressVerificationKey
AStakeVerificationKey :: VerificationKey StakeKey -> SomeAddressVerificationKey
AStakeExtendedVerificationKey :: VerificationKey StakeExtendedKey -> SomeAddressVerificationKey
AStakePoolVerificationKey :: VerificationKey StakePoolKey -> SomeAddressVerificationKey
AStakePoolExtendedVerificationKey :: VerificationKey StakePoolExtendedKey -> SomeAddressVerificationKey
ADRepVerificationKey :: VerificationKey DRepKey -> SomeAddressVerificationKey
ADRepExtendedVerificationKey :: VerificationKey DRepExtendedKey -> SomeAddressVerificationKey
ACommitteeColdVerificationKey :: VerificationKey CommitteeColdKey -> SomeAddressVerificationKey
ACommitteeColdExtendedVerificationKey :: VerificationKey CommitteeColdExtendedKey -> SomeAddressVerificationKey
ACommitteeHotVerificationKey :: VerificationKey CommitteeHotKey -> SomeAddressVerificationKey
ACommitteeHotExtendedVerificationKey :: VerificationKey CommitteeHotExtendedKey -> SomeAddressVerificationKey
data () => AllegraEraOnwards era
[AllegraEraOnwardsAllegra] :: AllegraEraOnwards AllegraEra
[AllegraEraOnwardsMary] :: AllegraEraOnwards MaryEra
[AllegraEraOnwardsAlonzo] :: AllegraEraOnwards AlonzoEra
[AllegraEraOnwardsBabbage] :: AllegraEraOnwards BabbageEra
[AllegraEraOnwardsConway] :: AllegraEraOnwards ConwayEra
class IsShelleyBasedEra era => IsAllegraBasedEra era
allegraBasedEra :: IsAllegraBasedEra era => AllegraEraOnwards era
data () => AlonzoEraOnwards era
[AlonzoEraOnwardsAlonzo] :: AlonzoEraOnwards AlonzoEra
[AlonzoEraOnwardsBabbage] :: AlonzoEraOnwards BabbageEra
[AlonzoEraOnwardsConway] :: AlonzoEraOnwards ConwayEra
type AlonzoEraOnwardsConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, AlonzoEraPParams ShelleyLedgerEra era, AlonzoEraTx ShelleyLedgerEra era, AlonzoEraTxBody ShelleyLedgerEra era, AlonzoEraTxOut ShelleyLedgerEra era, AlonzoEraTxWits ShelleyLedgerEra era, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, EraUTxO ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, MaryEraTxBody ShelleyLedgerEra era, NativeScript ShelleyLedgerEra era ~ Timelock ShelleyLedgerEra era, EraPlutusContext ShelleyLedgerEra era, Script ShelleyLedgerEra era ~ AlonzoScript ShelleyLedgerEra era, ScriptsNeeded ShelleyLedgerEra era ~ AlonzoScriptsNeeded ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, Value ShelleyLedgerEra era ~ MaryValue, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
class IsMaryBasedEra era => IsAlonzoBasedEra era
alonzoBasedEra :: IsAlonzoBasedEra era => AlonzoEraOnwards era
data () => BabbageEraOnwards era
[BabbageEraOnwardsBabbage] :: BabbageEraOnwards BabbageEra
[BabbageEraOnwardsConway] :: BabbageEraOnwards ConwayEra
class IsAlonzoBasedEra era => IsBabbageBasedEra era
babbageBasedEra :: IsBabbageBasedEra era => BabbageEraOnwards era
data () => ByronToAlonzoEra era
[ByronToAlonzoEraByron] :: ByronToAlonzoEra ByronEra
[ByronToAlonzoEraShelley] :: ByronToAlonzoEra ShelleyEra
[ByronToAlonzoEraAllegra] :: ByronToAlonzoEra AllegraEra
[ByronToAlonzoEraMary] :: ByronToAlonzoEra MaryEra
[ByronToAlonzoEraAlonzo] :: ByronToAlonzoEra AlonzoEra
class () => Convert (f :: a -> Type) (g :: a -> Type)
convert :: forall (era :: a). Convert f g => f era -> g era
data () => ConwayEraOnwards era
[ConwayEraOnwardsConway] :: ConwayEraOnwards ConwayEra
class IsBabbageBasedEra era => IsConwayBasedEra era
conwayBasedEra :: IsConwayBasedEra era => ConwayEraOnwards era
class IsAllegraBasedEra era => IsMaryBasedEra era
maryBasedEra :: IsMaryBasedEra era => MaryEraOnwards era
data () => MaryEraOnwards era
[MaryEraOnwardsMary] :: MaryEraOnwards MaryEra
[MaryEraOnwardsAlonzo] :: MaryEraOnwards AlonzoEra
[MaryEraOnwardsBabbage] :: MaryEraOnwards BabbageEra
[MaryEraOnwardsConway] :: MaryEraOnwards ConwayEra
data () => AnyShelleyBasedEra
[AnyShelleyBasedEra] :: forall era. Typeable era => ShelleyBasedEra era -> AnyShelleyBasedEra
data () => InAnyShelleyBasedEra (thing :: Type -> Type)
[InAnyShelleyBasedEra] :: forall era (thing :: Type -> Type). Typeable era => ShelleyBasedEra era -> thing era -> InAnyShelleyBasedEra thing
class IsCardanoEra era => IsShelleyBasedEra era
shelleyBasedEra :: IsShelleyBasedEra era => ShelleyBasedEra era
data () => ShelleyBasedEra era
[ShelleyBasedEraShelley] :: ShelleyBasedEra ShelleyEra
[ShelleyBasedEraAllegra] :: ShelleyBasedEra AllegraEra
[ShelleyBasedEraMary] :: ShelleyBasedEra MaryEra
[ShelleyBasedEraAlonzo] :: ShelleyBasedEra AlonzoEra
[ShelleyBasedEraBabbage] :: ShelleyBasedEra BabbageEra
[ShelleyBasedEraConway] :: ShelleyBasedEra ConwayEra
data () => ShelleyEraOnly era
[ShelleyEraOnlyShelley] :: ShelleyEraOnly ShelleyEra
data () => ShelleyToAllegraEra era
[ShelleyToAllegraEraShelley] :: ShelleyToAllegraEra ShelleyEra
[ShelleyToAllegraEraAllegra] :: ShelleyToAllegraEra AllegraEra
data () => ShelleyToAlonzoEra era
[ShelleyToAlonzoEraShelley] :: ShelleyToAlonzoEra ShelleyEra
[ShelleyToAlonzoEraAllegra] :: ShelleyToAlonzoEra AllegraEra
[ShelleyToAlonzoEraMary] :: ShelleyToAlonzoEra MaryEra
[ShelleyToAlonzoEraAlonzo] :: ShelleyToAlonzoEra AlonzoEra
data () => ShelleyToBabbageEra era
[ShelleyToBabbageEraShelley] :: ShelleyToBabbageEra ShelleyEra
[ShelleyToBabbageEraAllegra] :: ShelleyToBabbageEra AllegraEra
[ShelleyToBabbageEraMary] :: ShelleyToBabbageEra MaryEra
[ShelleyToBabbageEraAlonzo] :: ShelleyToBabbageEra AlonzoEra
[ShelleyToBabbageEraBabbage] :: ShelleyToBabbageEra BabbageEra
data () => ShelleyToMaryEra era
[ShelleyToMaryEraShelley] :: ShelleyToMaryEra ShelleyEra
[ShelleyToMaryEraAllegra] :: ShelleyToMaryEra AllegraEra
[ShelleyToMaryEraMary] :: ShelleyToMaryEra MaryEra
data () => AllegraEra
data () => AlonzoEra
data () => AnyCardanoEra
[AnyCardanoEra] :: forall era. Typeable era => CardanoEra era -> AnyCardanoEra
data () => BabbageEra
data () => ByronEra
data () => CardanoEra era
[ByronEra] :: CardanoEra ByronEra
[ShelleyEra] :: CardanoEra ShelleyEra
[AllegraEra] :: CardanoEra AllegraEra
[MaryEra] :: CardanoEra MaryEra
[AlonzoEra] :: CardanoEra AlonzoEra
[BabbageEra] :: CardanoEra BabbageEra
[ConwayEra] :: CardanoEra ConwayEra
class () => Eon (eon :: Type -> Type)
inEonForEra :: Eon eon => a -> (eon era -> a) -> CardanoEra era -> a
data () => EraInEon (eon :: Type -> Type)
[EraInEon] :: forall era (eon :: Type -> Type). (Typeable era, Typeable (eon era), Eon eon) => eon era -> EraInEon eon
data () => InAnyCardanoEra (thing :: Type -> Type)
[InAnyCardanoEra] :: forall era (thing :: Type -> Type). Typeable era => CardanoEra era -> thing era -> InAnyCardanoEra thing
class HasTypeProxy era => IsCardanoEra era
cardanoEra :: IsCardanoEra era => CardanoEra era
data () => MaryEra
data () => ShelleyEra
class () => ToCardanoEra (eon :: Type -> Type)
toCardanoEra :: ToCardanoEra eon => eon era -> CardanoEra era
data () => FileError e
FileError :: FilePath -> e -> FileError e
FileErrorTempFile :: FilePath -> FilePath -> Handle -> FileError e
FileDoesNotExistError :: FilePath -> FileError e
FileIOError :: FilePath -> IOException -> FileError e
data () => Featured (eon :: Type -> Type) era a
[Featured] :: forall (eon :: Type -> Type) era a. eon era -> a -> Featured eon era a
data () => AutoBalanceError era
AutoBalanceEstimationError :: TxFeeEstimationError era -> AutoBalanceError era
AutoBalanceCalculationError :: TxBodyErrorAutoBalance era -> AutoBalanceError era
data () => FeeEstimationMode era
CalculateWithSpendableUTxO :: UTxO era -> SystemStart -> LedgerEpochInfo -> Maybe Word -> FeeEstimationMode era
EstimateWithoutSpendableUTxO :: Coin -> Value -> Map ScriptWitnessIndex ExecutionUnits -> RequiredShelleyKeyWitnesses -> RequiredByronKeyWitnesses -> TotalReferenceScriptsSize -> FeeEstimationMode era
newtype () => RequiredByronKeyWitnesses
RequiredByronKeyWitnesses :: Int -> RequiredByronKeyWitnesses
[unRequiredByronKeyWitnesses] :: RequiredByronKeyWitnesses -> Int
newtype () => RequiredShelleyKeyWitnesses
RequiredShelleyKeyWitnesses :: Int -> RequiredShelleyKeyWitnesses
[unRequiredShelleyKeyWitnesses] :: RequiredShelleyKeyWitnesses -> Int
data () => ResolvablePointers
[ResolvablePointers] :: forall era. (Era (ShelleyLedgerEra era), Show (PlutusPurpose AsIx (ShelleyLedgerEra era)), Show (PlutusPurpose AsItem (ShelleyLedgerEra era)), Show (PlutusScript (ShelleyLedgerEra era))) => ShelleyBasedEra era -> !Map (PlutusPurpose AsIx (ShelleyLedgerEra era)) (PlutusPurpose AsItem (ShelleyLedgerEra era), Maybe (PlutusScriptBytes, Language), ScriptHash) -> ResolvablePointers
data () => ScriptExecutionError
ScriptErrorMissingTxIn :: TxIn -> ScriptExecutionError
ScriptErrorTxInWithoutDatum :: TxIn -> ScriptExecutionError
ScriptErrorWrongDatum :: Hash ScriptData -> ScriptExecutionError
ScriptErrorEvaluationFailed :: DebugPlutusFailure -> ScriptExecutionError
ScriptErrorExecutionUnitsOverflow :: ScriptExecutionError
ScriptErrorNotPlutusWitnessedTxIn :: ScriptWitnessIndex -> ScriptHash -> ScriptExecutionError
ScriptErrorRedeemerPointsToUnknownScriptHash :: ScriptWitnessIndex -> ScriptExecutionError
ScriptErrorMissingScript :: ScriptWitnessIndex -> ResolvablePointers -> ScriptExecutionError
ScriptErrorMissingCostModel :: Language -> ScriptExecutionError
ScriptErrorTranslationError :: ContextError (ShelleyLedgerEra era) -> ScriptExecutionError
newtype () => TotalReferenceScriptsSize
TotalReferenceScriptsSize :: Int -> TotalReferenceScriptsSize
[unTotalReferenceScriptsSize] :: TotalReferenceScriptsSize -> Int
data () => TransactionValidityError era
[TransactionValidityIntervalError] :: forall era. PastHorizonException -> TransactionValidityError era
[TransactionValidityCostModelError] :: forall era. Map AnyPlutusScriptVersion CostModel -> String -> TransactionValidityError era
data () => TxBodyError
TxBodyPlutusScriptDecodeError :: DecoderError -> TxBodyError
TxBodyEmptyTxIns :: TxBodyError
TxBodyEmptyTxInsCollateral :: TxBodyError
TxBodyEmptyTxOuts :: TxBodyError
TxBodyOutputError :: !TxOutputError -> TxBodyError
TxBodyMetadataError :: ![(Word64, TxMetadataRangeError)] -> TxBodyError
TxBodyInIxOverflow :: !TxIn -> TxBodyError
TxBodyMissingProtocolParams :: TxBodyError
TxBodyProtocolParamsConversionError :: !ProtocolParametersConversionError -> TxBodyError
data () => TxBodyErrorAutoBalance era
TxBodyError :: TxBodyError -> TxBodyErrorAutoBalance era
TxBodyScriptExecutionError :: [(ScriptWitnessIndex, ScriptExecutionError)] -> TxBodyErrorAutoBalance era
TxBodyScriptBadScriptValidity :: TxBodyErrorAutoBalance era
TxBodyErrorBalanceNegative :: Coin -> MultiAsset -> TxBodyErrorAutoBalance era
TxBodyErrorAdaBalanceTooSmall :: TxOutInAnyEra -> Coin -> Coin -> TxBodyErrorAutoBalance era
TxBodyErrorByronEraNotSupported :: TxBodyErrorAutoBalance era
TxBodyErrorMissingParamMinUTxO :: TxBodyErrorAutoBalance era
TxBodyErrorMinUTxONotMet :: TxOutInAnyEra -> Coin -> TxBodyErrorAutoBalance era
TxBodyErrorNonAdaAssetsUnbalanced :: Value -> TxBodyErrorAutoBalance era
TxBodyErrorScriptWitnessIndexMissingFromExecUnitsMap :: ScriptWitnessIndex -> Map ScriptWitnessIndex ExecutionUnits -> TxBodyErrorAutoBalance era
data () => TxFeeEstimationError era
TxFeeEstimationTransactionTranslationError :: TransactionValidityError era -> TxFeeEstimationError era
TxFeeEstimationScriptExecutionError :: TxBodyErrorAutoBalance era -> TxFeeEstimationError era
TxFeeEstimationBalanceError :: TxBodyErrorAutoBalance era -> TxFeeEstimationError era
TxFeeEstimationxBodyError :: TxBodyError -> TxFeeEstimationError era
TxFeeEstimationFinalConstructionError :: TxBodyError -> TxFeeEstimationError era
TxFeeEstimationOnlyMaryOnwardsSupportedError :: TxFeeEstimationError era
type AlonzoGenesisFile = File AlonzoGenesisConfig
type ByronGenesisFile = File ByronGenesisConfig
type ConwayGenesisFile = File ConwayGenesisConfig
newtype () => GenesisHashAlonzo
GenesisHashAlonzo :: Hash Blake2b_256 ByteString -> GenesisHashAlonzo
[unGenesisHashAlonzo] :: GenesisHashAlonzo -> Hash Blake2b_256 ByteString
newtype () => GenesisHashByron
GenesisHashByron :: Text -> GenesisHashByron
[unGenesisHashByron] :: GenesisHashByron -> Text
newtype () => GenesisHashConway
GenesisHashConway :: Hash Blake2b_256 ByteString -> GenesisHashConway
[unGenesisHashConway] :: GenesisHashConway -> Hash Blake2b_256 ByteString
newtype () => GenesisHashShelley
GenesisHashShelley :: Hash Blake2b_256 ByteString -> GenesisHashShelley
[unGenesisHashShelley] :: GenesisHashShelley -> Hash Blake2b_256 ByteString
data () => ShelleyConfig
ShelleyConfig :: !ShelleyGenesis -> !GenesisHashShelley -> ShelleyConfig
[scConfig] :: ShelleyConfig -> !ShelleyGenesis
[scGenesisHash] :: ShelleyConfig -> !GenesisHashShelley
type ShelleyGenesisFile = File ShelleyGenesisConfig
data () => GenesisParameters era
GenesisParameters :: UTCTime -> NetworkId -> Rational -> NonZero Word64 -> EpochSize -> NominalDiffTime -> Int -> Int -> Int -> Coin -> PParams (ShelleyLedgerEra era) -> GenesisParameters era
[protocolParamSystemStart] :: GenesisParameters era -> UTCTime
[protocolParamNetworkId] :: GenesisParameters era -> NetworkId
[protocolParamActiveSlotsCoefficient] :: GenesisParameters era -> Rational
[protocolParamSecurity] :: GenesisParameters era -> NonZero Word64
[protocolParamEpochLength] :: GenesisParameters era -> EpochSize
[protocolParamSlotLength] :: GenesisParameters era -> NominalDiffTime
[protocolParamSlotsPerKESPeriod] :: GenesisParameters era -> Int
[protocolParamMaxKESEvolutions] :: GenesisParameters era -> Int
[protocolParamUpdateQuorum] :: GenesisParameters era -> Int
[protocolParamMaxLovelaceSupply] :: GenesisParameters era -> Coin
[protocolInitialUpdateableProtocolParameters] :: GenesisParameters era -> PParams (ShelleyLedgerEra era)
data () => CIP119
DrepRegistrationMetadata :: CIP119
data () => CIP108
BaseGovActionMetadata :: CIP108
class Typeable t => HasTypeProxy t where {
    data family AsType t;
}
proxyToAsType :: HasTypeProxy t => Proxy t -> AsType t
data family AsType t
pattern AsByronAddress :: AsType (Address ByronAddr)
pattern AsShelleyAddress :: AsType (Address ShelleyAddr)
pattern AsAllegraTx :: AsType (Tx AllegraEra)
pattern AsAlonzoTx :: AsType (Tx AlonzoEra)
pattern AsByronTxBody :: AsType (TxBody ByronEra)
pattern AsByronWitness :: AsType (KeyWitness ByronEra)
pattern AsMaryTx :: AsType (Tx MaryEra)
pattern AsMaryTxBody :: AsType (TxBody MaryEra)
pattern AsShelleyTxBody :: AsType (TxBody ShelleyEra)
pattern AsShelleyWitness :: AsType (KeyWitness ShelleyEra)
data () => FromSomeType (c :: Type -> Constraint) b
[FromSomeType] :: forall (c :: Type -> Constraint) a b. c a => AsType a -> (a -> b) -> FromSomeType c b
data () => FileDirection
In :: FileDirection
Out :: FileDirection
InOut :: FileDirection
type SocketPath = File Socket 'InOut
data () => LocalChainSyncClient block point tip (m :: Type -> Type)
NoLocalChainSyncClient :: LocalChainSyncClient block point tip (m :: Type -> Type)
LocalChainSyncClientPipelined :: ChainSyncClientPipelined block point tip m () -> LocalChainSyncClient block point tip (m :: Type -> Type)
LocalChainSyncClient :: ChainSyncClient block point tip m () -> LocalChainSyncClient block point tip (m :: Type -> Type)
data () => LocalNodeClientParams
[LocalNodeClientParamsSingleBlock] :: forall block. (ProtocolClient block, LedgerSupportsProtocol (ShelleyBlock (TPraos StandardCrypto) ShelleyEra)) => ProtocolClientInfoArgs block -> (NodeToClientVersion -> LocalNodeClientProtocolsForBlock block) -> LocalNodeClientParams
[LocalNodeClientParamsCardano] :: forall block. (ProtocolClient block, CardanoHardForkConstraints (ConsensusCryptoForBlock block)) => ProtocolClientInfoArgs block -> (NodeToClientVersion -> LocalNodeClientProtocolsForBlock block) -> LocalNodeClientParams
data () => LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type)
LocalNodeClientProtocols :: LocalChainSyncClient block point tip m -> Maybe (LocalTxSubmissionClient tx txerr m ()) -> Maybe (LocalStateQueryClient block point query m ()) -> Maybe (LocalTxMonitorClient txid tx slot m ()) -> LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type)
[localChainSyncClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> LocalChainSyncClient block point tip m
[localTxSubmissionClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> Maybe (LocalTxSubmissionClient tx txerr m ())
[localStateQueryClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> Maybe (LocalStateQueryClient block point query m ())
[localTxMonitoringClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> Maybe (LocalTxMonitorClient txid tx slot m ())
type LocalNodeClientProtocolsInMode = LocalNodeClientProtocols BlockInMode ChainPoint ChainTip SlotNo TxInMode TxIdInMode TxValidationErrorInCardanoMode QueryInMode IO
data () => LocalNodeConnectInfo
LocalNodeConnectInfo :: ConsensusModeParams -> NetworkId -> SocketPath -> LocalNodeConnectInfo
[localConsensusModeParams] :: LocalNodeConnectInfo -> ConsensusModeParams
[localNodeNetworkId] :: LocalNodeConnectInfo -> NetworkId
[localNodeSocketPath] :: LocalNodeConnectInfo -> SocketPath
data () => LocalTxMonitoringQuery
LocalTxMonitoringQueryTx :: TxIdInMode -> LocalTxMonitoringQuery
LocalTxMonitoringSendNextTx :: LocalTxMonitoringQuery
LocalTxMonitoringMempoolInformation :: LocalTxMonitoringQuery
data () => LocalTxMonitoringResult
LocalTxMonitoringTxExists :: TxId -> SlotNo -> LocalTxMonitoringResult
LocalTxMonitoringTxDoesNotExist :: TxId -> SlotNo -> LocalTxMonitoringResult
LocalTxMonitoringNextTx :: Maybe TxInMode -> SlotNo -> LocalTxMonitoringResult
LocalTxMonitoringMempoolSizeAndCapacity :: MempoolSizeAndCapacity -> SlotNo -> LocalTxMonitoringResult
data () => LocalStateQueryExpr block point (query :: Type -> Type) r (m :: Type -> Type) a
data () => UnsupportedNtcVersionError
UnsupportedNtcVersionError :: !NodeToClientVersion -> ![NodeToClientVersion] -> UnsupportedNtcVersionError
data () => TxIdInMode
[TxIdInMode] :: forall era. CardanoEra era -> TxId -> TxIdInMode
data () => TxInMode
[TxInMode] :: forall era. ShelleyBasedEra era -> Tx era -> TxInMode
[TxInByronSpecial] :: GenTx ByronBlock -> TxInMode
data () => TxValidationErrorInCardanoMode
[TxValidationErrorInCardanoMode] :: forall era. TxValidationError era -> TxValidationErrorInCardanoMode
[TxValidationEraMismatch] :: EraMismatch -> TxValidationErrorInCardanoMode
data () => ByronKey
data () => ByronKeyLegacy
data () => MnemonicSize
MS12 :: MnemonicSize
MS15 :: MnemonicSize
MS18 :: MnemonicSize
MS21 :: MnemonicSize
MS24 :: MnemonicSize
data () => MnemonicToSigningKeyError
InvalidMnemonicError :: String -> MnemonicToSigningKeyError
InvalidAccountNumberError :: Word32 -> MnemonicToSigningKeyError
InvalidPaymentKeyNoError :: Word32 -> MnemonicToSigningKeyError
data () => CommitteeColdExtendedKey
data () => CommitteeColdKey
data () => CommitteeHotExtendedKey
data () => CommitteeHotKey
data () => DRepExtendedKey
data () => DRepKey
data () => GenesisDelegateExtendedKey
data () => GenesisDelegateKey
data () => GenesisExtendedKey
data () => GenesisKey
data () => GenesisUTxOKey
data () => PaymentExtendedKey
data () => PaymentKey
data () => StakeExtendedKey
data () => StakeKey
data () => AnyNewEpochState
[AnyNewEpochState] :: forall era. ShelleyBasedEra era -> NewEpochState (ShelleyLedgerEra era) -> LedgerTables (LedgerState (CardanoBlock StandardCrypto)) ValuesMK -> AnyNewEpochState
data () => ConditionResult
ConditionNotMet :: ConditionResult
ConditionMet :: ConditionResult
data () => Env
Env :: CardanoLedgerConfig StandardCrypto -> CardanoConsensusConfig StandardCrypto -> Env
[envLedgerConfig] :: Env -> CardanoLedgerConfig StandardCrypto
[envConsensusConfig] :: Env -> CardanoConsensusConfig StandardCrypto
data () => FoldBlocksError
FoldBlocksInitialLedgerStateError :: !InitialLedgerStateError -> FoldBlocksError
FoldBlocksApplyBlockError :: !LedgerStateError -> FoldBlocksError
FoldBlocksIOException :: !IOException -> FoldBlocksError
FoldBlocksMuxError :: !Error -> FoldBlocksError
data () => FoldStatus
ContinueFold :: FoldStatus
StopFold :: FoldStatus
DebugFold :: FoldStatus
data () => GenesisConfig
GenesisCardano :: !NodeConfig -> !Config -> !GenesisHashShelley -> !TransitionConfig LatestKnownEra -> GenesisConfig
data () => GenesisConfigError
NEError :: !Text -> GenesisConfigError
NEByronConfig :: !FilePath -> !ConfigurationError -> GenesisConfigError
NEShelleyConfig :: !FilePath -> !Text -> GenesisConfigError
NEAlonzoConfig :: !FilePath -> !Text -> GenesisConfigError
NEConwayConfig :: !FilePath -> !Text -> GenesisConfigError
NECardanoConfig :: !Text -> GenesisConfigError
data () => InitialLedgerStateError
ILSEConfigFile :: Text -> InitialLedgerStateError
ILSEGenesisFile :: GenesisConfigError -> InitialLedgerStateError
ILSELedgerConsensusConfig :: GenesisConfigError -> InitialLedgerStateError
data () => LedgerState
LedgerState :: CardanoLedgerState StandardCrypto EmptyMK -> LedgerTables (LedgerState (HardForkBlock (CardanoEras StandardCrypto))) ValuesMK -> LedgerState
[clsState] :: LedgerState -> CardanoLedgerState StandardCrypto EmptyMK
[clsTables] :: LedgerState -> LedgerTables (LedgerState (HardForkBlock (CardanoEras StandardCrypto))) ValuesMK
pattern LedgerStateAllegra :: LedgerState StandardAllegraBlock EmptyMK -> LedgerState
pattern LedgerStateAlonzo :: LedgerState StandardAlonzoBlock EmptyMK -> LedgerState
pattern LedgerStateBabbage :: LedgerState StandardBabbageBlock EmptyMK -> LedgerState
pattern LedgerStateByron :: LedgerState ByronBlock EmptyMK -> LedgerState
pattern LedgerStateConway :: LedgerState StandardConwayBlock EmptyMK -> LedgerState
pattern LedgerStateMary :: LedgerState StandardMaryBlock EmptyMK -> LedgerState
pattern LedgerStateShelley :: LedgerState StandardShelleyBlock EmptyMK -> LedgerState
data () => LedgerStateError
ApplyBlockHashMismatch :: Text -> LedgerStateError
ApplyBlockError :: CardanoLedgerError StandardCrypto -> LedgerStateError
InvalidRollback :: SlotNo -> ChainPoint -> LedgerStateError
TerminationEpochReached :: EpochNo -> LedgerStateError
UnexpectedLedgerState :: AnyShelleyBasedEra -> NS (Current (Flip LedgerState EmptyMK)) (CardanoEras StandardCrypto) -> LedgerStateError
ByronEraUnsupported :: LedgerStateError
DebugError :: !String -> LedgerStateError
data () => NodeConfig
NodeConfig :: !Maybe Double -> !File ByronGenesisConfig 'In -> !GenesisHashByron -> !File ShelleyGenesisConfig 'In -> !GenesisHashShelley -> !File AlonzoGenesis 'In -> !GenesisHashAlonzo -> !Maybe (File ConwayGenesisConfig 'In) -> !Maybe GenesisHashConway -> !RequiresNetworkMagic -> !ProtocolVersion -> !CardanoHardForkTriggers -> NodeConfig
[ncPBftSignatureThreshold] :: NodeConfig -> !Maybe Double
[ncByronGenesisFile] :: NodeConfig -> !File ByronGenesisConfig 'In
[ncByronGenesisHash] :: NodeConfig -> !GenesisHashByron
[ncShelleyGenesisFile] :: NodeConfig -> !File ShelleyGenesisConfig 'In
[ncShelleyGenesisHash] :: NodeConfig -> !GenesisHashShelley
[ncAlonzoGenesisFile] :: NodeConfig -> !File AlonzoGenesis 'In
[ncAlonzoGenesisHash] :: NodeConfig -> !GenesisHashAlonzo
[ncConwayGenesisFile] :: NodeConfig -> !Maybe (File ConwayGenesisConfig 'In)
[ncConwayGenesisHash] :: NodeConfig -> !Maybe GenesisHashConway
[ncRequiresNetworkMagic] :: NodeConfig -> !RequiresNetworkMagic
[ncByronProtocolVersion] :: NodeConfig -> !ProtocolVersion
[ncHardForkTriggers] :: NodeConfig -> !CardanoHardForkTriggers
type NodeConfigFile = File NodeConfig
data () => ValidationMode
FullValidation :: ValidationMode
QuickValidation :: ValidationMode
type family ChainDepStateProtocol era
type family ConsensusBlockForEra era
data () => ConsensusModeParams
[CardanoModeParams] :: EpochSlots -> ConsensusModeParams
type family ConsensusProtocol era
type MonadIOTransError e (t :: Type -> Type -> Type -> Type) (m :: Type -> Type) = (MonadIO m, MonadIO t m, MonadCatch m, MonadTrans t, MonadError e t m)
type MonadTransError e (t :: Type -> Type -> Type -> Type) (m :: Type -> Type) = (Monad m, MonadTrans t, MonadError e t m)
data () => OperationalCertIssueError
data () => OperationalCertificate
data () => OperationalCertificateIssueCounter
data () => DebugPlutusFailure
DebugPlutusFailure :: EvaluationError -> PlutusWithContext -> ExUnits -> [Text] -> DebugPlutusFailure
[dpfEvaluationError] :: DebugPlutusFailure -> EvaluationError
[dpfScriptWithContext] :: DebugPlutusFailure -> PlutusWithContext
[dpfExecutionUnits] :: DebugPlutusFailure -> ExUnits
[dpfExecutionLogs] :: DebugPlutusFailure -> [Text]
type Ann = AnsiStyle
data () => BlockType blk
[ByronBlockType] :: BlockType (HardForkBlock '[ByronBlock])
[ShelleyBlockType] :: BlockType (HardForkBlock '[ShelleyBlock (TPraos StandardCrypto) ShelleyEra])
[CardanoBlockType] :: BlockType (HardForkBlock (CardanoEras StandardCrypto))
class (RunNode blk, IOLike m) => Protocol (m :: Type -> Type) blk where {
    data family ProtocolInfoArgs blk;
}
protocolInfo :: Protocol m blk => ProtocolInfoArgs blk -> (ProtocolInfo blk, m [BlockForging m blk])
data family ProtocolInfoArgs blk
data () => SomeBlockType
[SomeBlockType] :: forall blk. BlockType blk -> SomeBlockType
newtype () => CostModel
CostModel :: [Int64] -> CostModel
data () => ExecutionUnitPrices
ExecutionUnitPrices :: Rational -> Rational -> ExecutionUnitPrices
[priceExecutionSteps] :: ExecutionUnitPrices -> Rational
[priceExecutionMemory] :: ExecutionUnitPrices -> Rational
data () => PraosNonce
data () => ProtocolParametersConversionError
PpceOutOfBounds :: !ProtocolParameterName -> !Rational -> ProtocolParametersConversionError
PpceVersionInvalid :: !ProtocolParameterVersion -> ProtocolParametersConversionError
PpceInvalidCostModel :: !CostModel -> !CostModelApplyError -> ProtocolParametersConversionError
PpceMissingParameter :: !ProtocolParameterName -> ProtocolParametersConversionError
data () => ProtocolParametersUpdate
ProtocolParametersUpdate :: Maybe (Natural, Natural) -> Maybe Rational -> Maybe (Maybe PraosNonce) -> Maybe Word16 -> Maybe Word32 -> Maybe Word32 -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe EpochInterval -> Maybe Word16 -> Maybe Rational -> Maybe Rational -> Maybe Rational -> Map AnyPlutusScriptVersion CostModel -> Maybe ExecutionUnitPrices -> Maybe ExecutionUnits -> Maybe ExecutionUnits -> Maybe Natural -> Maybe Natural -> Maybe Natural -> Maybe Coin -> ProtocolParametersUpdate
[protocolUpdateProtocolVersion] :: ProtocolParametersUpdate -> Maybe (Natural, Natural)
[protocolUpdateDecentralization] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateExtraPraosEntropy] :: ProtocolParametersUpdate -> Maybe (Maybe PraosNonce)
[protocolUpdateMaxBlockHeaderSize] :: ProtocolParametersUpdate -> Maybe Word16
[protocolUpdateMaxBlockBodySize] :: ProtocolParametersUpdate -> Maybe Word32
[protocolUpdateMaxTxSize] :: ProtocolParametersUpdate -> Maybe Word32
[protocolUpdateTxFeeFixed] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateTxFeePerByte] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateMinUTxOValue] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateStakeAddressDeposit] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateStakePoolDeposit] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateMinPoolCost] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdatePoolRetireMaxEpoch] :: ProtocolParametersUpdate -> Maybe EpochInterval
[protocolUpdateStakePoolTargetNum] :: ProtocolParametersUpdate -> Maybe Word16
[protocolUpdatePoolPledgeInfluence] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateMonetaryExpansion] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateTreasuryCut] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateCostModels] :: ProtocolParametersUpdate -> Map AnyPlutusScriptVersion CostModel
[protocolUpdatePrices] :: ProtocolParametersUpdate -> Maybe ExecutionUnitPrices
[protocolUpdateMaxTxExUnits] :: ProtocolParametersUpdate -> Maybe ExecutionUnits
[protocolUpdateMaxBlockExUnits] :: ProtocolParametersUpdate -> Maybe ExecutionUnits
[protocolUpdateMaxValueSize] :: ProtocolParametersUpdate -> Maybe Natural
[protocolUpdateCollateralPercent] :: ProtocolParametersUpdate -> Maybe Natural
[protocolUpdateMaxCollateralInputs] :: ProtocolParametersUpdate -> Maybe Natural
[protocolUpdateUTxOCostPerByte] :: ProtocolParametersUpdate -> Maybe Coin
data () => UpdateProposal
UpdateProposal :: !Map (Hash GenesisKey) ProtocolParametersUpdate -> !EpochNo -> UpdateProposal
data () => EraHistory
[EraHistory] :: forall (xs :: [Type]). CardanoBlock StandardCrypto ~ HardForkBlock xs => Interpreter xs -> EraHistory
newtype () => LedgerEpochInfo
LedgerEpochInfo :: EpochInfo (Either Text) -> LedgerEpochInfo
[unLedgerEpochInfo] :: LedgerEpochInfo -> EpochInfo (Either Text)
data () => QueryInEra era result
[QueryByronUpdateState] :: QueryInEra ByronEra ByronUpdateState
[QueryInShelleyBasedEra] :: forall era result. ShelleyBasedEra era -> QueryInShelleyBasedEra era result -> QueryInEra era result
data () => QueryInMode result
[QueryCurrentEra] :: QueryInMode AnyCardanoEra
[QueryInEra] :: forall era result1. QueryInEra era result1 -> QueryInMode (Either EraMismatch result1)
[QueryEraHistory] :: QueryInMode EraHistory
[QuerySystemStart] :: QueryInMode SystemStart
[QueryChainBlockNo] :: QueryInMode (WithOrigin BlockNo)
[QueryChainPoint] :: QueryInMode ChainPoint
[QueryLedgerConfig] :: QueryInMode (HardForkLedgerConfig (CardanoEras StandardCrypto))
data () => QueryInShelleyBasedEra era result
[QueryEpoch] :: forall era. QueryInShelleyBasedEra era EpochNo
[QueryGenesisParameters] :: forall era. QueryInShelleyBasedEra era (GenesisParameters ShelleyEra)
[QueryProtocolParameters] :: forall era. QueryInShelleyBasedEra era (PParams (ShelleyLedgerEra era))
[QueryStakeDistribution] :: forall era. QueryInShelleyBasedEra era (Map (Hash StakePoolKey) Rational)
[QueryUTxO] :: forall era. QueryUTxOFilter -> QueryInShelleyBasedEra era (UTxO era)
[QueryStakeAddresses] :: forall era. Set StakeCredential -> NetworkId -> QueryInShelleyBasedEra era (Map StakeAddress Coin, Map StakeAddress PoolId)
[QueryStakePools] :: forall era. QueryInShelleyBasedEra era (Set PoolId)
[QueryStakePoolParameters] :: forall era. Set PoolId -> QueryInShelleyBasedEra era (Map PoolId StakePoolParameters)
[QueryDebugLedgerState] :: forall era. QueryInShelleyBasedEra era (SerialisedDebugLedgerState era)
[QueryProtocolState] :: forall era. QueryInShelleyBasedEra era (ProtocolState era)
[QueryCurrentEpochState] :: forall era. QueryInShelleyBasedEra era (SerialisedCurrentEpochState era)
[QueryPoolState] :: forall era. Maybe (Set PoolId) -> QueryInShelleyBasedEra era (SerialisedPoolState era)
[QueryPoolDistribution] :: forall era. Maybe (Set PoolId) -> QueryInShelleyBasedEra era (SerialisedPoolDistribution era)
[QueryStakeSnapshot] :: forall era. Maybe (Set PoolId) -> QueryInShelleyBasedEra era (SerialisedStakeSnapshots era)
[QueryStakeDelegDeposits] :: forall era. Set StakeCredential -> QueryInShelleyBasedEra era (Map StakeCredential Coin)
[QueryAccountState] :: forall era. QueryInShelleyBasedEra era AccountState
[QueryConstitution] :: forall era. QueryInShelleyBasedEra era (Constitution (ShelleyLedgerEra era))
[QueryGovState] :: forall era. QueryInShelleyBasedEra era (GovState (ShelleyLedgerEra era))
[QueryRatifyState] :: forall era. QueryInShelleyBasedEra era (RatifyState (ShelleyLedgerEra era))
[QueryFuturePParams] :: forall era. QueryInShelleyBasedEra era (Maybe (PParams (ShelleyLedgerEra era)))
[QueryDRepState] :: forall era. Set (Credential 'DRepRole) -> QueryInShelleyBasedEra era (Map (Credential 'DRepRole) DRepState)
[QueryDRepStakeDistr] :: forall era. Set DRep -> QueryInShelleyBasedEra era (Map DRep Coin)
[QuerySPOStakeDistr] :: forall era. Set (KeyHash 'StakePool) -> QueryInShelleyBasedEra era (Map (KeyHash 'StakePool) Coin)
[QueryCommitteeMembersState] :: forall era. Set (Credential 'ColdCommitteeRole) -> Set (Credential 'HotCommitteeRole) -> Set MemberStatus -> QueryInShelleyBasedEra era CommitteeMembersState
[QueryStakeVoteDelegatees] :: forall era. Set StakeCredential -> QueryInShelleyBasedEra era (Map StakeCredential DRep)
[QueryProposals] :: forall era. Set GovActionId -> QueryInShelleyBasedEra era (Seq (GovActionState (ShelleyLedgerEra era)))
[QueryLedgerPeerSnapshot] :: forall era. QueryInShelleyBasedEra era (Serialised LedgerPeerSnapshot)
[QueryStakePoolDefaultVote] :: forall era. KeyHash 'StakePool -> QueryInShelleyBasedEra era DefaultVote
data () => QueryUTxOFilter
QueryUTxOWhole :: QueryUTxOFilter
QueryUTxOByAddress :: Set AddressAny -> QueryUTxOFilter
QueryUTxOByTxIn :: Set TxIn -> QueryUTxOFilter
newtype () => SlotsInEpoch
SlotsInEpoch :: Word64 -> SlotsInEpoch
newtype () => SlotsToEpochEnd
SlotsToEpochEnd :: Word64 -> SlotsToEpochEnd
newtype () => DelegationsAndRewards
DelegationsAndRewards :: (Map StakeAddress Coin, Map StakeAddress PoolId) -> DelegationsAndRewards
data () => AnyPlutusScriptVersion
[AnyPlutusScriptVersion] :: forall lang. IsPlutusScriptLanguage lang => PlutusScriptVersion lang -> AnyPlutusScriptVersion
data () => AnyScriptLanguage
[AnyScriptLanguage] :: forall lang. ScriptLanguage lang -> AnyScriptLanguage
class () => HasScriptLanguageInEra lang era
scriptLanguageInEra :: HasScriptLanguageInEra lang era => ScriptLanguageInEra lang era
class IsScriptLanguage lang => IsPlutusScriptLanguage lang
plutusScriptVersion :: IsPlutusScriptLanguage lang => PlutusScriptVersion lang
class HasTypeProxy lang => IsScriptLanguage lang
scriptLanguage :: IsScriptLanguage lang => ScriptLanguage lang
class () => IsScriptWitnessInCtx ctx
scriptWitnessInCtx :: IsScriptWitnessInCtx ctx => ScriptWitnessInCtx ctx
data () => KeyWitnessInCtx witctx
[KeyWitnessForSpending] :: KeyWitnessInCtx WitCtxTxIn
[KeyWitnessForStakeAddr] :: KeyWitnessInCtx WitCtxStake
data () => PlutusScriptInEra era lang
[PlutusScriptInEra] :: forall lang era. PlutusScript lang -> PlutusScriptInEra era lang
data () => PlutusScriptV1
data () => PlutusScriptV2
data () => PlutusScriptV3
data () => PlutusScriptVersion lang
[PlutusScriptV1] :: PlutusScriptVersion PlutusScriptV1
[PlutusScriptV2] :: PlutusScriptVersion PlutusScriptV2
[PlutusScriptV3] :: PlutusScriptVersion PlutusScriptV3
data () => ScriptInAnyLang
[ScriptInAnyLang] :: forall lang. ScriptLanguage lang -> Script lang -> ScriptInAnyLang
data () => ScriptLanguageInEra lang era
[SimpleScriptInShelley] :: ScriptLanguageInEra SimpleScript' ShelleyEra
[SimpleScriptInAllegra] :: ScriptLanguageInEra SimpleScript' AllegraEra
[SimpleScriptInMary] :: ScriptLanguageInEra SimpleScript' MaryEra
[SimpleScriptInAlonzo] :: ScriptLanguageInEra SimpleScript' AlonzoEra
[SimpleScriptInBabbage] :: ScriptLanguageInEra SimpleScript' BabbageEra
[SimpleScriptInConway] :: ScriptLanguageInEra SimpleScript' ConwayEra
[PlutusScriptV1InAlonzo] :: ScriptLanguageInEra PlutusScriptV1 AlonzoEra
[PlutusScriptV1InBabbage] :: ScriptLanguageInEra PlutusScriptV1 BabbageEra
[PlutusScriptV1InConway] :: ScriptLanguageInEra PlutusScriptV1 ConwayEra
[PlutusScriptV2InBabbage] :: ScriptLanguageInEra PlutusScriptV2 BabbageEra
[PlutusScriptV2InConway] :: ScriptLanguageInEra PlutusScriptV2 ConwayEra
[PlutusScriptV3InConway] :: ScriptLanguageInEra PlutusScriptV3 ConwayEra
type ScriptRedeemer = HashableScriptData
data () => ScriptWitnessInCtx witctx
[ScriptWitnessForSpending] :: ScriptWitnessInCtx WitCtxTxIn
[ScriptWitnessForMinting] :: ScriptWitnessInCtx WitCtxMint
[ScriptWitnessForStakeAddr] :: ScriptWitnessInCtx WitCtxStake
data () => SimpleScript
RequireSignature :: !Hash PaymentKey -> SimpleScript
RequireTimeBefore :: !SlotNo -> SimpleScript
RequireTimeAfter :: !SlotNo -> SimpleScript
RequireAllOf :: ![SimpleScript] -> SimpleScript
RequireAnyOf :: ![SimpleScript] -> SimpleScript
RequireMOf :: !Int -> ![SimpleScript] -> SimpleScript
data () => SimpleScript'
class () => ToAlonzoScript lang era
toLedgerScript :: ToAlonzoScript lang era => PlutusScript lang -> AlonzoScript (ShelleyLedgerEra era)
data () => WitCtx witctx
[WitCtxTxIn] :: WitCtx WitCtxTxIn
[WitCtxMint] :: WitCtx WitCtxMint
[WitCtxStake] :: WitCtx WitCtxStake
data () => WitCtxMint
data () => WitCtxStake
data () => WitCtxTxIn
data () => HashableScriptData
data () => ScriptDataJsonBytesError
ScriptDataJsonBytesErrorValue :: ScriptDataJsonError -> ScriptDataJsonBytesError
ScriptDataJsonBytesErrorInvalid :: ScriptDataRangeError -> ScriptDataJsonBytesError
data () => ScriptDataJsonError
ScriptDataJsonSchemaError :: !Value -> !ScriptDataJsonSchemaError -> ScriptDataJsonError
ScriptDataRangeError :: !Value -> !ScriptDataRangeError -> ScriptDataJsonError
data () => ScriptDataJsonSchema
ScriptDataJsonNoSchema :: ScriptDataJsonSchema
ScriptDataJsonDetailedSchema :: ScriptDataJsonSchema
data () => ScriptDataJsonSchemaError
ScriptDataJsonNullNotAllowed :: ScriptDataJsonSchemaError
ScriptDataJsonBoolNotAllowed :: ScriptDataJsonSchemaError
ScriptDataJsonNumberNotInteger :: !Double -> ScriptDataJsonSchemaError
ScriptDataJsonNotObject :: !Value -> ScriptDataJsonSchemaError
ScriptDataJsonBadObject :: ![(Text, Value)] -> ScriptDataJsonSchemaError
ScriptDataJsonBadMapPair :: !Value -> ScriptDataJsonSchemaError
ScriptDataJsonTypeMismatch :: !Text -> !Value -> ScriptDataJsonSchemaError
newtype () => ScriptDataRangeError
ScriptDataConstructorOutOfRange :: Integer -> ScriptDataRangeError
class HasTypeProxy a => SerialiseAsCBOR a
serialiseToCBOR :: SerialiseAsCBOR a => a -> ByteString
deserialiseFromCBOR :: SerialiseAsCBOR a => AsType a -> ByteString -> Either DecoderError a
data () => Bech32DecodeError
Bech32DecodingError :: !DecodingError -> Bech32DecodeError
Bech32UnexpectedPrefix :: !Text -> !Set Text -> Bech32DecodeError
Bech32DataPartToBytesError :: !Text -> Bech32DecodeError
Bech32DeserialiseFromBytesError :: !ByteString -> Bech32DecodeError
Bech32WrongPrefix :: !Text -> !Text -> Bech32DecodeError
Bech32UnexpectedHeader :: !Text -> !Text -> Bech32DecodeError
class (HasTypeProxy a, SerialiseAsRawBytes a) => SerialiseAsBech32 a
newtype () => JsonDecodeError
JsonDecodeError :: String -> JsonDecodeError
data () => FromSomeTypeCDDL c b
[FromCDDLTx] :: forall b. Text -> (InAnyShelleyBasedEra Tx -> b) -> FromSomeTypeCDDL TextEnvelope b
[FromCDDLWitness] :: forall b. Text -> (InAnyShelleyBasedEra KeyWitness -> b) -> FromSomeTypeCDDL TextEnvelope b
data () => TextEnvelopeCddlError
TextEnvelopeCddlErrCBORDecodingError :: DecoderError -> TextEnvelopeCddlError
TextEnvelopeCddlAesonDecodeError :: FilePath -> String -> TextEnvelopeCddlError
TextEnvelopeCddlUnknownKeyWitness :: TextEnvelopeCddlError
TextEnvelopeCddlTypeError :: [Text] -> Text -> TextEnvelopeCddlError
TextEnvelopeCddlErrUnknownType :: Text -> TextEnvelopeCddlError
TextEnvelopeCddlErrByronKeyWitnessUnsupported :: TextEnvelopeCddlError
data () => RawBytesHexError
RawBytesHexErrorBase16DecodeFail :: ByteString -> String -> RawBytesHexError
RawBytesHexErrorRawBytesDecodeFail :: ByteString -> TypeRep -> SerialiseAsRawBytesError -> RawBytesHexError
class (HasTypeProxy a, Typeable a) => SerialiseAsRawBytes a
serialiseToRawBytes :: SerialiseAsRawBytes a => a -> ByteString
deserialiseFromRawBytes :: SerialiseAsRawBytes a => AsType a -> ByteString -> Either SerialiseAsRawBytesError a
newtype () => SerialiseAsRawBytesError
SerialiseAsRawBytesError :: String -> SerialiseAsRawBytesError
[unSerialiseAsRawBytesError] :: SerialiseAsRawBytesError -> String
class SerialiseAsCBOR a => HasTextEnvelope a
textEnvelopeType :: HasTextEnvelope a => AsType a -> TextEnvelopeType
textEnvelopeDefaultDescr :: HasTextEnvelope a => a -> TextEnvelopeDescr
data () => TextEnvelope
TextEnvelope :: !TextEnvelopeType -> !TextEnvelopeDescr -> !ByteString -> TextEnvelope
[teType] :: TextEnvelope -> !TextEnvelopeType
[teDescription] :: TextEnvelope -> !TextEnvelopeDescr
[teRawCBOR] :: TextEnvelope -> !ByteString
data () => TextEnvelopeDescr
data () => TextEnvelopeError
TextEnvelopeTypeError :: ![TextEnvelopeType] -> !TextEnvelopeType -> TextEnvelopeError
TextEnvelopeDecodeError :: !DecoderError -> TextEnvelopeError
TextEnvelopeAesonDecodeError :: !String -> TextEnvelopeError
newtype () => TextEnvelopeType
TextEnvelopeType :: String -> TextEnvelopeType
newtype () => UsingBech32 a
UsingBech32 :: a -> UsingBech32 a
newtype () => UsingRawBytes a
UsingRawBytes :: a -> UsingRawBytes a
newtype () => UsingRawBytesHex a
UsingRawBytesHex :: a -> UsingRawBytesHex a
data () => StakePoolMetadata
data () => StakePoolMetadataValidationError
StakePoolMetadataJsonDecodeError :: !String -> StakePoolMetadataValidationError
StakePoolMetadataInvalidLengthError :: !Int -> !Int -> StakePoolMetadataValidationError
data () => AnyScriptWitness era
[AnyScriptWitness] :: forall witctx era. Typeable witctx => ScriptWitness witctx era -> AnyScriptWitness era
data () => ScriptWitnessIndex
ScriptWitnessIndexTxIn :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexMint :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexCertificate :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexWithdrawal :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexVoting :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexProposing :: !Word32 -> ScriptWitnessIndex
data () => TxCertificates build era
[TxCertificatesNone] :: forall build era. TxCertificates build era
[TxCertificates] :: forall era build. ShelleyBasedEra era -> OMap (Certificate era) (BuildTxWith build (Maybe (StakeCredential, Witness WitCtxStake era))) -> TxCertificates build era
data () => TxProposalProcedures build era
[TxProposalProceduresNone] :: forall build era. TxProposalProcedures build era
[TxProposalProcedures] :: forall era build. EraPParams (ShelleyLedgerEra era) => OMap (ProposalProcedure (ShelleyLedgerEra era)) (BuildTxWith build (Maybe (ScriptWitness WitCtxStake era))) -> TxProposalProcedures build era
data () => TxReturnCollateral ctx era
[TxReturnCollateralNone] :: forall ctx era. TxReturnCollateral ctx era
[TxReturnCollateral] :: forall era ctx. BabbageEraOnwards era -> TxOut ctx era -> TxReturnCollateral ctx era
data () => TxTotalCollateral era
[TxTotalCollateralNone] :: forall era. TxTotalCollateral era
[TxTotalCollateral] :: forall era. BabbageEraOnwards era -> Coin -> TxTotalCollateral era
data () => TxUpdateProposal era
[TxUpdateProposalNone] :: forall era. TxUpdateProposal era
[TxUpdateProposal] :: forall era. ShelleyToBabbageEra era -> UpdateProposal -> TxUpdateProposal era
data () => TxVotingProcedures build era
[TxVotingProceduresNone] :: forall build era. TxVotingProcedures build era
[TxVotingProcedures] :: forall era build. VotingProcedures (ShelleyLedgerEra era) -> BuildTxWith build (Map Voter (ScriptWitness WitCtxStake era)) -> TxVotingProcedures build era
data () => TxWithdrawals build era
[TxWithdrawalsNone] :: forall build era. TxWithdrawals build era
[TxWithdrawals] :: forall era build. ShelleyBasedEra era -> [(StakeAddress, Coin, BuildTxWith build (Witness WitCtxStake era))] -> TxWithdrawals build era
data () => BuildTx
data () => BuildTxWith build a
[ViewTx] :: forall a. BuildTxWith ViewTx a
[BuildTxWith] :: forall a. a -> BuildTxWith BuildTx a
data () => ViewTx
data () => CtxTx
data () => TxOutInAnyEra
[TxOutInAnyEra] :: forall era. CardanoEra era -> TxOut CtxTx era -> TxOutInAnyEra
data () => TxOutputError
TxOutputNegative :: !Quantity -> !TxOutInAnyEra -> TxOutputError
TxOutputOverflow :: !Quantity -> !TxOutInAnyEra -> TxOutputError
data () => ScriptValidity
ScriptInvalid :: ScriptValidity
ScriptValid :: ScriptValidity
data () => ShelleyWitnessSigningKey
WitnessPaymentKey :: SigningKey PaymentKey -> ShelleyWitnessSigningKey
WitnessPaymentExtendedKey :: SigningKey PaymentExtendedKey -> ShelleyWitnessSigningKey
WitnessStakeKey :: SigningKey StakeKey -> ShelleyWitnessSigningKey
WitnessStakeExtendedKey :: SigningKey StakeExtendedKey -> ShelleyWitnessSigningKey
WitnessStakePoolKey :: SigningKey StakePoolKey -> ShelleyWitnessSigningKey
WitnessStakePoolExtendedKey :: SigningKey StakePoolExtendedKey -> ShelleyWitnessSigningKey
WitnessGenesisKey :: SigningKey GenesisKey -> ShelleyWitnessSigningKey
WitnessGenesisExtendedKey :: SigningKey GenesisExtendedKey -> ShelleyWitnessSigningKey
WitnessGenesisDelegateKey :: SigningKey GenesisDelegateKey -> ShelleyWitnessSigningKey
WitnessGenesisDelegateExtendedKey :: SigningKey GenesisDelegateExtendedKey -> ShelleyWitnessSigningKey
WitnessGenesisUTxOKey :: SigningKey GenesisUTxOKey -> ShelleyWitnessSigningKey
WitnessCommitteeColdKey :: SigningKey CommitteeColdKey -> ShelleyWitnessSigningKey
WitnessCommitteeColdExtendedKey :: SigningKey CommitteeColdExtendedKey -> ShelleyWitnessSigningKey
WitnessCommitteeHotKey :: SigningKey CommitteeHotKey -> ShelleyWitnessSigningKey
WitnessCommitteeHotExtendedKey :: SigningKey CommitteeHotExtendedKey -> ShelleyWitnessSigningKey
WitnessDRepKey :: SigningKey DRepKey -> ShelleyWitnessSigningKey
WitnessDRepExtendedKey :: SigningKey DRepExtendedKey -> ShelleyWitnessSigningKey
newtype () => TxIx
TxIx :: Word -> TxIx
class () => AsTxMetadata a
asTxMetadata :: AsTxMetadata a => a -> TxMetadata
newtype () => TxMetadata
TxMetadata :: Map Word64 TxMetadataValue -> TxMetadata
[unTxMetadata] :: TxMetadata -> Map Word64 TxMetadataValue
data () => TxMetadataJsonError
TxMetadataJsonToplevelNotMap :: TxMetadataJsonError
TxMetadataJsonToplevelBadKey :: !Text -> TxMetadataJsonError
TxMetadataJsonSchemaError :: !Word64 -> !Value -> !TxMetadataJsonSchemaError -> TxMetadataJsonError
TxMetadataRangeError :: !Word64 -> !Value -> !TxMetadataRangeError -> TxMetadataJsonError
data () => TxMetadataJsonSchema
TxMetadataJsonNoSchema :: TxMetadataJsonSchema
TxMetadataJsonDetailedSchema :: TxMetadataJsonSchema
data () => TxMetadataJsonSchemaError
TxMetadataJsonNullNotAllowed :: TxMetadataJsonSchemaError
TxMetadataJsonBoolNotAllowed :: TxMetadataJsonSchemaError
TxMetadataJsonNumberNotInteger :: !Double -> TxMetadataJsonSchemaError
TxMetadataJsonNotObject :: !Value -> TxMetadataJsonSchemaError
TxMetadataJsonBadObject :: ![(Text, Value)] -> TxMetadataJsonSchemaError
TxMetadataJsonBadMapPair :: !Value -> TxMetadataJsonSchemaError
TxMetadataJsonTypeMismatch :: !Text -> !Value -> TxMetadataJsonSchemaError
data () => TxMetadataRangeError
TxMetadataNumberOutOfRange :: !Integer -> TxMetadataRangeError
TxMetadataTextTooLong :: !Int -> TxMetadataRangeError
TxMetadataBytesTooLong :: !Int -> TxMetadataRangeError
data () => TxMetadataValue
TxMetaMap :: [(TxMetadataValue, TxMetadataValue)] -> TxMetadataValue
TxMetaList :: [TxMetadataValue] -> TxMetadataValue
TxMetaNumber :: Integer -> TxMetadataValue
TxMetaBytes :: ByteString -> TxMetadataValue
TxMetaText :: Text -> TxMetadataValue
data () => AssetId
AdaAssetId :: AssetId
AssetId :: !PolicyId -> !AssetName -> AssetId
newtype () => AssetName
AssetName :: ByteString -> AssetName
type Lovelace = Coin
newtype () => Quantity
Quantity :: Integer -> Quantity
data () => ValueNestedBundle
ValueNestedBundleAda :: Quantity -> ValueNestedBundle
ValueNestedBundle :: PolicyId -> Map AssetName Quantity -> ValueNestedBundle
newtype () => ValueNestedRep
ValueNestedRep :: [ValueNestedBundle] -> ValueNestedRep
newtype () => ShowOf a
ShowOf :: a -> ShowOf a
data () => CommitteeMembersState
CommitteeMembersState :: !Map (Credential 'ColdCommitteeRole) CommitteeMemberState -> !Maybe UnitInterval -> !EpochNo -> CommitteeMembersState
[csCommittee] :: CommitteeMembersState -> !Map (Credential 'ColdCommitteeRole) CommitteeMemberState
[csThreshold] :: CommitteeMembersState -> !Maybe UnitInterval
[csEpochNo] :: CommitteeMembersState -> !EpochNo
data () => MemberStatus
Active :: MemberStatus
Expired :: MemberStatus
Unrecognized :: MemberStatus
newtype () => EpochSlots
EpochSlots :: Word64 -> EpochSlots
[unEpochSlots] :: EpochSlots -> Word64
class () => Inject t s
inject :: Inject t s => t -> s
data () => MIRPot
ReservesMIR :: MIRPot
TreasuryMIR :: MIRPot
data () => MIRTarget
StakeAddressesMIR :: !Map (Credential 'Staking) DeltaCoin -> MIRTarget
SendToOppositePotMIR :: !Coin -> MIRTarget
newtype () => BlockNo
BlockNo :: Word64 -> BlockNo
[unBlockNo] :: BlockNo -> Word64
newtype () => EpochNo
EpochNo :: Word64 -> EpochNo
[unEpochNo] :: EpochNo -> Word64
newtype () => SlotNo
SlotNo :: Word64 -> SlotNo
[unSlotNo] :: SlotNo -> Word64
newtype () => SystemStart
SystemStart :: UTCTime -> SystemStart
[getSystemStart] :: SystemStart -> UTCTime
data () => NodeToClientVersion
NodeToClientV_16 :: NodeToClientVersion
NodeToClientV_17 :: NodeToClientVersion
NodeToClientV_18 :: NodeToClientVersion
NodeToClientV_19 :: NodeToClientVersion
NodeToClientV_20 :: NodeToClientVersion
newtype () => ChainSyncClient header point tip (m :: Type -> Type) a
ChainSyncClient :: m (ClientStIdle header point tip m a) -> ChainSyncClient header point tip (m :: Type -> Type) a
[runChainSyncClient] :: ChainSyncClient header point tip (m :: Type -> Type) a -> m (ClientStIdle header point tip m a)
newtype () => ChainSyncClientPipelined header point tip (m :: Type -> Type) a
ChainSyncClientPipelined :: m (ClientPipelinedStIdle 'Z header point tip m a) -> ChainSyncClientPipelined header point tip (m :: Type -> Type) a
[runChainSyncClientPipelined] :: ChainSyncClientPipelined header point tip (m :: Type -> Type) a -> m (ClientPipelinedStIdle 'Z header point tip m a)
newtype () => LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a
LocalStateQueryClient :: m (ClientStIdle block point query m a) -> LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a
[runLocalStateQueryClient] :: LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a -> m (ClientStIdle block point query m a)
newtype () => LocalTxMonitorClient txid tx slot (m :: Type -> Type) a
LocalTxMonitorClient :: m (ClientStIdle txid tx slot m a) -> LocalTxMonitorClient txid tx slot (m :: Type -> Type) a
[runLocalTxMonitorClient] :: LocalTxMonitorClient txid tx slot (m :: Type -> Type) a -> m (ClientStIdle txid tx slot m a)
data () => MempoolSizeAndCapacity
MempoolSizeAndCapacity :: !Word32 -> !Word32 -> !Word32 -> MempoolSizeAndCapacity
[capacityInBytes] :: MempoolSizeAndCapacity -> !Word32
[sizeInBytes] :: MempoolSizeAndCapacity -> !Word32
[numberOfTxs] :: MempoolSizeAndCapacity -> !Word32
newtype () => LocalTxSubmissionClient tx reject (m :: Type -> Type) a
LocalTxSubmissionClient :: m (LocalTxClientStIdle tx reject m a) -> LocalTxSubmissionClient tx reject (m :: Type -> Type) a
[runLocalTxSubmissionClient] :: LocalTxSubmissionClient tx reject (m :: Type -> Type) a -> m (LocalTxClientStIdle tx reject m a)
data () => SubmitResult reason
SubmitSuccess :: SubmitResult reason
SubmitFail :: reason -> SubmitResult reason
pattern Block :: BlockHeader -> [Tx era] -> Block era
(<+>) :: Doc ann -> Doc ann -> Doc ann
runParsecParser :: Parser a -> Text -> Parser a
left :: forall (m :: Type -> Type) x a. Monad m => x -> ExceptT x m a
right :: forall (m :: Type -> Type) a x. Monad m => a -> ExceptT x m a

-- | Signal an exception value <tt>e</tt>.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>throwE</a> e) = <a>return</a>
--   (<a>Left</a> e)</pre></li>
--   <li><pre><a>throwE</a> e &gt;&gt;= m = <a>throwE</a> e</pre></li>
--   </ul>
throwE :: forall (m :: Type -> Type) e a. Monad m => e -> ExceptT e m a

-- | Extractor for computations in the exception monad. (The inverse of
--   <a>except</a>).
runExcept :: Except e a -> Either e a

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExcept</a> (<a>mapExcept</a> f m) = f (<a>runExcept</a>
--   m)</pre></li>
--   </ul>
mapExcept :: (Either e a -> Either e' b) -> Except e a -> Except e' b

-- | Transform any exceptions thrown by the computation using the given
--   function (a specialization of <a>withExceptT</a>).
withExcept :: (e -> e') -> Except e a -> Except e' a

-- | The inverse of <a>ExceptT</a>.
runExceptT :: ExceptT e m a -> m (Either e a)

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>mapExceptT</a> f m) = f
--   (<a>runExceptT</a> m)</pre></li>
--   </ul>
mapExceptT :: (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b

-- | Transform any exceptions thrown by the computation using the given
--   function.
withExceptT :: forall (m :: Type -> Type) e e' a. Functor m => (e -> e') -> ExceptT e m a -> ExceptT e' m a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: CallCC m (Either e a) (Either e b) -> CallCC (ExceptT e m) a b

-- | Lifts an <tt><a>Either</a> e</tt> into any <tt><a>MonadError</a>
--   e</tt>.
--   
--   <pre>
--   do { val &lt;- liftEither =&lt;&lt; action1; action2 }
--   </pre>
--   
--   where <tt>action1</tt> returns an <a>Either</a> to represent errors.
liftEither :: MonadError e m => Either e a -> m a
modifyError :: forall e' t (m :: Type -> Type) e a. MonadTransError e' t m => (e -> e') -> ExceptT e m a -> t m a
hsep :: [Doc ann] -> Doc ann

-- | Handle an exception.
--   
--   <ul>
--   <li><pre><a>catchE</a> (<a>lift</a> m) h = <a>lift</a> m</pre></li>
--   <li><pre><a>catchE</a> (<a>throwE</a> e) h = h e</pre></li>
--   </ul>
catchE :: forall (m :: Type -> Type) e a e'. Monad m => ExceptT e m a -> (e -> ExceptT e' m a) -> ExceptT e' m a

-- | Constructor for computations in the exception monad. (The inverse of
--   <a>runExcept</a>).
except :: forall (m :: Type -> Type) e a. Monad m => Either e a -> ExceptT e m a

-- | The same as <tt><a>flip</a> <a>catchE</a></tt>, which is useful in
--   situations where the code for the handler is shorter.
handleE :: forall (m :: Type -> Type) e e' a. Monad m => (e -> ExceptT e' m a) -> ExceptT e m a -> ExceptT e' m a

-- | Similar to <a>catchE</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception was thown, or
--   <tt>(<a>Left</a> ex)</tt> if an exception <tt>ex</tt> was thrown.
tryE :: forall (m :: Type -> Type) e a. Monad m => ExceptT e m a -> ExceptT e m (Either e a)

-- | <tt><a>finallyE</a> a b</tt> executes computation <tt>a</tt> followed
--   by computation <tt>b</tt>, even if <tt>a</tt> exits early by throwing
--   an exception. In the latter case, the exception is re-thrown after
--   <tt>b</tt> has been executed.
finallyE :: forall (m :: Type -> Type) e a. Monad m => ExceptT e m a -> ExceptT e m () -> ExceptT e m a

-- | Lift a <tt>listen</tt> operation to the new monad.
liftListen :: Monad m => Listen w m (Either e a) -> Listen w (ExceptT e m) a

-- | Lift a <tt>pass</tt> operation to the new monad.
liftPass :: Monad m => Pass w m (Either e a) -> Pass w (ExceptT e m) a
hoistMaybe :: forall (m :: Type -> Type) x a. Monad m => x -> Maybe a -> ExceptT x m a
blue :: Doc AnsiStyle -> Doc AnsiStyle
createAndValidateTransactionBody :: ShelleyBasedEra era -> TxBodyContent BuildTx era -> Either TxBodyError (TxBody era)
defaultTxBodyContent :: ShelleyBasedEra era -> TxBodyContent BuildTx era
fromLedgerUTxO :: ShelleyBasedEra era -> UTxO (ShelleyLedgerEra era) -> UTxO era
fromLedgerValue :: ShelleyBasedEra era -> Value (ShelleyLedgerEra era) -> Value
green :: Doc AnsiStyle -> Doc AnsiStyle
makeShelleyKeyWitness :: ShelleyBasedEra era -> TxBody era -> ShelleyWitnessSigningKey -> KeyWitness era
queryEraHistory :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError EraHistory)
queryProtocolParameters :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (PParams (ShelleyLedgerEra era))))
queryStakePools :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Set PoolId)))
querySystemStart :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError SystemStart)
red :: Doc AnsiStyle -> Doc AnsiStyle
signShelleyTransaction :: ShelleyBasedEra era -> TxBody era -> [ShelleyWitnessSigningKey] -> Tx era
toLedgerValue :: MaryEraOnwards era -> Value -> Value (ShelleyLedgerEra era)
txOutValueToValue :: TxOutValue era -> Value
renderTxIn :: TxIn -> Text
renderValue :: Value -> Text
selectLovelace :: Value -> Lovelace
anyAddressInShelleyBasedEra :: ShelleyBasedEra era -> AddressAny -> AddressInEra era
toAddressAny :: Address addr -> AddressAny
lovelaceToTxOutValue :: ShelleyBasedEra era -> Coin -> TxOutValue era
anyAddressInEra :: CardanoEra era -> AddressAny -> Either String (AddressInEra era)
byronAddressInEra :: Address ByronAddr -> AddressInEra era
isKeyAddress :: AddressInEra era -> Bool
lexPlausibleAddressString :: Parser Text
makeByronAddress :: NetworkId -> VerificationKey ByronKey -> Address ByronAddr
makeByronAddressInEra :: NetworkId -> VerificationKey ByronKey -> AddressInEra era
makeShelleyAddress :: NetworkId -> PaymentCredential -> StakeAddressReference -> Address ShelleyAddr
makeShelleyAddressInEra :: ShelleyBasedEra era -> NetworkId -> PaymentCredential -> StakeAddressReference -> AddressInEra era
makeStakeAddress :: NetworkId -> StakeCredential -> StakeAddress
parseAddressAny :: SerialiseAddress addr => Parser addr
shelleyAddressInEra :: ShelleyBasedEra era -> Address ShelleyAddr -> AddressInEra era
stakeAddressCredential :: StakeAddress -> StakeCredential
chainPointToHeaderHash :: ChainPoint -> Maybe (Hash BlockHeader)
chainPointToSlotNo :: ChainPoint -> Maybe SlotNo
chainTipToChainPoint :: ChainTip -> ChainPoint
getBlockHeader :: Block era -> BlockHeader
getBlockTxs :: Block era -> [Tx era]
makeChainTip :: WithOrigin BlockNo -> ChainPoint -> ChainTip
deserialiseFromBech32Cip129 :: Cip129 a => Text -> Either Bech32DecodeError a
deserialiseGovActionIdFromBech32Cip129 :: Text -> Either Bech32DecodeError GovActionId
serialiseGovActionIdToBech32Cip129 :: GovActionId -> Text
serialiseToBech32Cip129 :: Cip129 a => a -> Text
getAnchorDataFromCertificate :: Certificate era -> Either AnchorDataFromCertificateError (Maybe Anchor)
isDRepRegOrUpdateCert :: Certificate era -> Bool
makeCommitteeColdkeyResignationCertificate :: Typeable era => CommitteeColdkeyResignationRequirements era -> Certificate era
makeCommitteeHotKeyAuthorizationCertificate :: Typeable era => CommitteeHotKeyAuthorizationRequirements era -> Certificate era
makeDrepRegistrationCertificate :: Typeable era => DRepRegistrationRequirements era -> Maybe Anchor -> Certificate era
makeDrepUnregistrationCertificate :: Typeable era => DRepUnregistrationRequirements era -> Certificate era
makeDrepUpdateCertificate :: Typeable era => DRepUpdateRequirements era -> Maybe Anchor -> Certificate era
makeGenesisKeyDelegationCertificate :: Typeable era => GenesisKeyDelegationRequirements era -> Certificate era
makeMIRCertificate :: Typeable era => MirCertificateRequirements era -> Certificate era
makeStakeAddressAndDRepDelegationCertificate :: ConwayEraOnwards era -> StakeCredential -> Delegatee -> Coin -> Certificate era
makeStakeAddressDelegationCertificate :: StakeDelegationRequirements era -> Certificate era
makeStakeAddressRegistrationCertificate :: StakeAddressRequirements era -> Certificate era
makeStakeAddressUnregistrationCertificate :: StakeAddressRequirements era -> Certificate era
makeStakePoolRegistrationCertificate :: StakePoolRegistrationRequirements era -> Certificate era
makeStakePoolRetirementCertificate :: StakePoolRetirementRequirements era -> Certificate era
selectStakeCredentialWitness :: Certificate era -> Maybe StakeCredential
constructBalancedTx :: ShelleyBasedEra era -> TxBodyContent BuildTx era -> AddressInEra era -> Maybe Word -> UTxO era -> LedgerProtocolParameters era -> LedgerEpochInfo -> SystemStart -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> [ShelleyWitnessSigningKey] -> Either (TxBodyErrorAutoBalance era) (Tx era)
notScriptLockedTxIns :: [TxIn] -> UTxO era -> Either ScriptLockedTxInsError ()
renderNotScriptLockedTxInsError :: ScriptLockedTxInsError -> Text
renderTxInsExistError :: TxInsExistError -> Text
txInsExistInUTxO :: [TxIn] -> UTxO era -> Either TxInsExistError ()
determineEra :: LocalNodeConnectInfo -> ExceptT AcquiringFailure IO AnyCardanoEra
executeQueryAnyMode :: LocalNodeConnectInfo -> QueryInMode (Either EraMismatch result) -> ExceptT QueryConvenienceError IO result
executeQueryCardanoMode :: SocketPath -> NetworkId -> QueryInMode (Either EraMismatch result) -> ExceptT QueryConvenienceError IO result
queryStateForBalancedTx :: CardanoEra era -> [TxIn] -> [Certificate era] -> LocalStateQueryExpr block point QueryInMode r IO (Either QueryConvenienceError (UTxO era, LedgerProtocolParameters era, EraHistory, SystemStart, Set PoolId, Map StakeCredential Coin, Map (Credential 'DRepRole) Coin, Maybe (Featured ConwayEraOnwards era TxCurrentTreasuryValue)))
renderQueryConvenienceError :: QueryConvenienceError -> Text
hashDRepMetadata :: ByteString -> (DRepMetadata, Hash DRepMetadata)
deserialiseAnyVerificationKey :: ByteString -> Either InputDecodeError SomeAddressVerificationKey
deserialiseAnyVerificationKeyBech32 :: ByteString -> Either Bech32DecodeError SomeAddressVerificationKey
deserialiseAnyVerificationKeyTextEnvelope :: ByteString -> Either TextEnvelopeError SomeAddressVerificationKey
deserialiseInput :: NonEmpty (InputFormat a) -> ByteString -> Either InputDecodeError a
deserialiseInputAnyOf :: [FromSomeType SerialiseAsBech32 b] -> [FromSomeType HasTextEnvelope b] -> ByteString -> Either InputDecodeError b
mapSomeAddressVerificationKey :: (forall keyrole. Key keyrole => VerificationKey keyrole -> a) -> SomeAddressVerificationKey -> a
renderInputDecodeError :: InputDecodeError -> Doc ann
renderSomeAddressVerificationKey :: SomeAddressVerificationKey -> Text
alonzoEraOnwardsConstraints :: AlonzoEraOnwards era -> (AlonzoEraOnwardsConstraints era => a) -> a
alonzoEraOnwardsToShelleyBasedEra :: AlonzoEraOnwards era -> ShelleyBasedEra era
babbageEraOnwardsConstraints :: BabbageEraOnwards era -> (BabbageEraOnwardsConstraints era => a) -> a
babbageEraOnwardsToShelleyBasedEra :: BabbageEraOnwards era -> ShelleyBasedEra era
byronToAlonzoEraConstraints :: ByronToAlonzoEra era -> (ByronToAlonzoEraConstraints era => a) -> a
conwayEraOnwardsConstraints :: ConwayEraOnwards era -> (ConwayEraOnwardsConstraints era => a) -> a
conwayEraOnwardsToBabbageEraOnwards :: ConwayEraOnwards era -> BabbageEraOnwards era
conwayEraOnwardsToShelleyBasedEra :: ConwayEraOnwards era -> ShelleyBasedEra era
maryEraOnwardsConstraints :: MaryEraOnwards era -> (MaryEraOnwardsConstraints era => a) -> a
maryEraOnwardsToShelleyBasedEra :: MaryEraOnwards era -> ShelleyBasedEra era
forShelleyBasedEraInEon :: Eon eon => ShelleyBasedEra era -> a -> (eon era -> a) -> a
forShelleyBasedEraInEonMaybe :: Eon eon => ShelleyBasedEra era -> (eon era -> a) -> Maybe a
forShelleyBasedEraMaybeEon :: Eon eon => ShelleyBasedEra era -> Maybe (eon era)
inAnyShelleyBasedEra :: ShelleyBasedEra era -> thing era -> InAnyShelleyBasedEra thing
inEonForShelleyBasedEra :: Eon eon => a -> (eon era -> a) -> ShelleyBasedEra era -> a
inEonForShelleyBasedEraMaybe :: Eon eon => (eon era -> a) -> ShelleyBasedEra era -> Maybe a
requireShelleyBasedEra :: Applicative m => CardanoEra era -> m (Maybe (ShelleyBasedEra era))
shelleyBasedEraConstraints :: ShelleyBasedEra era -> (ShelleyBasedEraConstraints era => a) -> a
shelleyEraOnlyConstraints :: ShelleyEraOnly era -> (ShelleyEraOnlyConstraints era => a) -> a
shelleyEraOnlyToShelleyBasedEra :: ShelleyEraOnly era -> ShelleyBasedEra era
shelleyToAllegraEraConstraints :: ShelleyToAllegraEra era -> (ShelleyToAllegraEraConstraints era => a) -> a
shelleyToAllegraEraToShelleyBasedEra :: ShelleyToAllegraEra era -> ShelleyBasedEra era
shelleyToAlonzoEraConstraints :: ShelleyToAlonzoEra era -> (ShelleyToAlonzoEraConstraints era => a) -> a
shelleyToAlonzoEraToShelleyBasedEra :: ShelleyToAlonzoEra era -> ShelleyBasedEra era
shelleyToBabbageEraConstraints :: ShelleyToBabbageEra era -> (ShelleyToBabbageEraConstraints era => a) -> a
shelleyToBabbageEraToShelleyBasedEra :: ShelleyToBabbageEra era -> ShelleyBasedEra era
shelleyToMaryEraConstraints :: ShelleyToMaryEra era -> (ShelleyToMaryEraConstraints era => a) -> a
shelleyToMaryEraToShelleyBasedEra :: ShelleyToMaryEra era -> ShelleyBasedEra era
alonzoEraOnwardsToMaryEraOnwards :: AlonzoEraOnwards era -> MaryEraOnwards era
babbageEraOnwardsToAlonzoEraOnwards :: BabbageEraOnwards era -> AlonzoEraOnwards era
babbageEraOnwardsToMaryEraOnwards :: BabbageEraOnwards era -> MaryEraOnwards era
caseByronOrShelleyBasedEra :: a -> (ShelleyBasedEraConstraints era => ShelleyBasedEra era -> a) -> CardanoEra era -> a
caseByronToAlonzoOrBabbageEraOnwards :: (ByronToAlonzoEraConstraints era => ByronToAlonzoEra era -> a) -> (BabbageEraOnwardsConstraints era => BabbageEraOnwards era -> a) -> CardanoEra era -> a
caseShelleyEraOnlyOrAllegraEraOnwards :: (ShelleyEraOnlyConstraints era => ShelleyEraOnly era -> a) -> (AllegraEraOnwardsConstraints era => AllegraEraOnwards era -> a) -> ShelleyBasedEra era -> a
caseShelleyToAllegraOrMaryEraOnwards :: (ShelleyToAllegraEraConstraints era => ShelleyToAllegraEra era -> a) -> (MaryEraOnwardsConstraints era => MaryEraOnwards era -> a) -> ShelleyBasedEra era -> a
caseShelleyToAlonzoOrBabbageEraOnwards :: (ShelleyToAlonzoEraConstraints era => ShelleyToAlonzoEra era -> a) -> (BabbageEraOnwardsConstraints era => BabbageEraOnwards era -> a) -> ShelleyBasedEra era -> a
caseShelleyToBabbageOrConwayEraOnwards :: (ShelleyToBabbageEraConstraints era => ShelleyToBabbageEra era -> a) -> (ConwayEraOnwardsConstraints era => ConwayEraOnwards era -> a) -> ShelleyBasedEra era -> a
caseShelleyToMaryOrAlonzoEraOnwards :: (ShelleyToMaryEraConstraints era => ShelleyToMaryEra era -> a) -> (AlonzoEraOnwardsConstraints era => AlonzoEraOnwards era -> a) -> ShelleyBasedEra era -> a
shelleyToAlonzoEraToShelleyToBabbageEra :: ShelleyToAlonzoEra era -> ShelleyToBabbageEra era
anyCardanoEra :: CardanoEra era -> AnyCardanoEra
cardanoEraConstraints :: CardanoEra era -> (CardanoEraConstraints era => a) -> a
forEraInEon :: Eon eon => CardanoEra era -> a -> (eon era -> a) -> a
forEraInEonMaybe :: Eon eon => CardanoEra era -> (eon era -> a) -> Maybe a
forEraMaybeEon :: Eon eon => CardanoEra era -> Maybe (eon era)
inAnyCardanoEra :: CardanoEra era -> thing era -> InAnyCardanoEra thing
inEonForEraMaybe :: Eon eon => (eon era -> a) -> CardanoEra era -> Maybe a
maybeEon :: (Eon eon, IsCardanoEra era) => Maybe (eon era)
monoidForEraInEon :: (Eon eon, Monoid a) => CardanoEra era -> (eon era -> a) -> a
monoidForEraInEonA :: (Eon eon, Applicative f, Monoid a) => CardanoEra era -> (eon era -> f a) -> f a
throwErrorAsException :: Error e => e -> IO a
asFeaturedInEra :: forall (eon :: Type -> Type) a era. Eon eon => a -> CardanoEra era -> Maybe (Featured eon era a)
asFeaturedInShelleyBasedEra :: forall (eon :: Type -> Type) a era. Eon eon => a -> ShelleyBasedEra era -> Maybe (Featured eon era a)
mkFeatured :: forall (eon :: Type -> Type) era a. (IsCardanoEra era, Eon eon) => a -> Maybe (Featured eon era a)
unFeatured :: forall (eon :: Type -> Type) era a. Featured eon era a -> a
calculateMinTxFee :: ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> UTxO era -> TxBody era -> Word -> Coin
calculateMinimumUTxO :: HasCallStack => ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> TxOut CtxTx era -> Coin
estimateBalancedTxBody :: HasCallStack => MaryEraOnwards era -> TxBodyContent BuildTx era -> PParams (ShelleyLedgerEra era) -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> Map ScriptWitnessIndex ExecutionUnits -> Coin -> Int -> Int -> Int -> AddressInEra era -> Value -> Either (TxFeeEstimationError era) (BalancedTxBody era)
estimateOrCalculateBalancedTxBody :: ShelleyBasedEra era -> FeeEstimationMode era -> PParams (ShelleyLedgerEra era) -> TxBodyContent BuildTx era -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> AddressInEra era -> Either (AutoBalanceError era) (BalancedTxBody era)
estimateTransactionKeyWitnessCount :: TxBodyContent BuildTx era -> Word
evaluateTransactionBalance :: ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> UTxO era -> TxBody era -> TxOutValue era
evaluateTransactionExecutionUnits :: CardanoEra era -> SystemStart -> LedgerEpochInfo -> LedgerProtocolParameters era -> UTxO era -> TxBody era -> Map ScriptWitnessIndex (Either ScriptExecutionError (EvalTxExecutionUnitsLog, ExecutionUnits))
evaluateTransactionFee :: ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> TxBody era -> Word -> Word -> Int -> Coin
makeTransactionBodyAutoBalance :: HasCallStack => ShelleyBasedEra era -> SystemStart -> LedgerEpochInfo -> LedgerProtocolParameters era -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> UTxO era -> TxBodyContent BuildTx era -> AddressInEra era -> Maybe Word -> Either (TxBodyErrorAutoBalance era) (BalancedTxBody era)
getAnchorDataFromGovernanceAction :: GovAction (ShelleyLedgerEra era) -> Maybe Anchor
validateGovActionAnchorData :: FromJSON (GovActionMetadata cip) => cip -> ByteString -> Either String ()
asType :: HasTypeProxy t => AsType t
castHash :: CastHash roleA roleB => Hash roleA -> Hash roleB
renderSafeHashAsHex :: SafeHash tag -> Text
intoFile :: File content 'Out -> content -> (File content 'Out -> stream -> result) -> (content -> stream) -> result
mapFile :: forall content (direction :: FileDirection). (FilePath -> FilePath) -> File content direction -> File content direction
onlyIn :: File content 'InOut -> File content 'In
onlyOut :: File content 'InOut -> File content 'Out
readByteStringFile :: MonadIO m => File content 'In -> m (Either (FileError e) ByteString)
readLazyByteStringFile :: MonadIO m => File content 'In -> m (Either (FileError e) ByteString)
readTextFile :: MonadIO m => File content 'In -> m (Either (FileError e) Text)
writeByteStringFile :: MonadIO m => File content 'Out -> ByteString -> m (Either (FileError e) ())
writeByteStringFileWithOwnerPermissions :: FilePath -> ByteString -> IO (Either (FileError e) ())
writeByteStringOutput :: MonadIO m => Maybe (File content 'Out) -> ByteString -> m (Either (FileError e) ())
writeLazyByteStringFile :: MonadIO m => File content 'Out -> ByteString -> m (Either (FileError e) ())
writeLazyByteStringFileWithOwnerPermissions :: File content 'Out -> ByteString -> IO (Either (FileError e) ())
writeLazyByteStringOutput :: MonadIO m => Maybe (File content 'Out) -> ByteString -> m (Either (FileError e) ())
writeTextFile :: MonadIO m => File content 'Out -> Text -> m (Either (FileError e) ())
writeTextFileWithOwnerPermissions :: File content 'Out -> Text -> IO (Either (FileError e) ())
writeTextOutput :: MonadIO m => Maybe (File content 'Out) -> Text -> m (Either (FileError e) ())
writeSecrets :: FilePath -> [Char] -> [Char] -> (a -> ByteString) -> [a] -> IO ()
connectToLocalNode :: MonadIO m => LocalNodeConnectInfo -> LocalNodeClientProtocolsInMode -> m ()
connectToLocalNodeWithVersion :: MonadIO m => LocalNodeConnectInfo -> (NodeToClientVersion -> LocalNodeClientProtocolsInMode) -> m ()
getLocalChainTip :: MonadIO m => LocalNodeConnectInfo -> m ChainTip
mkLocalNodeClientParams :: ConsensusModeParams -> (NodeToClientVersion -> LocalNodeClientProtocolsInMode) -> LocalNodeClientParams
queryNodeLocalState :: LocalNodeConnectInfo -> Target ChainPoint -> QueryInMode result -> ExceptT AcquiringFailure IO result
queryTxMonitoringLocal :: MonadIO m => LocalNodeConnectInfo -> LocalTxMonitoringQuery -> m LocalTxMonitoringResult
submitTxToNodeLocal :: MonadIO m => LocalNodeConnectInfo -> TxInMode -> m (SubmitResult TxValidationErrorInCardanoMode)
executeLocalStateQueryExpr :: LocalNodeConnectInfo -> Target ChainPoint -> LocalStateQueryExpr BlockInMode ChainPoint QueryInMode () IO a -> IO (Either AcquiringFailure a)
queryExpr :: QueryInMode a -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError a)
castSigningKey :: CastSigningKeyRole keyroleA keyroleB => SigningKey keyroleA -> SigningKey keyroleB
castVerificationKey :: CastVerificationKeyRole keyroleA keyroleB => VerificationKey keyroleA -> VerificationKey keyroleB
generateInsecureSigningKey :: (MonadIO m, Key keyrole, SerialiseAsRawBytes (SigningKey keyrole)) => StdGen -> AsType keyrole -> m (SigningKey keyrole, StdGen)
generateSigningKey :: (MonadIO m, Key keyrole) => AsType keyrole -> m (SigningKey keyrole)
autocompleteMnemonicPrefix :: Text -> Maybe Text
findMnemonicWordsWithPrefix :: Text -> [(Text, Int)]
generateMnemonic :: MonadIO m => MnemonicSize -> m [Text]
signingKeyFromMnemonic :: SigningKeyFromRootKey keyrole => AsType keyrole -> [Text] -> Word32 -> Either MnemonicToSigningKeyError (SigningKey keyrole)
signingKeyFromMnemonicWithPaymentKeyIndex :: IndexedSigningKeyFromRootKey keyrole => AsType keyrole -> [Text] -> Word32 -> Word32 -> Either MnemonicToSigningKeyError (SigningKey keyrole)
readKeyFile :: NonEmpty (InputFormat a) -> FilePath -> IO (Either (FileError InputDecodeError) a)
readKeyFileAnyOf :: forall content b. [FromSomeType SerialiseAsBech32 b] -> [FromSomeType HasTextEnvelope b] -> File content 'In -> IO (Either (FileError InputDecodeError) b)
readKeyFileTextEnvelope :: HasTextEnvelope a => File content 'In -> IO (Either (FileError InputDecodeError) a)
applyBlock :: Env -> LedgerState -> ValidationMode -> BlockInMode -> Either LedgerStateError (LedgerState, [LedgerEvent])
chainSyncClientPipelinedWithLedgerState :: forall (m :: Type -> Type) a. Monad m => Env -> LedgerState -> ValidationMode -> ChainSyncClientPipelined (BlockInMode, Either LedgerStateError (LedgerState, [LedgerEvent])) ChainPoint ChainTip m a -> ChainSyncClientPipelined BlockInMode ChainPoint ChainTip m a
chainSyncClientWithLedgerState :: forall (m :: Type -> Type) a. Monad m => Env -> LedgerState -> ValidationMode -> ChainSyncClient (BlockInMode, Either LedgerStateError (LedgerState, [LedgerEvent])) ChainPoint ChainTip m a -> ChainSyncClient BlockInMode ChainPoint ChainTip m a
decodeLedgerState :: Decoder s LedgerState
encodeLedgerState :: LedgerState -> Encoding
envSecurityParam :: Env -> Word64
foldBlocks :: forall a t (m :: Type -> Type). (Show a, MonadIOTransError FoldBlocksError t m) => NodeConfigFile 'In -> SocketPath -> ValidationMode -> a -> (Env -> LedgerState -> [LedgerEvent] -> BlockInMode -> a -> IO (a, FoldStatus)) -> t m a
foldEpochState :: forall t (m :: Type -> Type) s. MonadIOTransError FoldBlocksError t m => NodeConfigFile 'In -> SocketPath -> ValidationMode -> EpochNo -> s -> (AnyNewEpochState -> SlotNo -> BlockNo -> StateT s IO ConditionResult) -> t m (ConditionResult, s)
fromConditionResult :: ConditionResult -> Bool
genesisConfigToEnv :: GenesisConfig -> Either GenesisConfigError Env
getAnyNewEpochState :: ShelleyBasedEra era -> LedgerState -> Either LedgerStateError AnyNewEpochState
getLedgerTablesUTxOValues :: ShelleyBasedEra era -> LedgerTables (LedgerState (CardanoBlock StandardCrypto)) ValuesMK -> Map TxIn (TxOut CtxUTxO era)
initialLedgerState :: forall t (m :: Type -> Type). MonadIOTransError InitialLedgerStateError t m => NodeConfigFile 'In -> t m (Env, LedgerState)
mkProtocolInfoCardano :: GenesisConfig -> (ProtocolInfo (CardanoBlock StandardCrypto), IO [BlockForging IO (CardanoBlock StandardCrypto)])
readAlonzoGenesisConfig :: forall t (m :: Type -> Type) era. MonadIOTransError GenesisConfigError t m => Maybe (CardanoEra era) -> NodeConfig -> t m AlonzoGenesis
readByronGenesisConfig :: forall t (m :: Type -> Type). MonadIOTransError GenesisConfigError t m => NodeConfig -> t m Config
readCardanoGenesisConfig :: forall t (m :: Type -> Type) era. MonadIOTransError GenesisConfigError t m => Maybe (CardanoEra era) -> NodeConfig -> t m GenesisConfig
readConwayGenesisConfig :: forall t (m :: Type -> Type). MonadIOTransError GenesisConfigError t m => NodeConfig -> t m ConwayGenesis
readNodeConfig :: (MonadError Text m, MonadIO m) => NodeConfigFile 'In -> m NodeConfig
readShelleyGenesisConfig :: forall t (m :: Type -> Type). MonadIOTransError GenesisConfigError t m => NodeConfig -> t m ShelleyConfig
shelleyPraosNonce :: GenesisHashShelley -> Nonce
toConditionResult :: Bool -> ConditionResult
handleIOExceptionsLiftWith :: (MonadIOTransError e' t m, Exception e) => (e -> e') -> m a -> t m a
handleIOExceptionsWith :: (MonadError e' m, MonadCatch m, Exception e) => (e -> e') -> m a -> m a
hoistIOEither :: forall e t (m :: Type -> Type) a. MonadIOTransError e t m => IO (Either e a) -> t m a
liftExceptT :: forall e t (m :: Type -> Type) a. MonadTransError e t m => ExceptT e m a -> t m a
liftMaybe :: MonadError e m => e -> Maybe a -> m a
fromNetworkMagic :: NetworkMagic -> NetworkId
toNetworkMagic :: NetworkId -> NetworkMagic
getHotKey :: OperationalCertificate -> VerificationKey KesKey
getKesPeriod :: OperationalCertificate -> Word
getOpCertCount :: OperationalCertificate -> Word64
issueOperationalCertificate :: VerificationKey KesKey -> Either AnyStakePoolSigningKey (SigningKey GenesisDelegateExtendedKey) -> KESPeriod -> OperationalCertificateIssueCounter -> Either OperationalCertIssueError (OperationalCertificate, OperationalCertificateIssueCounter)
collectPlutusScriptHashes :: AlonzoEraOnwards era -> Tx era -> UTxO era -> Map ScriptWitnessIndex ScriptHash
renderDebugPlutusFailure :: DebugPlutusFailure -> Text
black :: Doc AnsiStyle -> Doc AnsiStyle
cyan :: Doc AnsiStyle -> Doc AnsiStyle
docToLazyText :: Doc AnsiStyle -> Text
docToString :: Doc AnsiStyle -> String
docToText :: Doc AnsiStyle -> Text
magenta :: Doc AnsiStyle -> Doc AnsiStyle
prettyException :: Exception a => a -> Doc ann
pshow :: Show a => a -> Doc ann
white :: Doc AnsiStyle -> Doc AnsiStyle
yellow :: Doc AnsiStyle -> Doc AnsiStyle
reflBlockType :: BlockType blk -> BlockType blk' -> Maybe (blk :~: blk')
fromAlonzoCostModel :: CostModel -> CostModel
makePraosNonce :: ByteString -> PraosNonce
makeShelleyUpdateProposal :: ProtocolParametersUpdate -> [Hash GenesisKey] -> EpochNo -> UpdateProposal
toAlonzoCostModel :: CostModel -> Language -> Either ProtocolParametersConversionError CostModel
toAlonzoCostModels :: Map AnyPlutusScriptVersion CostModel -> Either ProtocolParametersConversionError CostModels
getProgress :: SlotNo -> EraHistory -> Either PastHorizonException (RelativeTime, SlotLength)
getSlotForRelativeTime :: RelativeTime -> EraHistory -> Either PastHorizonException SlotNo
slotToEpoch :: SlotNo -> EraHistory -> Either PastHorizonException (EpochNo, SlotsInEpoch, SlotsToEpochEnd)
toLedgerEpochInfo :: EraHistory -> LedgerEpochInfo
queryAccountState :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch AccountState))
queryChainBlockNo :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (WithOrigin BlockNo))
queryChainPoint :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError ChainPoint)
queryCommitteeMembersState :: ConwayEraOnwards era -> Set (Credential 'ColdCommitteeRole) -> Set (Credential 'HotCommitteeRole) -> Set MemberStatus -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch CommitteeMembersState))
queryConstitution :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Constitution (ShelleyLedgerEra era))))
queryConstitutionHash :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SafeHash AnchorData)))
queryCurrentEpochState :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedCurrentEpochState era)))
queryCurrentEra :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError AnyCardanoEra)
queryDRepStakeDistribution :: ConwayEraOnwards era -> Set DRep -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map DRep Coin)))
queryDRepState :: ConwayEraOnwards era -> Set (Credential 'DRepRole) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map (Credential 'DRepRole) DRepState)))
queryDebugLedgerState :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedDebugLedgerState era)))
queryEpoch :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch EpochNo))
queryFuturePParams :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Maybe (PParams (ShelleyLedgerEra era)))))
queryGenesisParameters :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (GenesisParameters ShelleyEra)))
queryGovState :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (GovState (ShelleyLedgerEra era))))
queryLedgerConfig :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (CardanoLedgerConfig StandardCrypto))
queryLedgerPeerSnapshot :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Serialised LedgerPeerSnapshot)))
queryPoolDistribution :: BabbageEraOnwards era -> Maybe (Set PoolId) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedPoolDistribution era)))
queryPoolState :: BabbageEraOnwards era -> Maybe (Set PoolId) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedPoolState era)))
queryProposals :: ConwayEraOnwards era -> Set GovActionId -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Seq (GovActionState (ShelleyLedgerEra era)))))
queryProtocolState :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (ProtocolState era)))
queryRatifyState :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (RatifyState (ShelleyLedgerEra era))))
querySPOStakeDistribution :: ConwayEraOnwards era -> Set (KeyHash 'StakePool) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map (KeyHash 'StakePool) Coin)))
queryStakeAddresses :: ShelleyBasedEra era -> Set StakeCredential -> NetworkId -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map StakeAddress Coin, Map StakeAddress PoolId)))
queryStakeDelegDeposits :: BabbageEraOnwards era -> Set StakeCredential -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map StakeCredential Coin)))
queryStakeDistribution :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map (Hash StakePoolKey) Rational)))
queryStakePoolDefaultVote :: ConwayEraOnwards era -> KeyHash 'StakePool -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch DefaultVote))
queryStakePoolParameters :: ShelleyBasedEra era -> Set PoolId -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map PoolId StakePoolParameters)))
queryStakeSnapshot :: BabbageEraOnwards era -> Maybe (Set PoolId) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedStakeSnapshots era)))
queryStakeVoteDelegatees :: ConwayEraOnwards era -> Set StakeCredential -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map StakeCredential DRep)))
queryUtxo :: ShelleyBasedEra era -> QueryUTxOFilter -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (UTxO era)))
mergeDelegsAndRewards :: DelegationsAndRewards -> [(StakeAddress, Maybe Coin, Maybe PoolId)]
eraOfScriptInEra :: ScriptInEra era -> ShelleyBasedEra era
eraOfScriptLanguageInEra :: ScriptLanguageInEra lang era -> ShelleyBasedEra era
examplePlutusScriptAlwaysFails :: WitCtx witctx -> PlutusScript PlutusScriptV1
examplePlutusScriptAlwaysSucceeds :: WitCtx witctx -> PlutusScript PlutusScriptV1
getScriptWitnessReferenceInput :: ScriptWitness witctx era -> Maybe TxIn
getScriptWitnessReferenceInputOrScript :: ScriptWitness witctx era -> Either (ScriptInEra era) TxIn
getScriptWitnessScript :: ScriptWitness witctx era -> Maybe (ScriptInEra era)
hashScript :: Script lang -> ScriptHash
languageOfScriptLanguageInEra :: ScriptLanguageInEra lang era -> ScriptLanguage lang
sbeToSimpleScriptLanguageInEra :: ShelleyBasedEra era -> ScriptLanguageInEra SimpleScript' era
toScriptInAnyLang :: Script lang -> ScriptInAnyLang
toScriptInEra :: ShelleyBasedEra era -> ScriptInAnyLang -> Maybe (ScriptInEra era)
getOriginalScriptDataBytes :: HashableScriptData -> ByteString
getScriptData :: HashableScriptData -> ScriptData
hashScriptDataBytes :: HashableScriptData -> Hash ScriptData
scriptDataFromJson :: ScriptDataJsonSchema -> Value -> Either ScriptDataJsonError HashableScriptData
scriptDataJsonToHashable :: ScriptDataJsonSchema -> Value -> Either ScriptDataJsonBytesError HashableScriptData
scriptDataToJson :: ScriptDataJsonSchema -> HashableScriptData -> Value
unsafeHashableScriptData :: ScriptData -> HashableScriptData
validateScriptData :: ScriptData -> Either ScriptDataRangeError ()
deserialiseAnyOfFromBech32 :: [FromSomeType SerialiseAsBech32 b] -> Text -> Either Bech32DecodeError b
deserialiseFromBech32 :: SerialiseAsBech32 a => Text -> Either Bech32DecodeError a
serialiseToBech32 :: SerialiseAsBech32 a => a -> Text
deserialiseFromJSON :: FromJSON a => ByteString -> Either JsonDecodeError a
prettyPrintJSON :: ToJSON a => a -> ByteString
readFileJSON :: FromJSON a => FilePath -> IO (Either (FileError JsonDecodeError) a)
serialiseToJSON :: ToJSON a => a -> ByteString
writeFileJSON :: ToJSON a => FilePath -> a -> IO (Either (FileError ()) ())
deserialiseByronTxCddl :: TextEnvelope -> Either TextEnvelopeCddlError (ATxAux ByteString)
deserialiseFromTextEnvelopeCddlAnyOf :: [FromSomeTypeCDDL TextEnvelope b] -> TextEnvelope -> Either TextEnvelopeCddlError b
deserialiseWitnessLedgerCddl :: ShelleyBasedEra era -> TextEnvelope -> Either TextEnvelopeCddlError (KeyWitness era)
readFileTextEnvelopeCddlAnyOf :: [FromSomeTypeCDDL TextEnvelope b] -> FilePath -> IO (Either (FileError TextEnvelopeCddlError) b)
serialiseWitnessLedgerCddl :: ShelleyBasedEra era -> KeyWitness era -> TextEnvelope
writeTxFileTextEnvelopeCanonicalCddl :: ShelleyBasedEra era -> File content 'Out -> Tx era -> IO (Either (FileError ()) ())
writeTxFileTextEnvelopeCddl :: ShelleyBasedEra era -> File content 'Out -> Tx era -> IO (Either (FileError ()) ())
writeTxWitnessFileTextEnvelopeCddl :: ShelleyBasedEra era -> File () 'Out -> KeyWitness era -> IO (Either (FileError ()) ())
deserialiseFromRawBytesHex :: SerialiseAsRawBytes a => ByteString -> Either RawBytesHexError a
serialiseToRawBytesHex :: SerialiseAsRawBytes a => a -> ByteString
serialiseToRawBytesHexText :: SerialiseAsRawBytes a => a -> Text
deserialiseFromTextEnvelope :: HasTextEnvelope a => TextEnvelope -> Either TextEnvelopeError a
deserialiseFromTextEnvelopeAnyOf :: [FromSomeType HasTextEnvelope b] -> TextEnvelope -> Either TextEnvelopeError b
readFileTextEnvelope :: HasTextEnvelope a => File content 'In -> IO (Either (FileError TextEnvelopeError) a)
readFileTextEnvelopeAnyOf :: [FromSomeType HasTextEnvelope b] -> File content 'In -> IO (Either (FileError TextEnvelopeError) b)
readTextEnvelopeFromFile :: FilePath -> IO (Either (FileError TextEnvelopeError) TextEnvelope)
readTextEnvelopeOfTypeFromFile :: TextEnvelopeType -> FilePath -> IO (Either (FileError TextEnvelopeError) TextEnvelope)
serialiseToTextEnvelope :: HasTextEnvelope a => Maybe TextEnvelopeDescr -> a -> TextEnvelope
textEnvelopeRawCBOR :: TextEnvelope -> ByteString
textEnvelopeToJSON :: HasTextEnvelope a => Maybe TextEnvelopeDescr -> a -> ByteString
textEnvelopeTypeInEra :: HasTextEnvelope (f era) => CardanoEra era -> AsType (f era) -> TextEnvelopeType
writeFileTextEnvelope :: HasTextEnvelope a => File content 'Out -> Maybe TextEnvelopeDescr -> a -> IO (Either (FileError ()) ())
validateAndHashStakePoolMetadata :: ByteString -> Either StakePoolMetadataValidationError (StakePoolMetadata, Hash StakePoolMetadata)
addTxExtraKeyWits :: IsAlonzoBasedEra era => [Hash PaymentKey] -> TxBodyContent build era -> TxBodyContent build era
addTxIn :: (TxIn, BuildTxWith build (Witness WitCtxTxIn era)) -> TxBodyContent build era -> TxBodyContent build era
addTxInCollateral :: IsAlonzoBasedEra era => TxIn -> TxBodyContent build era -> TxBodyContent build era
addTxInReference :: (Applicative (BuildTxWith build), IsBabbageBasedEra era) => TxIn -> Maybe HashableScriptData -> TxBodyContent build era -> TxBodyContent build era
addTxIns :: TxIns build era -> TxBodyContent build era -> TxBodyContent build era
addTxInsCollateral :: IsAlonzoBasedEra era => [TxIn] -> TxBodyContent build era -> TxBodyContent build era
addTxInsReference :: (Applicative (BuildTxWith build), IsBabbageBasedEra era) => [TxIn] -> Set HashableScriptData -> TxBodyContent build era -> TxBodyContent build era
addTxMintValue :: IsMaryBasedEra era => Map PolicyId (PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era)) -> TxBodyContent build era -> TxBodyContent build era
addTxOut :: TxOut CtxTx era -> TxBodyContent build era -> TxBodyContent build era
addTxOuts :: [TxOut CtxTx era] -> TxBodyContent build era -> TxBodyContent build era
collectTxBodyScriptWitnesses :: ShelleyBasedEra era -> TxBodyContent BuildTx era -> [(ScriptWitnessIndex, AnyScriptWitness era)]
convProposalProcedures :: TxProposalProcedures build era -> OSet (ProposalProcedure (ShelleyLedgerEra era))
createTransactionBody :: HasCallStack => ShelleyBasedEra era -> TxBodyContent BuildTx era -> Either TxBodyError (TxBody era)
defaultTxFee :: ShelleyBasedEra era -> TxFee era
defaultTxValidityUpperBound :: ShelleyBasedEra era -> TxValidityUpperBound era
genesisUTxOPseudoTxIn :: NetworkId -> Hash GenesisUTxOKey -> TxIn
getReferenceInputsSizeForTxIds :: ShelleyLedgerEra era ~ ledgerera => BabbageEraOnwards era -> UTxO ledgerera -> Set TxIn -> Int
getTxBodyContent :: TxBody era -> TxBodyContent ViewTx era
getTxId :: TxBody era -> TxId
getTxIdByron :: ATxAux ByteString -> TxId
indexTxMintValue :: TxMintValue build era -> [(ScriptWitnessIndex, PolicyId, PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era))]
makeByronTransactionBody :: TxIns BuildTx ByronEra -> [TxOut CtxTx ByronEra] -> Either TxBodyError (Annotated Tx ByteString)
mkTxCertificates :: Applicative (BuildTxWith build) => ShelleyBasedEra era -> [(Certificate era, Maybe (ScriptWitness WitCtxStake era))] -> TxCertificates build era
mkTxMintValue :: MaryEraOnwards era -> [(PolicyId, PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era))] -> TxMintValue build era
mkTxProposalProcedures :: forall era build. (Applicative (BuildTxWith build), IsShelleyBasedEra era) => [(ProposalProcedure (ShelleyLedgerEra era), Maybe (ScriptWitness WitCtxStake era))] -> TxProposalProcedures build era
mkTxVotingProcedures :: Applicative (BuildTxWith build) => [(VotingProcedures era, Maybe (ScriptWitness WitCtxStake era))] -> Either (VotesMergingConflict era) (TxVotingProcedures build era)
modTxAuxScripts :: (TxAuxScripts era -> TxAuxScripts era) -> TxBodyContent build era -> TxBodyContent build era
modTxCertificates :: (TxCertificates build era -> TxCertificates build era) -> TxBodyContent build era -> TxBodyContent build era
modTxExtraKeyWits :: (TxExtraKeyWitnesses era -> TxExtraKeyWitnesses era) -> TxBodyContent build era -> TxBodyContent build era
modTxFee :: (TxFee era -> TxFee era) -> TxBodyContent build era -> TxBodyContent build era
modTxIns :: (TxIns build era -> TxIns build era) -> TxBodyContent build era -> TxBodyContent build era
modTxInsCollateral :: (TxInsCollateral era -> TxInsCollateral era) -> TxBodyContent build era -> TxBodyContent build era
modTxInsReference :: (TxInsReference build era -> TxInsReference build era) -> TxBodyContent build era -> TxBodyContent build era
modTxMetadata :: (TxMetadataInEra era -> TxMetadataInEra era) -> TxBodyContent build era -> TxBodyContent build era
modTxMintValue :: (TxMintValue build era -> TxMintValue build era) -> TxBodyContent build era -> TxBodyContent build era
modTxOuts :: ([TxOut CtxTx era] -> [TxOut CtxTx era]) -> TxBodyContent build era -> TxBodyContent build era
modTxReturnCollateral :: (TxReturnCollateral CtxTx era -> TxReturnCollateral CtxTx era) -> TxBodyContent build era -> TxBodyContent build era
modTxScriptValidity :: (TxScriptValidity era -> TxScriptValidity era) -> TxBodyContent build era -> TxBodyContent build era
modTxTotalCollateral :: (TxTotalCollateral era -> TxTotalCollateral era) -> TxBodyContent build era -> TxBodyContent build era
modTxUpdateProposal :: (TxUpdateProposal era -> TxUpdateProposal era) -> TxBodyContent build era -> TxBodyContent build era
modTxValidityLowerBound :: (TxValidityLowerBound era -> TxValidityLowerBound era) -> TxBodyContent build era -> TxBodyContent build era
modTxValidityUpperBound :: (TxValidityUpperBound era -> TxValidityUpperBound era) -> TxBodyContent build era -> TxBodyContent build era
modTxWithdrawals :: (TxWithdrawals build era -> TxWithdrawals build era) -> TxBodyContent build era -> TxBodyContent build era
renderScriptWitnessIndex :: ScriptWitnessIndex -> String
setTxAuxScripts :: TxAuxScripts era -> TxBodyContent build era -> TxBodyContent build era
setTxCertificates :: TxCertificates build era -> TxBodyContent build era -> TxBodyContent build era
setTxCurrentTreasuryValue :: Maybe (Featured ConwayEraOnwards era (Maybe Coin)) -> TxBodyContent build era -> TxBodyContent build era
setTxExtraKeyWits :: TxExtraKeyWitnesses era -> TxBodyContent build era -> TxBodyContent build era
setTxFee :: TxFee era -> TxBodyContent build era -> TxBodyContent build era
setTxIns :: TxIns build era -> TxBodyContent build era -> TxBodyContent build era
setTxInsCollateral :: TxInsCollateral era -> TxBodyContent build era -> TxBodyContent build era
setTxInsReference :: TxInsReference build era -> TxBodyContent build era -> TxBodyContent build era
setTxMetadata :: TxMetadataInEra era -> TxBodyContent build era -> TxBodyContent build era
setTxMintValue :: TxMintValue build era -> TxBodyContent build era -> TxBodyContent build era
setTxOuts :: [TxOut CtxTx era] -> TxBodyContent build era -> TxBodyContent build era
setTxProposalProcedures :: Maybe (Featured ConwayEraOnwards era (TxProposalProcedures build era)) -> TxBodyContent build era -> TxBodyContent build era
setTxProtocolParams :: BuildTxWith build (Maybe (LedgerProtocolParameters era)) -> TxBodyContent build era -> TxBodyContent build era
setTxReturnCollateral :: TxReturnCollateral CtxTx era -> TxBodyContent build era -> TxBodyContent build era
setTxScriptValidity :: TxScriptValidity era -> TxBodyContent build era -> TxBodyContent build era
setTxTotalCollateral :: TxTotalCollateral era -> TxBodyContent build era -> TxBodyContent build era
setTxTreasuryDonation :: Maybe (Featured ConwayEraOnwards era Coin) -> TxBodyContent build era -> TxBodyContent build era
setTxUpdateProposal :: TxUpdateProposal era -> TxBodyContent build era -> TxBodyContent build era
setTxValidityLowerBound :: TxValidityLowerBound era -> TxBodyContent build era -> TxBodyContent build era
setTxValidityUpperBound :: TxValidityUpperBound era -> TxBodyContent build era -> TxBodyContent build era
setTxVotingProcedures :: Maybe (Featured ConwayEraOnwards era (TxVotingProcedures build era)) -> TxBodyContent build era -> TxBodyContent build era
setTxWithdrawals :: TxWithdrawals build era -> TxBodyContent build era -> TxBodyContent build era
subtractTxMintValue :: IsMaryBasedEra era => Map PolicyId (PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era)) -> TxBodyContent build era -> TxBodyContent build era
txMintValueToValue :: TxMintValue build era -> Value
buildTxWithToMaybe :: BuildTxWith build a -> Maybe a
fromCtxUTxOTxOut :: TxOut CtxUTxO era -> TxOut CtxTx era
fromLedgerTxOuts :: ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> TxBodyScriptData era -> [TxOut CtxTx era]
parseHash :: SerialiseAsRawBytes (Hash a) => Parser (Hash a)
toCtxUTxOTxOut :: TxOut CtxTx era -> TxOut CtxUTxO era
txOutInAnyEra :: CardanoEra era -> TxOut CtxTx era -> TxOutInAnyEra
txOutValueToLovelace :: TxOutValue era -> Coin
getTxBody :: Tx era -> TxBody era
getTxWitnesses :: Tx era -> [KeyWitness era]
makeByronKeyWitness :: IsByronKey key => NetworkId -> Annotated Tx ByteString -> SigningKey key -> KeyWitness ByronEra
makeShelleyBasedBootstrapWitness :: ShelleyBasedEra era -> WitnessNetworkIdOrByronAddress -> TxBody (ShelleyLedgerEra era) -> SigningKey ByronKey -> KeyWitness era
makeShelleyBootstrapWitness :: ShelleyBasedEra era -> WitnessNetworkIdOrByronAddress -> TxBody era -> SigningKey ByronKey -> KeyWitness era
makeShelleyKeyWitness' :: ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> ShelleyWitnessSigningKey -> KeyWitness era
makeSignedByronTransaction :: [KeyWitness era] -> Annotated Tx ByteString -> ATxAux ByteString
makeSignedTransaction :: [KeyWitness era] -> TxBody era -> Tx era
signByronTransaction :: NetworkId -> Annotated Tx ByteString -> [SigningKey ByronKey] -> ATxAux ByteString
txScriptValidityToScriptValidity :: TxScriptValidity era -> ScriptValidity
unUTxO :: UTxO era -> Map TxIn (TxOut CtxUTxO era)
makeTransactionMetadata :: Map Word64 TxMetadataValue -> TxMetadata
mergeTransactionMetadata :: (TxMetadataValue -> TxMetadataValue -> TxMetadataValue) -> TxMetadata -> TxMetadata -> TxMetadata
metaBytesChunks :: ByteString -> TxMetadataValue
metaTextChunks :: Text -> TxMetadataValue
metadataFromJson :: TxMetadataJsonSchema -> Value -> Either TxMetadataJsonError TxMetadata
metadataToJson :: TxMetadataJsonSchema -> TxMetadata -> Value
metadataValueFromJsonNoSchema :: Value -> Either TxMetadataJsonSchemaError TxMetadataValue
metadataValueToJsonNoSchema :: TxMetadataValue -> Value
validateTxMetadata :: TxMetadata -> Either [(Word64, TxMetadataRangeError)] ()
textShow :: Show a => a -> Text
unsafeBoundedRational :: (HasCallStack, Typeable r, BoundedRational r) => Rational -> r
filterValue :: (AssetId -> Bool) -> Value -> Value
lovelaceToQuantity :: Lovelace -> Quantity
lovelaceToValue :: Lovelace -> Value
multiAssetToPolicyAssets :: MultiAsset -> Map PolicyId PolicyAssets
negateValue :: Value -> Value
policyAssetsToValue :: PolicyId -> PolicyAssets -> Value
quantityToLovelace :: Quantity -> Lovelace
renderMultiAsset :: MultiAsset -> Text
renderMultiAssetPretty :: MultiAsset -> Text
renderValuePretty :: Value -> Text
scriptPolicyId :: Script lang -> PolicyId
selectAsset :: Value -> AssetId -> Quantity
valueFromList :: [(AssetId, Quantity)] -> Value
valueFromNestedRep :: ValueNestedRep -> Value
valueToList :: Value -> [(AssetId, Quantity)]
valueToLovelace :: Value -> Maybe Lovelace
valueToNestedRep :: Value -> ValueNestedRep
valueToPolicyAssets :: Value -> Map PolicyId PolicyAssets
parseAssetName :: Parser AssetName
parseMintingMultiAssetValue :: MaryEraOnwards era -> Parser MultiAsset
parsePolicyId :: Parser PolicyId
parseTxOutMultiAssetValue :: Parser Value
parseUTxOValue :: Parser Value
vsep :: [Doc ann] -> Doc ann
bimapExceptT :: forall (m :: Type -> Type) x y a b. Functor m => (x -> y) -> (a -> b) -> ExceptT x m a -> ExceptT y m b
bracketExceptT :: forall (m :: Type -> Type) e a b c. Monad m => ExceptT e m a -> (a -> ExceptT e m b) -> (a -> ExceptT e m c) -> ExceptT e m c
bracketExceptionT :: forall (m :: Type -> Type) e a c b. MonadMask m => ExceptT e m a -> (a -> ExceptT e m c) -> (a -> ExceptT e m b) -> ExceptT e m b
catchExceptT :: (MonadCatch m, Exception e) => m a -> (e -> x) -> ExceptT x m a
catchIOExceptT :: forall (m :: Type -> Type) a x. MonadIO m => IO a -> (IOException -> x) -> ExceptT x m a
catchLeftT :: forall (m :: Type -> Type) e a. Monad m => ExceptT e m a -> (e -> ExceptT e m a) -> ExceptT e m a
catchesExceptT :: (Foldable f, MonadCatch m) => m a -> f (Handler m x) -> ExceptT x m a
exceptT :: Monad m => (x -> m b) -> (a -> m b) -> ExceptT x m a -> m b
firstExceptT :: forall (m :: Type -> Type) x y a. Functor m => (x -> y) -> ExceptT x m a -> ExceptT y m a
handleExceptT :: (MonadCatch m, Exception e) => (e -> x) -> m a -> ExceptT x m a
handleIOExceptT :: forall (m :: Type -> Type) x a. MonadIO m => (IOException -> x) -> IO a -> ExceptT x m a
handleLeftT :: forall (m :: Type -> Type) e a. Monad m => (e -> ExceptT e m a) -> ExceptT e m a -> ExceptT e m a
handlesExceptT :: (Foldable f, MonadCatch m) => f (Handler m x) -> m a -> ExceptT x m a
hoistEither :: forall (m :: Type -> Type) x a. Monad m => Either x a -> ExceptT x m a
hoistExceptT :: (forall b. () => m b -> n b) -> ExceptT x m a -> ExceptT x n a
hushM :: Monad m => Either e a -> (e -> m ()) -> m (Maybe a)
newExceptT :: m (Either x a) -> ExceptT x m a
onLeft :: forall e x (m :: Type -> Type) a. Monad m => (e -> ExceptT x m a) -> ExceptT x m (Either e a) -> ExceptT x m a
onNothing :: forall x (m :: Type -> Type) a. Monad m => ExceptT x m a -> ExceptT x m (Maybe a) -> ExceptT x m a
secondExceptT :: forall (m :: Type -> Type) a b x. Functor m => (a -> b) -> ExceptT x m a -> ExceptT x m b
class () => Pretty a
pretty :: Pretty a => a -> Doc ann
prettyList :: Pretty a => [a] -> Doc ann
class (Eq VerificationKey keyrole, Show VerificationKey keyrole, SerialiseAsRawBytes Hash keyrole, HasTextEnvelope VerificationKey keyrole, HasTextEnvelope SigningKey keyrole) => Key keyrole where {
    data family VerificationKey keyrole;
    data family SigningKey keyrole;
}
getVerificationKey :: Key keyrole => SigningKey keyrole -> VerificationKey keyrole
deterministicSigningKey :: Key keyrole => AsType keyrole -> Seed -> SigningKey keyrole
deterministicSigningKeySeedSize :: Key keyrole => AsType keyrole -> Word
verificationKeyHash :: Key keyrole => VerificationKey keyrole -> Hash keyrole
data () => Block era
[ByronBlock] :: ByronBlock -> Block ByronEra
[ShelleyBlock] :: forall era. ShelleyBasedEra era -> ShelleyBlock (ConsensusProtocol era) (ShelleyLedgerEra era) -> Block era

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   • Couldn't match type ‘IO’ with ‘StateT s IO’
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a
newtype () => File content (direction :: FileDirection)
File :: FilePath -> File content (direction :: FileDirection)
[unFile] :: File content (direction :: FileDirection) -> FilePath

-- | A monad transformer that adds exceptions to other monads.
--   
--   <tt>ExceptT</tt> constructs a monad parameterized over two things:
--   
--   <ul>
--   <li>e - The exception type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a computation that produces the
--   given value, while <tt>&gt;&gt;=</tt> sequences two subcomputations,
--   exiting on the first exception.
newtype () => ExceptT e (m :: Type -> Type) a
ExceptT :: m (Either e a) -> ExceptT e (m :: Type -> Type) a

-- | The parameterizable exception monad.
--   
--   Computations are either exceptions or normal values.
--   
--   The <a>return</a> function returns a normal value, while
--   <tt>&gt;&gt;=</tt> exits on the first exception. For a variant that
--   continues after an error and collects all the errors, see
--   <a>Errors</a>.
type Except e = ExceptT e Identity

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <tt>Error</tt> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | A handler function to handle previous errors and return to normal
--   execution. A common idiom is:
--   
--   <pre>
--   do { action1; action2; action3 } `catchError` handler
--   </pre>
--   
--   where the <tt>action</tt> functions can call <a>throwError</a>. Note
--   that <tt>handler</tt> and the do-block must have the same return type.
catchError :: MonadError e m => m a -> (e -> m a) -> m a

-- | The class of monad transformers. For any monad <tt>m</tt>, the result
--   <tt>t m</tt> should also be a monad, and <a>lift</a> should be a monad
--   transformation from <tt>m</tt> to <tt>t m</tt>, i.e. it should satisfy
--   the following laws:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
--   
--   Since 0.6.0.0 and for GHC 8.6 and later, the requirement that <tt>t
--   m</tt> be a <a>Monad</a> is enforced by the implication constraint
--   <tt>forall m. <a>Monad</a> m =&gt; <a>Monad</a> (t m)</tt> enabled by
--   the <tt>QuantifiedConstraints</tt> extension.
--   
--   <h3><b>Ambiguity error with GHC 9.0 to 9.2.2</b></h3>
--   
--   These versions of GHC have a bug
--   (<a>https://gitlab.haskell.org/ghc/ghc/-/issues/20582</a>) which
--   causes constraints like
--   
--   <pre>
--   (MonadTrans t, forall m. Monad m =&gt; Monad (t m)) =&gt; ...
--   </pre>
--   
--   to be reported as ambiguous. For transformers 0.6 and later, this can
--   be fixed by removing the second constraint, which is implied by the
--   first.
class forall (m :: Type -> Type). Monad m => Monad t m => MonadTrans (t :: Type -> Type -> Type -> Type)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a
class () => Error e
prettyError :: Error e => e -> Doc ann
data () => Doc ann
data () => ReferenceScript era
[ReferenceScript] :: forall era. BabbageEraOnwards era -> ScriptInAnyLang -> ReferenceScript era
[ReferenceScriptNone] :: forall era. ReferenceScript era
newtype () => LedgerProtocolParameters era
LedgerProtocolParameters :: PParams (ShelleyLedgerEra era) -> LedgerProtocolParameters era
[unLedgerProtocolParameters] :: LedgerProtocolParameters era -> PParams (ShelleyLedgerEra era)
data () => AddressInEra era
[AddressInEra] :: forall addrtype era. AddressTypeInEra addrtype era -> Address addrtype -> AddressInEra era
data () => AddressTypeInEra addrtype era
[ByronAddressInAnyEra] :: forall era. AddressTypeInEra ByronAddr era
[ShelleyAddressInEra] :: forall era. ShelleyBasedEra era -> AddressTypeInEra ShelleyAddr era
data () => BalancedTxBody era
BalancedTxBody :: TxBodyContent BuildTx era -> TxBody era -> TxOut CtxTx era -> Coin -> BalancedTxBody era
data () => KeyWitness era
[ShelleyBootstrapWitness] :: forall era. ShelleyBasedEra era -> BootstrapWitness -> KeyWitness era
[ShelleyKeyWitness] :: forall era. ShelleyBasedEra era -> WitVKey 'Witness -> KeyWitness era
data () => PlutusScript lang
[PlutusScriptSerialised] :: forall lang. ShortByteString -> PlutusScript lang
data () => Script lang
[SimpleScript] :: !SimpleScript -> Script SimpleScript'
[PlutusScript] :: forall lang. IsPlutusScriptLanguage lang => !PlutusScriptVersion lang -> !PlutusScript lang -> Script lang
data () => ScriptInEra era
[ScriptInEra] :: forall lang era. ScriptLanguageInEra lang era -> Script lang -> ScriptInEra era
data () => ScriptLanguage lang
[SimpleScriptLanguage] :: ScriptLanguage SimpleScript'
[PlutusScriptLanguage] :: forall lang. IsPlutusScriptLanguage lang => PlutusScriptVersion lang -> ScriptLanguage lang
data () => ScriptWitness witctx era
[SimpleScriptWitness] :: forall era witctx. ScriptLanguageInEra SimpleScript' era -> SimpleScriptOrReferenceInput SimpleScript' -> ScriptWitness witctx era
[PlutusScriptWitness] :: forall lang era witctx. IsPlutusScriptLanguage lang => ScriptLanguageInEra lang era -> PlutusScriptVersion lang -> PlutusScriptOrReferenceInput lang -> ScriptDatum witctx -> ScriptRedeemer -> ExecutionUnits -> ScriptWitness witctx era
data () => Tx era
[ShelleyTx] :: forall era. ShelleyBasedEra era -> Tx (ShelleyLedgerEra era) -> Tx era
pattern Tx :: TxBody era -> [KeyWitness era] -> Tx era
data () => TxAuxScripts era
[TxAuxScriptsNone] :: forall era. TxAuxScripts era
[TxAuxScripts] :: forall era. AllegraEraOnwards era -> [ScriptInEra era] -> TxAuxScripts era
data () => TxBody era
[ShelleyTxBody] :: forall era. ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> [Script (ShelleyLedgerEra era)] -> TxBodyScriptData era -> Maybe (TxAuxData (ShelleyLedgerEra era)) -> TxScriptValidity era -> TxBody era
pattern TxBody :: TxBodyContent ViewTx era -> TxBody era
data () => TxBodyContent build era
TxBodyContent :: TxIns build era -> TxInsCollateral era -> TxInsReference build era -> [TxOut CtxTx era] -> TxTotalCollateral era -> TxReturnCollateral CtxTx era -> TxFee era -> TxValidityLowerBound era -> TxValidityUpperBound era -> TxMetadataInEra era -> TxAuxScripts era -> TxExtraKeyWitnesses era -> BuildTxWith build (Maybe (LedgerProtocolParameters era)) -> TxWithdrawals build era -> TxCertificates build era -> TxUpdateProposal era -> TxMintValue build era -> TxScriptValidity era -> Maybe (Featured ConwayEraOnwards era (TxProposalProcedures build era)) -> Maybe (Featured ConwayEraOnwards era (TxVotingProcedures build era)) -> Maybe (Featured ConwayEraOnwards era (Maybe Coin)) -> Maybe (Featured ConwayEraOnwards era Coin) -> TxBodyContent build era
[txIns] :: TxBodyContent build era -> TxIns build era
[txInsCollateral] :: TxBodyContent build era -> TxInsCollateral era
[txInsReference] :: TxBodyContent build era -> TxInsReference build era
[txOuts] :: TxBodyContent build era -> [TxOut CtxTx era]
[txTotalCollateral] :: TxBodyContent build era -> TxTotalCollateral era
[txReturnCollateral] :: TxBodyContent build era -> TxReturnCollateral CtxTx era
[txFee] :: TxBodyContent build era -> TxFee era
[txValidityLowerBound] :: TxBodyContent build era -> TxValidityLowerBound era
[txValidityUpperBound] :: TxBodyContent build era -> TxValidityUpperBound era
[txMetadata] :: TxBodyContent build era -> TxMetadataInEra era
[txAuxScripts] :: TxBodyContent build era -> TxAuxScripts era
[txExtraKeyWits] :: TxBodyContent build era -> TxExtraKeyWitnesses era
[txProtocolParams] :: TxBodyContent build era -> BuildTxWith build (Maybe (LedgerProtocolParameters era))
[txWithdrawals] :: TxBodyContent build era -> TxWithdrawals build era
[txCertificates] :: TxBodyContent build era -> TxCertificates build era
[txUpdateProposal] :: TxBodyContent build era -> TxUpdateProposal era
[txMintValue] :: TxBodyContent build era -> TxMintValue build era
[txScriptValidity] :: TxBodyContent build era -> TxScriptValidity era
[txProposalProcedures] :: TxBodyContent build era -> Maybe (Featured ConwayEraOnwards era (TxProposalProcedures build era))
[txVotingProcedures] :: TxBodyContent build era -> Maybe (Featured ConwayEraOnwards era (TxVotingProcedures build era))
[txCurrentTreasuryValue] :: TxBodyContent build era -> Maybe (Featured ConwayEraOnwards era (Maybe Coin))
[txTreasuryDonation] :: TxBodyContent build era -> Maybe (Featured ConwayEraOnwards era Coin)
data () => TxBodyScriptData era
[TxBodyNoScriptData] :: forall era. TxBodyScriptData era
[TxBodyScriptData] :: forall era. AlonzoEraOnwardsConstraints era => AlonzoEraOnwards era -> TxDats (ShelleyLedgerEra era) -> Redeemers (ShelleyLedgerEra era) -> TxBodyScriptData era
data () => TxExtraKeyWitnesses era
[TxExtraKeyWitnessesNone] :: forall era. TxExtraKeyWitnesses era
[TxExtraKeyWitnesses] :: forall era. AlonzoEraOnwards era -> [Hash PaymentKey] -> TxExtraKeyWitnesses era
data () => TxFee era
[TxFeeExplicit] :: forall era. ShelleyBasedEra era -> Coin -> TxFee era
type TxIns build era = [(TxIn, BuildTxWith build Witness WitCtxTxIn era)]
data () => TxInsCollateral era
[TxInsCollateralNone] :: forall era. TxInsCollateral era
[TxInsCollateral] :: forall era. AlonzoEraOnwards era -> [TxIn] -> TxInsCollateral era
data () => TxInsReference build era
[TxInsReferenceNone] :: forall build era. TxInsReference build era
[TxInsReference] :: forall era build. BabbageEraOnwards era -> [TxIn] -> TxInsReferenceDatums build -> TxInsReference build era
data () => TxMetadataInEra era
[TxMetadataNone] :: forall era. TxMetadataInEra era
[TxMetadataInEra] :: forall era. ShelleyBasedEra era -> TxMetadata -> TxMetadataInEra era
data () => TxMintValue build era
[TxMintNone] :: forall build era. TxMintValue build era
[TxMintValue] :: forall era build. MaryEraOnwards era -> Map PolicyId (PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era)) -> TxMintValue build era
data () => TxOut ctx era
TxOut :: AddressInEra era -> TxOutValue era -> TxOutDatum ctx era -> ReferenceScript era -> TxOut ctx era
data () => TxOutDatum ctx era
[TxOutDatumNone] :: forall ctx era. TxOutDatum ctx era
[TxOutDatumHash] :: forall era ctx. AlonzoEraOnwards era -> Hash ScriptData -> TxOutDatum ctx era
[TxOutSupplementalDatum] :: forall era. AlonzoEraOnwards era -> HashableScriptData -> TxOutDatum CtxTx era
[TxOutDatumInline] :: forall era ctx. BabbageEraOnwards era -> HashableScriptData -> TxOutDatum ctx era
data () => TxScriptValidity era
[TxScriptValidityNone] :: forall era. TxScriptValidity era
[TxScriptValidity] :: forall era. AlonzoEraOnwards era -> ScriptValidity -> TxScriptValidity era
data () => TxValidityLowerBound era
[TxValidityNoLowerBound] :: forall era. TxValidityLowerBound era
[TxValidityLowerBound] :: forall era. AllegraEraOnwards era -> SlotNo -> TxValidityLowerBound era
data () => TxValidityUpperBound era
[TxValidityUpperBound] :: forall era. ShelleyBasedEra era -> Maybe SlotNo -> TxValidityUpperBound era
data () => Witness witctx era
[KeyWitness] :: forall witctx era. KeyWitnessInCtx witctx -> Witness witctx era
[ScriptWitness] :: forall witctx era. ScriptWitnessInCtx witctx -> ScriptWitness witctx era -> Witness witctx era
data () => AcquiringFailure
AFPointTooOld :: AcquiringFailure
AFPointNotOnChain :: AcquiringFailure
data family Hash keyrole
data () => PlutusScriptOrReferenceInput lang
PScript :: PlutusScript lang -> PlutusScriptOrReferenceInput lang
PReferenceScript :: TxIn -> PlutusScriptOrReferenceInput lang
type PoolId = Hash StakePoolKey
data () => ShelleyGenesis
ShelleyGenesis :: !UTCTime -> !Word32 -> !Network -> !PositiveUnitInterval -> !NonZero Word64 -> !EpochSize -> !Word64 -> !Word64 -> !NominalDiffTimeMicro -> !Word64 -> !Word64 -> !PParams ShelleyEra -> !Map (KeyHash 'Genesis) GenDelegPair -> ListMap Addr Coin -> ShelleyGenesisStaking -> ShelleyGenesis
[sgSystemStart] :: ShelleyGenesis -> !UTCTime
[sgNetworkMagic] :: ShelleyGenesis -> !Word32
[sgNetworkId] :: ShelleyGenesis -> !Network
[sgActiveSlotsCoeff] :: ShelleyGenesis -> !PositiveUnitInterval
[sgSecurityParam] :: ShelleyGenesis -> !NonZero Word64
[sgEpochLength] :: ShelleyGenesis -> !EpochSize
[sgSlotsPerKESPeriod] :: ShelleyGenesis -> !Word64
[sgMaxKESEvolutions] :: ShelleyGenesis -> !Word64
[sgSlotLength] :: ShelleyGenesis -> !NominalDiffTimeMicro
[sgUpdateQuorum] :: ShelleyGenesis -> !Word64
[sgMaxLovelaceSupply] :: ShelleyGenesis -> !Word64
[sgProtocolParams] :: ShelleyGenesis -> !PParams ShelleyEra
[sgGenDelegs] :: ShelleyGenesis -> !Map (KeyHash 'Genesis) GenDelegPair
[sgInitialFunds] :: ShelleyGenesis -> ListMap Addr Coin
[sgStaking] :: ShelleyGenesis -> ShelleyGenesisStaking
type family ShelleyLedgerEra era = (ledgerera :: Type) | ledgerera -> era
data family SigningKey keyrole
data () => StakeCredential
StakeCredentialByKey :: Hash StakeKey -> StakeCredential
StakeCredentialByScript :: ScriptHash -> StakeCredential
data family VerificationKey keyrole
data () => Address addrtype
[ByronAddress] :: Address -> Address ByronAddr
[ShelleyAddress] :: Network -> PaymentCredential -> StakeReference -> Address ShelleyAddr
data () => BlockHeader
BlockHeader :: !SlotNo -> !Hash BlockHeader -> !BlockNo -> BlockHeader
data () => ChainPoint
ChainPointAtGenesis :: ChainPoint
ChainPoint :: !SlotNo -> !Hash BlockHeader -> ChainPoint
data () => ExecutionUnits
ExecutionUnits :: Natural -> Natural -> ExecutionUnits
[executionSteps] :: ExecutionUnits -> Natural
[executionMemory] :: ExecutionUnits -> Natural
data () => NetworkId
Mainnet :: NetworkId
Testnet :: !NetworkMagic -> NetworkId
newtype () => NetworkMagic
NetworkMagic :: Word32 -> NetworkMagic
[unNetworkMagic] :: NetworkMagic -> Word32
newtype () => PolicyAssets
PolicyAssets :: Map AssetName Quantity -> PolicyAssets
newtype () => PolicyId
PolicyId :: ScriptHash -> PolicyId
[unPolicyId] :: PolicyId -> ScriptHash
data () => ScriptData
ScriptDataConstructor :: Integer -> [ScriptData] -> ScriptData
ScriptDataMap :: [(ScriptData, ScriptData)] -> ScriptData
ScriptDataList :: [ScriptData] -> ScriptData
ScriptDataNumber :: Integer -> ScriptData
ScriptDataBytes :: ByteString -> ScriptData
data () => ScriptDatum witctx
[ScriptDatumForTxIn] :: Maybe HashableScriptData -> ScriptDatum WitCtxTxIn
[InlineScriptDatum] :: ScriptDatum WitCtxTxIn
[NoScriptDatumForMint] :: ScriptDatum WitCtxMint
[NoScriptDatumForStake] :: ScriptDatum WitCtxStake
newtype () => ScriptHash
ScriptHash :: ScriptHash -> ScriptHash
data () => StakeAddress
[StakeAddress] :: Network -> StakeCredential -> StakeAddress
newtype () => TxId
TxId :: Hash HASH EraIndependentTxBody -> TxId
data () => TxIn
TxIn :: TxId -> TxIx -> TxIn
data () => TxOutValue era
[TxOutValueByron] :: Coin -> TxOutValue ByronEra
[TxOutValueShelleyBased] :: forall era. (Eq (Value (ShelleyLedgerEra era)), Show (Value (ShelleyLedgerEra era))) => ShelleyBasedEra era -> Value (ShelleyLedgerEra era) -> TxOutValue era
data () => Value
data () => ByronAddr
class () => FromJSON a
class () => ToJSON a
class Typeable a => FromCBOR a
class Typeable a => ToCBOR a
data () => ConwayEra
data () => CtxUTxO
data () => AddressAny
AddressByron :: !Address ByronAddr -> AddressAny
AddressShelley :: !Address ShelleyAddr -> AddressAny
data () => PaymentCredential
PaymentCredentialByKey :: Hash PaymentKey -> PaymentCredential
PaymentCredentialByScript :: ScriptHash -> PaymentCredential
class HasTypeProxy addr => SerialiseAddress addr
serialiseAddress :: SerialiseAddress addr => addr -> Text
deserialiseAddress :: SerialiseAddress addr => AsType addr -> Text -> Maybe addr
data () => ShelleyAddr
newtype () => StakeAddressPointer
StakeAddressPointer :: Ptr -> StakeAddressPointer
[unStakeAddressPointer] :: StakeAddressPointer -> Ptr
data () => StakeAddressReference
StakeAddressByValue :: StakeCredential -> StakeAddressReference
StakeAddressByPointer :: StakeAddressPointer -> StakeAddressReference
NoStakeAddress :: StakeAddressReference
newtype () => AnchorDataHash
AnchorDataHash :: SafeHash AnchorData -> AnchorDataHash
[unAnchorDataHash] :: AnchorDataHash -> SafeHash AnchorData
newtype () => AnchorUrl
AnchorUrl :: Url -> AnchorUrl
[unAnchorUrl] :: AnchorUrl -> Url
data () => BlockInMode
[BlockInMode] :: forall era. CardanoEra era -> Block era -> BlockInMode
data () => ChainTip
ChainTipAtGenesis :: ChainTip
ChainTip :: !SlotNo -> !Hash BlockHeader -> !BlockNo -> ChainTip
class (SerialiseAsRawBytes a, HasTypeProxy a) => Cip129 a
cip129Bech32PrefixFor :: Cip129 a => AsType a -> HumanReadablePart
cip129HeaderHexByte :: Cip129 a => a -> ByteString
cip129Bech32PrefixesPermitted :: Cip129 a => AsType a -> [Text]
data () => AnchorDataFromCertificateError
InvalidPoolMetadataHashError :: Url -> ByteString -> AnchorDataFromCertificateError
data () => Certificate era
[ShelleyRelatedCertificate] :: forall era. Typeable era => ShelleyToBabbageEra era -> ShelleyTxCert (ShelleyLedgerEra era) -> Certificate era
[ConwayCertificate] :: forall era. Typeable era => ConwayEraOnwards era -> ConwayTxCert (ShelleyLedgerEra era) -> Certificate era
data () => CommitteeColdkeyResignationRequirements era
[CommitteeColdkeyResignationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'ColdCommitteeRole -> Maybe Anchor -> CommitteeColdkeyResignationRequirements era
data () => CommitteeHotKeyAuthorizationRequirements era
[CommitteeHotKeyAuthorizationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'ColdCommitteeRole -> Credential 'HotCommitteeRole -> CommitteeHotKeyAuthorizationRequirements era
data () => DRepMetadataReference
DRepMetadataReference :: Text -> Hash DRepMetadata -> DRepMetadataReference
data () => DRepRegistrationRequirements era
[DRepRegistrationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'DRepRole -> Coin -> DRepRegistrationRequirements era
data () => DRepUnregistrationRequirements era
[DRepUnregistrationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'DRepRole -> Coin -> DRepUnregistrationRequirements era
data () => DRepUpdateRequirements era
[DRepUpdateRequirements] :: forall era. ConwayEraOnwards era -> Credential 'DRepRole -> DRepUpdateRequirements era
data () => GenesisKeyDelegationRequirements era
[GenesisKeyDelegationRequirements] :: forall era. ShelleyToBabbageEra era -> Hash GenesisKey -> Hash GenesisDelegateKey -> Hash VrfKey -> GenesisKeyDelegationRequirements era
data () => MirCertificateRequirements era
[MirCertificateRequirements] :: forall era. ShelleyToBabbageEra era -> MIRPot -> MIRTarget -> MirCertificateRequirements era
data () => StakeAddressRequirements era
[StakeAddrRegistrationConway] :: forall era. ConwayEraOnwards era -> Coin -> StakeCredential -> StakeAddressRequirements era
[StakeAddrRegistrationPreConway] :: forall era. ShelleyToBabbageEra era -> StakeCredential -> StakeAddressRequirements era
data () => StakeDelegationRequirements era
[StakeDelegationRequirementsConwayOnwards] :: forall era. ConwayEraOnwards era -> StakeCredential -> Delegatee -> StakeDelegationRequirements era
[StakeDelegationRequirementsPreConway] :: forall era. ShelleyToBabbageEra era -> StakeCredential -> PoolId -> StakeDelegationRequirements era
data () => StakePoolMetadataReference
StakePoolMetadataReference :: Text -> Hash StakePoolMetadata -> StakePoolMetadataReference
[stakePoolMetadataURL] :: StakePoolMetadataReference -> Text
[stakePoolMetadataHash] :: StakePoolMetadataReference -> Hash StakePoolMetadata
data () => StakePoolParameters
StakePoolParameters :: PoolId -> Hash VrfKey -> Coin -> Rational -> StakeAddress -> Coin -> [Hash StakeKey] -> [StakePoolRelay] -> Maybe StakePoolMetadataReference -> StakePoolParameters
[stakePoolId] :: StakePoolParameters -> PoolId
[stakePoolVRF] :: StakePoolParameters -> Hash VrfKey
[stakePoolCost] :: StakePoolParameters -> Coin
[stakePoolMargin] :: StakePoolParameters -> Rational
[stakePoolRewardAccount] :: StakePoolParameters -> StakeAddress
[stakePoolPledge] :: StakePoolParameters -> Coin
[stakePoolOwners] :: StakePoolParameters -> [Hash StakeKey]
[stakePoolRelays] :: StakePoolParameters -> [StakePoolRelay]
[stakePoolMetadata] :: StakePoolParameters -> Maybe StakePoolMetadataReference
data () => StakePoolRegistrationRequirements era
[StakePoolRegistrationRequirementsConwayOnwards] :: forall era. ConwayEraOnwards era -> PoolParams -> StakePoolRegistrationRequirements era
[StakePoolRegistrationRequirementsPreConway] :: forall era. ShelleyToBabbageEra era -> PoolParams -> StakePoolRegistrationRequirements era
data () => StakePoolRelay
StakePoolRelayIp :: Maybe IPv4 -> Maybe IPv6 -> Maybe PortNumber -> StakePoolRelay
StakePoolRelayDnsARecord :: ByteString -> Maybe PortNumber -> StakePoolRelay
StakePoolRelayDnsSrvRecord :: ByteString -> StakePoolRelay
data () => StakePoolRetirementRequirements era
[StakePoolRetirementRequirementsConwayOnwards] :: forall era. ConwayEraOnwards era -> PoolId -> EpochNo -> StakePoolRetirementRequirements era
[StakePoolRetirementRequirementsPreConway] :: forall era. ShelleyToBabbageEra era -> PoolId -> EpochNo -> StakePoolRetirementRequirements era
newtype () => ScriptLockedTxInsError
ScriptLockedTxIns :: [TxIn] -> ScriptLockedTxInsError
data () => TxInsExistError
TxInsDoNotExist :: [TxIn] -> TxInsExistError
EmptyUTxO :: TxInsExistError
data () => QueryConvenienceError
AcqFailure :: AcquiringFailure -> QueryConvenienceError
QueryEraMismatch :: EraMismatch -> QueryConvenienceError
ByronEraNotSupported :: QueryConvenienceError
QceUnsupportedNtcVersion :: !UnsupportedNtcVersionError -> QueryConvenienceError
QceUnexpectedException :: !SomeException -> QueryConvenienceError
newtype () => TxCurrentTreasuryValue
TxCurrentTreasuryValue :: Coin -> TxCurrentTreasuryValue
[unTxCurrentTreasuryValue] :: TxCurrentTreasuryValue -> Coin
newtype () => DRepMetadata
DRepMetadata :: ByteString -> DRepMetadata
data () => InputDecodeError
InputTextEnvelopeError :: !TextEnvelopeError -> InputDecodeError
InputBech32DecodeError :: !Bech32DecodeError -> InputDecodeError
InputInvalidError :: InputDecodeError
data () => InputFormat a
[InputFormatBech32] :: forall a. SerialiseAsBech32 a => InputFormat a
[InputFormatHex] :: forall a. SerialiseAsRawBytes a => InputFormat a
[InputFormatTextEnvelope] :: forall a. HasTextEnvelope a => InputFormat a
data () => SomeAddressVerificationKey
AByronVerificationKey :: VerificationKey ByronKey -> SomeAddressVerificationKey
APaymentVerificationKey :: VerificationKey PaymentKey -> SomeAddressVerificationKey
APaymentExtendedVerificationKey :: VerificationKey PaymentExtendedKey -> SomeAddressVerificationKey
AGenesisUTxOVerificationKey :: VerificationKey GenesisUTxOKey -> SomeAddressVerificationKey
AGenesisExtendedVerificationKey :: VerificationKey GenesisExtendedKey -> SomeAddressVerificationKey
AGenesisDelegateExtendedVerificationKey :: VerificationKey GenesisDelegateExtendedKey -> SomeAddressVerificationKey
AKesVerificationKey :: VerificationKey KesKey -> SomeAddressVerificationKey
AVrfVerificationKey :: VerificationKey VrfKey -> SomeAddressVerificationKey
AStakeVerificationKey :: VerificationKey StakeKey -> SomeAddressVerificationKey
AStakeExtendedVerificationKey :: VerificationKey StakeExtendedKey -> SomeAddressVerificationKey
AStakePoolVerificationKey :: VerificationKey StakePoolKey -> SomeAddressVerificationKey
AStakePoolExtendedVerificationKey :: VerificationKey StakePoolExtendedKey -> SomeAddressVerificationKey
ADRepVerificationKey :: VerificationKey DRepKey -> SomeAddressVerificationKey
ADRepExtendedVerificationKey :: VerificationKey DRepExtendedKey -> SomeAddressVerificationKey
ACommitteeColdVerificationKey :: VerificationKey CommitteeColdKey -> SomeAddressVerificationKey
ACommitteeColdExtendedVerificationKey :: VerificationKey CommitteeColdExtendedKey -> SomeAddressVerificationKey
ACommitteeHotVerificationKey :: VerificationKey CommitteeHotKey -> SomeAddressVerificationKey
ACommitteeHotExtendedVerificationKey :: VerificationKey CommitteeHotExtendedKey -> SomeAddressVerificationKey
data () => AllegraEraOnwards era
[AllegraEraOnwardsAllegra] :: AllegraEraOnwards AllegraEra
[AllegraEraOnwardsMary] :: AllegraEraOnwards MaryEra
[AllegraEraOnwardsAlonzo] :: AllegraEraOnwards AlonzoEra
[AllegraEraOnwardsBabbage] :: AllegraEraOnwards BabbageEra
[AllegraEraOnwardsConway] :: AllegraEraOnwards ConwayEra
class IsShelleyBasedEra era => IsAllegraBasedEra era
allegraBasedEra :: IsAllegraBasedEra era => AllegraEraOnwards era
data () => AlonzoEraOnwards era
[AlonzoEraOnwardsAlonzo] :: AlonzoEraOnwards AlonzoEra
[AlonzoEraOnwardsBabbage] :: AlonzoEraOnwards BabbageEra
[AlonzoEraOnwardsConway] :: AlonzoEraOnwards ConwayEra
type AlonzoEraOnwardsConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, AlonzoEraPParams ShelleyLedgerEra era, AlonzoEraTx ShelleyLedgerEra era, AlonzoEraTxBody ShelleyLedgerEra era, AlonzoEraTxOut ShelleyLedgerEra era, AlonzoEraTxWits ShelleyLedgerEra era, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, EraUTxO ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, MaryEraTxBody ShelleyLedgerEra era, NativeScript ShelleyLedgerEra era ~ Timelock ShelleyLedgerEra era, EraPlutusContext ShelleyLedgerEra era, Script ShelleyLedgerEra era ~ AlonzoScript ShelleyLedgerEra era, ScriptsNeeded ShelleyLedgerEra era ~ AlonzoScriptsNeeded ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, Value ShelleyLedgerEra era ~ MaryValue, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
class IsMaryBasedEra era => IsAlonzoBasedEra era
alonzoBasedEra :: IsAlonzoBasedEra era => AlonzoEraOnwards era
data () => BabbageEraOnwards era
[BabbageEraOnwardsBabbage] :: BabbageEraOnwards BabbageEra
[BabbageEraOnwardsConway] :: BabbageEraOnwards ConwayEra
class IsAlonzoBasedEra era => IsBabbageBasedEra era
babbageBasedEra :: IsBabbageBasedEra era => BabbageEraOnwards era
data () => ByronToAlonzoEra era
[ByronToAlonzoEraByron] :: ByronToAlonzoEra ByronEra
[ByronToAlonzoEraShelley] :: ByronToAlonzoEra ShelleyEra
[ByronToAlonzoEraAllegra] :: ByronToAlonzoEra AllegraEra
[ByronToAlonzoEraMary] :: ByronToAlonzoEra MaryEra
[ByronToAlonzoEraAlonzo] :: ByronToAlonzoEra AlonzoEra
class () => Convert (f :: a -> Type) (g :: a -> Type)
convert :: forall (era :: a). Convert f g => f era -> g era
data () => ConwayEraOnwards era
[ConwayEraOnwardsConway] :: ConwayEraOnwards ConwayEra
class IsBabbageBasedEra era => IsConwayBasedEra era
conwayBasedEra :: IsConwayBasedEra era => ConwayEraOnwards era
class IsAllegraBasedEra era => IsMaryBasedEra era
maryBasedEra :: IsMaryBasedEra era => MaryEraOnwards era
data () => MaryEraOnwards era
[MaryEraOnwardsMary] :: MaryEraOnwards MaryEra
[MaryEraOnwardsAlonzo] :: MaryEraOnwards AlonzoEra
[MaryEraOnwardsBabbage] :: MaryEraOnwards BabbageEra
[MaryEraOnwardsConway] :: MaryEraOnwards ConwayEra
data () => AnyShelleyBasedEra
[AnyShelleyBasedEra] :: forall era. Typeable era => ShelleyBasedEra era -> AnyShelleyBasedEra
data () => InAnyShelleyBasedEra (thing :: Type -> Type)
[InAnyShelleyBasedEra] :: forall era (thing :: Type -> Type). Typeable era => ShelleyBasedEra era -> thing era -> InAnyShelleyBasedEra thing
class IsCardanoEra era => IsShelleyBasedEra era
shelleyBasedEra :: IsShelleyBasedEra era => ShelleyBasedEra era
data () => ShelleyBasedEra era
[ShelleyBasedEraShelley] :: ShelleyBasedEra ShelleyEra
[ShelleyBasedEraAllegra] :: ShelleyBasedEra AllegraEra
[ShelleyBasedEraMary] :: ShelleyBasedEra MaryEra
[ShelleyBasedEraAlonzo] :: ShelleyBasedEra AlonzoEra
[ShelleyBasedEraBabbage] :: ShelleyBasedEra BabbageEra
[ShelleyBasedEraConway] :: ShelleyBasedEra ConwayEra
data () => ShelleyEraOnly era
[ShelleyEraOnlyShelley] :: ShelleyEraOnly ShelleyEra
data () => ShelleyToAllegraEra era
[ShelleyToAllegraEraShelley] :: ShelleyToAllegraEra ShelleyEra
[ShelleyToAllegraEraAllegra] :: ShelleyToAllegraEra AllegraEra
data () => ShelleyToAlonzoEra era
[ShelleyToAlonzoEraShelley] :: ShelleyToAlonzoEra ShelleyEra
[ShelleyToAlonzoEraAllegra] :: ShelleyToAlonzoEra AllegraEra
[ShelleyToAlonzoEraMary] :: ShelleyToAlonzoEra MaryEra
[ShelleyToAlonzoEraAlonzo] :: ShelleyToAlonzoEra AlonzoEra
data () => ShelleyToBabbageEra era
[ShelleyToBabbageEraShelley] :: ShelleyToBabbageEra ShelleyEra
[ShelleyToBabbageEraAllegra] :: ShelleyToBabbageEra AllegraEra
[ShelleyToBabbageEraMary] :: ShelleyToBabbageEra MaryEra
[ShelleyToBabbageEraAlonzo] :: ShelleyToBabbageEra AlonzoEra
[ShelleyToBabbageEraBabbage] :: ShelleyToBabbageEra BabbageEra
data () => ShelleyToMaryEra era
[ShelleyToMaryEraShelley] :: ShelleyToMaryEra ShelleyEra
[ShelleyToMaryEraAllegra] :: ShelleyToMaryEra AllegraEra
[ShelleyToMaryEraMary] :: ShelleyToMaryEra MaryEra
data () => AllegraEra
data () => AlonzoEra
data () => AnyCardanoEra
[AnyCardanoEra] :: forall era. Typeable era => CardanoEra era -> AnyCardanoEra
data () => BabbageEra
data () => ByronEra
data () => CardanoEra era
[ByronEra] :: CardanoEra ByronEra
[ShelleyEra] :: CardanoEra ShelleyEra
[AllegraEra] :: CardanoEra AllegraEra
[MaryEra] :: CardanoEra MaryEra
[AlonzoEra] :: CardanoEra AlonzoEra
[BabbageEra] :: CardanoEra BabbageEra
[ConwayEra] :: CardanoEra ConwayEra
class () => Eon (eon :: Type -> Type)
inEonForEra :: Eon eon => a -> (eon era -> a) -> CardanoEra era -> a
data () => EraInEon (eon :: Type -> Type)
[EraInEon] :: forall era (eon :: Type -> Type). (Typeable era, Typeable (eon era), Eon eon) => eon era -> EraInEon eon
data () => InAnyCardanoEra (thing :: Type -> Type)
[InAnyCardanoEra] :: forall era (thing :: Type -> Type). Typeable era => CardanoEra era -> thing era -> InAnyCardanoEra thing
class HasTypeProxy era => IsCardanoEra era
cardanoEra :: IsCardanoEra era => CardanoEra era
data () => MaryEra
data () => ShelleyEra
class () => ToCardanoEra (eon :: Type -> Type)
toCardanoEra :: ToCardanoEra eon => eon era -> CardanoEra era
data () => FileError e
FileError :: FilePath -> e -> FileError e
FileErrorTempFile :: FilePath -> FilePath -> Handle -> FileError e
FileDoesNotExistError :: FilePath -> FileError e
FileIOError :: FilePath -> IOException -> FileError e
data () => Featured (eon :: Type -> Type) era a
[Featured] :: forall (eon :: Type -> Type) era a. eon era -> a -> Featured eon era a
data () => AutoBalanceError era
AutoBalanceEstimationError :: TxFeeEstimationError era -> AutoBalanceError era
AutoBalanceCalculationError :: TxBodyErrorAutoBalance era -> AutoBalanceError era
data () => FeeEstimationMode era
CalculateWithSpendableUTxO :: UTxO era -> SystemStart -> LedgerEpochInfo -> Maybe Word -> FeeEstimationMode era
EstimateWithoutSpendableUTxO :: Coin -> Value -> Map ScriptWitnessIndex ExecutionUnits -> RequiredShelleyKeyWitnesses -> RequiredByronKeyWitnesses -> TotalReferenceScriptsSize -> FeeEstimationMode era
newtype () => RequiredByronKeyWitnesses
RequiredByronKeyWitnesses :: Int -> RequiredByronKeyWitnesses
[unRequiredByronKeyWitnesses] :: RequiredByronKeyWitnesses -> Int
newtype () => RequiredShelleyKeyWitnesses
RequiredShelleyKeyWitnesses :: Int -> RequiredShelleyKeyWitnesses
[unRequiredShelleyKeyWitnesses] :: RequiredShelleyKeyWitnesses -> Int
data () => ResolvablePointers
[ResolvablePointers] :: forall era. (Era (ShelleyLedgerEra era), Show (PlutusPurpose AsIx (ShelleyLedgerEra era)), Show (PlutusPurpose AsItem (ShelleyLedgerEra era)), Show (PlutusScript (ShelleyLedgerEra era))) => ShelleyBasedEra era -> !Map (PlutusPurpose AsIx (ShelleyLedgerEra era)) (PlutusPurpose AsItem (ShelleyLedgerEra era), Maybe (PlutusScriptBytes, Language), ScriptHash) -> ResolvablePointers
data () => ScriptExecutionError
ScriptErrorMissingTxIn :: TxIn -> ScriptExecutionError
ScriptErrorTxInWithoutDatum :: TxIn -> ScriptExecutionError
ScriptErrorWrongDatum :: Hash ScriptData -> ScriptExecutionError
ScriptErrorEvaluationFailed :: DebugPlutusFailure -> ScriptExecutionError
ScriptErrorExecutionUnitsOverflow :: ScriptExecutionError
ScriptErrorNotPlutusWitnessedTxIn :: ScriptWitnessIndex -> ScriptHash -> ScriptExecutionError
ScriptErrorRedeemerPointsToUnknownScriptHash :: ScriptWitnessIndex -> ScriptExecutionError
ScriptErrorMissingScript :: ScriptWitnessIndex -> ResolvablePointers -> ScriptExecutionError
ScriptErrorMissingCostModel :: Language -> ScriptExecutionError
ScriptErrorTranslationError :: ContextError (ShelleyLedgerEra era) -> ScriptExecutionError
newtype () => TotalReferenceScriptsSize
TotalReferenceScriptsSize :: Int -> TotalReferenceScriptsSize
[unTotalReferenceScriptsSize] :: TotalReferenceScriptsSize -> Int
data () => TransactionValidityError era
[TransactionValidityIntervalError] :: forall era. PastHorizonException -> TransactionValidityError era
[TransactionValidityCostModelError] :: forall era. Map AnyPlutusScriptVersion CostModel -> String -> TransactionValidityError era
data () => TxBodyError
TxBodyPlutusScriptDecodeError :: DecoderError -> TxBodyError
TxBodyEmptyTxIns :: TxBodyError
TxBodyEmptyTxInsCollateral :: TxBodyError
TxBodyEmptyTxOuts :: TxBodyError
TxBodyOutputError :: !TxOutputError -> TxBodyError
TxBodyMetadataError :: ![(Word64, TxMetadataRangeError)] -> TxBodyError
TxBodyInIxOverflow :: !TxIn -> TxBodyError
TxBodyMissingProtocolParams :: TxBodyError
TxBodyProtocolParamsConversionError :: !ProtocolParametersConversionError -> TxBodyError
data () => TxBodyErrorAutoBalance era
TxBodyError :: TxBodyError -> TxBodyErrorAutoBalance era
TxBodyScriptExecutionError :: [(ScriptWitnessIndex, ScriptExecutionError)] -> TxBodyErrorAutoBalance era
TxBodyScriptBadScriptValidity :: TxBodyErrorAutoBalance era
TxBodyErrorBalanceNegative :: Coin -> MultiAsset -> TxBodyErrorAutoBalance era
TxBodyErrorAdaBalanceTooSmall :: TxOutInAnyEra -> Coin -> Coin -> TxBodyErrorAutoBalance era
TxBodyErrorByronEraNotSupported :: TxBodyErrorAutoBalance era
TxBodyErrorMissingParamMinUTxO :: TxBodyErrorAutoBalance era
TxBodyErrorMinUTxONotMet :: TxOutInAnyEra -> Coin -> TxBodyErrorAutoBalance era
TxBodyErrorNonAdaAssetsUnbalanced :: Value -> TxBodyErrorAutoBalance era
TxBodyErrorScriptWitnessIndexMissingFromExecUnitsMap :: ScriptWitnessIndex -> Map ScriptWitnessIndex ExecutionUnits -> TxBodyErrorAutoBalance era
data () => TxFeeEstimationError era
TxFeeEstimationTransactionTranslationError :: TransactionValidityError era -> TxFeeEstimationError era
TxFeeEstimationScriptExecutionError :: TxBodyErrorAutoBalance era -> TxFeeEstimationError era
TxFeeEstimationBalanceError :: TxBodyErrorAutoBalance era -> TxFeeEstimationError era
TxFeeEstimationxBodyError :: TxBodyError -> TxFeeEstimationError era
TxFeeEstimationFinalConstructionError :: TxBodyError -> TxFeeEstimationError era
TxFeeEstimationOnlyMaryOnwardsSupportedError :: TxFeeEstimationError era
type AlonzoGenesisFile = File AlonzoGenesisConfig
type ByronGenesisFile = File ByronGenesisConfig
type ConwayGenesisFile = File ConwayGenesisConfig
newtype () => GenesisHashAlonzo
GenesisHashAlonzo :: Hash Blake2b_256 ByteString -> GenesisHashAlonzo
[unGenesisHashAlonzo] :: GenesisHashAlonzo -> Hash Blake2b_256 ByteString
newtype () => GenesisHashByron
GenesisHashByron :: Text -> GenesisHashByron
[unGenesisHashByron] :: GenesisHashByron -> Text
newtype () => GenesisHashConway
GenesisHashConway :: Hash Blake2b_256 ByteString -> GenesisHashConway
[unGenesisHashConway] :: GenesisHashConway -> Hash Blake2b_256 ByteString
newtype () => GenesisHashShelley
GenesisHashShelley :: Hash Blake2b_256 ByteString -> GenesisHashShelley
[unGenesisHashShelley] :: GenesisHashShelley -> Hash Blake2b_256 ByteString
data () => ShelleyConfig
ShelleyConfig :: !ShelleyGenesis -> !GenesisHashShelley -> ShelleyConfig
[scConfig] :: ShelleyConfig -> !ShelleyGenesis
[scGenesisHash] :: ShelleyConfig -> !GenesisHashShelley
type ShelleyGenesisFile = File ShelleyGenesisConfig
data () => GenesisParameters era
GenesisParameters :: UTCTime -> NetworkId -> Rational -> NonZero Word64 -> EpochSize -> NominalDiffTime -> Int -> Int -> Int -> Coin -> PParams (ShelleyLedgerEra era) -> GenesisParameters era
[protocolParamSystemStart] :: GenesisParameters era -> UTCTime
[protocolParamNetworkId] :: GenesisParameters era -> NetworkId
[protocolParamActiveSlotsCoefficient] :: GenesisParameters era -> Rational
[protocolParamSecurity] :: GenesisParameters era -> NonZero Word64
[protocolParamEpochLength] :: GenesisParameters era -> EpochSize
[protocolParamSlotLength] :: GenesisParameters era -> NominalDiffTime
[protocolParamSlotsPerKESPeriod] :: GenesisParameters era -> Int
[protocolParamMaxKESEvolutions] :: GenesisParameters era -> Int
[protocolParamUpdateQuorum] :: GenesisParameters era -> Int
[protocolParamMaxLovelaceSupply] :: GenesisParameters era -> Coin
[protocolInitialUpdateableProtocolParameters] :: GenesisParameters era -> PParams (ShelleyLedgerEra era)
data () => CIP119
DrepRegistrationMetadata :: CIP119
data () => CIP108
BaseGovActionMetadata :: CIP108
class Typeable t => HasTypeProxy t where {
    data family AsType t;
}
proxyToAsType :: HasTypeProxy t => Proxy t -> AsType t
data family AsType t
pattern AsByronAddress :: AsType (Address ByronAddr)
pattern AsShelleyAddress :: AsType (Address ShelleyAddr)
pattern AsAllegraTx :: AsType (Tx AllegraEra)
pattern AsAlonzoTx :: AsType (Tx AlonzoEra)
pattern AsByronTxBody :: AsType (TxBody ByronEra)
pattern AsByronWitness :: AsType (KeyWitness ByronEra)
pattern AsMaryTx :: AsType (Tx MaryEra)
pattern AsMaryTxBody :: AsType (TxBody MaryEra)
pattern AsShelleyTxBody :: AsType (TxBody ShelleyEra)
pattern AsShelleyWitness :: AsType (KeyWitness ShelleyEra)
data () => FromSomeType (c :: Type -> Constraint) b
[FromSomeType] :: forall (c :: Type -> Constraint) a b. c a => AsType a -> (a -> b) -> FromSomeType c b
data () => FileDirection
In :: FileDirection
Out :: FileDirection
InOut :: FileDirection
type SocketPath = File Socket 'InOut
data () => LocalChainSyncClient block point tip (m :: Type -> Type)
NoLocalChainSyncClient :: LocalChainSyncClient block point tip (m :: Type -> Type)
LocalChainSyncClientPipelined :: ChainSyncClientPipelined block point tip m () -> LocalChainSyncClient block point tip (m :: Type -> Type)
LocalChainSyncClient :: ChainSyncClient block point tip m () -> LocalChainSyncClient block point tip (m :: Type -> Type)
data () => LocalNodeClientParams
[LocalNodeClientParamsSingleBlock] :: forall block. (ProtocolClient block, LedgerSupportsProtocol (ShelleyBlock (TPraos StandardCrypto) ShelleyEra)) => ProtocolClientInfoArgs block -> (NodeToClientVersion -> LocalNodeClientProtocolsForBlock block) -> LocalNodeClientParams
[LocalNodeClientParamsCardano] :: forall block. (ProtocolClient block, CardanoHardForkConstraints (ConsensusCryptoForBlock block)) => ProtocolClientInfoArgs block -> (NodeToClientVersion -> LocalNodeClientProtocolsForBlock block) -> LocalNodeClientParams
data () => LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type)
LocalNodeClientProtocols :: LocalChainSyncClient block point tip m -> Maybe (LocalTxSubmissionClient tx txerr m ()) -> Maybe (LocalStateQueryClient block point query m ()) -> Maybe (LocalTxMonitorClient txid tx slot m ()) -> LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type)
[localChainSyncClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> LocalChainSyncClient block point tip m
[localTxSubmissionClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> Maybe (LocalTxSubmissionClient tx txerr m ())
[localStateQueryClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> Maybe (LocalStateQueryClient block point query m ())
[localTxMonitoringClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> Maybe (LocalTxMonitorClient txid tx slot m ())
type LocalNodeClientProtocolsInMode = LocalNodeClientProtocols BlockInMode ChainPoint ChainTip SlotNo TxInMode TxIdInMode TxValidationErrorInCardanoMode QueryInMode IO
data () => LocalNodeConnectInfo
LocalNodeConnectInfo :: ConsensusModeParams -> NetworkId -> SocketPath -> LocalNodeConnectInfo
[localConsensusModeParams] :: LocalNodeConnectInfo -> ConsensusModeParams
[localNodeNetworkId] :: LocalNodeConnectInfo -> NetworkId
[localNodeSocketPath] :: LocalNodeConnectInfo -> SocketPath
data () => LocalTxMonitoringQuery
LocalTxMonitoringQueryTx :: TxIdInMode -> LocalTxMonitoringQuery
LocalTxMonitoringSendNextTx :: LocalTxMonitoringQuery
LocalTxMonitoringMempoolInformation :: LocalTxMonitoringQuery
data () => LocalTxMonitoringResult
LocalTxMonitoringTxExists :: TxId -> SlotNo -> LocalTxMonitoringResult
LocalTxMonitoringTxDoesNotExist :: TxId -> SlotNo -> LocalTxMonitoringResult
LocalTxMonitoringNextTx :: Maybe TxInMode -> SlotNo -> LocalTxMonitoringResult
LocalTxMonitoringMempoolSizeAndCapacity :: MempoolSizeAndCapacity -> SlotNo -> LocalTxMonitoringResult
data () => LocalStateQueryExpr block point (query :: Type -> Type) r (m :: Type -> Type) a
data () => UnsupportedNtcVersionError
UnsupportedNtcVersionError :: !NodeToClientVersion -> ![NodeToClientVersion] -> UnsupportedNtcVersionError
data () => TxIdInMode
[TxIdInMode] :: forall era. CardanoEra era -> TxId -> TxIdInMode
data () => TxInMode
[TxInMode] :: forall era. ShelleyBasedEra era -> Tx era -> TxInMode
[TxInByronSpecial] :: GenTx ByronBlock -> TxInMode
data () => TxValidationErrorInCardanoMode
[TxValidationErrorInCardanoMode] :: forall era. TxValidationError era -> TxValidationErrorInCardanoMode
[TxValidationEraMismatch] :: EraMismatch -> TxValidationErrorInCardanoMode
data () => ByronKey
data () => ByronKeyLegacy
data () => MnemonicSize
MS12 :: MnemonicSize
MS15 :: MnemonicSize
MS18 :: MnemonicSize
MS21 :: MnemonicSize
MS24 :: MnemonicSize
data () => MnemonicToSigningKeyError
InvalidMnemonicError :: String -> MnemonicToSigningKeyError
InvalidAccountNumberError :: Word32 -> MnemonicToSigningKeyError
InvalidPaymentKeyNoError :: Word32 -> MnemonicToSigningKeyError
data () => CommitteeColdExtendedKey
data () => CommitteeColdKey
data () => CommitteeHotExtendedKey
data () => CommitteeHotKey
data () => DRepExtendedKey
data () => DRepKey
data () => GenesisDelegateExtendedKey
data () => GenesisDelegateKey
data () => GenesisExtendedKey
data () => GenesisKey
data () => GenesisUTxOKey
data () => PaymentExtendedKey
data () => PaymentKey
data () => StakeExtendedKey
data () => StakeKey
data () => AnyNewEpochState
[AnyNewEpochState] :: forall era. ShelleyBasedEra era -> NewEpochState (ShelleyLedgerEra era) -> LedgerTables (LedgerState (CardanoBlock StandardCrypto)) ValuesMK -> AnyNewEpochState
data () => ConditionResult
ConditionNotMet :: ConditionResult
ConditionMet :: ConditionResult
data () => Env
Env :: CardanoLedgerConfig StandardCrypto -> CardanoConsensusConfig StandardCrypto -> Env
[envLedgerConfig] :: Env -> CardanoLedgerConfig StandardCrypto
[envConsensusConfig] :: Env -> CardanoConsensusConfig StandardCrypto
data () => FoldBlocksError
FoldBlocksInitialLedgerStateError :: !InitialLedgerStateError -> FoldBlocksError
FoldBlocksApplyBlockError :: !LedgerStateError -> FoldBlocksError
FoldBlocksIOException :: !IOException -> FoldBlocksError
FoldBlocksMuxError :: !Error -> FoldBlocksError
data () => FoldStatus
ContinueFold :: FoldStatus
StopFold :: FoldStatus
DebugFold :: FoldStatus
data () => GenesisConfig
GenesisCardano :: !NodeConfig -> !Config -> !GenesisHashShelley -> !TransitionConfig LatestKnownEra -> GenesisConfig
data () => GenesisConfigError
NEError :: !Text -> GenesisConfigError
NEByronConfig :: !FilePath -> !ConfigurationError -> GenesisConfigError
NEShelleyConfig :: !FilePath -> !Text -> GenesisConfigError
NEAlonzoConfig :: !FilePath -> !Text -> GenesisConfigError
NEConwayConfig :: !FilePath -> !Text -> GenesisConfigError
NECardanoConfig :: !Text -> GenesisConfigError
data () => InitialLedgerStateError
ILSEConfigFile :: Text -> InitialLedgerStateError
ILSEGenesisFile :: GenesisConfigError -> InitialLedgerStateError
ILSELedgerConsensusConfig :: GenesisConfigError -> InitialLedgerStateError
data () => LedgerState
LedgerState :: CardanoLedgerState StandardCrypto EmptyMK -> LedgerTables (LedgerState (HardForkBlock (CardanoEras StandardCrypto))) ValuesMK -> LedgerState
[clsState] :: LedgerState -> CardanoLedgerState StandardCrypto EmptyMK
[clsTables] :: LedgerState -> LedgerTables (LedgerState (HardForkBlock (CardanoEras StandardCrypto))) ValuesMK
pattern LedgerStateAllegra :: LedgerState StandardAllegraBlock EmptyMK -> LedgerState
pattern LedgerStateAlonzo :: LedgerState StandardAlonzoBlock EmptyMK -> LedgerState
pattern LedgerStateBabbage :: LedgerState StandardBabbageBlock EmptyMK -> LedgerState
pattern LedgerStateByron :: LedgerState ByronBlock EmptyMK -> LedgerState
pattern LedgerStateConway :: LedgerState StandardConwayBlock EmptyMK -> LedgerState
pattern LedgerStateMary :: LedgerState StandardMaryBlock EmptyMK -> LedgerState
pattern LedgerStateShelley :: LedgerState StandardShelleyBlock EmptyMK -> LedgerState
data () => LedgerStateError
ApplyBlockHashMismatch :: Text -> LedgerStateError
ApplyBlockError :: CardanoLedgerError StandardCrypto -> LedgerStateError
InvalidRollback :: SlotNo -> ChainPoint -> LedgerStateError
TerminationEpochReached :: EpochNo -> LedgerStateError
UnexpectedLedgerState :: AnyShelleyBasedEra -> NS (Current (Flip LedgerState EmptyMK)) (CardanoEras StandardCrypto) -> LedgerStateError
ByronEraUnsupported :: LedgerStateError
DebugError :: !String -> LedgerStateError
data () => NodeConfig
NodeConfig :: !Maybe Double -> !File ByronGenesisConfig 'In -> !GenesisHashByron -> !File ShelleyGenesisConfig 'In -> !GenesisHashShelley -> !File AlonzoGenesis 'In -> !GenesisHashAlonzo -> !Maybe (File ConwayGenesisConfig 'In) -> !Maybe GenesisHashConway -> !RequiresNetworkMagic -> !ProtocolVersion -> !CardanoHardForkTriggers -> NodeConfig
[ncPBftSignatureThreshold] :: NodeConfig -> !Maybe Double
[ncByronGenesisFile] :: NodeConfig -> !File ByronGenesisConfig 'In
[ncByronGenesisHash] :: NodeConfig -> !GenesisHashByron
[ncShelleyGenesisFile] :: NodeConfig -> !File ShelleyGenesisConfig 'In
[ncShelleyGenesisHash] :: NodeConfig -> !GenesisHashShelley
[ncAlonzoGenesisFile] :: NodeConfig -> !File AlonzoGenesis 'In
[ncAlonzoGenesisHash] :: NodeConfig -> !GenesisHashAlonzo
[ncConwayGenesisFile] :: NodeConfig -> !Maybe (File ConwayGenesisConfig 'In)
[ncConwayGenesisHash] :: NodeConfig -> !Maybe GenesisHashConway
[ncRequiresNetworkMagic] :: NodeConfig -> !RequiresNetworkMagic
[ncByronProtocolVersion] :: NodeConfig -> !ProtocolVersion
[ncHardForkTriggers] :: NodeConfig -> !CardanoHardForkTriggers
type NodeConfigFile = File NodeConfig
data () => ValidationMode
FullValidation :: ValidationMode
QuickValidation :: ValidationMode
type family ChainDepStateProtocol era
type family ConsensusBlockForEra era
data () => ConsensusModeParams
[CardanoModeParams] :: EpochSlots -> ConsensusModeParams
type family ConsensusProtocol era
type MonadIOTransError e (t :: Type -> Type -> Type -> Type) (m :: Type -> Type) = (MonadIO m, MonadIO t m, MonadCatch m, MonadTrans t, MonadError e t m)
type MonadTransError e (t :: Type -> Type -> Type -> Type) (m :: Type -> Type) = (Monad m, MonadTrans t, MonadError e t m)
data () => OperationalCertIssueError
OperationalCertKeyMismatch :: VerificationKey StakePoolKey -> VerificationKey StakePoolKey -> OperationalCertIssueError
data () => OperationalCertificate
OperationalCertificate :: !OCert StandardCrypto -> !VerificationKey StakePoolKey -> OperationalCertificate
data () => OperationalCertificateIssueCounter
OperationalCertificateIssueCounter :: !Word64 -> !VerificationKey StakePoolKey -> OperationalCertificateIssueCounter
[opCertIssueCount] :: OperationalCertificateIssueCounter -> !Word64
[opCertIssueColdKey] :: OperationalCertificateIssueCounter -> !VerificationKey StakePoolKey
data () => DebugPlutusFailure
DebugPlutusFailure :: EvaluationError -> PlutusWithContext -> ExUnits -> [Text] -> DebugPlutusFailure
[dpfEvaluationError] :: DebugPlutusFailure -> EvaluationError
[dpfScriptWithContext] :: DebugPlutusFailure -> PlutusWithContext
[dpfExecutionUnits] :: DebugPlutusFailure -> ExUnits
[dpfExecutionLogs] :: DebugPlutusFailure -> [Text]
type Ann = AnsiStyle
data () => BlockType blk
[ByronBlockType] :: BlockType (HardForkBlock '[ByronBlock])
[ShelleyBlockType] :: BlockType (HardForkBlock '[ShelleyBlock (TPraos StandardCrypto) ShelleyEra])
[CardanoBlockType] :: BlockType (HardForkBlock (CardanoEras StandardCrypto))
class (RunNode blk, IOLike m) => Protocol (m :: Type -> Type) blk where {
    data family ProtocolInfoArgs blk;
}
protocolInfo :: Protocol m blk => ProtocolInfoArgs blk -> (ProtocolInfo blk, m [BlockForging m blk])
data family ProtocolInfoArgs blk
data () => SomeBlockType
[SomeBlockType] :: forall blk. BlockType blk -> SomeBlockType
newtype () => CostModel
CostModel :: [Int64] -> CostModel
data () => ExecutionUnitPrices
ExecutionUnitPrices :: Rational -> Rational -> ExecutionUnitPrices
[priceExecutionSteps] :: ExecutionUnitPrices -> Rational
[priceExecutionMemory] :: ExecutionUnitPrices -> Rational
data () => PraosNonce
data () => ProtocolParametersConversionError
PpceOutOfBounds :: !ProtocolParameterName -> !Rational -> ProtocolParametersConversionError
PpceVersionInvalid :: !ProtocolParameterVersion -> ProtocolParametersConversionError
PpceInvalidCostModel :: !CostModel -> !CostModelApplyError -> ProtocolParametersConversionError
PpceMissingParameter :: !ProtocolParameterName -> ProtocolParametersConversionError
data () => ProtocolParametersUpdate
ProtocolParametersUpdate :: Maybe (Natural, Natural) -> Maybe Rational -> Maybe (Maybe PraosNonce) -> Maybe Word16 -> Maybe Word32 -> Maybe Word32 -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe EpochInterval -> Maybe Word16 -> Maybe Rational -> Maybe Rational -> Maybe Rational -> Map AnyPlutusScriptVersion CostModel -> Maybe ExecutionUnitPrices -> Maybe ExecutionUnits -> Maybe ExecutionUnits -> Maybe Natural -> Maybe Natural -> Maybe Natural -> Maybe Coin -> ProtocolParametersUpdate
[protocolUpdateProtocolVersion] :: ProtocolParametersUpdate -> Maybe (Natural, Natural)
[protocolUpdateDecentralization] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateExtraPraosEntropy] :: ProtocolParametersUpdate -> Maybe (Maybe PraosNonce)
[protocolUpdateMaxBlockHeaderSize] :: ProtocolParametersUpdate -> Maybe Word16
[protocolUpdateMaxBlockBodySize] :: ProtocolParametersUpdate -> Maybe Word32
[protocolUpdateMaxTxSize] :: ProtocolParametersUpdate -> Maybe Word32
[protocolUpdateTxFeeFixed] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateTxFeePerByte] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateMinUTxOValue] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateStakeAddressDeposit] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateStakePoolDeposit] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateMinPoolCost] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdatePoolRetireMaxEpoch] :: ProtocolParametersUpdate -> Maybe EpochInterval
[protocolUpdateStakePoolTargetNum] :: ProtocolParametersUpdate -> Maybe Word16
[protocolUpdatePoolPledgeInfluence] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateMonetaryExpansion] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateTreasuryCut] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateCostModels] :: ProtocolParametersUpdate -> Map AnyPlutusScriptVersion CostModel
[protocolUpdatePrices] :: ProtocolParametersUpdate -> Maybe ExecutionUnitPrices
[protocolUpdateMaxTxExUnits] :: ProtocolParametersUpdate -> Maybe ExecutionUnits
[protocolUpdateMaxBlockExUnits] :: ProtocolParametersUpdate -> Maybe ExecutionUnits
[protocolUpdateMaxValueSize] :: ProtocolParametersUpdate -> Maybe Natural
[protocolUpdateCollateralPercent] :: ProtocolParametersUpdate -> Maybe Natural
[protocolUpdateMaxCollateralInputs] :: ProtocolParametersUpdate -> Maybe Natural
[protocolUpdateUTxOCostPerByte] :: ProtocolParametersUpdate -> Maybe Coin
data () => UpdateProposal
UpdateProposal :: !Map (Hash GenesisKey) ProtocolParametersUpdate -> !EpochNo -> UpdateProposal
data () => EraHistory
[EraHistory] :: forall (xs :: [Type]). CardanoBlock StandardCrypto ~ HardForkBlock xs => Interpreter xs -> EraHistory
newtype () => LedgerEpochInfo
LedgerEpochInfo :: EpochInfo (Either Text) -> LedgerEpochInfo
[unLedgerEpochInfo] :: LedgerEpochInfo -> EpochInfo (Either Text)
data () => QueryInEra era result
[QueryByronUpdateState] :: QueryInEra ByronEra ByronUpdateState
[QueryInShelleyBasedEra] :: forall era result. ShelleyBasedEra era -> QueryInShelleyBasedEra era result -> QueryInEra era result
data () => QueryInMode result
[QueryCurrentEra] :: QueryInMode AnyCardanoEra
[QueryInEra] :: forall era result1. QueryInEra era result1 -> QueryInMode (Either EraMismatch result1)
[QueryEraHistory] :: QueryInMode EraHistory
[QuerySystemStart] :: QueryInMode SystemStart
[QueryChainBlockNo] :: QueryInMode (WithOrigin BlockNo)
[QueryChainPoint] :: QueryInMode ChainPoint
[QueryLedgerConfig] :: QueryInMode (HardForkLedgerConfig (CardanoEras StandardCrypto))
data () => QueryInShelleyBasedEra era result
[QueryEpoch] :: forall era. QueryInShelleyBasedEra era EpochNo
[QueryGenesisParameters] :: forall era. QueryInShelleyBasedEra era (GenesisParameters ShelleyEra)
[QueryProtocolParameters] :: forall era. QueryInShelleyBasedEra era (PParams (ShelleyLedgerEra era))
[QueryStakeDistribution] :: forall era. QueryInShelleyBasedEra era (Map (Hash StakePoolKey) Rational)
[QueryUTxO] :: forall era. QueryUTxOFilter -> QueryInShelleyBasedEra era (UTxO era)
[QueryStakeAddresses] :: forall era. Set StakeCredential -> NetworkId -> QueryInShelleyBasedEra era (Map StakeAddress Coin, Map StakeAddress PoolId)
[QueryStakePools] :: forall era. QueryInShelleyBasedEra era (Set PoolId)
[QueryStakePoolParameters] :: forall era. Set PoolId -> QueryInShelleyBasedEra era (Map PoolId StakePoolParameters)
[QueryDebugLedgerState] :: forall era. QueryInShelleyBasedEra era (SerialisedDebugLedgerState era)
[QueryProtocolState] :: forall era. QueryInShelleyBasedEra era (ProtocolState era)
[QueryCurrentEpochState] :: forall era. QueryInShelleyBasedEra era (SerialisedCurrentEpochState era)
[QueryPoolState] :: forall era. Maybe (Set PoolId) -> QueryInShelleyBasedEra era (SerialisedPoolState era)
[QueryPoolDistribution] :: forall era. Maybe (Set PoolId) -> QueryInShelleyBasedEra era (SerialisedPoolDistribution era)
[QueryStakeSnapshot] :: forall era. Maybe (Set PoolId) -> QueryInShelleyBasedEra era (SerialisedStakeSnapshots era)
[QueryStakeDelegDeposits] :: forall era. Set StakeCredential -> QueryInShelleyBasedEra era (Map StakeCredential Coin)
[QueryAccountState] :: forall era. QueryInShelleyBasedEra era AccountState
[QueryConstitution] :: forall era. QueryInShelleyBasedEra era (Constitution (ShelleyLedgerEra era))
[QueryGovState] :: forall era. QueryInShelleyBasedEra era (GovState (ShelleyLedgerEra era))
[QueryRatifyState] :: forall era. QueryInShelleyBasedEra era (RatifyState (ShelleyLedgerEra era))
[QueryFuturePParams] :: forall era. QueryInShelleyBasedEra era (Maybe (PParams (ShelleyLedgerEra era)))
[QueryDRepState] :: forall era. Set (Credential 'DRepRole) -> QueryInShelleyBasedEra era (Map (Credential 'DRepRole) DRepState)
[QueryDRepStakeDistr] :: forall era. Set DRep -> QueryInShelleyBasedEra era (Map DRep Coin)
[QuerySPOStakeDistr] :: forall era. Set (KeyHash 'StakePool) -> QueryInShelleyBasedEra era (Map (KeyHash 'StakePool) Coin)
[QueryCommitteeMembersState] :: forall era. Set (Credential 'ColdCommitteeRole) -> Set (Credential 'HotCommitteeRole) -> Set MemberStatus -> QueryInShelleyBasedEra era CommitteeMembersState
[QueryStakeVoteDelegatees] :: forall era. Set StakeCredential -> QueryInShelleyBasedEra era (Map StakeCredential DRep)
[QueryProposals] :: forall era. Set GovActionId -> QueryInShelleyBasedEra era (Seq (GovActionState (ShelleyLedgerEra era)))
[QueryLedgerPeerSnapshot] :: forall era. QueryInShelleyBasedEra era (Serialised LedgerPeerSnapshot)
[QueryStakePoolDefaultVote] :: forall era. KeyHash 'StakePool -> QueryInShelleyBasedEra era DefaultVote
data () => QueryUTxOFilter
QueryUTxOWhole :: QueryUTxOFilter
QueryUTxOByAddress :: Set AddressAny -> QueryUTxOFilter
QueryUTxOByTxIn :: Set TxIn -> QueryUTxOFilter
newtype () => SlotsInEpoch
SlotsInEpoch :: Word64 -> SlotsInEpoch
newtype () => SlotsToEpochEnd
SlotsToEpochEnd :: Word64 -> SlotsToEpochEnd
newtype () => DelegationsAndRewards
DelegationsAndRewards :: (Map StakeAddress Coin, Map StakeAddress PoolId) -> DelegationsAndRewards
data () => AnyPlutusScriptVersion
[AnyPlutusScriptVersion] :: forall lang. IsPlutusScriptLanguage lang => PlutusScriptVersion lang -> AnyPlutusScriptVersion
data () => AnyScriptLanguage
[AnyScriptLanguage] :: forall lang. ScriptLanguage lang -> AnyScriptLanguage
class () => HasScriptLanguageInEra lang era
scriptLanguageInEra :: HasScriptLanguageInEra lang era => ScriptLanguageInEra lang era
class IsScriptLanguage lang => IsPlutusScriptLanguage lang
plutusScriptVersion :: IsPlutusScriptLanguage lang => PlutusScriptVersion lang
class HasTypeProxy lang => IsScriptLanguage lang
scriptLanguage :: IsScriptLanguage lang => ScriptLanguage lang
class () => IsScriptWitnessInCtx ctx
scriptWitnessInCtx :: IsScriptWitnessInCtx ctx => ScriptWitnessInCtx ctx
data () => KeyWitnessInCtx witctx
[KeyWitnessForSpending] :: KeyWitnessInCtx WitCtxTxIn
[KeyWitnessForStakeAddr] :: KeyWitnessInCtx WitCtxStake
data () => PlutusScriptInEra era lang
[PlutusScriptInEra] :: forall lang era. PlutusScript lang -> PlutusScriptInEra era lang
data () => PlutusScriptV1
data () => PlutusScriptV2
data () => PlutusScriptV3
data () => PlutusScriptVersion lang
[PlutusScriptV1] :: PlutusScriptVersion PlutusScriptV1
[PlutusScriptV2] :: PlutusScriptVersion PlutusScriptV2
[PlutusScriptV3] :: PlutusScriptVersion PlutusScriptV3
data () => ScriptInAnyLang
[ScriptInAnyLang] :: forall lang. ScriptLanguage lang -> Script lang -> ScriptInAnyLang
data () => ScriptLanguageInEra lang era
[SimpleScriptInShelley] :: ScriptLanguageInEra SimpleScript' ShelleyEra
[SimpleScriptInAllegra] :: ScriptLanguageInEra SimpleScript' AllegraEra
[SimpleScriptInMary] :: ScriptLanguageInEra SimpleScript' MaryEra
[SimpleScriptInAlonzo] :: ScriptLanguageInEra SimpleScript' AlonzoEra
[SimpleScriptInBabbage] :: ScriptLanguageInEra SimpleScript' BabbageEra
[SimpleScriptInConway] :: ScriptLanguageInEra SimpleScript' ConwayEra
[PlutusScriptV1InAlonzo] :: ScriptLanguageInEra PlutusScriptV1 AlonzoEra
[PlutusScriptV1InBabbage] :: ScriptLanguageInEra PlutusScriptV1 BabbageEra
[PlutusScriptV1InConway] :: ScriptLanguageInEra PlutusScriptV1 ConwayEra
[PlutusScriptV2InBabbage] :: ScriptLanguageInEra PlutusScriptV2 BabbageEra
[PlutusScriptV2InConway] :: ScriptLanguageInEra PlutusScriptV2 ConwayEra
[PlutusScriptV3InConway] :: ScriptLanguageInEra PlutusScriptV3 ConwayEra
type ScriptRedeemer = HashableScriptData
data () => ScriptWitnessInCtx witctx
[ScriptWitnessForSpending] :: ScriptWitnessInCtx WitCtxTxIn
[ScriptWitnessForMinting] :: ScriptWitnessInCtx WitCtxMint
[ScriptWitnessForStakeAddr] :: ScriptWitnessInCtx WitCtxStake
data () => SimpleScript
RequireSignature :: !Hash PaymentKey -> SimpleScript
RequireTimeBefore :: !SlotNo -> SimpleScript
RequireTimeAfter :: !SlotNo -> SimpleScript
RequireAllOf :: ![SimpleScript] -> SimpleScript
RequireAnyOf :: ![SimpleScript] -> SimpleScript
RequireMOf :: !Int -> ![SimpleScript] -> SimpleScript
data () => SimpleScript'
class () => ToAlonzoScript lang era
toLedgerScript :: ToAlonzoScript lang era => PlutusScript lang -> AlonzoScript (ShelleyLedgerEra era)
data () => WitCtx witctx
[WitCtxTxIn] :: WitCtx WitCtxTxIn
[WitCtxMint] :: WitCtx WitCtxMint
[WitCtxStake] :: WitCtx WitCtxStake
data () => WitCtxMint
data () => WitCtxStake
data () => WitCtxTxIn
data () => HashableScriptData
data () => ScriptDataJsonBytesError
ScriptDataJsonBytesErrorValue :: ScriptDataJsonError -> ScriptDataJsonBytesError
ScriptDataJsonBytesErrorInvalid :: ScriptDataRangeError -> ScriptDataJsonBytesError
data () => ScriptDataJsonError
ScriptDataJsonSchemaError :: !Value -> !ScriptDataJsonSchemaError -> ScriptDataJsonError
ScriptDataRangeError :: !Value -> !ScriptDataRangeError -> ScriptDataJsonError
data () => ScriptDataJsonSchema
ScriptDataJsonNoSchema :: ScriptDataJsonSchema
ScriptDataJsonDetailedSchema :: ScriptDataJsonSchema
data () => ScriptDataJsonSchemaError
ScriptDataJsonNullNotAllowed :: ScriptDataJsonSchemaError
ScriptDataJsonBoolNotAllowed :: ScriptDataJsonSchemaError
ScriptDataJsonNumberNotInteger :: !Double -> ScriptDataJsonSchemaError
ScriptDataJsonNotObject :: !Value -> ScriptDataJsonSchemaError
ScriptDataJsonBadObject :: ![(Text, Value)] -> ScriptDataJsonSchemaError
ScriptDataJsonBadMapPair :: !Value -> ScriptDataJsonSchemaError
ScriptDataJsonTypeMismatch :: !Text -> !Value -> ScriptDataJsonSchemaError
newtype () => ScriptDataRangeError
ScriptDataConstructorOutOfRange :: Integer -> ScriptDataRangeError
class HasTypeProxy a => SerialiseAsCBOR a
serialiseToCBOR :: SerialiseAsCBOR a => a -> ByteString
deserialiseFromCBOR :: SerialiseAsCBOR a => AsType a -> ByteString -> Either DecoderError a
data () => Bech32DecodeError
Bech32DecodingError :: !DecodingError -> Bech32DecodeError
Bech32UnexpectedPrefix :: !Text -> !Set Text -> Bech32DecodeError
Bech32DataPartToBytesError :: !Text -> Bech32DecodeError
Bech32DeserialiseFromBytesError :: !ByteString -> Bech32DecodeError
Bech32WrongPrefix :: !Text -> !Text -> Bech32DecodeError
Bech32UnexpectedHeader :: !Text -> !Text -> Bech32DecodeError
class (HasTypeProxy a, SerialiseAsRawBytes a) => SerialiseAsBech32 a
newtype () => JsonDecodeError
JsonDecodeError :: String -> JsonDecodeError
data () => FromSomeTypeCDDL c b
[FromCDDLTx] :: forall b. Text -> (InAnyShelleyBasedEra Tx -> b) -> FromSomeTypeCDDL TextEnvelope b
[FromCDDLWitness] :: forall b. Text -> (InAnyShelleyBasedEra KeyWitness -> b) -> FromSomeTypeCDDL TextEnvelope b
data () => TextEnvelopeCddlError
TextEnvelopeCddlErrCBORDecodingError :: DecoderError -> TextEnvelopeCddlError
TextEnvelopeCddlAesonDecodeError :: FilePath -> String -> TextEnvelopeCddlError
TextEnvelopeCddlUnknownKeyWitness :: TextEnvelopeCddlError
TextEnvelopeCddlTypeError :: [Text] -> Text -> TextEnvelopeCddlError
TextEnvelopeCddlErrUnknownType :: Text -> TextEnvelopeCddlError
TextEnvelopeCddlErrByronKeyWitnessUnsupported :: TextEnvelopeCddlError
data () => RawBytesHexError
RawBytesHexErrorBase16DecodeFail :: ByteString -> String -> RawBytesHexError
RawBytesHexErrorRawBytesDecodeFail :: ByteString -> TypeRep -> SerialiseAsRawBytesError -> RawBytesHexError
class (HasTypeProxy a, Typeable a) => SerialiseAsRawBytes a
serialiseToRawBytes :: SerialiseAsRawBytes a => a -> ByteString
deserialiseFromRawBytes :: SerialiseAsRawBytes a => AsType a -> ByteString -> Either SerialiseAsRawBytesError a
newtype () => SerialiseAsRawBytesError
SerialiseAsRawBytesError :: String -> SerialiseAsRawBytesError
[unSerialiseAsRawBytesError] :: SerialiseAsRawBytesError -> String
class SerialiseAsCBOR a => HasTextEnvelope a
textEnvelopeType :: HasTextEnvelope a => AsType a -> TextEnvelopeType
textEnvelopeDefaultDescr :: HasTextEnvelope a => a -> TextEnvelopeDescr
data () => TextEnvelope
TextEnvelope :: !TextEnvelopeType -> !TextEnvelopeDescr -> !ByteString -> TextEnvelope
[teType] :: TextEnvelope -> !TextEnvelopeType
[teDescription] :: TextEnvelope -> !TextEnvelopeDescr
[teRawCBOR] :: TextEnvelope -> !ByteString
data () => TextEnvelopeDescr
data () => TextEnvelopeError
TextEnvelopeTypeError :: ![TextEnvelopeType] -> !TextEnvelopeType -> TextEnvelopeError
TextEnvelopeDecodeError :: !DecoderError -> TextEnvelopeError
TextEnvelopeAesonDecodeError :: !String -> TextEnvelopeError
newtype () => TextEnvelopeType
TextEnvelopeType :: String -> TextEnvelopeType
newtype () => UsingBech32 a
UsingBech32 :: a -> UsingBech32 a
newtype () => UsingRawBytes a
UsingRawBytes :: a -> UsingRawBytes a
newtype () => UsingRawBytesHex a
UsingRawBytesHex :: a -> UsingRawBytesHex a
data () => StakePoolMetadata
StakePoolMetadata :: !Text -> !Text -> !Text -> !Text -> StakePoolMetadata
[stakePoolName] :: StakePoolMetadata -> !Text
[stakePoolDescription] :: StakePoolMetadata -> !Text
[stakePoolTicker] :: StakePoolMetadata -> !Text
[stakePoolHomepage] :: StakePoolMetadata -> !Text
data () => StakePoolMetadataValidationError
StakePoolMetadataJsonDecodeError :: !String -> StakePoolMetadataValidationError
StakePoolMetadataInvalidLengthError :: !Int -> !Int -> StakePoolMetadataValidationError
data () => AnyScriptWitness era
[AnyScriptWitness] :: forall witctx era. Typeable witctx => ScriptWitness witctx era -> AnyScriptWitness era
data () => ScriptWitnessIndex
ScriptWitnessIndexTxIn :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexMint :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexCertificate :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexWithdrawal :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexVoting :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexProposing :: !Word32 -> ScriptWitnessIndex
data () => TxCertificates build era
[TxCertificatesNone] :: forall build era. TxCertificates build era
[TxCertificates] :: forall era build. ShelleyBasedEra era -> OMap (Certificate era) (BuildTxWith build (Maybe (StakeCredential, Witness WitCtxStake era))) -> TxCertificates build era
data () => TxProposalProcedures build era
[TxProposalProceduresNone] :: forall build era. TxProposalProcedures build era
[TxProposalProcedures] :: forall era build. EraPParams (ShelleyLedgerEra era) => OMap (ProposalProcedure (ShelleyLedgerEra era)) (BuildTxWith build (Maybe (ScriptWitness WitCtxStake era))) -> TxProposalProcedures build era
data () => TxReturnCollateral ctx era
[TxReturnCollateralNone] :: forall ctx era. TxReturnCollateral ctx era
[TxReturnCollateral] :: forall era ctx. BabbageEraOnwards era -> TxOut ctx era -> TxReturnCollateral ctx era
data () => TxTotalCollateral era
[TxTotalCollateralNone] :: forall era. TxTotalCollateral era
[TxTotalCollateral] :: forall era. BabbageEraOnwards era -> Coin -> TxTotalCollateral era
data () => TxUpdateProposal era
[TxUpdateProposalNone] :: forall era. TxUpdateProposal era
[TxUpdateProposal] :: forall era. ShelleyToBabbageEra era -> UpdateProposal -> TxUpdateProposal era
data () => TxVotingProcedures build era
[TxVotingProceduresNone] :: forall build era. TxVotingProcedures build era
[TxVotingProcedures] :: forall era build. VotingProcedures (ShelleyLedgerEra era) -> BuildTxWith build (Map Voter (ScriptWitness WitCtxStake era)) -> TxVotingProcedures build era
data () => TxWithdrawals build era
[TxWithdrawalsNone] :: forall build era. TxWithdrawals build era
[TxWithdrawals] :: forall era build. ShelleyBasedEra era -> [(StakeAddress, Coin, BuildTxWith build (Witness WitCtxStake era))] -> TxWithdrawals build era
data () => BuildTx
data () => BuildTxWith build a
[ViewTx] :: forall a. BuildTxWith ViewTx a
[BuildTxWith] :: forall a. a -> BuildTxWith BuildTx a
data () => ViewTx
data () => CtxTx
data () => TxOutInAnyEra
[TxOutInAnyEra] :: forall era. CardanoEra era -> TxOut CtxTx era -> TxOutInAnyEra
data () => TxOutputError
TxOutputNegative :: !Quantity -> !TxOutInAnyEra -> TxOutputError
TxOutputOverflow :: !Quantity -> !TxOutInAnyEra -> TxOutputError
data () => ScriptValidity
ScriptInvalid :: ScriptValidity
ScriptValid :: ScriptValidity
data () => ShelleyWitnessSigningKey
WitnessPaymentKey :: SigningKey PaymentKey -> ShelleyWitnessSigningKey
WitnessPaymentExtendedKey :: SigningKey PaymentExtendedKey -> ShelleyWitnessSigningKey
WitnessStakeKey :: SigningKey StakeKey -> ShelleyWitnessSigningKey
WitnessStakeExtendedKey :: SigningKey StakeExtendedKey -> ShelleyWitnessSigningKey
WitnessStakePoolKey :: SigningKey StakePoolKey -> ShelleyWitnessSigningKey
WitnessStakePoolExtendedKey :: SigningKey StakePoolExtendedKey -> ShelleyWitnessSigningKey
WitnessGenesisKey :: SigningKey GenesisKey -> ShelleyWitnessSigningKey
WitnessGenesisExtendedKey :: SigningKey GenesisExtendedKey -> ShelleyWitnessSigningKey
WitnessGenesisDelegateKey :: SigningKey GenesisDelegateKey -> ShelleyWitnessSigningKey
WitnessGenesisDelegateExtendedKey :: SigningKey GenesisDelegateExtendedKey -> ShelleyWitnessSigningKey
WitnessGenesisUTxOKey :: SigningKey GenesisUTxOKey -> ShelleyWitnessSigningKey
WitnessCommitteeColdKey :: SigningKey CommitteeColdKey -> ShelleyWitnessSigningKey
WitnessCommitteeColdExtendedKey :: SigningKey CommitteeColdExtendedKey -> ShelleyWitnessSigningKey
WitnessCommitteeHotKey :: SigningKey CommitteeHotKey -> ShelleyWitnessSigningKey
WitnessCommitteeHotExtendedKey :: SigningKey CommitteeHotExtendedKey -> ShelleyWitnessSigningKey
WitnessDRepKey :: SigningKey DRepKey -> ShelleyWitnessSigningKey
WitnessDRepExtendedKey :: SigningKey DRepExtendedKey -> ShelleyWitnessSigningKey
newtype () => TxIx
TxIx :: Word -> TxIx
class () => AsTxMetadata a
asTxMetadata :: AsTxMetadata a => a -> TxMetadata
newtype () => TxMetadata
TxMetadata :: Map Word64 TxMetadataValue -> TxMetadata
[unTxMetadata] :: TxMetadata -> Map Word64 TxMetadataValue
data () => TxMetadataJsonError
TxMetadataJsonToplevelNotMap :: TxMetadataJsonError
TxMetadataJsonToplevelBadKey :: !Text -> TxMetadataJsonError
TxMetadataJsonSchemaError :: !Word64 -> !Value -> !TxMetadataJsonSchemaError -> TxMetadataJsonError
TxMetadataRangeError :: !Word64 -> !Value -> !TxMetadataRangeError -> TxMetadataJsonError
data () => TxMetadataJsonSchema
TxMetadataJsonNoSchema :: TxMetadataJsonSchema
TxMetadataJsonDetailedSchema :: TxMetadataJsonSchema
data () => TxMetadataJsonSchemaError
TxMetadataJsonNullNotAllowed :: TxMetadataJsonSchemaError
TxMetadataJsonBoolNotAllowed :: TxMetadataJsonSchemaError
TxMetadataJsonNumberNotInteger :: !Double -> TxMetadataJsonSchemaError
TxMetadataJsonNotObject :: !Value -> TxMetadataJsonSchemaError
TxMetadataJsonBadObject :: ![(Text, Value)] -> TxMetadataJsonSchemaError
TxMetadataJsonBadMapPair :: !Value -> TxMetadataJsonSchemaError
TxMetadataJsonTypeMismatch :: !Text -> !Value -> TxMetadataJsonSchemaError
data () => TxMetadataRangeError
TxMetadataNumberOutOfRange :: !Integer -> TxMetadataRangeError
TxMetadataTextTooLong :: !Int -> TxMetadataRangeError
TxMetadataBytesTooLong :: !Int -> TxMetadataRangeError
data () => TxMetadataValue
TxMetaMap :: [(TxMetadataValue, TxMetadataValue)] -> TxMetadataValue
TxMetaList :: [TxMetadataValue] -> TxMetadataValue
TxMetaNumber :: Integer -> TxMetadataValue
TxMetaBytes :: ByteString -> TxMetadataValue
TxMetaText :: Text -> TxMetadataValue
data () => AssetId
AdaAssetId :: AssetId
AssetId :: !PolicyId -> !AssetName -> AssetId
newtype () => AssetName
AssetName :: ByteString -> AssetName
type Lovelace = Coin
newtype () => Quantity
Quantity :: Integer -> Quantity
data () => ValueNestedBundle
ValueNestedBundleAda :: Quantity -> ValueNestedBundle
ValueNestedBundle :: PolicyId -> Map AssetName Quantity -> ValueNestedBundle
newtype () => ValueNestedRep
ValueNestedRep :: [ValueNestedBundle] -> ValueNestedRep
newtype () => ShowOf a
ShowOf :: a -> ShowOf a
data () => CommitteeMembersState
CommitteeMembersState :: !Map (Credential 'ColdCommitteeRole) CommitteeMemberState -> !Maybe UnitInterval -> !EpochNo -> CommitteeMembersState
[csCommittee] :: CommitteeMembersState -> !Map (Credential 'ColdCommitteeRole) CommitteeMemberState
[csThreshold] :: CommitteeMembersState -> !Maybe UnitInterval
[csEpochNo] :: CommitteeMembersState -> !EpochNo
data () => MemberStatus
Active :: MemberStatus
Expired :: MemberStatus
Unrecognized :: MemberStatus
newtype () => EpochSlots
EpochSlots :: Word64 -> EpochSlots
[unEpochSlots] :: EpochSlots -> Word64
class () => Inject t s
inject :: Inject t s => t -> s
data () => MIRPot
ReservesMIR :: MIRPot
TreasuryMIR :: MIRPot
data () => MIRTarget
StakeAddressesMIR :: !Map (Credential 'Staking) DeltaCoin -> MIRTarget
SendToOppositePotMIR :: !Coin -> MIRTarget
newtype () => BlockNo
BlockNo :: Word64 -> BlockNo
[unBlockNo] :: BlockNo -> Word64
newtype () => EpochNo
EpochNo :: Word64 -> EpochNo
[unEpochNo] :: EpochNo -> Word64
newtype () => SlotNo
SlotNo :: Word64 -> SlotNo
[unSlotNo] :: SlotNo -> Word64
newtype () => SystemStart
SystemStart :: UTCTime -> SystemStart
[getSystemStart] :: SystemStart -> UTCTime
data () => NodeToClientVersion
NodeToClientV_16 :: NodeToClientVersion
NodeToClientV_17 :: NodeToClientVersion
NodeToClientV_18 :: NodeToClientVersion
NodeToClientV_19 :: NodeToClientVersion
NodeToClientV_20 :: NodeToClientVersion
newtype () => ChainSyncClient header point tip (m :: Type -> Type) a
ChainSyncClient :: m (ClientStIdle header point tip m a) -> ChainSyncClient header point tip (m :: Type -> Type) a
[runChainSyncClient] :: ChainSyncClient header point tip (m :: Type -> Type) a -> m (ClientStIdle header point tip m a)
newtype () => ChainSyncClientPipelined header point tip (m :: Type -> Type) a
ChainSyncClientPipelined :: m (ClientPipelinedStIdle 'Z header point tip m a) -> ChainSyncClientPipelined header point tip (m :: Type -> Type) a
[runChainSyncClientPipelined] :: ChainSyncClientPipelined header point tip (m :: Type -> Type) a -> m (ClientPipelinedStIdle 'Z header point tip m a)
newtype () => LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a
LocalStateQueryClient :: m (ClientStIdle block point query m a) -> LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a
[runLocalStateQueryClient] :: LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a -> m (ClientStIdle block point query m a)
newtype () => LocalTxMonitorClient txid tx slot (m :: Type -> Type) a
LocalTxMonitorClient :: m (ClientStIdle txid tx slot m a) -> LocalTxMonitorClient txid tx slot (m :: Type -> Type) a
[runLocalTxMonitorClient] :: LocalTxMonitorClient txid tx slot (m :: Type -> Type) a -> m (ClientStIdle txid tx slot m a)
data () => MempoolSizeAndCapacity
MempoolSizeAndCapacity :: !Word32 -> !Word32 -> !Word32 -> MempoolSizeAndCapacity
[capacityInBytes] :: MempoolSizeAndCapacity -> !Word32
[sizeInBytes] :: MempoolSizeAndCapacity -> !Word32
[numberOfTxs] :: MempoolSizeAndCapacity -> !Word32
newtype () => LocalTxSubmissionClient tx reject (m :: Type -> Type) a
LocalTxSubmissionClient :: m (LocalTxClientStIdle tx reject m a) -> LocalTxSubmissionClient tx reject (m :: Type -> Type) a
[runLocalTxSubmissionClient] :: LocalTxSubmissionClient tx reject (m :: Type -> Type) a -> m (LocalTxClientStIdle tx reject m a)
data () => SubmitResult reason
SubmitSuccess :: SubmitResult reason
SubmitFail :: reason -> SubmitResult reason
data () => Vote
No :: Vote
Yes :: Vote
Abstain :: Vote
newtype () => VotingProcedure era
VotingProcedure :: VotingProcedure (ShelleyLedgerEra era) -> VotingProcedure era
[unVotingProcedure] :: VotingProcedure era -> VotingProcedure (ShelleyLedgerEra era)
newtype () => VotingProcedures era
VotingProcedures :: VotingProcedures (ShelleyLedgerEra era) -> VotingProcedures era
[unVotingProcedures] :: VotingProcedures era -> VotingProcedures (ShelleyLedgerEra era)
data () => GovernanceAction era
MotionOfNoConfidence :: StrictMaybe (GovPurposeId 'CommitteePurpose (ShelleyLedgerEra era)) -> GovernanceAction era
ProposeNewConstitution :: StrictMaybe (GovPurposeId 'ConstitutionPurpose (ShelleyLedgerEra era)) -> Anchor -> StrictMaybe ScriptHash -> GovernanceAction era
ProposeNewCommittee :: StrictMaybe (GovPurposeId 'CommitteePurpose (ShelleyLedgerEra era)) -> [Credential 'ColdCommitteeRole] -> Map (Credential 'ColdCommitteeRole) EpochNo -> Rational -> GovernanceAction era
InfoAct :: GovernanceAction era
TreasuryWithdrawal :: [(Network, StakeCredential, Coin)] -> !StrictMaybe ScriptHash -> GovernanceAction era
InitiateHardfork :: StrictMaybe (GovPurposeId 'HardForkPurpose (ShelleyLedgerEra era)) -> ProtVer -> GovernanceAction era
UpdatePParams :: StrictMaybe (GovPurposeId 'PParamUpdatePurpose (ShelleyLedgerEra era)) -> PParamsUpdate (ShelleyLedgerEra era) -> !StrictMaybe ScriptHash -> GovernanceAction era
data () => Proposal era
[Proposal] :: forall era. Typeable era => ProposalProcedure (ShelleyLedgerEra era) -> Proposal era
newtype () => VotesMergingConflict era
VotesMergingConflict :: (Voter, [GovActionId]) -> VotesMergingConflict era
data () => GovernancePoll
GovernancePoll :: Text -> [Text] -> Maybe Word -> GovernancePoll
[govPollQuestion] :: GovernancePoll -> Text
[govPollAnswers] :: GovernancePoll -> [Text]
[govPollNonce] :: GovernancePoll -> Maybe Word
data () => GovernancePollAnswer
GovernancePollAnswer :: Hash GovernancePoll -> Word -> GovernancePollAnswer
[govAnsPoll] :: GovernancePollAnswer -> Hash GovernancePoll
[govAnsChoice] :: GovernancePollAnswer -> Word
data () => GovernancePollError
ErrGovernancePollMismatch :: GovernancePollMismatchError -> GovernancePollError
ErrGovernancePollNoAnswer :: GovernancePollError
ErrGovernancePollUnauthenticated :: GovernancePollError
ErrGovernancePollMalformedAnswer :: DecoderError -> GovernancePollError
ErrGovernancePollInvalidAnswer :: GovernancePollInvalidAnswerError -> GovernancePollError
data () => KesKey
data () => VrfKey
data () => AnyStakePoolSigningKey
AnyStakePoolNormalSigningKey :: SigningKey StakePoolKey -> AnyStakePoolSigningKey
AnyStakePoolExtendedSigningKey :: SigningKey StakePoolExtendedKey -> AnyStakePoolSigningKey
data () => AnyStakePoolVerificationKey
AnyStakePoolNormalVerificationKey :: VerificationKey StakePoolKey -> AnyStakePoolVerificationKey
AnyStakePoolExtendedVerificationKey :: VerificationKey StakePoolExtendedKey -> AnyStakePoolVerificationKey
data () => StakePoolExtendedKey
data () => StakePoolKey
data () => AnyProposals
AnyProposals :: Proposals era -> AnyProposals
data () => AnyRatificationState
AnyRatificationState :: RatifyState era -> AnyRatificationState
data () => LedgerEvent
PoolRegistration :: LedgerEvent
PoolReRegistration :: LedgerEvent
IncrementalRewardsDistribution :: EpochNo -> Map StakeCredential (Set Reward) -> LedgerEvent
RewardsDistribution :: EpochNo -> Map StakeCredential (Set Reward) -> LedgerEvent
MIRDistribution :: MIRDistributionDetails -> LedgerEvent
PoolReap :: PoolReapDetails -> LedgerEvent
SuccessfulPlutusScript :: NonEmpty PlutusWithContext -> LedgerEvent
FailedPlutusScript :: NonEmpty PlutusWithContext -> LedgerEvent
NewGovernanceProposals :: TxId -> AnyProposals -> LedgerEvent
RemovedGovernanceVotes :: TxId -> Set (Voter, GovActionId) -> Set (Credential 'DRepRole) -> LedgerEvent
EpochBoundaryRatificationState :: AnyRatificationState -> LedgerEvent
data () => MIRDistributionDetails
MIRDistributionDetails :: Map StakeCredential Coin -> Map StakeCredential Coin -> Coin -> Coin -> MIRDistributionDetails
[mirddReservePayouts] :: MIRDistributionDetails -> Map StakeCredential Coin
[mirddTreasuryPayouts] :: MIRDistributionDetails -> Map StakeCredential Coin
[mirddReservesToTreasury] :: MIRDistributionDetails -> Coin
[mirddTreasuryToReserves] :: MIRDistributionDetails -> Coin
data () => PoolReapDetails
PoolReapDetails :: EpochNo -> Map StakeCredential (Map (Hash StakePoolKey) Coin) -> Map StakeCredential (Map (Hash StakePoolKey) Coin) -> PoolReapDetails
[prdEpochNo] :: PoolReapDetails -> EpochNo
[prdRefunded] :: PoolReapDetails -> Map StakeCredential (Map (Hash StakePoolKey) Coin)
[prdUnclaimed] :: PoolReapDetails -> Map StakeCredential (Map (Hash StakePoolKey) Coin)
data () => LeadershipError
LeaderErrDecodeLedgerStateFailure :: LeadershipError
LeaderErrDecodeProtocolStateFailure :: (ByteString, DecoderError) -> LeadershipError
LeaderErrDecodeProtocolEpochStateFailure :: DecoderError -> LeadershipError
LeaderErrGenesisSlot :: LeadershipError
LeaderErrStakePoolHasNoStake :: PoolId -> LeadershipError
LeaderErrStakeDistribUnstable :: SlotNo -> SlotNo -> SlotNo -> SlotNo -> LeadershipError
LeaderErrSlotRangeCalculationFailure :: Text -> LeadershipError
LeaderErrCandidateNonceStillEvolving :: LeadershipError
data () => AlonzoOnwardsPParams ledgerera
AlonzoOnwardsPParams :: StrictMaybe CostModels -> StrictMaybe Prices -> StrictMaybe ExUnits -> StrictMaybe ExUnits -> StrictMaybe Natural -> StrictMaybe Natural -> StrictMaybe Natural -> AlonzoOnwardsPParams ledgerera
[alCostModels] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe CostModels
[alPrices] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe Prices
[alMaxTxExUnits] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe ExUnits
[alMaxBlockExUnits] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe ExUnits
[alMaxValSize] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe Natural
[alCollateralPercentage] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe Natural
[alMaxCollateralInputs] :: AlonzoOnwardsPParams ledgerera -> StrictMaybe Natural
data () => CommonProtocolParametersUpdate
CommonProtocolParametersUpdate :: StrictMaybe Coin -> StrictMaybe Coin -> StrictMaybe Word32 -> StrictMaybe Word32 -> StrictMaybe Word16 -> StrictMaybe Coin -> StrictMaybe Coin -> StrictMaybe EpochInterval -> StrictMaybe Word16 -> StrictMaybe NonNegativeInterval -> StrictMaybe UnitInterval -> StrictMaybe UnitInterval -> StrictMaybe Coin -> CommonProtocolParametersUpdate
[cppMinFeeA] :: CommonProtocolParametersUpdate -> StrictMaybe Coin
[cppMinFeeB] :: CommonProtocolParametersUpdate -> StrictMaybe Coin
[cppMaxBlockBodySize] :: CommonProtocolParametersUpdate -> StrictMaybe Word32
[cppMaxTxSize] :: CommonProtocolParametersUpdate -> StrictMaybe Word32
[cppMaxBlockHeaderSize] :: CommonProtocolParametersUpdate -> StrictMaybe Word16
[cppKeyDeposit] :: CommonProtocolParametersUpdate -> StrictMaybe Coin
[cppPoolDeposit] :: CommonProtocolParametersUpdate -> StrictMaybe Coin
[cppPoolRetireMaxEpoch] :: CommonProtocolParametersUpdate -> StrictMaybe EpochInterval
[cppStakePoolTargetNum] :: CommonProtocolParametersUpdate -> StrictMaybe Word16
[cppPoolPledgeInfluence] :: CommonProtocolParametersUpdate -> StrictMaybe NonNegativeInterval
[cppTreasuryExpansion] :: CommonProtocolParametersUpdate -> StrictMaybe UnitInterval
[cppMonetaryExpansion] :: CommonProtocolParametersUpdate -> StrictMaybe UnitInterval
[cppMinPoolCost] :: CommonProtocolParametersUpdate -> StrictMaybe Coin
newtype () => DeprecatedAfterBabbagePParams ledgerera
DeprecatedAfterBabbagePParams :: StrictMaybe ProtVer -> DeprecatedAfterBabbagePParams ledgerera
newtype () => DeprecatedAfterMaryPParams ledgerera
DeprecatedAfterMaryPParams :: StrictMaybe Coin -> DeprecatedAfterMaryPParams ledgerera
data () => EraBasedProtocolParametersUpdate era
[ShelleyEraBasedProtocolParametersUpdate] :: CommonProtocolParametersUpdate -> DeprecatedAfterMaryPParams ShelleyEra -> DeprecatedAfterBabbagePParams ShelleyEra -> ShelleyToAlonzoPParams ShelleyEra -> EraBasedProtocolParametersUpdate ShelleyEra
[AllegraEraBasedProtocolParametersUpdate] :: CommonProtocolParametersUpdate -> DeprecatedAfterMaryPParams AllegraEra -> ShelleyToAlonzoPParams AllegraEra -> DeprecatedAfterBabbagePParams ShelleyEra -> EraBasedProtocolParametersUpdate AllegraEra
[MaryEraBasedProtocolParametersUpdate] :: CommonProtocolParametersUpdate -> DeprecatedAfterMaryPParams MaryEra -> ShelleyToAlonzoPParams MaryEra -> DeprecatedAfterBabbagePParams ShelleyEra -> EraBasedProtocolParametersUpdate MaryEra
[AlonzoEraBasedProtocolParametersUpdate] :: CommonProtocolParametersUpdate -> ShelleyToAlonzoPParams AlonzoEra -> AlonzoOnwardsPParams AlonzoEra -> DeprecatedAfterBabbagePParams ShelleyEra -> EraBasedProtocolParametersUpdate AlonzoEra
[BabbageEraBasedProtocolParametersUpdate] :: CommonProtocolParametersUpdate -> AlonzoOnwardsPParams BabbageEra -> DeprecatedAfterBabbagePParams ShelleyEra -> IntroducedInBabbagePParams BabbageEra -> EraBasedProtocolParametersUpdate BabbageEra
[ConwayEraBasedProtocolParametersUpdate] :: CommonProtocolParametersUpdate -> AlonzoOnwardsPParams ConwayEra -> IntroducedInBabbagePParams ConwayEra -> IntroducedInConwayPParams (ShelleyLedgerEra ConwayEra) -> EraBasedProtocolParametersUpdate ConwayEra
newtype () => IntroducedInBabbagePParams era
IntroducedInBabbagePParams :: StrictMaybe CoinPerByte -> IntroducedInBabbagePParams era
data () => IntroducedInConwayPParams era
IntroducedInConwayPParams :: StrictMaybe PoolVotingThresholds -> StrictMaybe DRepVotingThresholds -> StrictMaybe Natural -> StrictMaybe EpochInterval -> StrictMaybe EpochInterval -> StrictMaybe Coin -> StrictMaybe Coin -> StrictMaybe EpochInterval -> StrictMaybe NonNegativeInterval -> IntroducedInConwayPParams era
[icPoolVotingThresholds] :: IntroducedInConwayPParams era -> StrictMaybe PoolVotingThresholds
[icDRepVotingThresholds] :: IntroducedInConwayPParams era -> StrictMaybe DRepVotingThresholds
[icMinCommitteeSize] :: IntroducedInConwayPParams era -> StrictMaybe Natural
[icCommitteeTermLength] :: IntroducedInConwayPParams era -> StrictMaybe EpochInterval
[icGovActionLifetime] :: IntroducedInConwayPParams era -> StrictMaybe EpochInterval
[icGovActionDeposit] :: IntroducedInConwayPParams era -> StrictMaybe Coin
[icDRepDeposit] :: IntroducedInConwayPParams era -> StrictMaybe Coin
[icDRepActivity] :: IntroducedInConwayPParams era -> StrictMaybe EpochInterval
[icMinFeeRefScriptCostPerByte] :: IntroducedInConwayPParams era -> StrictMaybe NonNegativeInterval
data () => ProtocolParametersError
PParamsErrorMissingMinUTxoValue :: !AnyCardanoEra -> ProtocolParametersError
PParamsErrorMissingAlonzoProtocolParameter :: ProtocolParametersError
data () => ShelleyToAlonzoPParams ledgerera
ShelleyToAlonzoPParams :: StrictMaybe Nonce -> StrictMaybe UnitInterval -> ShelleyToAlonzoPParams ledgerera
newtype () => CurrentEpochState era
CurrentEpochState :: EpochState (ShelleyLedgerEra era) -> CurrentEpochState era
newtype () => PoolDistribution era
PoolDistribution :: PoolDistr StandardCrypto -> PoolDistribution era
[unPoolDistr] :: PoolDistribution era -> PoolDistr StandardCrypto
newtype () => PoolState era
PoolState :: PState (ShelleyLedgerEra era) -> PoolState era
newtype () => ProtocolState era
ProtocolState :: Serialised (ChainDepState (ConsensusProtocol era)) -> ProtocolState era
newtype () => SerialisedCurrentEpochState era
SerialisedCurrentEpochState :: Serialised (EpochState (ShelleyLedgerEra era)) -> SerialisedCurrentEpochState era
newtype () => SerialisedDebugLedgerState era
SerialisedDebugLedgerState :: Serialised (NewEpochState (ShelleyLedgerEra era)) -> SerialisedDebugLedgerState era
newtype () => SerialisedPoolDistribution era
SerialisedPoolDistribution :: Serialised (PoolDistr StandardCrypto) -> SerialisedPoolDistribution era
newtype () => SerialisedPoolState era
SerialisedPoolState :: Serialised (PState (ShelleyLedgerEra era)) -> SerialisedPoolState era
newtype () => SerialisedStakeSnapshots era
SerialisedStakeSnapshots :: Serialised StakeSnapshots -> SerialisedStakeSnapshots era
newtype () => StakeSnapshot era
StakeSnapshot :: StakeSnapshots -> StakeSnapshot era
newtype () => DebugLedgerState era
DebugLedgerState :: NewEpochState (ShelleyLedgerEra era) -> DebugLedgerState era
[unDebugLedgerState] :: DebugLedgerState era -> NewEpochState (ShelleyLedgerEra era)
data () => SimpleScriptOrReferenceInput lang
SScript :: SimpleScript -> SimpleScriptOrReferenceInput lang
SReferenceScript :: TxIn -> SimpleScriptOrReferenceInput lang
data () => ShelleySigningKey
ShelleyNormalSigningKey :: SignKeyDSIGN DSIGN -> ShelleySigningKey
ShelleyExtendedSigningKey :: XPrv -> ShelleySigningKey
newtype () => KESPeriod
KESPeriod :: Word -> KESPeriod
[unKESPeriod] :: KESPeriod -> Word
pattern Block :: BlockHeader -> [Tx era] -> Block era
(<+>) :: Doc ann -> Doc ann -> Doc ann
runParsecParser :: Parser a -> Text -> Parser a
left :: forall (m :: Type -> Type) x a. Monad m => x -> ExceptT x m a
right :: forall (m :: Type -> Type) a x. Monad m => a -> ExceptT x m a

-- | Signal an exception value <tt>e</tt>.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>throwE</a> e) = <a>return</a>
--   (<a>Left</a> e)</pre></li>
--   <li><pre><a>throwE</a> e &gt;&gt;= m = <a>throwE</a> e</pre></li>
--   </ul>
throwE :: forall (m :: Type -> Type) e a. Monad m => e -> ExceptT e m a

-- | Extractor for computations in the exception monad. (The inverse of
--   <a>except</a>).
runExcept :: Except e a -> Either e a

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExcept</a> (<a>mapExcept</a> f m) = f (<a>runExcept</a>
--   m)</pre></li>
--   </ul>
mapExcept :: (Either e a -> Either e' b) -> Except e a -> Except e' b

-- | Transform any exceptions thrown by the computation using the given
--   function (a specialization of <a>withExceptT</a>).
withExcept :: (e -> e') -> Except e a -> Except e' a

-- | The inverse of <a>ExceptT</a>.
runExceptT :: ExceptT e m a -> m (Either e a)

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>mapExceptT</a> f m) = f
--   (<a>runExceptT</a> m)</pre></li>
--   </ul>
mapExceptT :: (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b

-- | Transform any exceptions thrown by the computation using the given
--   function.
withExceptT :: forall (m :: Type -> Type) e e' a. Functor m => (e -> e') -> ExceptT e m a -> ExceptT e' m a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: CallCC m (Either e a) (Either e b) -> CallCC (ExceptT e m) a b

-- | Lifts an <tt><a>Either</a> e</tt> into any <tt><a>MonadError</a>
--   e</tt>.
--   
--   <pre>
--   do { val &lt;- liftEither =&lt;&lt; action1; action2 }
--   </pre>
--   
--   where <tt>action1</tt> returns an <a>Either</a> to represent errors.
liftEither :: MonadError e m => Either e a -> m a
modifyError :: forall e' t (m :: Type -> Type) e a. MonadTransError e' t m => (e -> e') -> ExceptT e m a -> t m a
hsep :: [Doc ann] -> Doc ann

-- | Handle an exception.
--   
--   <ul>
--   <li><pre><a>catchE</a> (<a>lift</a> m) h = <a>lift</a> m</pre></li>
--   <li><pre><a>catchE</a> (<a>throwE</a> e) h = h e</pre></li>
--   </ul>
catchE :: forall (m :: Type -> Type) e a e'. Monad m => ExceptT e m a -> (e -> ExceptT e' m a) -> ExceptT e' m a

-- | Constructor for computations in the exception monad. (The inverse of
--   <a>runExcept</a>).
except :: forall (m :: Type -> Type) e a. Monad m => Either e a -> ExceptT e m a

-- | The same as <tt><a>flip</a> <a>catchE</a></tt>, which is useful in
--   situations where the code for the handler is shorter.
handleE :: forall (m :: Type -> Type) e e' a. Monad m => (e -> ExceptT e' m a) -> ExceptT e m a -> ExceptT e' m a

-- | Similar to <a>catchE</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception was thown, or
--   <tt>(<a>Left</a> ex)</tt> if an exception <tt>ex</tt> was thrown.
tryE :: forall (m :: Type -> Type) e a. Monad m => ExceptT e m a -> ExceptT e m (Either e a)

-- | <tt><a>finallyE</a> a b</tt> executes computation <tt>a</tt> followed
--   by computation <tt>b</tt>, even if <tt>a</tt> exits early by throwing
--   an exception. In the latter case, the exception is re-thrown after
--   <tt>b</tt> has been executed.
finallyE :: forall (m :: Type -> Type) e a. Monad m => ExceptT e m a -> ExceptT e m () -> ExceptT e m a

-- | Lift a <tt>listen</tt> operation to the new monad.
liftListen :: Monad m => Listen w m (Either e a) -> Listen w (ExceptT e m) a

-- | Lift a <tt>pass</tt> operation to the new monad.
liftPass :: Monad m => Pass w m (Either e a) -> Pass w (ExceptT e m) a
hoistMaybe :: forall (m :: Type -> Type) x a. Monad m => x -> Maybe a -> ExceptT x m a
blue :: Doc AnsiStyle -> Doc AnsiStyle
createAndValidateTransactionBody :: ShelleyBasedEra era -> TxBodyContent BuildTx era -> Either TxBodyError (TxBody era)
defaultTxBodyContent :: ShelleyBasedEra era -> TxBodyContent BuildTx era
fromLedgerUTxO :: ShelleyBasedEra era -> UTxO (ShelleyLedgerEra era) -> UTxO era
fromLedgerValue :: ShelleyBasedEra era -> Value (ShelleyLedgerEra era) -> Value
green :: Doc AnsiStyle -> Doc AnsiStyle
makeShelleyKeyWitness :: ShelleyBasedEra era -> TxBody era -> ShelleyWitnessSigningKey -> KeyWitness era
queryEraHistory :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError EraHistory)
queryProtocolParameters :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (PParams (ShelleyLedgerEra era))))
queryStakePools :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Set PoolId)))
querySystemStart :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError SystemStart)
red :: Doc AnsiStyle -> Doc AnsiStyle
signShelleyTransaction :: ShelleyBasedEra era -> TxBody era -> [ShelleyWitnessSigningKey] -> Tx era
toLedgerValue :: MaryEraOnwards era -> Value -> Value (ShelleyLedgerEra era)
fromAlonzoCostModels :: CostModels -> Map AnyPlutusScriptVersion CostModel
fromAlonzoPrices :: Prices -> ExecutionUnitPrices
fromPlutusData :: Data -> ScriptData
fromShelleyMetadata :: Map Word64 Metadatum -> Map Word64 TxMetadataValue
toAlonzoPrices :: ExecutionUnitPrices -> Either ProtocolParametersConversionError Prices
toPlutusData :: ScriptData -> Data
toShelleyMetadata :: Map Word64 TxMetadataValue -> Map Word64 Metadatum
toShelleyNetwork :: NetworkId -> Network
txOutValueToValue :: TxOutValue era -> Value
renderTxIn :: TxIn -> Text
renderValue :: Value -> Text
selectLovelace :: Value -> Lovelace
anyAddressInShelleyBasedEra :: ShelleyBasedEra era -> AddressAny -> AddressInEra era
toAddressAny :: Address addr -> AddressAny
lovelaceToTxOutValue :: ShelleyBasedEra era -> Coin -> TxOutValue era
anyAddressInEra :: CardanoEra era -> AddressAny -> Either String (AddressInEra era)
byronAddressInEra :: Address ByronAddr -> AddressInEra era
isKeyAddress :: AddressInEra era -> Bool
lexPlausibleAddressString :: Parser Text
makeByronAddress :: NetworkId -> VerificationKey ByronKey -> Address ByronAddr
makeByronAddressInEra :: NetworkId -> VerificationKey ByronKey -> AddressInEra era
makeShelleyAddress :: NetworkId -> PaymentCredential -> StakeAddressReference -> Address ShelleyAddr
makeShelleyAddressInEra :: ShelleyBasedEra era -> NetworkId -> PaymentCredential -> StakeAddressReference -> AddressInEra era
makeStakeAddress :: NetworkId -> StakeCredential -> StakeAddress
parseAddressAny :: SerialiseAddress addr => Parser addr
shelleyAddressInEra :: ShelleyBasedEra era -> Address ShelleyAddr -> AddressInEra era
stakeAddressCredential :: StakeAddress -> StakeCredential
chainPointToHeaderHash :: ChainPoint -> Maybe (Hash BlockHeader)
chainPointToSlotNo :: ChainPoint -> Maybe SlotNo
chainTipToChainPoint :: ChainTip -> ChainPoint
getBlockHeader :: Block era -> BlockHeader
getBlockTxs :: Block era -> [Tx era]
makeChainTip :: WithOrigin BlockNo -> ChainPoint -> ChainTip
deserialiseFromBech32Cip129 :: Cip129 a => Text -> Either Bech32DecodeError a
deserialiseGovActionIdFromBech32Cip129 :: Text -> Either Bech32DecodeError GovActionId
serialiseGovActionIdToBech32Cip129 :: GovActionId -> Text
serialiseToBech32Cip129 :: Cip129 a => a -> Text
getAnchorDataFromCertificate :: Certificate era -> Either AnchorDataFromCertificateError (Maybe Anchor)
isDRepRegOrUpdateCert :: Certificate era -> Bool
makeCommitteeColdkeyResignationCertificate :: Typeable era => CommitteeColdkeyResignationRequirements era -> Certificate era
makeCommitteeHotKeyAuthorizationCertificate :: Typeable era => CommitteeHotKeyAuthorizationRequirements era -> Certificate era
makeDrepRegistrationCertificate :: Typeable era => DRepRegistrationRequirements era -> Maybe Anchor -> Certificate era
makeDrepUnregistrationCertificate :: Typeable era => DRepUnregistrationRequirements era -> Certificate era
makeDrepUpdateCertificate :: Typeable era => DRepUpdateRequirements era -> Maybe Anchor -> Certificate era
makeGenesisKeyDelegationCertificate :: Typeable era => GenesisKeyDelegationRequirements era -> Certificate era
makeMIRCertificate :: Typeable era => MirCertificateRequirements era -> Certificate era
makeStakeAddressAndDRepDelegationCertificate :: ConwayEraOnwards era -> StakeCredential -> Delegatee -> Coin -> Certificate era
makeStakeAddressDelegationCertificate :: StakeDelegationRequirements era -> Certificate era
makeStakeAddressRegistrationCertificate :: StakeAddressRequirements era -> Certificate era
makeStakeAddressUnregistrationCertificate :: StakeAddressRequirements era -> Certificate era
makeStakePoolRegistrationCertificate :: StakePoolRegistrationRequirements era -> Certificate era
makeStakePoolRetirementCertificate :: StakePoolRetirementRequirements era -> Certificate era
selectStakeCredentialWitness :: Certificate era -> Maybe StakeCredential
constructBalancedTx :: ShelleyBasedEra era -> TxBodyContent BuildTx era -> AddressInEra era -> Maybe Word -> UTxO era -> LedgerProtocolParameters era -> LedgerEpochInfo -> SystemStart -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> [ShelleyWitnessSigningKey] -> Either (TxBodyErrorAutoBalance era) (Tx era)
notScriptLockedTxIns :: [TxIn] -> UTxO era -> Either ScriptLockedTxInsError ()
renderNotScriptLockedTxInsError :: ScriptLockedTxInsError -> Text
renderTxInsExistError :: TxInsExistError -> Text
txInsExistInUTxO :: [TxIn] -> UTxO era -> Either TxInsExistError ()
determineEra :: LocalNodeConnectInfo -> ExceptT AcquiringFailure IO AnyCardanoEra
executeQueryAnyMode :: LocalNodeConnectInfo -> QueryInMode (Either EraMismatch result) -> ExceptT QueryConvenienceError IO result
executeQueryCardanoMode :: SocketPath -> NetworkId -> QueryInMode (Either EraMismatch result) -> ExceptT QueryConvenienceError IO result
queryStateForBalancedTx :: CardanoEra era -> [TxIn] -> [Certificate era] -> LocalStateQueryExpr block point QueryInMode r IO (Either QueryConvenienceError (UTxO era, LedgerProtocolParameters era, EraHistory, SystemStart, Set PoolId, Map StakeCredential Coin, Map (Credential 'DRepRole) Coin, Maybe (Featured ConwayEraOnwards era TxCurrentTreasuryValue)))
renderQueryConvenienceError :: QueryConvenienceError -> Text
hashDRepMetadata :: ByteString -> (DRepMetadata, Hash DRepMetadata)
deserialiseAnyVerificationKey :: ByteString -> Either InputDecodeError SomeAddressVerificationKey
deserialiseAnyVerificationKeyBech32 :: ByteString -> Either Bech32DecodeError SomeAddressVerificationKey
deserialiseAnyVerificationKeyTextEnvelope :: ByteString -> Either TextEnvelopeError SomeAddressVerificationKey
deserialiseInput :: NonEmpty (InputFormat a) -> ByteString -> Either InputDecodeError a
deserialiseInputAnyOf :: [FromSomeType SerialiseAsBech32 b] -> [FromSomeType HasTextEnvelope b] -> ByteString -> Either InputDecodeError b
mapSomeAddressVerificationKey :: (forall keyrole. Key keyrole => VerificationKey keyrole -> a) -> SomeAddressVerificationKey -> a
renderInputDecodeError :: InputDecodeError -> Doc ann
renderSomeAddressVerificationKey :: SomeAddressVerificationKey -> Text
alonzoEraOnwardsConstraints :: AlonzoEraOnwards era -> (AlonzoEraOnwardsConstraints era => a) -> a
alonzoEraOnwardsToShelleyBasedEra :: AlonzoEraOnwards era -> ShelleyBasedEra era
babbageEraOnwardsConstraints :: BabbageEraOnwards era -> (BabbageEraOnwardsConstraints era => a) -> a
babbageEraOnwardsToShelleyBasedEra :: BabbageEraOnwards era -> ShelleyBasedEra era
byronToAlonzoEraConstraints :: ByronToAlonzoEra era -> (ByronToAlonzoEraConstraints era => a) -> a
conwayEraOnwardsConstraints :: ConwayEraOnwards era -> (ConwayEraOnwardsConstraints era => a) -> a
conwayEraOnwardsToBabbageEraOnwards :: ConwayEraOnwards era -> BabbageEraOnwards era
conwayEraOnwardsToShelleyBasedEra :: ConwayEraOnwards era -> ShelleyBasedEra era
maryEraOnwardsConstraints :: MaryEraOnwards era -> (MaryEraOnwardsConstraints era => a) -> a
maryEraOnwardsToShelleyBasedEra :: MaryEraOnwards era -> ShelleyBasedEra era
forShelleyBasedEraInEon :: Eon eon => ShelleyBasedEra era -> a -> (eon era -> a) -> a
forShelleyBasedEraInEonMaybe :: Eon eon => ShelleyBasedEra era -> (eon era -> a) -> Maybe a
forShelleyBasedEraMaybeEon :: Eon eon => ShelleyBasedEra era -> Maybe (eon era)
inAnyShelleyBasedEra :: ShelleyBasedEra era -> thing era -> InAnyShelleyBasedEra thing
inEonForShelleyBasedEra :: Eon eon => a -> (eon era -> a) -> ShelleyBasedEra era -> a
inEonForShelleyBasedEraMaybe :: Eon eon => (eon era -> a) -> ShelleyBasedEra era -> Maybe a
requireShelleyBasedEra :: Applicative m => CardanoEra era -> m (Maybe (ShelleyBasedEra era))
shelleyBasedEraConstraints :: ShelleyBasedEra era -> (ShelleyBasedEraConstraints era => a) -> a
shelleyEraOnlyConstraints :: ShelleyEraOnly era -> (ShelleyEraOnlyConstraints era => a) -> a
shelleyEraOnlyToShelleyBasedEra :: ShelleyEraOnly era -> ShelleyBasedEra era
shelleyToAllegraEraConstraints :: ShelleyToAllegraEra era -> (ShelleyToAllegraEraConstraints era => a) -> a
shelleyToAllegraEraToShelleyBasedEra :: ShelleyToAllegraEra era -> ShelleyBasedEra era
shelleyToAlonzoEraConstraints :: ShelleyToAlonzoEra era -> (ShelleyToAlonzoEraConstraints era => a) -> a
shelleyToAlonzoEraToShelleyBasedEra :: ShelleyToAlonzoEra era -> ShelleyBasedEra era
shelleyToBabbageEraConstraints :: ShelleyToBabbageEra era -> (ShelleyToBabbageEraConstraints era => a) -> a
shelleyToBabbageEraToShelleyBasedEra :: ShelleyToBabbageEra era -> ShelleyBasedEra era
shelleyToMaryEraConstraints :: ShelleyToMaryEra era -> (ShelleyToMaryEraConstraints era => a) -> a
shelleyToMaryEraToShelleyBasedEra :: ShelleyToMaryEra era -> ShelleyBasedEra era
alonzoEraOnwardsToMaryEraOnwards :: AlonzoEraOnwards era -> MaryEraOnwards era
babbageEraOnwardsToAlonzoEraOnwards :: BabbageEraOnwards era -> AlonzoEraOnwards era
babbageEraOnwardsToMaryEraOnwards :: BabbageEraOnwards era -> MaryEraOnwards era
caseByronOrShelleyBasedEra :: a -> (ShelleyBasedEraConstraints era => ShelleyBasedEra era -> a) -> CardanoEra era -> a
caseByronToAlonzoOrBabbageEraOnwards :: (ByronToAlonzoEraConstraints era => ByronToAlonzoEra era -> a) -> (BabbageEraOnwardsConstraints era => BabbageEraOnwards era -> a) -> CardanoEra era -> a
caseShelleyEraOnlyOrAllegraEraOnwards :: (ShelleyEraOnlyConstraints era => ShelleyEraOnly era -> a) -> (AllegraEraOnwardsConstraints era => AllegraEraOnwards era -> a) -> ShelleyBasedEra era -> a
caseShelleyToAllegraOrMaryEraOnwards :: (ShelleyToAllegraEraConstraints era => ShelleyToAllegraEra era -> a) -> (MaryEraOnwardsConstraints era => MaryEraOnwards era -> a) -> ShelleyBasedEra era -> a
caseShelleyToAlonzoOrBabbageEraOnwards :: (ShelleyToAlonzoEraConstraints era => ShelleyToAlonzoEra era -> a) -> (BabbageEraOnwardsConstraints era => BabbageEraOnwards era -> a) -> ShelleyBasedEra era -> a
caseShelleyToBabbageOrConwayEraOnwards :: (ShelleyToBabbageEraConstraints era => ShelleyToBabbageEra era -> a) -> (ConwayEraOnwardsConstraints era => ConwayEraOnwards era -> a) -> ShelleyBasedEra era -> a
caseShelleyToMaryOrAlonzoEraOnwards :: (ShelleyToMaryEraConstraints era => ShelleyToMaryEra era -> a) -> (AlonzoEraOnwardsConstraints era => AlonzoEraOnwards era -> a) -> ShelleyBasedEra era -> a
shelleyToAlonzoEraToShelleyToBabbageEra :: ShelleyToAlonzoEra era -> ShelleyToBabbageEra era
anyCardanoEra :: CardanoEra era -> AnyCardanoEra
cardanoEraConstraints :: CardanoEra era -> (CardanoEraConstraints era => a) -> a
forEraInEon :: Eon eon => CardanoEra era -> a -> (eon era -> a) -> a
forEraInEonMaybe :: Eon eon => CardanoEra era -> (eon era -> a) -> Maybe a
forEraMaybeEon :: Eon eon => CardanoEra era -> Maybe (eon era)
inAnyCardanoEra :: CardanoEra era -> thing era -> InAnyCardanoEra thing
inEonForEraMaybe :: Eon eon => (eon era -> a) -> CardanoEra era -> Maybe a
maybeEon :: (Eon eon, IsCardanoEra era) => Maybe (eon era)
monoidForEraInEon :: (Eon eon, Monoid a) => CardanoEra era -> (eon era -> a) -> a
monoidForEraInEonA :: (Eon eon, Applicative f, Monoid a) => CardanoEra era -> (eon era -> f a) -> f a
throwErrorAsException :: Error e => e -> IO a
asFeaturedInEra :: forall (eon :: Type -> Type) a era. Eon eon => a -> CardanoEra era -> Maybe (Featured eon era a)
asFeaturedInShelleyBasedEra :: forall (eon :: Type -> Type) a era. Eon eon => a -> ShelleyBasedEra era -> Maybe (Featured eon era a)
mkFeatured :: forall (eon :: Type -> Type) era a. (IsCardanoEra era, Eon eon) => a -> Maybe (Featured eon era a)
unFeatured :: forall (eon :: Type -> Type) era a. Featured eon era a -> a
calculateMinTxFee :: ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> UTxO era -> TxBody era -> Word -> Coin
calculateMinimumUTxO :: HasCallStack => ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> TxOut CtxTx era -> Coin
estimateBalancedTxBody :: HasCallStack => MaryEraOnwards era -> TxBodyContent BuildTx era -> PParams (ShelleyLedgerEra era) -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> Map ScriptWitnessIndex ExecutionUnits -> Coin -> Int -> Int -> Int -> AddressInEra era -> Value -> Either (TxFeeEstimationError era) (BalancedTxBody era)
estimateOrCalculateBalancedTxBody :: ShelleyBasedEra era -> FeeEstimationMode era -> PParams (ShelleyLedgerEra era) -> TxBodyContent BuildTx era -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> AddressInEra era -> Either (AutoBalanceError era) (BalancedTxBody era)
estimateTransactionKeyWitnessCount :: TxBodyContent BuildTx era -> Word
evaluateTransactionBalance :: ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> UTxO era -> TxBody era -> TxOutValue era
evaluateTransactionExecutionUnits :: CardanoEra era -> SystemStart -> LedgerEpochInfo -> LedgerProtocolParameters era -> UTxO era -> TxBody era -> Map ScriptWitnessIndex (Either ScriptExecutionError (EvalTxExecutionUnitsLog, ExecutionUnits))
evaluateTransactionFee :: ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> TxBody era -> Word -> Word -> Int -> Coin
makeTransactionBodyAutoBalance :: HasCallStack => ShelleyBasedEra era -> SystemStart -> LedgerEpochInfo -> LedgerProtocolParameters era -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> UTxO era -> TxBodyContent BuildTx era -> AddressInEra era -> Maybe Word -> Either (TxBodyErrorAutoBalance era) (BalancedTxBody era)
getAnchorDataFromGovernanceAction :: GovAction (ShelleyLedgerEra era) -> Maybe Anchor
validateGovActionAnchorData :: FromJSON (GovActionMetadata cip) => cip -> ByteString -> Either String ()
asType :: HasTypeProxy t => AsType t
castHash :: CastHash roleA roleB => Hash roleA -> Hash roleB
renderSafeHashAsHex :: SafeHash tag -> Text
intoFile :: File content 'Out -> content -> (File content 'Out -> stream -> result) -> (content -> stream) -> result
mapFile :: forall content (direction :: FileDirection). (FilePath -> FilePath) -> File content direction -> File content direction
onlyIn :: File content 'InOut -> File content 'In
onlyOut :: File content 'InOut -> File content 'Out
readByteStringFile :: MonadIO m => File content 'In -> m (Either (FileError e) ByteString)
readLazyByteStringFile :: MonadIO m => File content 'In -> m (Either (FileError e) ByteString)
readTextFile :: MonadIO m => File content 'In -> m (Either (FileError e) Text)
writeByteStringFile :: MonadIO m => File content 'Out -> ByteString -> m (Either (FileError e) ())
writeByteStringFileWithOwnerPermissions :: FilePath -> ByteString -> IO (Either (FileError e) ())
writeByteStringOutput :: MonadIO m => Maybe (File content 'Out) -> ByteString -> m (Either (FileError e) ())
writeLazyByteStringFile :: MonadIO m => File content 'Out -> ByteString -> m (Either (FileError e) ())
writeLazyByteStringFileWithOwnerPermissions :: File content 'Out -> ByteString -> IO (Either (FileError e) ())
writeLazyByteStringOutput :: MonadIO m => Maybe (File content 'Out) -> ByteString -> m (Either (FileError e) ())
writeTextFile :: MonadIO m => File content 'Out -> Text -> m (Either (FileError e) ())
writeTextFileWithOwnerPermissions :: File content 'Out -> Text -> IO (Either (FileError e) ())
writeTextOutput :: MonadIO m => Maybe (File content 'Out) -> Text -> m (Either (FileError e) ())
writeSecrets :: FilePath -> [Char] -> [Char] -> (a -> ByteString) -> [a] -> IO ()
connectToLocalNode :: MonadIO m => LocalNodeConnectInfo -> LocalNodeClientProtocolsInMode -> m ()
connectToLocalNodeWithVersion :: MonadIO m => LocalNodeConnectInfo -> (NodeToClientVersion -> LocalNodeClientProtocolsInMode) -> m ()
getLocalChainTip :: MonadIO m => LocalNodeConnectInfo -> m ChainTip
mkLocalNodeClientParams :: ConsensusModeParams -> (NodeToClientVersion -> LocalNodeClientProtocolsInMode) -> LocalNodeClientParams
queryNodeLocalState :: LocalNodeConnectInfo -> Target ChainPoint -> QueryInMode result -> ExceptT AcquiringFailure IO result
queryTxMonitoringLocal :: MonadIO m => LocalNodeConnectInfo -> LocalTxMonitoringQuery -> m LocalTxMonitoringResult
submitTxToNodeLocal :: MonadIO m => LocalNodeConnectInfo -> TxInMode -> m (SubmitResult TxValidationErrorInCardanoMode)
executeLocalStateQueryExpr :: LocalNodeConnectInfo -> Target ChainPoint -> LocalStateQueryExpr BlockInMode ChainPoint QueryInMode () IO a -> IO (Either AcquiringFailure a)
queryExpr :: QueryInMode a -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError a)
castSigningKey :: CastSigningKeyRole keyroleA keyroleB => SigningKey keyroleA -> SigningKey keyroleB
castVerificationKey :: CastVerificationKeyRole keyroleA keyroleB => VerificationKey keyroleA -> VerificationKey keyroleB
generateInsecureSigningKey :: (MonadIO m, Key keyrole, SerialiseAsRawBytes (SigningKey keyrole)) => StdGen -> AsType keyrole -> m (SigningKey keyrole, StdGen)
generateSigningKey :: (MonadIO m, Key keyrole) => AsType keyrole -> m (SigningKey keyrole)
autocompleteMnemonicPrefix :: Text -> Maybe Text
findMnemonicWordsWithPrefix :: Text -> [(Text, Int)]
generateMnemonic :: MonadIO m => MnemonicSize -> m [Text]
signingKeyFromMnemonic :: SigningKeyFromRootKey keyrole => AsType keyrole -> [Text] -> Word32 -> Either MnemonicToSigningKeyError (SigningKey keyrole)
signingKeyFromMnemonicWithPaymentKeyIndex :: IndexedSigningKeyFromRootKey keyrole => AsType keyrole -> [Text] -> Word32 -> Word32 -> Either MnemonicToSigningKeyError (SigningKey keyrole)
readKeyFile :: NonEmpty (InputFormat a) -> FilePath -> IO (Either (FileError InputDecodeError) a)
readKeyFileAnyOf :: forall content b. [FromSomeType SerialiseAsBech32 b] -> [FromSomeType HasTextEnvelope b] -> File content 'In -> IO (Either (FileError InputDecodeError) b)
readKeyFileTextEnvelope :: HasTextEnvelope a => File content 'In -> IO (Either (FileError InputDecodeError) a)
applyBlock :: Env -> LedgerState -> ValidationMode -> BlockInMode -> Either LedgerStateError (LedgerState, [LedgerEvent])
chainSyncClientPipelinedWithLedgerState :: forall (m :: Type -> Type) a. Monad m => Env -> LedgerState -> ValidationMode -> ChainSyncClientPipelined (BlockInMode, Either LedgerStateError (LedgerState, [LedgerEvent])) ChainPoint ChainTip m a -> ChainSyncClientPipelined BlockInMode ChainPoint ChainTip m a
chainSyncClientWithLedgerState :: forall (m :: Type -> Type) a. Monad m => Env -> LedgerState -> ValidationMode -> ChainSyncClient (BlockInMode, Either LedgerStateError (LedgerState, [LedgerEvent])) ChainPoint ChainTip m a -> ChainSyncClient BlockInMode ChainPoint ChainTip m a
decodeLedgerState :: Decoder s LedgerState
encodeLedgerState :: LedgerState -> Encoding
envSecurityParam :: Env -> Word64
foldBlocks :: forall a t (m :: Type -> Type). (Show a, MonadIOTransError FoldBlocksError t m) => NodeConfigFile 'In -> SocketPath -> ValidationMode -> a -> (Env -> LedgerState -> [LedgerEvent] -> BlockInMode -> a -> IO (a, FoldStatus)) -> t m a
foldEpochState :: forall t (m :: Type -> Type) s. MonadIOTransError FoldBlocksError t m => NodeConfigFile 'In -> SocketPath -> ValidationMode -> EpochNo -> s -> (AnyNewEpochState -> SlotNo -> BlockNo -> StateT s IO ConditionResult) -> t m (ConditionResult, s)
fromConditionResult :: ConditionResult -> Bool
genesisConfigToEnv :: GenesisConfig -> Either GenesisConfigError Env
getAnyNewEpochState :: ShelleyBasedEra era -> LedgerState -> Either LedgerStateError AnyNewEpochState
getLedgerTablesUTxOValues :: ShelleyBasedEra era -> LedgerTables (LedgerState (CardanoBlock StandardCrypto)) ValuesMK -> Map TxIn (TxOut CtxUTxO era)
initialLedgerState :: forall t (m :: Type -> Type). MonadIOTransError InitialLedgerStateError t m => NodeConfigFile 'In -> t m (Env, LedgerState)
mkProtocolInfoCardano :: GenesisConfig -> (ProtocolInfo (CardanoBlock StandardCrypto), IO [BlockForging IO (CardanoBlock StandardCrypto)])
readAlonzoGenesisConfig :: forall t (m :: Type -> Type) era. MonadIOTransError GenesisConfigError t m => Maybe (CardanoEra era) -> NodeConfig -> t m AlonzoGenesis
readByronGenesisConfig :: forall t (m :: Type -> Type). MonadIOTransError GenesisConfigError t m => NodeConfig -> t m Config
readCardanoGenesisConfig :: forall t (m :: Type -> Type) era. MonadIOTransError GenesisConfigError t m => Maybe (CardanoEra era) -> NodeConfig -> t m GenesisConfig
readConwayGenesisConfig :: forall t (m :: Type -> Type). MonadIOTransError GenesisConfigError t m => NodeConfig -> t m ConwayGenesis
readNodeConfig :: (MonadError Text m, MonadIO m) => NodeConfigFile 'In -> m NodeConfig
readShelleyGenesisConfig :: forall t (m :: Type -> Type). MonadIOTransError GenesisConfigError t m => NodeConfig -> t m ShelleyConfig
shelleyPraosNonce :: GenesisHashShelley -> Nonce
toConditionResult :: Bool -> ConditionResult
handleIOExceptionsLiftWith :: (MonadIOTransError e' t m, Exception e) => (e -> e') -> m a -> t m a
handleIOExceptionsWith :: (MonadError e' m, MonadCatch m, Exception e) => (e -> e') -> m a -> m a
hoistIOEither :: forall e t (m :: Type -> Type) a. MonadIOTransError e t m => IO (Either e a) -> t m a
liftExceptT :: forall e t (m :: Type -> Type) a. MonadTransError e t m => ExceptT e m a -> t m a
liftMaybe :: MonadError e m => e -> Maybe a -> m a
fromNetworkMagic :: NetworkMagic -> NetworkId
toNetworkMagic :: NetworkId -> NetworkMagic
getHotKey :: OperationalCertificate -> VerificationKey KesKey
getKesPeriod :: OperationalCertificate -> Word
getOpCertCount :: OperationalCertificate -> Word64
issueOperationalCertificate :: VerificationKey KesKey -> Either AnyStakePoolSigningKey (SigningKey GenesisDelegateExtendedKey) -> KESPeriod -> OperationalCertificateIssueCounter -> Either OperationalCertIssueError (OperationalCertificate, OperationalCertificateIssueCounter)
collectPlutusScriptHashes :: AlonzoEraOnwards era -> Tx era -> UTxO era -> Map ScriptWitnessIndex ScriptHash
renderDebugPlutusFailure :: DebugPlutusFailure -> Text
black :: Doc AnsiStyle -> Doc AnsiStyle
cyan :: Doc AnsiStyle -> Doc AnsiStyle
docToLazyText :: Doc AnsiStyle -> Text
docToString :: Doc AnsiStyle -> String
docToText :: Doc AnsiStyle -> Text
magenta :: Doc AnsiStyle -> Doc AnsiStyle
prettyException :: Exception a => a -> Doc ann
pshow :: Show a => a -> Doc ann
white :: Doc AnsiStyle -> Doc AnsiStyle
yellow :: Doc AnsiStyle -> Doc AnsiStyle
reflBlockType :: BlockType blk -> BlockType blk' -> Maybe (blk :~: blk')
fromAlonzoCostModel :: CostModel -> CostModel
makePraosNonce :: ByteString -> PraosNonce
makeShelleyUpdateProposal :: ProtocolParametersUpdate -> [Hash GenesisKey] -> EpochNo -> UpdateProposal
toAlonzoCostModel :: CostModel -> Language -> Either ProtocolParametersConversionError CostModel
toAlonzoCostModels :: Map AnyPlutusScriptVersion CostModel -> Either ProtocolParametersConversionError CostModels
getProgress :: SlotNo -> EraHistory -> Either PastHorizonException (RelativeTime, SlotLength)
getSlotForRelativeTime :: RelativeTime -> EraHistory -> Either PastHorizonException SlotNo
slotToEpoch :: SlotNo -> EraHistory -> Either PastHorizonException (EpochNo, SlotsInEpoch, SlotsToEpochEnd)
toLedgerEpochInfo :: EraHistory -> LedgerEpochInfo
queryAccountState :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch AccountState))
queryChainBlockNo :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (WithOrigin BlockNo))
queryChainPoint :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError ChainPoint)
queryCommitteeMembersState :: ConwayEraOnwards era -> Set (Credential 'ColdCommitteeRole) -> Set (Credential 'HotCommitteeRole) -> Set MemberStatus -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch CommitteeMembersState))
queryConstitution :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Constitution (ShelleyLedgerEra era))))
queryConstitutionHash :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SafeHash AnchorData)))
queryCurrentEpochState :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedCurrentEpochState era)))
queryCurrentEra :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError AnyCardanoEra)
queryDRepStakeDistribution :: ConwayEraOnwards era -> Set DRep -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map DRep Coin)))
queryDRepState :: ConwayEraOnwards era -> Set (Credential 'DRepRole) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map (Credential 'DRepRole) DRepState)))
queryDebugLedgerState :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedDebugLedgerState era)))
queryEpoch :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch EpochNo))
queryFuturePParams :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Maybe (PParams (ShelleyLedgerEra era)))))
queryGenesisParameters :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (GenesisParameters ShelleyEra)))
queryGovState :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (GovState (ShelleyLedgerEra era))))
queryLedgerConfig :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (CardanoLedgerConfig StandardCrypto))
queryLedgerPeerSnapshot :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Serialised LedgerPeerSnapshot)))
queryPoolDistribution :: BabbageEraOnwards era -> Maybe (Set PoolId) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedPoolDistribution era)))
queryPoolState :: BabbageEraOnwards era -> Maybe (Set PoolId) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedPoolState era)))
queryProposals :: ConwayEraOnwards era -> Set GovActionId -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Seq (GovActionState (ShelleyLedgerEra era)))))
queryProtocolState :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (ProtocolState era)))
queryRatifyState :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (RatifyState (ShelleyLedgerEra era))))
querySPOStakeDistribution :: ConwayEraOnwards era -> Set (KeyHash 'StakePool) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map (KeyHash 'StakePool) Coin)))
queryStakeAddresses :: ShelleyBasedEra era -> Set StakeCredential -> NetworkId -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map StakeAddress Coin, Map StakeAddress PoolId)))
queryStakeDelegDeposits :: BabbageEraOnwards era -> Set StakeCredential -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map StakeCredential Coin)))
queryStakeDistribution :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map (Hash StakePoolKey) Rational)))
queryStakePoolDefaultVote :: ConwayEraOnwards era -> KeyHash 'StakePool -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch DefaultVote))
queryStakePoolParameters :: ShelleyBasedEra era -> Set PoolId -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map PoolId StakePoolParameters)))
queryStakeSnapshot :: BabbageEraOnwards era -> Maybe (Set PoolId) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedStakeSnapshots era)))
queryStakeVoteDelegatees :: ConwayEraOnwards era -> Set StakeCredential -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map StakeCredential DRep)))
queryUtxo :: ShelleyBasedEra era -> QueryUTxOFilter -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (UTxO era)))
mergeDelegsAndRewards :: DelegationsAndRewards -> [(StakeAddress, Maybe Coin, Maybe PoolId)]
eraOfScriptInEra :: ScriptInEra era -> ShelleyBasedEra era
eraOfScriptLanguageInEra :: ScriptLanguageInEra lang era -> ShelleyBasedEra era
examplePlutusScriptAlwaysFails :: WitCtx witctx -> PlutusScript PlutusScriptV1
examplePlutusScriptAlwaysSucceeds :: WitCtx witctx -> PlutusScript PlutusScriptV1
getScriptWitnessReferenceInput :: ScriptWitness witctx era -> Maybe TxIn
getScriptWitnessReferenceInputOrScript :: ScriptWitness witctx era -> Either (ScriptInEra era) TxIn
getScriptWitnessScript :: ScriptWitness witctx era -> Maybe (ScriptInEra era)
hashScript :: Script lang -> ScriptHash
languageOfScriptLanguageInEra :: ScriptLanguageInEra lang era -> ScriptLanguage lang
sbeToSimpleScriptLanguageInEra :: ShelleyBasedEra era -> ScriptLanguageInEra SimpleScript' era
toScriptInAnyLang :: Script lang -> ScriptInAnyLang
toScriptInEra :: ShelleyBasedEra era -> ScriptInAnyLang -> Maybe (ScriptInEra era)
getOriginalScriptDataBytes :: HashableScriptData -> ByteString
getScriptData :: HashableScriptData -> ScriptData
hashScriptDataBytes :: HashableScriptData -> Hash ScriptData
scriptDataFromJson :: ScriptDataJsonSchema -> Value -> Either ScriptDataJsonError HashableScriptData
scriptDataJsonToHashable :: ScriptDataJsonSchema -> Value -> Either ScriptDataJsonBytesError HashableScriptData
scriptDataToJson :: ScriptDataJsonSchema -> HashableScriptData -> Value
unsafeHashableScriptData :: ScriptData -> HashableScriptData
validateScriptData :: ScriptData -> Either ScriptDataRangeError ()
deserialiseAnyOfFromBech32 :: [FromSomeType SerialiseAsBech32 b] -> Text -> Either Bech32DecodeError b
deserialiseFromBech32 :: SerialiseAsBech32 a => Text -> Either Bech32DecodeError a
serialiseToBech32 :: SerialiseAsBech32 a => a -> Text
deserialiseFromJSON :: FromJSON a => ByteString -> Either JsonDecodeError a
prettyPrintJSON :: ToJSON a => a -> ByteString
readFileJSON :: FromJSON a => FilePath -> IO (Either (FileError JsonDecodeError) a)
serialiseToJSON :: ToJSON a => a -> ByteString
writeFileJSON :: ToJSON a => FilePath -> a -> IO (Either (FileError ()) ())
deserialiseByronTxCddl :: TextEnvelope -> Either TextEnvelopeCddlError (ATxAux ByteString)
deserialiseFromTextEnvelopeCddlAnyOf :: [FromSomeTypeCDDL TextEnvelope b] -> TextEnvelope -> Either TextEnvelopeCddlError b
deserialiseWitnessLedgerCddl :: ShelleyBasedEra era -> TextEnvelope -> Either TextEnvelopeCddlError (KeyWitness era)
readFileTextEnvelopeCddlAnyOf :: [FromSomeTypeCDDL TextEnvelope b] -> FilePath -> IO (Either (FileError TextEnvelopeCddlError) b)
serialiseWitnessLedgerCddl :: ShelleyBasedEra era -> KeyWitness era -> TextEnvelope
writeTxFileTextEnvelopeCanonicalCddl :: ShelleyBasedEra era -> File content 'Out -> Tx era -> IO (Either (FileError ()) ())
writeTxFileTextEnvelopeCddl :: ShelleyBasedEra era -> File content 'Out -> Tx era -> IO (Either (FileError ()) ())
writeTxWitnessFileTextEnvelopeCddl :: ShelleyBasedEra era -> File () 'Out -> KeyWitness era -> IO (Either (FileError ()) ())
deserialiseFromRawBytesHex :: SerialiseAsRawBytes a => ByteString -> Either RawBytesHexError a
serialiseToRawBytesHex :: SerialiseAsRawBytes a => a -> ByteString
serialiseToRawBytesHexText :: SerialiseAsRawBytes a => a -> Text
deserialiseFromTextEnvelope :: HasTextEnvelope a => TextEnvelope -> Either TextEnvelopeError a
deserialiseFromTextEnvelopeAnyOf :: [FromSomeType HasTextEnvelope b] -> TextEnvelope -> Either TextEnvelopeError b
readFileTextEnvelope :: HasTextEnvelope a => File content 'In -> IO (Either (FileError TextEnvelopeError) a)
readFileTextEnvelopeAnyOf :: [FromSomeType HasTextEnvelope b] -> File content 'In -> IO (Either (FileError TextEnvelopeError) b)
readTextEnvelopeFromFile :: FilePath -> IO (Either (FileError TextEnvelopeError) TextEnvelope)
readTextEnvelopeOfTypeFromFile :: TextEnvelopeType -> FilePath -> IO (Either (FileError TextEnvelopeError) TextEnvelope)
serialiseToTextEnvelope :: HasTextEnvelope a => Maybe TextEnvelopeDescr -> a -> TextEnvelope
textEnvelopeRawCBOR :: TextEnvelope -> ByteString
textEnvelopeToJSON :: HasTextEnvelope a => Maybe TextEnvelopeDescr -> a -> ByteString
textEnvelopeTypeInEra :: HasTextEnvelope (f era) => CardanoEra era -> AsType (f era) -> TextEnvelopeType
writeFileTextEnvelope :: HasTextEnvelope a => File content 'Out -> Maybe TextEnvelopeDescr -> a -> IO (Either (FileError ()) ())
validateAndHashStakePoolMetadata :: ByteString -> Either StakePoolMetadataValidationError (StakePoolMetadata, Hash StakePoolMetadata)
addTxExtraKeyWits :: IsAlonzoBasedEra era => [Hash PaymentKey] -> TxBodyContent build era -> TxBodyContent build era
addTxIn :: (TxIn, BuildTxWith build (Witness WitCtxTxIn era)) -> TxBodyContent build era -> TxBodyContent build era
addTxInCollateral :: IsAlonzoBasedEra era => TxIn -> TxBodyContent build era -> TxBodyContent build era
addTxInReference :: (Applicative (BuildTxWith build), IsBabbageBasedEra era) => TxIn -> Maybe HashableScriptData -> TxBodyContent build era -> TxBodyContent build era
addTxIns :: TxIns build era -> TxBodyContent build era -> TxBodyContent build era
addTxInsCollateral :: IsAlonzoBasedEra era => [TxIn] -> TxBodyContent build era -> TxBodyContent build era
addTxInsReference :: (Applicative (BuildTxWith build), IsBabbageBasedEra era) => [TxIn] -> Set HashableScriptData -> TxBodyContent build era -> TxBodyContent build era
addTxMintValue :: IsMaryBasedEra era => Map PolicyId (PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era)) -> TxBodyContent build era -> TxBodyContent build era
addTxOut :: TxOut CtxTx era -> TxBodyContent build era -> TxBodyContent build era
addTxOuts :: [TxOut CtxTx era] -> TxBodyContent build era -> TxBodyContent build era
collectTxBodyScriptWitnesses :: ShelleyBasedEra era -> TxBodyContent BuildTx era -> [(ScriptWitnessIndex, AnyScriptWitness era)]
convProposalProcedures :: TxProposalProcedures build era -> OSet (ProposalProcedure (ShelleyLedgerEra era))
createTransactionBody :: HasCallStack => ShelleyBasedEra era -> TxBodyContent BuildTx era -> Either TxBodyError (TxBody era)
defaultTxFee :: ShelleyBasedEra era -> TxFee era
defaultTxValidityUpperBound :: ShelleyBasedEra era -> TxValidityUpperBound era
genesisUTxOPseudoTxIn :: NetworkId -> Hash GenesisUTxOKey -> TxIn
getReferenceInputsSizeForTxIds :: ShelleyLedgerEra era ~ ledgerera => BabbageEraOnwards era -> UTxO ledgerera -> Set TxIn -> Int
getTxBodyContent :: TxBody era -> TxBodyContent ViewTx era
getTxId :: TxBody era -> TxId
getTxIdByron :: ATxAux ByteString -> TxId
indexTxMintValue :: TxMintValue build era -> [(ScriptWitnessIndex, PolicyId, PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era))]
makeByronTransactionBody :: TxIns BuildTx ByronEra -> [TxOut CtxTx ByronEra] -> Either TxBodyError (Annotated Tx ByteString)
mkTxCertificates :: Applicative (BuildTxWith build) => ShelleyBasedEra era -> [(Certificate era, Maybe (ScriptWitness WitCtxStake era))] -> TxCertificates build era
mkTxMintValue :: MaryEraOnwards era -> [(PolicyId, PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era))] -> TxMintValue build era
mkTxProposalProcedures :: forall era build. (Applicative (BuildTxWith build), IsShelleyBasedEra era) => [(ProposalProcedure (ShelleyLedgerEra era), Maybe (ScriptWitness WitCtxStake era))] -> TxProposalProcedures build era
mkTxVotingProcedures :: Applicative (BuildTxWith build) => [(VotingProcedures era, Maybe (ScriptWitness WitCtxStake era))] -> Either (VotesMergingConflict era) (TxVotingProcedures build era)
modTxAuxScripts :: (TxAuxScripts era -> TxAuxScripts era) -> TxBodyContent build era -> TxBodyContent build era
modTxCertificates :: (TxCertificates build era -> TxCertificates build era) -> TxBodyContent build era -> TxBodyContent build era
modTxExtraKeyWits :: (TxExtraKeyWitnesses era -> TxExtraKeyWitnesses era) -> TxBodyContent build era -> TxBodyContent build era
modTxFee :: (TxFee era -> TxFee era) -> TxBodyContent build era -> TxBodyContent build era
modTxIns :: (TxIns build era -> TxIns build era) -> TxBodyContent build era -> TxBodyContent build era
modTxInsCollateral :: (TxInsCollateral era -> TxInsCollateral era) -> TxBodyContent build era -> TxBodyContent build era
modTxInsReference :: (TxInsReference build era -> TxInsReference build era) -> TxBodyContent build era -> TxBodyContent build era
modTxMetadata :: (TxMetadataInEra era -> TxMetadataInEra era) -> TxBodyContent build era -> TxBodyContent build era
modTxMintValue :: (TxMintValue build era -> TxMintValue build era) -> TxBodyContent build era -> TxBodyContent build era
modTxOuts :: ([TxOut CtxTx era] -> [TxOut CtxTx era]) -> TxBodyContent build era -> TxBodyContent build era
modTxReturnCollateral :: (TxReturnCollateral CtxTx era -> TxReturnCollateral CtxTx era) -> TxBodyContent build era -> TxBodyContent build era
modTxScriptValidity :: (TxScriptValidity era -> TxScriptValidity era) -> TxBodyContent build era -> TxBodyContent build era
modTxTotalCollateral :: (TxTotalCollateral era -> TxTotalCollateral era) -> TxBodyContent build era -> TxBodyContent build era
modTxUpdateProposal :: (TxUpdateProposal era -> TxUpdateProposal era) -> TxBodyContent build era -> TxBodyContent build era
modTxValidityLowerBound :: (TxValidityLowerBound era -> TxValidityLowerBound era) -> TxBodyContent build era -> TxBodyContent build era
modTxValidityUpperBound :: (TxValidityUpperBound era -> TxValidityUpperBound era) -> TxBodyContent build era -> TxBodyContent build era
modTxWithdrawals :: (TxWithdrawals build era -> TxWithdrawals build era) -> TxBodyContent build era -> TxBodyContent build era
renderScriptWitnessIndex :: ScriptWitnessIndex -> String
setTxAuxScripts :: TxAuxScripts era -> TxBodyContent build era -> TxBodyContent build era
setTxCertificates :: TxCertificates build era -> TxBodyContent build era -> TxBodyContent build era
setTxCurrentTreasuryValue :: Maybe (Featured ConwayEraOnwards era (Maybe Coin)) -> TxBodyContent build era -> TxBodyContent build era
setTxExtraKeyWits :: TxExtraKeyWitnesses era -> TxBodyContent build era -> TxBodyContent build era
setTxFee :: TxFee era -> TxBodyContent build era -> TxBodyContent build era
setTxIns :: TxIns build era -> TxBodyContent build era -> TxBodyContent build era
setTxInsCollateral :: TxInsCollateral era -> TxBodyContent build era -> TxBodyContent build era
setTxInsReference :: TxInsReference build era -> TxBodyContent build era -> TxBodyContent build era
setTxMetadata :: TxMetadataInEra era -> TxBodyContent build era -> TxBodyContent build era
setTxMintValue :: TxMintValue build era -> TxBodyContent build era -> TxBodyContent build era
setTxOuts :: [TxOut CtxTx era] -> TxBodyContent build era -> TxBodyContent build era
setTxProposalProcedures :: Maybe (Featured ConwayEraOnwards era (TxProposalProcedures build era)) -> TxBodyContent build era -> TxBodyContent build era
setTxProtocolParams :: BuildTxWith build (Maybe (LedgerProtocolParameters era)) -> TxBodyContent build era -> TxBodyContent build era
setTxReturnCollateral :: TxReturnCollateral CtxTx era -> TxBodyContent build era -> TxBodyContent build era
setTxScriptValidity :: TxScriptValidity era -> TxBodyContent build era -> TxBodyContent build era
setTxTotalCollateral :: TxTotalCollateral era -> TxBodyContent build era -> TxBodyContent build era
setTxTreasuryDonation :: Maybe (Featured ConwayEraOnwards era Coin) -> TxBodyContent build era -> TxBodyContent build era
setTxUpdateProposal :: TxUpdateProposal era -> TxBodyContent build era -> TxBodyContent build era
setTxValidityLowerBound :: TxValidityLowerBound era -> TxBodyContent build era -> TxBodyContent build era
setTxValidityUpperBound :: TxValidityUpperBound era -> TxBodyContent build era -> TxBodyContent build era
setTxVotingProcedures :: Maybe (Featured ConwayEraOnwards era (TxVotingProcedures build era)) -> TxBodyContent build era -> TxBodyContent build era
setTxWithdrawals :: TxWithdrawals build era -> TxBodyContent build era -> TxBodyContent build era
subtractTxMintValue :: IsMaryBasedEra era => Map PolicyId (PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era)) -> TxBodyContent build era -> TxBodyContent build era
txMintValueToValue :: TxMintValue build era -> Value
buildTxWithToMaybe :: BuildTxWith build a -> Maybe a
fromCtxUTxOTxOut :: TxOut CtxUTxO era -> TxOut CtxTx era
fromLedgerTxOuts :: ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> TxBodyScriptData era -> [TxOut CtxTx era]
parseHash :: SerialiseAsRawBytes (Hash a) => Parser (Hash a)
toCtxUTxOTxOut :: TxOut CtxTx era -> TxOut CtxUTxO era
txOutInAnyEra :: CardanoEra era -> TxOut CtxTx era -> TxOutInAnyEra
txOutValueToLovelace :: TxOutValue era -> Coin
getTxBody :: Tx era -> TxBody era
getTxWitnesses :: Tx era -> [KeyWitness era]
makeByronKeyWitness :: IsByronKey key => NetworkId -> Annotated Tx ByteString -> SigningKey key -> KeyWitness ByronEra
makeShelleyBasedBootstrapWitness :: ShelleyBasedEra era -> WitnessNetworkIdOrByronAddress -> TxBody (ShelleyLedgerEra era) -> SigningKey ByronKey -> KeyWitness era
makeShelleyBootstrapWitness :: ShelleyBasedEra era -> WitnessNetworkIdOrByronAddress -> TxBody era -> SigningKey ByronKey -> KeyWitness era
makeShelleyKeyWitness' :: ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> ShelleyWitnessSigningKey -> KeyWitness era
makeSignedByronTransaction :: [KeyWitness era] -> Annotated Tx ByteString -> ATxAux ByteString
makeSignedTransaction :: [KeyWitness era] -> TxBody era -> Tx era
signByronTransaction :: NetworkId -> Annotated Tx ByteString -> [SigningKey ByronKey] -> ATxAux ByteString
txScriptValidityToScriptValidity :: TxScriptValidity era -> ScriptValidity
unUTxO :: UTxO era -> Map TxIn (TxOut CtxUTxO era)
makeTransactionMetadata :: Map Word64 TxMetadataValue -> TxMetadata
mergeTransactionMetadata :: (TxMetadataValue -> TxMetadataValue -> TxMetadataValue) -> TxMetadata -> TxMetadata -> TxMetadata
metaBytesChunks :: ByteString -> TxMetadataValue
metaTextChunks :: Text -> TxMetadataValue
metadataFromJson :: TxMetadataJsonSchema -> Value -> Either TxMetadataJsonError TxMetadata
metadataToJson :: TxMetadataJsonSchema -> TxMetadata -> Value
metadataValueFromJsonNoSchema :: Value -> Either TxMetadataJsonSchemaError TxMetadataValue
metadataValueToJsonNoSchema :: TxMetadataValue -> Value
validateTxMetadata :: TxMetadata -> Either [(Word64, TxMetadataRangeError)] ()
textShow :: Show a => a -> Text
unsafeBoundedRational :: (HasCallStack, Typeable r, BoundedRational r) => Rational -> r
filterValue :: (AssetId -> Bool) -> Value -> Value
lovelaceToQuantity :: Lovelace -> Quantity
lovelaceToValue :: Lovelace -> Value
multiAssetToPolicyAssets :: MultiAsset -> Map PolicyId PolicyAssets
negateValue :: Value -> Value
policyAssetsToValue :: PolicyId -> PolicyAssets -> Value
quantityToLovelace :: Quantity -> Lovelace
renderMultiAsset :: MultiAsset -> Text
renderMultiAssetPretty :: MultiAsset -> Text
renderValuePretty :: Value -> Text
scriptPolicyId :: Script lang -> PolicyId
selectAsset :: Value -> AssetId -> Quantity
valueFromList :: [(AssetId, Quantity)] -> Value
valueFromNestedRep :: ValueNestedRep -> Value
valueToList :: Value -> [(AssetId, Quantity)]
valueToLovelace :: Value -> Maybe Lovelace
valueToNestedRep :: Value -> ValueNestedRep
valueToPolicyAssets :: Value -> Map PolicyId PolicyAssets
parseAssetName :: Parser AssetName
parseMintingMultiAssetValue :: MaryEraOnwards era -> Parser MultiAsset
parsePolicyId :: Parser PolicyId
parseTxOutMultiAssetValue :: Parser Value
parseUTxOValue :: Parser Value
vsep :: [Doc ann] -> Doc ann
bimapExceptT :: forall (m :: Type -> Type) x y a b. Functor m => (x -> y) -> (a -> b) -> ExceptT x m a -> ExceptT y m b
bracketExceptT :: forall (m :: Type -> Type) e a b c. Monad m => ExceptT e m a -> (a -> ExceptT e m b) -> (a -> ExceptT e m c) -> ExceptT e m c
bracketExceptionT :: forall (m :: Type -> Type) e a c b. MonadMask m => ExceptT e m a -> (a -> ExceptT e m c) -> (a -> ExceptT e m b) -> ExceptT e m b
catchExceptT :: (MonadCatch m, Exception e) => m a -> (e -> x) -> ExceptT x m a
catchIOExceptT :: forall (m :: Type -> Type) a x. MonadIO m => IO a -> (IOException -> x) -> ExceptT x m a
catchLeftT :: forall (m :: Type -> Type) e a. Monad m => ExceptT e m a -> (e -> ExceptT e m a) -> ExceptT e m a
catchesExceptT :: (Foldable f, MonadCatch m) => m a -> f (Handler m x) -> ExceptT x m a
exceptT :: Monad m => (x -> m b) -> (a -> m b) -> ExceptT x m a -> m b
firstExceptT :: forall (m :: Type -> Type) x y a. Functor m => (x -> y) -> ExceptT x m a -> ExceptT y m a
handleExceptT :: (MonadCatch m, Exception e) => (e -> x) -> m a -> ExceptT x m a
handleIOExceptT :: forall (m :: Type -> Type) x a. MonadIO m => (IOException -> x) -> IO a -> ExceptT x m a
handleLeftT :: forall (m :: Type -> Type) e a. Monad m => (e -> ExceptT e m a) -> ExceptT e m a -> ExceptT e m a
handlesExceptT :: (Foldable f, MonadCatch m) => f (Handler m x) -> m a -> ExceptT x m a
hoistEither :: forall (m :: Type -> Type) x a. Monad m => Either x a -> ExceptT x m a
hoistExceptT :: (forall b. () => m b -> n b) -> ExceptT x m a -> ExceptT x n a
hushM :: Monad m => Either e a -> (e -> m ()) -> m (Maybe a)
newExceptT :: m (Either x a) -> ExceptT x m a
onLeft :: forall e x (m :: Type -> Type) a. Monad m => (e -> ExceptT x m a) -> ExceptT x m (Either e a) -> ExceptT x m a
onNothing :: forall x (m :: Type -> Type) a. Monad m => ExceptT x m a -> ExceptT x m (Maybe a) -> ExceptT x m a
secondExceptT :: forall (m :: Type -> Type) a b x. Functor m => (a -> b) -> ExceptT x m a -> ExceptT x m b
fromShelleyAddr :: ShelleyBasedEra era -> Addr -> AddressInEra era
fromShelleyAddrIsSbe :: ShelleyBasedEra era -> Addr -> AddressInEra era
fromShelleyAddrToAny :: Addr -> AddressAny
fromShelleyPaymentCredential :: PaymentCredential -> PaymentCredential
fromShelleyStakeAddr :: RewardAccount -> StakeAddress
fromShelleyStakeCredential :: StakeCredential -> StakeCredential
fromShelleyStakeReference :: StakeReference -> StakeAddressReference
shelleyPayAddrToPlutusPubKHash :: Address ShelleyAddr -> Maybe PubKeyHash
toShelleyAddr :: AddressInEra era -> Addr
toShelleyStakeAddr :: StakeAddress -> RewardAccount
toShelleyStakeCredential :: StakeCredential -> StakeCredential
fromConsensusBlock :: CardanoBlock StandardCrypto ~ block => block -> BlockInMode
fromConsensusPointHF :: forall block (xs :: [Type]). HeaderHash block ~ OneEraHash xs => Point block -> ChainPoint
fromConsensusTip :: CardanoBlock StandardCrypto ~ block => Tip block -> ChainTip
toConsensusBlock :: CardanoBlock StandardCrypto ~ block => BlockInMode -> block
toConsensusPointHF :: forall block (xs :: [Type]). HeaderHash block ~ OneEraHash xs => ChainPoint -> Point block
fromShelleyCertificate :: ShelleyBasedEra era -> TxCert (ShelleyLedgerEra era) -> Certificate era
fromShelleyPoolParams :: PoolParams -> StakePoolParameters
toShelleyCertificate :: Certificate era -> TxCert (ShelleyLedgerEra era)
toShelleyPoolParams :: StakePoolParameters -> PoolParams
extractExecutionUnits :: TxScriptWitnessRequirements era -> [ExecutionUnits]
getTxScriptWitnessRequirements :: forall era (witnessable :: WitnessableItem). AlonzoEraOnwards era -> [(Witnessable witnessable (ShelleyLedgerEra era), AnyWitness (ShelleyLedgerEra era))] -> TxScriptWitnessRequirements (ShelleyLedgerEra era)
evaluateTransactionExecutionUnitsShelley :: ShelleyBasedEra era -> SystemStart -> LedgerEpochInfo -> LedgerProtocolParameters era -> UTxO era -> Tx (ShelleyLedgerEra era) -> Map ScriptWitnessIndex (Either ScriptExecutionError (EvalTxExecutionUnitsLog, ExecutionUnits))
alonzoGenesisDefaults :: CardanoEra era -> AlonzoGenesis
conwayGenesisDefaults :: ConwayGenesis
decodeAlonzoGenesis :: forall era t (m :: Type -> Type). MonadTransError String t m => Maybe (CardanoEra era) -> ByteString -> t m AlonzoGenesis
shelleyGenesisDefaults :: ShelleyGenesis
createAnchor :: Url -> ByteString -> Anchor
createGovernanceActionId :: TxId -> Word16 -> GovActionId
createProposalProcedure :: ShelleyBasedEra era -> Network -> Coin -> StakeCredential -> GovernanceAction era -> Anchor -> Proposal era
fromProposalProcedure :: ShelleyBasedEra era -> Proposal era -> (Coin, StakeCredential, GovernanceAction era)
createVotingProcedure :: ConwayEraOnwards era -> Vote -> Maybe (Url, Text) -> VotingProcedure era
emptyVotingProcedures :: VotingProcedures era
mergeVotingProcedures :: VotingProcedures era -> VotingProcedures era -> Either (VotesMergingConflict era) (VotingProcedures era)
singletonVotingProcedures :: ConwayEraOnwards era -> Voter -> GovActionId -> VotingProcedure (ShelleyLedgerEra era) -> VotingProcedures era
hashGovernancePoll :: GovernancePoll -> Hash GovernancePoll
renderGovernancePollError :: GovernancePollError -> Text
verifyPollAnswer :: GovernancePoll -> InAnyShelleyBasedEra Tx -> Either GovernancePollError [Hash PaymentKey]
toConsensusGenTx :: CardanoBlock StandardCrypto ~ block => TxInMode -> GenTx block
signArbitraryBytesKes :: SigningKey KesKey -> Period -> ByteString -> SignedKES (KES StandardCrypto) ByteString
anyStakePoolSigningKeyToVerificationKey :: AnyStakePoolSigningKey -> AnyStakePoolVerificationKey
anyStakePoolVerificationKeyHash :: AnyStakePoolVerificationKey -> Hash StakePoolKey
toLedgerEvent :: ConvertLedgerEvent blk => WrapLedgerEvent blk -> Maybe LedgerEvent
currentEpochEligibleLeadershipSlots :: ShelleyBasedEra era -> ShelleyGenesis -> EpochInfo (Either Text) -> PParams (ShelleyLedgerEra era) -> ProtocolState era -> PoolId -> SigningKey VrfKey -> SerialisedPoolDistribution era -> EpochNo -> Either LeadershipError (Set SlotNo)
nextEpochEligibleLeadershipSlots :: ShelleyBasedEra era -> ShelleyGenesis -> SerialisedCurrentEpochState era -> ProtocolState era -> PoolId -> SigningKey VrfKey -> PParams (ShelleyLedgerEra era) -> EpochInfo (Either Text) -> (ChainTip, EpochNo) -> Either LeadershipError (Set SlotNo)
createEraBasedProtocolParamUpdate :: ShelleyBasedEra era -> EraBasedProtocolParametersUpdate era -> PParamsUpdate (ShelleyLedgerEra era)
fromLedgerPParamsUpdate :: ShelleyBasedEra era -> PParamsUpdate (ShelleyLedgerEra era) -> ProtocolParametersUpdate
toLedgerNonce :: Maybe PraosNonce -> Nonce
decodeBigLedgerPeerSnapshot :: Serialised LedgerPeerSnapshot -> Either (ByteString, DecoderError) LedgerPeerSnapshot
decodeCurrentEpochState :: ShelleyBasedEra era -> SerialisedCurrentEpochState era -> Either DecoderError (CurrentEpochState era)
decodeDebugLedgerState :: FromCBOR (DebugLedgerState era) => SerialisedDebugLedgerState era -> Either (ByteString, DecoderError) (DebugLedgerState era)
decodePoolDistribution :: ShelleyBasedEra era -> SerialisedPoolDistribution era -> Either DecoderError (PoolDistribution era)
decodePoolState :: (Era (ShelleyLedgerEra era), DecCBOR (PState (ShelleyLedgerEra era))) => SerialisedPoolState era -> Either DecoderError (PoolState era)
decodeProtocolState :: FromCBOR (ChainDepState (ConsensusProtocol era)) => ProtocolState era -> Either (ByteString, DecoderError) (ChainDepState (ConsensusProtocol era))
decodeStakeSnapshot :: SerialisedStakeSnapshots era -> Either DecoderError (StakeSnapshot era)
fromAllegraTimelock :: AllegraEraScript era => NativeScript era -> SimpleScript
fromAlonzoExUnits :: ExUnits -> ExecutionUnits
fromAlonzoLanguage :: Language -> AnyPlutusScriptVersion
fromShelleyBasedScript :: ShelleyBasedEra era -> Script (ShelleyLedgerEra era) -> ScriptInEra era
fromShelleyMultiSig :: MultiSig (ShelleyLedgerEra ShelleyEra) -> SimpleScript
fromShelleyScriptHash :: ScriptHash -> ScriptHash
refScriptToShelleyScript :: ShelleyBasedEra era -> ReferenceScript era -> StrictMaybe (Script (ShelleyLedgerEra era))
toAllegraTimelock :: (AllegraEraScript era, NativeScript era ~ Timelock era) => SimpleScript -> NativeScript era
toAlonzoExUnits :: ExecutionUnits -> ExUnits
toAlonzoLanguage :: AnyPlutusScriptVersion -> Language
toShelleyMultiSig :: SimpleScript -> Either MultiSigError (MultiSig (ShelleyLedgerEra ShelleyEra))
toShelleyScript :: ScriptInEra era -> Script (ShelleyLedgerEra era)
toShelleyScriptHash :: ScriptHash -> ScriptHash
fromAlonzoData :: Data ledgerera -> HashableScriptData
scriptDataFromJsonDetailedSchema :: Value -> Either ScriptDataJsonSchemaError HashableScriptData
scriptDataToJsonDetailedSchema :: HashableScriptData -> Value
toAlonzoData :: Era ledgerera => HashableScriptData -> Data ledgerera
calculateExecutionUnitsLovelace :: Prices -> ExecutionUnits -> Maybe Coin
collectTxBodyScriptWitnessRequirements :: IsShelleyBasedEra era => AlonzoEraOnwards era -> TxBodyContent BuildTx era -> Either TxBodyError (TxScriptWitnessRequirements (ShelleyLedgerEra era))
getTxIdShelley :: EraTxBody (ShelleyLedgerEra era) => ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> TxId
toScriptIndex :: AlonzoEraOnwards era -> PlutusPurpose AsIx (ShelleyLedgerEra era) -> ScriptWitnessIndex
fromShelleyTxOut :: ShelleyBasedEra era -> TxOut (ShelleyLedgerEra era) -> TxOut ctx era
toShelleyTxOut :: (HasCallStack, ShelleyLedgerEra era ~ ledgerera) => ShelleyBasedEra era -> TxOut CtxUTxO era -> TxOut ledgerera
getShelleyKeyWitnessVerificationKey :: ShelleySigningKey -> VKey 'Witness
getTxBodyAndWitnesses :: Tx era -> (TxBody era, [KeyWitness era])
makeShelleySignature :: SignableRepresentation tosign => tosign -> ShelleySigningKey -> SignedDSIGN DSIGN tosign
toShelleySigningKey :: ShelleyWitnessSigningKey -> ShelleySigningKey
fromShelleyTxId :: TxId -> TxId
fromShelleyTxIn :: TxIn -> TxIn
toShelleyTxId :: TxId -> TxId
toShelleyTxIn :: TxIn -> TxIn
fromShelleyMetadatum :: Metadatum -> TxMetadataValue
toShelleyMetadatum :: TxMetadataValue -> Metadatum
calcMinimumDeposit :: Value -> Lovelace -> Lovelace
fromMaryValue :: MaryValue -> Value
toMaryValue :: Value -> MaryValue
class () => FromJSON a
parseJSON :: FromJSON a => Value -> Parser a
parseJSONList :: FromJSON a => Value -> Parser [a]
omittedField :: FromJSON a => Maybe a
class () => ToJSON a
toJSON :: ToJSON a => a -> Value
toEncoding :: ToJSON a => a -> Encoding
toJSONList :: ToJSON a => [a] -> Value
toEncodingList :: ToJSON a => [a] -> Encoding
omitField :: ToJSON a => a -> Bool

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = ?callStack :: CallStack

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data () => Proxy (t :: k)
Proxy :: Proxy (t :: k)

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class () => Typeable (a :: k)
type UTxO = UTxO' (TxOut CtxUTxO Era)

-- | Newtype with phantom types mostly required to work around the poor
--   interface of <a>UTXO</a> and provide <a>Monoid</a> and <a>Foldable</a>
--   instances to make utxo manipulation bareable.
newtype UTxO' out
UTxO :: Map TxIn out -> UTxO' out
type Era = ConwayEra

-- | Currently supported ledger era.
type LedgerEra = ShelleyLedgerEra Era

-- | Associated version for the fixed <a>LedgerEra</a>.
ledgerEraVersion :: Version

-- | A space efficient, packed, unboxed Unicode text type.
data () => Text

-- | Decode a <a>ByteString</a> containing UTF-8 encoded text that is known
--   to be valid.
--   
--   If the input contains any invalid UTF-8 data, an exception will be
--   thrown that cannot be caught in pure code. For more control over the
--   handling of invalid data, use <a>decodeUtf8'</a> or
--   <a>decodeUtf8With</a>.
--   
--   This is a partial function: it checks that input is a well-formed
--   UTF-8 sequence and copies buffer or throws an error otherwise.
decodeUtf8 :: ByteString -> Text

-- | Encode text using UTF-8 encoding.
encodeUtf8 :: Text -> ByteString

-- | <i>O(n)</i> Convert a lazy <a>ByteString</a> into a strict
--   <a>ByteString</a>.
--   
--   Note that this is an <i>expensive</i> operation that forces the whole
--   lazy ByteString into memory and then copies all the data. If possible,
--   try to avoid converting back and forth between strict and lazy
--   bytestrings.
toStrict :: ByteString -> ByteString

-- | <i>O(1)</i> Convert a strict <a>ByteString</a> into a lazy
--   <a>ByteString</a>.
fromStrict :: ByteString -> ByteString

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data () => ByteString

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
--   
--   The <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which
--   prefers values from the left operand. If <tt>m1</tt> maps a key
--   <tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key
--   to a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;
--   m2</tt> maps <tt>k</tt> to <tt>a1</tt>.
data () => Map k a

-- | A set of values <tt>a</tt>.
data () => Set a

-- | Interpret some raw <a>ByteString</a> as a particular <a>Hash</a>.
--   
--   NOTE: This throws if byte string has a length different that the
--   expected target digest length.
unsafeHashFromBytes :: (HasCallStack, HashAlgorithm hash) => ByteString -> Hash hash a
class () => Arbitrary a
arbitrary :: Arbitrary a => Gen a
shrink :: Arbitrary a => a -> [a]
data () => Gen a

module Hydra.Cardano.Api.PolicyAssets
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Api.Internal.Value.PolicyAssets
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Api.Internal.Value.PolicyAssets

module Hydra.Cardano.Api.NetworkId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Api.Internal.NetworkId.NetworkId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Api.Internal.NetworkId.NetworkId
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Api.Internal.NetworkId.NetworkId

module Hydra.Cardano.Api.Hash

-- | Convert a cardano-api <a>Hash</a> into a plutus <tt>PubKeyHash</tt>
toPlutusKeyHash :: Hash PaymentKey -> PubKeyHash

-- | Convert a cardano-api <a>Hash</a> into a cardano-ledger
--   <tt>KeyHash</tt>
toLedgerKeyHash :: Hash PaymentKey -> KeyHash 'Witness

-- | Unsafe wrap some bytes as a 'Hash PaymentKey'.
--   
--   Pre-condition: the input bytestring MUST be of length 28.
unsafePaymentKeyHashFromBytes :: HasCallStack => ByteString -> Hash PaymentKey

-- | Unsafe wrap some bytes as a 'Hash ScriptData', relying on the fact
--   that Plutus is using Blake2b_256 for hashing data (according to
--   'cardano-ledger').
--   
--   Pre-condition: the input bytestring MUST be of length 32.
unsafeScriptDataHashFromBytes :: HasCallStack => ByteString -> Hash ScriptData
unsafeCastHash :: (SerialiseAsCBOR (Hash a), SerialiseAsCBOR (Hash b), HasCallStack) => Hash a -> Hash b

module Hydra.Cardano.Api.ExecutionUnits

-- | Convert a cardano-api <a>ExecutionUnits</a> into a cardano-ledger
--   <tt>ExUnits</tt>
toLedgerExUnits :: ExecutionUnits -> ExUnits

module Hydra.Cardano.Api.BlockHeader

-- | Fully arbitrary block header with completely random hash.
genBlockHeader :: Gen BlockHeader

-- | Generate a random block header with completely random hash, but at a
--   certain slot.
genBlockHeaderAt :: SlotNo -> Gen BlockHeader

-- | Generate a random block header hash.
genBlockHeaderHash :: Gen (Hash BlockHeader)
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Api.Internal.Block.BlockHeader

module Hydra.Cardano.Api.ChainPoint

-- | Get the chain point corresponding to a given <a>BlockHeader</a>.
getChainPoint :: BlockHeader -> ChainPoint

-- | Generate a chain point with a likely invalid block header hash.
genChainPoint :: Gen ChainPoint

-- | Generate a chain point at given slot with a likely invalid block
--   header hash.
genChainPointAt :: SlotNo -> Gen ChainPoint
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Api.Internal.Block.ChainPoint

module Hydra.Cardano.Api.AddressInEra

-- | Construct a Shelley-style address from a verification key. This
--   address has no stake rights.
--   
--   TODO: <a>NetworkId</a> here is an annoying API because it requires a
--   network magic for testnet addresses. Nevertheless, the network magic
--   is only needed for Byron addresses; Shelley addresses use a different
--   kind of network discriminant which is currently fully captured as
--   'Mainnet | Testnet'.
--   
--   So, it would be a slightly better DX to use Mainnet | Testnet as an
--   interface here since we are only constructing Shelley addresses.
mkVkAddress :: IsShelleyBasedEra era => NetworkId -> VerificationKey PaymentKey -> AddressInEra era

-- | Construct a Shelley-style address from a Plutus script. This address
--   has no stake rights.
mkScriptAddress :: forall lang era. (IsShelleyBasedEra era, IsPlutusScriptLanguage lang) => NetworkId -> PlutusScript lang -> AddressInEra era

-- | From a ledger <tt>Addr</tt> to an api <a>AddressInEra</a>
fromLedgerAddr :: IsShelleyBasedEra era => Addr -> AddressInEra era

-- | From an api <a>AddressInEra</a> to a ledger <tt>Addr</tt>
toLedgerAddr :: AddressInEra era -> Addr

-- | Convert a plutus <a>Address</a> to an api <a>AddressInEra</a>. NOTE:
--   Requires the <tt>Network</tt> discriminator (Testnet or Mainnet)
--   because Plutus addresses are stripped off it.
fromPlutusAddress :: IsShelleyBasedEra era => Network -> Address -> AddressInEra era

module Hydra.Cardano.Api.Address
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Api.Internal.Address.Address Cardano.Api.Internal.Address.ByronAddr)

module Hydra.Cardano.Api.ReferenceScript

-- | Construct a <a>ReferenceScript</a> from any given Plutus script.
mkScriptRef :: IsPlutusScriptLanguage lang => PlutusScript lang -> ReferenceScript Era

module Hydra.Cardano.Api.ScriptData

-- | Data-types that can be marshalled into a generic <a>ScriptData</a>
--   structure.
type ToScriptData a = ToData a

-- | Data-types that can be unmarshalled from a generic <a>ScriptData</a>
--   structure.
type FromScriptData a = FromData a

-- | Serialise some type into a generic script data.
toScriptData :: ToScriptData a => a -> HashableScriptData

-- | Deserialise some generic script data into some type.
fromScriptData :: FromScriptData a => HashableScriptData -> Maybe a

-- | Get the <a>HashableScriptData</a> associated to the a <a>TxOut</a>.
--   Note that this requires the <a>CtxTx</a> context.
txOutScriptData :: TxOut CtxTx era -> Maybe HashableScriptData

-- | Convert a cardano-ledger script <tt>Data</tt> into a cardano-api
--   <a>ScriptDatum</a>.
fromLedgerData :: Data era -> HashableScriptData

-- | Convert a cardano-api script data into a cardano-ledger script
--   <tt>Data</tt>. XXX: This is a partial function. Ideally it would fall
--   back to the <a>Data</a> portion in <a>HashableScriptData</a>.
toLedgerData :: Era era => HashableScriptData -> Data era

module Hydra.Cardano.Api.ScriptDatum

-- | Construct a <a>ScriptDatum</a> for use as transaction witness.
mkScriptDatum :: ToScriptData a => a -> ScriptDatum WitCtxTxIn

module Hydra.Cardano.Api.ScriptHash

-- | Like <a>hashScript</a>, but for a <a>ScriptInAnyLang</a>.
hashScriptInAnyLang :: ScriptInAnyLang -> ScriptHash

module Hydra.Cardano.Api.PolicyId

-- | Convert Cardano api <a>PolicyId</a> to Cardano ledger
--   <tt>PolicyID</tt>.
toLedgerPolicyID :: PolicyId -> PolicyID

-- | Convert Cardano api <a>PolicyId</a> to Plutus <a>CurrencySymbol</a>.
toPlutusCurrencySymbol :: PolicyId -> CurrencySymbol

-- | Convert a plutus <a>CurrencySymbol</a> into a cardano-api
--   <a>PolicyId</a>.
fromPlutusCurrencySymbol :: MonadFail m => CurrencySymbol -> m PolicyId
instance Data.Aeson.Types.ToJSON.ToJSONKey Cardano.Api.Internal.Value.PolicyId
instance Data.Aeson.Types.FromJSON.FromJSONKey Cardano.Api.Internal.Value.PolicyId
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Api.Internal.Value.PolicyId

module Hydra.Cardano.Api.StakeAddress

-- | Construct a stake address from a Plutus script.
mkScriptStakeAddress :: forall lang. IsPlutusScriptLanguage lang => NetworkId -> PlutusScript lang -> StakeAddress

module Hydra.Cardano.Api.TxId

-- | Convert a cardano-api <a>TxId</a> into a cardano-ledger <a>TxId</a>.
toLedgerTxId :: TxId -> TxId
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Api.Internal.TxIn.TxId
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Api.Internal.TxIn.TxId

module Hydra.Cardano.Api.TxIn

-- | Create a <a>TxIn</a> (a.k.a UTXO) from a transaction and output index.
mkTxIn :: Tx era -> Word -> TxIn

-- | Attach some verification-key witness to a <a>TxIn</a>.
withWitness :: TxIn -> (TxIn, BuildTxWith BuildTx (Witness WitCtxTxIn Era))

-- | Access inputs of a transaction, as an ordered list.
txIns' :: Tx era -> [TxIn]

-- | Access inputs of a transaction, as an ordered set.
txInputSet :: Tx era -> Set TxIn

-- | Convert a cardano-ledger <a>TxIn</a> into a cardano-api <a>TxIn</a>
fromLedgerTxIn :: TxIn -> TxIn

-- | Convert a cardano-api <a>TxIn</a> into a cardano-ledger <a>TxIn</a>
toLedgerTxIn :: TxIn -> TxIn

-- | Convert a plutus' <tt>TxOutRef</tt> into a cardano-api <a>TxIn</a>
fromPlutusTxOutRef :: TxOutRef -> TxIn

-- | Convert a cardano-api <a>TxIn</a> into a plutus <tt>TxOutRef</tt>.
toPlutusTxOutRef :: TxIn -> TxOutRef

-- | A more random generator than the 'Arbitrary TxIn' from cardano-ledger.
--   NOTE: This is using the Cardano ledger's deserialization framework
--   using the latest protocol version via <a>maxBound</a>.
genTxIn :: Gen TxIn
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Api.Internal.TxIn.TxIn

module Hydra.Cardano.Api.TxBody

-- | Find and deserialise from <a>ScriptData</a>, a redeemer from the
--   transaction associated to the given input.
findRedeemerSpending :: FromData a => Tx Era -> TxIn -> Maybe a
lookupRedeemer :: FromData a => PlutusPurpose AsIx LedgerEra -> TxBodyScriptData Era -> Maybe a

module Hydra.Cardano.Api.Tx

-- | Sign transaction using the provided secret key It only works for tx
--   not containing scripts. You can't sign a script utxo with this.
signTx :: IsShelleyBasedEra era => SigningKey PaymentKey -> Tx era -> Tx era

-- | Create a transaction spending all given <a>UTxO</a>.
txSpendingUTxO :: UTxO -> Tx Era

-- | Convert a cardano-ledger's <a>Tx</a> in the Babbage era into a
--   cardano-api <a>Tx</a>.
fromLedgerTx :: IsShelleyBasedEra era => Tx (ShelleyLedgerEra era) -> Tx era

-- | Get the UTxO that are produced by some transaction. XXX: Defined here
--   to avoid cyclic module dependency
utxoProducedByTx :: Tx Era -> UTxO

-- | Convert a cardano-api <a>Tx</a> into a matching cardano-ledger
--   <a>Tx</a>.
toLedgerTx :: Tx era -> Tx (ShelleyLedgerEra era)
data () => Tx era

module Hydra.Cardano.Api.TxOutDatum

-- | Construct a <a>TxOutDatum</a> as a <a>ScriptData</a> hash from some
--   serialisable data.
mkTxOutDatumHash :: forall era a ctx. (ToScriptData a, IsAlonzoBasedEra era) => a -> TxOutDatum ctx era

-- | Construct an inline <a>TxOutDatum</a> from some serialisable data.
mkTxOutDatumInline :: forall era a ctx. (ToScriptData a, IsBabbageBasedEra era) => a -> TxOutDatum ctx era

module Hydra.Cardano.Api.TxOutValue

-- | Inject some <a>Value</a> into a <a>TxOutValue</a>
mkTxOutValue :: forall era. IsMaryBasedEra era => Value -> TxOutValue era

module Hydra.Cardano.Api.UTxO

-- | Get a human-readable pretty text representation of a UTxO.
renderUTxO :: IsString str => UTxO -> str

-- | Construct a UTxO from a transaction. This constructs artificial
--   <a>TxIn</a> (a.k.a output reference) from the transaction itself,
--   zipping them to the outputs they correspond to.
utxoFromTx :: Tx Era -> UTxO

-- | Resolve tx inputs in a given UTxO
resolveInputsUTxO :: UTxO -> Tx Era -> UTxO
toLedgerUTxO :: UTxO -> UTxO LedgerEra
fromLedgerUTxO :: UTxO LedgerEra -> UTxO

module Hydra.Cardano.Api.ValidityInterval
toLedgerValidityInterval :: (TxValidityLowerBound era, TxValidityUpperBound era) -> ValidityInterval
fromLedgerValidityInterval :: ValidityInterval -> (TxValidityLowerBound Era, TxValidityUpperBound Era)
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Api.Internal.Tx.Body.TxValidityLowerBound Hydra.Cardano.Api.Prelude.Era)
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Api.Internal.Tx.Body.TxValidityUpperBound Hydra.Cardano.Api.Prelude.Era)

module Hydra.Cardano.Api.Value

-- | Check whether left contains right.
containsValue :: Value -> Value -> Bool

-- | Calculate minimum ada as <a>Value</a> for a <a>TxOut</a>. NOTE: This
--   function can throw although you can't tell from the signature.
--   <a>toLedgerValue</a> can error out with _Illegal Value in TxOut_
minUTxOValue :: PParams LedgerEra -> TxOut CtxTx Era -> Value

-- | Count number of assets in a <a>Value</a>.
valueSize :: Value -> Int

-- | Convert a cardano-ledger <a>Value</a> into a cardano-api <a>Value</a>.
fromLedgerValue :: MaryValue -> Value

-- | Convert a cardano-ledger <tt>MultiAsset</tt> into a cardano-api
--   <a>Value</a>. The cardano-api currently does not have an asset-only
--   type. So this conversion will construct a <a>Value</a> with no
--   <a>AdaAssetId</a> entry in it.
fromLedgerMultiAsset :: MultiAsset -> Value

-- | Convert a cardano-api <a>Value</a> into a cardano-ledger <a>Value</a>.
toLedgerValue :: Value -> MaryValue

-- | Convert a plutus <a>Value</a> into a cardano-api <a>Value</a>.
fromPlutusValue :: Value -> Maybe Value

module Hydra.Cardano.Api.TxOut
txOuts' :: Tx era -> [TxOut CtxTx era]

-- | Modify a <a>TxOut</a> to set the minimum ada on the value.
setMinUTxOValue :: PParams LedgerEra -> TxOut CtxUTxO Era -> TxOut ctx Era

-- | Automatically balance a given output with the minimum required amount.
--   Number of assets, presence of datum and/or reference scripts may
--   affect this minimum value.
mkTxOutAutoBalance :: PParams LedgerEra -> AddressInEra Era -> Value -> TxOutDatum CtxTx Era -> ReferenceScript Era -> TxOut CtxTx Era

-- | Alter the address of a <a>TxOut</a> with the given transformation.
modifyTxOutAddress :: (AddressInEra era -> AddressInEra era) -> TxOut ctx era -> TxOut ctx era

-- | Alter the value of a <a>TxOut</a> with the given transformation.
modifyTxOutValue :: IsMaryBasedEra era => (Value -> Value) -> TxOut ctx era -> TxOut ctx era

-- | Alter the datum of a <a>TxOut</a> with the given transformation.
modifyTxOutDatum :: (TxOutDatum ctx0 era -> TxOutDatum ctx1 era) -> TxOut ctx0 era -> TxOut ctx1 era

-- | Find first <a>TxOut</a> which pays to given address and also return
--   the corresponding <a>TxIn</a> to reference it.
findTxOutByAddress :: AddressInEra era -> Tx era -> Maybe (TxIn, TxOut CtxTx era)

-- | Find a single script output in some <a>UTxO</a>
findTxOutByScript :: forall lang. IsPlutusScriptLanguage lang => UTxO -> PlutusScript lang -> Maybe (TxIn, TxOut CtxUTxO Era)

-- | Predicate to find or filter <a>TxOut</a> owned by a key. This is
--   better than comparing the full address as it does not require a
--   network discriminator.
isVkTxOut :: forall ctx era. VerificationKey PaymentKey -> TxOut ctx era -> Bool

-- | Predicate to find or filter <a>TxOut</a> which are governed by some
--   script. This is better than comparing the full address as it does not
--   require a network discriminator.
isScriptTxOut :: forall lang ctx era. IsPlutusScriptLanguage lang => PlutusScript lang -> TxOut ctx era -> Bool

-- | Convert a cardano-ledger <a>TxOut</a> into a cardano-api <a>TxOut</a>
fromLedgerTxOut :: IsShelleyBasedEra era => TxOut (ShelleyLedgerEra era) -> TxOut ctx era

-- | Convert a cardano-api <a>TxOut</a> into a cardano-ledger <a>TxOut</a>
toLedgerTxOut :: IsShelleyBasedEra era => TxOut CtxUTxO era -> TxOut (ShelleyLedgerEra era)

-- | Convert a plutus <a>TxOut</a> into a cardano-api <a>TxOut</a>. NOTE:
--   Reference scripts are not resolvable right now. NOTE: Requires the
--   <tt>Network</tt> discriminator (Testnet or Mainnet) because Plutus
--   addresses are stripped off it.
fromPlutusTxOut :: forall era. IsBabbageBasedEra era => Network -> TxOut -> Maybe (TxOut CtxUTxO era)

-- | Convert a cardano-api <a>TxOut</a> into a plutus <a>TxOut</a>. Returns
--   <a>Nothing</a> if a byron address is used in the given <a>TxOut</a>.
toPlutusTxOut :: HasCallStack => TxOut CtxUTxO Era -> Maybe TxOut

module Hydra.Cardano.Api.Witness

-- | Construct a full script witness from a datum, a redeemer and a full
--   <a>Script</a>. That witness has no execution budget.
mkScriptWitness :: forall ctx era lang. (IsPlutusScriptLanguage lang, HasScriptLanguageInEra lang era) => PlutusScript lang -> ScriptDatum ctx -> ScriptRedeemer -> ScriptWitness ctx era

-- | Construct a reference script witness, only referring to a <a>TxIn</a>
--   which is expected to contain the given script (only required to
--   satisfy types).
mkScriptReference :: forall ctx era lang. (IsPlutusScriptLanguage lang, HasScriptLanguageInEra lang era) => TxIn -> PlutusScript lang -> ScriptDatum ctx -> ScriptRedeemer -> ScriptWitness ctx era


-- | A Haskell API for Cardano, tailored to the Hydra project.
--   
--   This package provides a wrapper around the <tt>cardano-ledger</tt>,
--   <tt>cardano-api</tt> and <tt>plutus</tt> libraries with extra
--   utilities and function commonly used across the Hydra project.
--   
--   NOTE: We always use the **latest era** available in our codebase, so
--   to ease type signatures and notations, we specialize any type of the
--   <tt>cardano-api</tt> normally parameterized by an era to the latest
--   era <a>Era</a>. As a consequence, we've defined pattern synonyms for
--   most constructors in the <tt>cardano-api</tt> to also get rid of era
--   witnesses.
--   
--   NOTE: This module also uses the **latest plutus version** available
--   (currently <a>PlutusScriptVersion</a>). So make sure that you give it
--   a plutus script of the right version (e.g. when compiling and
--   serializing plutus-tx).
module Hydra.Cardano.Api
type Era = ConwayEra

-- | Currently supported ledger era.
type LedgerEra = ShelleyLedgerEra Era

-- | Associated version for the fixed <a>LedgerEra</a>.
ledgerEraVersion :: Version
newtype () => LedgerProtocolParameters era
LedgerProtocolParameters :: PParams (ShelleyLedgerEra era) -> LedgerProtocolParameters era
[unLedgerProtocolParameters] :: LedgerProtocolParameters era -> PParams (ShelleyLedgerEra era)
type ReferenceScript = ReferenceScript Era
type AddressInEra = AddressInEra Era
type AddressTypeInEra addrType = AddressTypeInEra addrType Era
type BalancedTxBody = BalancedTxBody Era
type KeyWitness = KeyWitness Era
type PlutusScript = PlutusScript PlutusScriptV3
type Script = Script PlutusScriptV3
type ScriptInEra = ScriptInEra Era
type ScriptLanguage = ScriptLanguage PlutusScriptV3
type ScriptWitness witCtx = ScriptWitness witCtx Era
type Tx = Tx Era
type TxAuxScripts = TxAuxScripts Era
type TxBody = TxBody Era
type TxBodyContent build = TxBodyContent build Era
type TxBodyScriptData = TxBodyScriptData Era
type TxExtraKeyWitnesses = TxExtraKeyWitnesses Era
type TxFee = TxFee Era
type TxIns build = [(TxIn, BuildTxWith build (Witness WitCtxTxIn Era))]
type TxInsCollateral = TxInsCollateral Era
type TxInsReference build = TxInsReference build Era
type TxMetadataInEra = TxMetadataInEra Era
type TxMintValue build = TxMintValue build Era
type TxOut ctx = TxOut ctx Era
type TxOutDatum ctx = TxOutDatum ctx Era
type TxScriptValidity = TxScriptValidity Era
type TxValidityLowerBound = TxValidityLowerBound Era
type TxValidityUpperBound = TxValidityUpperBound Era
type Witness witCtx = Witness witCtx Era
pattern ReferenceScript :: ScriptInAnyLang -> ReferenceScript
pattern BalancedTxBody :: TxBodyContent BuildTx -> TxBody -> TxOut CtxTx -> Coin -> BalancedTxBody
pattern KeyWitness :: KeyWitnessInCtx ctx -> Witness ctx
pattern PlutusScript :: PlutusScript -> Script
pattern ScriptWitness :: ScriptWitnessInCtx ctx -> ScriptWitness ctx -> Witness ctx
pattern Tx :: TxBody -> [KeyWitness] -> Tx
pattern TxAuxScripts :: [ScriptInEra] -> TxAuxScripts
pattern TxBodyContent :: TxIns build -> TxInsCollateral -> TxInsReference build -> [TxOut CtxTx] -> TxTotalCollateral Era -> TxReturnCollateral CtxTx Era -> TxFee -> TxValidityLowerBound -> TxValidityUpperBound -> TxMetadataInEra -> TxAuxScripts -> TxExtraKeyWitnesses -> BuildTxWith build (Maybe (LedgerProtocolParameters Era)) -> TxWithdrawals build Era -> TxCertificates build Era -> TxUpdateProposal Era -> TxMintValue build -> TxScriptValidity -> Maybe (Featured ConwayEraOnwards Era (TxProposalProcedures build Era)) -> Maybe (Featured ConwayEraOnwards Era (TxVotingProcedures build Era)) -> Maybe (Featured ConwayEraOnwards Era (Maybe Coin)) -> Maybe (Featured ConwayEraOnwards Era Coin) -> TxBodyContent build
pattern TxBodyScriptData :: TxDats (ShelleyLedgerEra Era) -> Redeemers (ShelleyLedgerEra Era) -> TxBodyScriptData
pattern TxExtraKeyWitnesses :: [Hash PaymentKey] -> TxExtraKeyWitnesses
pattern TxInsCollateral :: [TxIn] -> TxInsCollateral
pattern TxInsReference :: [TxIn] -> TxInsReferenceDatums build -> TxInsReference build
pattern TxMetadataInEra :: TxMetadata -> TxMetadataInEra
pattern TxMintValue :: Map PolicyId (PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint)) -> TxMintValue build

-- | TxOut specialized for <a>Era</a>
pattern TxOut :: AddressInEra -> Value -> TxOutDatum ctx -> ReferenceScript -> TxOut ctx
pattern TxScriptValidity :: ScriptValidity -> TxScriptValidity
pattern TxValidityLowerBound :: SlotNo -> TxValidityLowerBound
pattern TxValidityUpperBound :: SlotNo -> TxValidityUpperBound
pattern TxOutDatumNone :: TxOutDatum ctx
pattern TxOutDatumHash :: Hash ScriptData -> TxOutDatum ctx
pattern TxOutDatumInline :: HashableScriptData -> TxOutDatum ctx
pattern ReferenceScriptNone :: ReferenceScript Era
pattern ByronAddressInAnyEra :: AddressTypeInEra ByronAddr
pattern ShelleyAddressInEra :: Address ShelleyAddr -> AddressInEra
pattern PlutusScriptLanguage :: ScriptLanguage
pattern PlutusScriptWitness :: PlutusScript -> ScriptDatum witctx -> ScriptRedeemer -> ExecutionUnits -> ScriptWitness witctx
pattern TxAuxScriptsNone :: TxAuxScripts
pattern TxExtraKeyWitnessesNone :: TxExtraKeyWitnesses
pattern TxFeeExplicit :: Coin -> TxFee
pattern TxInsCollateralNone :: TxInsCollateral
pattern TxInsReferenceNone :: TxInsReference build
pattern TxMetadataNone :: TxMetadataInEra
pattern TxValidityNoLowerBound :: TxValidityLowerBound
pattern TxOutSupplementalDatum :: HashableScriptData -> TxOutDatum CtxTx
pattern ShelleyTxBody :: TxBody LedgerEra -> [Script LedgerEra] -> TxBodyScriptData -> Maybe (AlonzoTxAuxData LedgerEra) -> TxScriptValidity -> TxBody
pattern TxBodyNoScriptData :: TxBodyScriptData
pattern TxScriptValidityNone :: TxScriptValidity
pattern PlutusScriptSerialised :: ShortByteString -> PlutusScript
pattern ShelleyBootstrapWitness :: BootstrapWitness -> KeyWitness
pattern ShelleyKeyWitness :: WitVKey 'Witness -> KeyWitness
pattern ByronAddressInEra :: Address ByronAddr -> AddressInEra
pattern ShelleyAddressInAnyEra :: AddressTypeInEra ShelleyAddr
pattern TxMintValueNone :: TxMintValue build
pattern TxValidityNoUpperBound :: TxValidityUpperBound
upperBound :: TxValidityUpperBound -> SlotNo
lowerBound :: TxValidityLowerBound -> SlotNo
createAndValidateTransactionBody :: TxBodyContent BuildTx -> Either TxBodyError TxBody
defaultTxBodyContent :: TxBodyContent BuildTx
makeShelleyKeyWitness :: TxBody -> ShelleyWitnessSigningKey -> KeyWitness
signShelleyTransaction :: TxBody -> [ShelleyWitnessSigningKey] -> Tx
txAuxScripts :: TxBodyContent build -> TxAuxScripts
txCertificates :: TxBodyContent build -> TxCertificates build Era
txCurrentTreasuryValue :: TxBodyContent build -> Maybe (Featured ConwayEraOnwards Era (Maybe Coin))
txExtraKeyWits :: TxBodyContent build -> TxExtraKeyWitnesses
txFee :: TxBodyContent build -> TxFee
txIns :: TxBodyContent build -> TxIns build
txInsCollateral :: TxBodyContent build -> TxInsCollateral
txInsReference :: TxBodyContent build -> TxInsReference build
txMetadata :: TxBodyContent build -> TxMetadataInEra
txMintValue :: TxBodyContent build -> TxMintValue build
txOuts :: TxBodyContent build -> [TxOut CtxTx]
txProposalProcedures :: TxBodyContent build -> Maybe (Featured ConwayEraOnwards Era (TxProposalProcedures build Era))
txProtocolParams :: TxBodyContent build -> BuildTxWith build (Maybe (LedgerProtocolParameters Era))
txReturnCollateral :: TxBodyContent build -> TxReturnCollateral CtxTx Era
txScriptValidity :: TxBodyContent build -> TxScriptValidity
txTotalCollateral :: TxBodyContent build -> TxTotalCollateral Era
txTreasuryDonation :: TxBodyContent build -> Maybe (Featured ConwayEraOnwards Era Coin)
txUpdateProposal :: TxBodyContent build -> TxUpdateProposal Era
txValidityLowerBound :: TxBodyContent build -> TxValidityLowerBound
txValidityUpperBound :: TxBodyContent build -> TxValidityUpperBound
txVotingProcedures :: TxBodyContent build -> Maybe (Featured ConwayEraOnwards Era (TxVotingProcedures build Era))
txWithdrawals :: TxBodyContent build -> TxWithdrawals build Era
plutusScript :: Script -> PlutusScript
txBody :: Tx -> TxBody
address :: AddressInEra -> Address ShelleyAddr
scriptData :: TxInsReference build -> TxInsReferenceDatums build
txOutAddress :: TxOut ctx -> AddressInEra
txOutValue :: TxOut ctx -> Value
txOutDatum :: TxOut ctx -> TxOutDatum ctx
txOutReferenceScript :: TxOut ctx -> ReferenceScript
byronAddress :: AddressInEra -> Address ByronAddr
balancedTxBodyContent :: BalancedTxBody -> TxBodyContent BuildTx
balancedTxBody :: BalancedTxBody -> TxBody
balancedTxChangeOutput :: BalancedTxBody -> TxOut CtxTx
balancedTxFee :: BalancedTxBody -> Coin
shelleyBootstrapWitness :: KeyWitness -> BootstrapWitness
shelleyKeyWitness :: KeyWitness -> WitVKey 'Witness
plutusScriptSerialised :: PlutusScript -> ShortByteString
plutusScriptWitnessScript :: ScriptWitness witctx -> PlutusScript
plutusScriptWitnessDatum :: ScriptWitness witctx -> ScriptDatum witctx
plutusScriptWitnessRedeemer :: ScriptWitness witctx -> ScriptRedeemer
plutusScriptWitnessExecutionUnits :: ScriptWitness witctx -> ExecutionUnits
txKeyWitnesses :: Tx -> [KeyWitness]
txBodyLedgerTxBody :: TxBody -> TxBody LedgerEra
txBodyScripts :: TxBody -> [Script LedgerEra]
txBodyScriptData :: TxBody -> TxBodyScriptData
txBodyAuxiliaryData :: TxBody -> Maybe (AlonzoTxAuxData LedgerEra)
txBodyScriptValidity :: TxBody -> TxScriptValidity
txAuxScripts' :: TxAuxScripts -> [ScriptInEra]
txBodyScriptDatums :: TxBodyScriptData -> TxDats (ShelleyLedgerEra Era)
txBodyScriptRedeemers :: TxBodyScriptData -> Redeemers (ShelleyLedgerEra Era)
txExtraKeyWitnesses :: TxExtraKeyWitnesses -> [Hash PaymentKey]
txFeeExplicit :: TxFee -> Coin
txInsReference' :: TxInsReference build -> [TxIn]
txInsCollateral' :: TxInsCollateral -> [TxIn]
txMetadataInEra :: TxMetadataInEra -> TxMetadata
txMintValueInEra :: TxMintValue build -> Map PolicyId (PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint))
referenceScript :: ReferenceScript -> ScriptInAnyLang
txOutDatumHash :: TxOutDatum ctx -> Hash ScriptData
txOutDatumScriptData :: TxOutDatum CtxTx -> HashableScriptData
txOutDatumInlineScriptData :: TxOutDatum ctx -> HashableScriptData
txScriptValidity' :: TxScriptValidity -> ScriptValidity
type UTxO = UTxO' (TxOut CtxUTxO Era)

-- | Newtype with phantom types mostly required to work around the poor
--   interface of <a>UTXO</a> and provide <a>Monoid</a> and <a>Foldable</a>
--   instances to make utxo manipulation bareable.
newtype UTxO' out
UTxO :: Map TxIn out -> UTxO' out

-- | Data-types that can be marshalled into a generic <a>ScriptData</a>
--   structure.
type ToScriptData a = ToData a

-- | Data-types that can be unmarshalled from a generic <a>ScriptData</a>
--   structure.
type FromScriptData a = FromData a
toLedgerUTxO :: UTxO -> UTxO LedgerEra
fromLedgerUTxO :: UTxO LedgerEra -> UTxO

-- | Convert a cardano-ledger <a>Value</a> into a cardano-api <a>Value</a>.
fromLedgerValue :: MaryValue -> Value

-- | Convert a cardano-api <a>Value</a> into a cardano-ledger <a>Value</a>.
toLedgerValue :: Value -> MaryValue

-- | Construct a Shelley-style address from a verification key. This
--   address has no stake rights.
--   
--   TODO: <a>NetworkId</a> here is an annoying API because it requires a
--   network magic for testnet addresses. Nevertheless, the network magic
--   is only needed for Byron addresses; Shelley addresses use a different
--   kind of network discriminant which is currently fully captured as
--   'Mainnet | Testnet'.
--   
--   So, it would be a slightly better DX to use Mainnet | Testnet as an
--   interface here since we are only constructing Shelley addresses.
mkVkAddress :: IsShelleyBasedEra era => NetworkId -> VerificationKey PaymentKey -> AddressInEra era

-- | Fully arbitrary block header with completely random hash.
genBlockHeader :: Gen BlockHeader

-- | Generate a random block header hash.
genBlockHeaderHash :: Gen (Hash BlockHeader)

-- | Get the chain point corresponding to a given <a>BlockHeader</a>.
getChainPoint :: BlockHeader -> ChainPoint

-- | Convert a cardano-api <a>ExecutionUnits</a> into a cardano-ledger
--   <tt>ExUnits</tt>
toLedgerExUnits :: ExecutionUnits -> ExUnits

-- | Convert a cardano-api <a>Hash</a> into a plutus <tt>PubKeyHash</tt>
toPlutusKeyHash :: Hash PaymentKey -> PubKeyHash

-- | Convert a cardano-ledger script <tt>Data</tt> into a cardano-api
--   <a>ScriptDatum</a>.
fromLedgerData :: Data era -> HashableScriptData

-- | Construct a <a>ReferenceScript</a> from any given Plutus script.
mkScriptRef :: IsPlutusScriptLanguage lang => PlutusScript lang -> ReferenceScript Era

-- | Serialise some type into a generic script data.
toScriptData :: ToScriptData a => a -> HashableScriptData

-- | Construct a <a>ScriptDatum</a> for use as transaction witness.
mkScriptDatum :: ToScriptData a => a -> ScriptDatum WitCtxTxIn

-- | Like <a>hashScript</a>, but for a <a>ScriptInAnyLang</a>.
hashScriptInAnyLang :: ScriptInAnyLang -> ScriptHash

-- | Construct a stake address from a Plutus script.
mkScriptStakeAddress :: forall lang. IsPlutusScriptLanguage lang => NetworkId -> PlutusScript lang -> StakeAddress

-- | Create a <a>TxIn</a> (a.k.a UTXO) from a transaction and output index.
mkTxIn :: Tx era -> Word -> TxIn

-- | Convert a cardano-api <a>TxIn</a> into a cardano-ledger <a>TxIn</a>
toLedgerTxIn :: TxIn -> TxIn

-- | Sign transaction using the provided secret key It only works for tx
--   not containing scripts. You can't sign a script utxo with this.
signTx :: IsShelleyBasedEra era => SigningKey PaymentKey -> Tx era -> Tx era

-- | Find and deserialise from <a>ScriptData</a>, a redeemer from the
--   transaction associated to the given input.
findRedeemerSpending :: FromData a => Tx Era -> TxIn -> Maybe a

-- | Inject some <a>Value</a> into a <a>TxOutValue</a>
mkTxOutValue :: forall era. IsMaryBasedEra era => Value -> TxOutValue era

-- | Convert a plutus <a>Address</a> to an api <a>AddressInEra</a>. NOTE:
--   Requires the <tt>Network</tt> discriminator (Testnet or Mainnet)
--   because Plutus addresses are stripped off it.
fromPlutusAddress :: IsShelleyBasedEra era => Network -> Address -> AddressInEra era

-- | Unsafe wrap some bytes as a 'Hash ScriptData', relying on the fact
--   that Plutus is using Blake2b_256 for hashing data (according to
--   'cardano-ledger').
--   
--   Pre-condition: the input bytestring MUST be of length 32.
unsafeScriptDataHashFromBytes :: HasCallStack => ByteString -> Hash ScriptData

-- | Convert a plutus <a>Value</a> into a cardano-api <a>Value</a>.
fromPlutusValue :: Value -> Maybe Value

-- | Calculate minimum ada as <a>Value</a> for a <a>TxOut</a>. NOTE: This
--   function can throw although you can't tell from the signature.
--   <a>toLedgerValue</a> can error out with _Illegal Value in TxOut_
minUTxOValue :: PParams LedgerEra -> TxOut CtxTx Era -> Value
txOuts' :: Tx era -> [TxOut CtxTx era]

-- | Construct a <a>TxOutDatum</a> as a <a>ScriptData</a> hash from some
--   serialisable data.
mkTxOutDatumHash :: forall era a ctx. (ToScriptData a, IsAlonzoBasedEra era) => a -> TxOutDatum ctx era

-- | Convert a cardano-api <a>TxId</a> into a cardano-ledger <a>TxId</a>.
toLedgerTxId :: TxId -> TxId

-- | Access inputs of a transaction, as an ordered list.
txIns' :: Tx era -> [TxIn]

-- | Get a human-readable pretty text representation of a UTxO.
renderUTxO :: IsString str => UTxO -> str
toLedgerValidityInterval :: (TxValidityLowerBound era, TxValidityUpperBound era) -> ValidityInterval

-- | Convert a plutus <a>CurrencySymbol</a> into a cardano-api
--   <a>PolicyId</a>.
fromPlutusCurrencySymbol :: MonadFail m => CurrencySymbol -> m PolicyId

-- | Check whether left contains right.
containsValue :: Value -> Value -> Bool

-- | Construct a full script witness from a datum, a redeemer and a full
--   <a>Script</a>. That witness has no execution budget.
mkScriptWitness :: forall ctx era lang. (IsPlutusScriptLanguage lang, HasScriptLanguageInEra lang era) => PlutusScript lang -> ScriptDatum ctx -> ScriptRedeemer -> ScriptWitness ctx era
lookupRedeemer :: FromData a => PlutusPurpose AsIx LedgerEra -> TxBodyScriptData Era -> Maybe a

-- | Convert a cardano-api <a>Hash</a> into a cardano-ledger
--   <tt>KeyHash</tt>
toLedgerKeyHash :: Hash PaymentKey -> KeyHash 'Witness

-- | Unsafe wrap some bytes as a 'Hash PaymentKey'.
--   
--   Pre-condition: the input bytestring MUST be of length 28.
unsafePaymentKeyHashFromBytes :: HasCallStack => ByteString -> Hash PaymentKey
unsafeCastHash :: (SerialiseAsCBOR (Hash a), SerialiseAsCBOR (Hash b), HasCallStack) => Hash a -> Hash b

-- | Generate a random block header with completely random hash, but at a
--   certain slot.
genBlockHeaderAt :: SlotNo -> Gen BlockHeader

-- | Generate a chain point with a likely invalid block header hash.
genChainPoint :: Gen ChainPoint

-- | Generate a chain point at given slot with a likely invalid block
--   header hash.
genChainPointAt :: SlotNo -> Gen ChainPoint

-- | Construct a Shelley-style address from a Plutus script. This address
--   has no stake rights.
mkScriptAddress :: forall lang era. (IsShelleyBasedEra era, IsPlutusScriptLanguage lang) => NetworkId -> PlutusScript lang -> AddressInEra era

-- | From a ledger <tt>Addr</tt> to an api <a>AddressInEra</a>
fromLedgerAddr :: IsShelleyBasedEra era => Addr -> AddressInEra era

-- | From an api <a>AddressInEra</a> to a ledger <tt>Addr</tt>
toLedgerAddr :: AddressInEra era -> Addr

-- | A more random generator than the 'Arbitrary TxIn' from cardano-ledger.
--   NOTE: This is using the Cardano ledger's deserialization framework
--   using the latest protocol version via <a>maxBound</a>.
genTxIn :: Gen TxIn

-- | Deserialise some generic script data into some type.
fromScriptData :: FromScriptData a => HashableScriptData -> Maybe a

-- | Get the <a>HashableScriptData</a> associated to the a <a>TxOut</a>.
--   Note that this requires the <a>CtxTx</a> context.
txOutScriptData :: TxOut CtxTx era -> Maybe HashableScriptData

-- | Convert a cardano-api script data into a cardano-ledger script
--   <tt>Data</tt>. XXX: This is a partial function. Ideally it would fall
--   back to the <a>Data</a> portion in <a>HashableScriptData</a>.
toLedgerData :: Era era => HashableScriptData -> Data era

-- | Convert Cardano api <a>PolicyId</a> to Cardano ledger
--   <tt>PolicyID</tt>.
toLedgerPolicyID :: PolicyId -> PolicyID

-- | Convert Cardano api <a>PolicyId</a> to Plutus <a>CurrencySymbol</a>.
toPlutusCurrencySymbol :: PolicyId -> CurrencySymbol

-- | Attach some verification-key witness to a <a>TxIn</a>.
withWitness :: TxIn -> (TxIn, BuildTxWith BuildTx (Witness WitCtxTxIn Era))

-- | Access inputs of a transaction, as an ordered set.
txInputSet :: Tx era -> Set TxIn

-- | Convert a cardano-ledger <a>TxIn</a> into a cardano-api <a>TxIn</a>
fromLedgerTxIn :: TxIn -> TxIn

-- | Convert a plutus' <tt>TxOutRef</tt> into a cardano-api <a>TxIn</a>
fromPlutusTxOutRef :: TxOutRef -> TxIn

-- | Convert a cardano-api <a>TxIn</a> into a plutus <tt>TxOutRef</tt>.
toPlutusTxOutRef :: TxIn -> TxOutRef

-- | Create a transaction spending all given <a>UTxO</a>.
txSpendingUTxO :: UTxO -> Tx Era

-- | Convert a cardano-ledger's <a>Tx</a> in the Babbage era into a
--   cardano-api <a>Tx</a>.
fromLedgerTx :: IsShelleyBasedEra era => Tx (ShelleyLedgerEra era) -> Tx era

-- | Get the UTxO that are produced by some transaction. XXX: Defined here
--   to avoid cyclic module dependency
utxoProducedByTx :: Tx Era -> UTxO

-- | Convert a cardano-api <a>Tx</a> into a matching cardano-ledger
--   <a>Tx</a>.
toLedgerTx :: Tx era -> Tx (ShelleyLedgerEra era)

-- | Construct an inline <a>TxOutDatum</a> from some serialisable data.
mkTxOutDatumInline :: forall era a ctx. (ToScriptData a, IsBabbageBasedEra era) => a -> TxOutDatum ctx era

-- | Construct a UTxO from a transaction. This constructs artificial
--   <a>TxIn</a> (a.k.a output reference) from the transaction itself,
--   zipping them to the outputs they correspond to.
utxoFromTx :: Tx Era -> UTxO

-- | Resolve tx inputs in a given UTxO
resolveInputsUTxO :: UTxO -> Tx Era -> UTxO
fromLedgerValidityInterval :: ValidityInterval -> (TxValidityLowerBound Era, TxValidityUpperBound Era)

-- | Count number of assets in a <a>Value</a>.
valueSize :: Value -> Int

-- | Convert a cardano-ledger <tt>MultiAsset</tt> into a cardano-api
--   <a>Value</a>. The cardano-api currently does not have an asset-only
--   type. So this conversion will construct a <a>Value</a> with no
--   <a>AdaAssetId</a> entry in it.
fromLedgerMultiAsset :: MultiAsset -> Value

-- | Modify a <a>TxOut</a> to set the minimum ada on the value.
setMinUTxOValue :: PParams LedgerEra -> TxOut CtxUTxO Era -> TxOut ctx Era

-- | Convert a cardano-ledger <a>TxOut</a> into a cardano-api <a>TxOut</a>
fromLedgerTxOut :: IsShelleyBasedEra era => TxOut (ShelleyLedgerEra era) -> TxOut ctx era

-- | Convert a cardano-api <a>TxOut</a> into a cardano-ledger <a>TxOut</a>
toLedgerTxOut :: IsShelleyBasedEra era => TxOut CtxUTxO era -> TxOut (ShelleyLedgerEra era)

-- | Automatically balance a given output with the minimum required amount.
--   Number of assets, presence of datum and/or reference scripts may
--   affect this minimum value.
mkTxOutAutoBalance :: PParams LedgerEra -> AddressInEra Era -> Value -> TxOutDatum CtxTx Era -> ReferenceScript Era -> TxOut CtxTx Era

-- | Alter the value of a <a>TxOut</a> with the given transformation.
modifyTxOutValue :: IsMaryBasedEra era => (Value -> Value) -> TxOut ctx era -> TxOut ctx era

-- | Alter the address of a <a>TxOut</a> with the given transformation.
modifyTxOutAddress :: (AddressInEra era -> AddressInEra era) -> TxOut ctx era -> TxOut ctx era

-- | Alter the datum of a <a>TxOut</a> with the given transformation.
modifyTxOutDatum :: (TxOutDatum ctx0 era -> TxOutDatum ctx1 era) -> TxOut ctx0 era -> TxOut ctx1 era

-- | Find first <a>TxOut</a> which pays to given address and also return
--   the corresponding <a>TxIn</a> to reference it.
findTxOutByAddress :: AddressInEra era -> Tx era -> Maybe (TxIn, TxOut CtxTx era)

-- | Find a single script output in some <a>UTxO</a>
findTxOutByScript :: forall lang. IsPlutusScriptLanguage lang => UTxO -> PlutusScript lang -> Maybe (TxIn, TxOut CtxUTxO Era)

-- | Predicate to find or filter <a>TxOut</a> owned by a key. This is
--   better than comparing the full address as it does not require a
--   network discriminator.
isVkTxOut :: forall ctx era. VerificationKey PaymentKey -> TxOut ctx era -> Bool

-- | Predicate to find or filter <a>TxOut</a> which are governed by some
--   script. This is better than comparing the full address as it does not
--   require a network discriminator.
isScriptTxOut :: forall lang ctx era. IsPlutusScriptLanguage lang => PlutusScript lang -> TxOut ctx era -> Bool

-- | Convert a plutus <a>TxOut</a> into a cardano-api <a>TxOut</a>. NOTE:
--   Reference scripts are not resolvable right now. NOTE: Requires the
--   <tt>Network</tt> discriminator (Testnet or Mainnet) because Plutus
--   addresses are stripped off it.
fromPlutusTxOut :: forall era. IsBabbageBasedEra era => Network -> TxOut -> Maybe (TxOut CtxUTxO era)

-- | Convert a cardano-api <a>TxOut</a> into a plutus <a>TxOut</a>. Returns
--   <a>Nothing</a> if a byron address is used in the given <a>TxOut</a>.
toPlutusTxOut :: HasCallStack => TxOut CtxUTxO Era -> Maybe TxOut

-- | Construct a reference script witness, only referring to a <a>TxIn</a>
--   which is expected to contain the given script (only required to
--   satisfy types).
mkScriptReference :: forall ctx era lang. (IsPlutusScriptLanguage lang, HasScriptLanguageInEra lang era) => TxIn -> PlutusScript lang -> ScriptDatum ctx -> ScriptRedeemer -> ScriptWitness ctx era
class () => Pretty a
pretty :: Pretty a => a -> Doc ann
prettyList :: Pretty a => [a] -> Doc ann
class (Eq VerificationKey keyrole, Show VerificationKey keyrole, SerialiseAsRawBytes Hash keyrole, HasTextEnvelope VerificationKey keyrole, HasTextEnvelope SigningKey keyrole) => Key keyrole where {
    data family VerificationKey keyrole;
    data family SigningKey keyrole;
}
getVerificationKey :: Key keyrole => SigningKey keyrole -> VerificationKey keyrole
deterministicSigningKey :: Key keyrole => AsType keyrole -> Seed -> SigningKey keyrole
deterministicSigningKeySeedSize :: Key keyrole => AsType keyrole -> Word
verificationKeyHash :: Key keyrole => VerificationKey keyrole -> Hash keyrole
data () => Block era
[ByronBlock] :: ByronBlock -> Block ByronEra
[ShelleyBlock] :: forall era. ShelleyBasedEra era -> ShelleyBlock (ConsensusProtocol era) (ShelleyLedgerEra era) -> Block era

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad. This allows us to run IO
--   computations in any monadic stack, so long as it supports these kinds
--   of operations (i.e. <a>IO</a> is the base monad for the stack).
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   import Control.Monad.Trans.State -- from the "transformers" library
--   
--   printState :: Show s =&gt; StateT s IO ()
--   printState = do
--     state &lt;- get
--     liftIO $ print state
--   </pre>
--   
--   Had we omitted <tt><a>liftIO</a></tt>, we would have ended up with
--   this error:
--   
--   <pre>
--   • Couldn't match type ‘IO’ with ‘StateT s IO’
--    Expected type: StateT s IO ()
--      Actual type: IO ()
--   </pre>
--   
--   The important part here is the mismatch between <tt>StateT s IO
--   ()</tt> and <tt><a>IO</a> ()</tt>.
--   
--   Luckily, we know of a function that takes an <tt><a>IO</a> a</tt> and
--   returns an <tt>(m a)</tt>: <tt><a>liftIO</a></tt>, enabling us to run
--   the program and see the expected results:
--   
--   <pre>
--   &gt; evalStateT printState "hello"
--   "hello"
--   
--   &gt; evalStateT printState 3
--   3
--   </pre>
liftIO :: MonadIO m => IO a -> m a
newtype () => File content (direction :: FileDirection)
File :: FilePath -> File content (direction :: FileDirection)
[unFile] :: File content (direction :: FileDirection) -> FilePath

-- | A monad transformer that adds exceptions to other monads.
--   
--   <tt>ExceptT</tt> constructs a monad parameterized over two things:
--   
--   <ul>
--   <li>e - The exception type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a computation that produces the
--   given value, while <tt>&gt;&gt;=</tt> sequences two subcomputations,
--   exiting on the first exception.
newtype () => ExceptT e (m :: Type -> Type) a
ExceptT :: m (Either e a) -> ExceptT e (m :: Type -> Type) a

-- | The parameterizable exception monad.
--   
--   Computations are either exceptions or normal values.
--   
--   The <a>return</a> function returns a normal value, while
--   <tt>&gt;&gt;=</tt> exits on the first exception. For a variant that
--   continues after an error and collects all the errors, see
--   <a>Errors</a>.
type Except e = ExceptT e Identity

-- | The strategy of combining computations that can throw exceptions by
--   bypassing bound functions from the point an exception is thrown to the
--   point that it is handled.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a> String</tt> as the
--   monad type constructor for an error monad in which error descriptions
--   take the form of strings. In that case and many other common cases the
--   resulting monad is already defined as an instance of the
--   <a>MonadError</a> class. You can also define your own error type
--   and/or use a monad type constructor other than <tt><a>Either</a>
--   <tt>String</tt></tt> or <tt><a>Either</a> <tt>IOError</tt></tt>. In
--   these cases you will have to explicitly define instances of the
--   <a>MonadError</a> class. (If you are using the deprecated
--   <a>Control.Monad.Error</a> or <a>Control.Monad.Trans.Error</a>, you
--   may also have to define an <tt>Error</tt> instance.)
class Monad m => MonadError e (m :: Type -> Type) | m -> e

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | A handler function to handle previous errors and return to normal
--   execution. A common idiom is:
--   
--   <pre>
--   do { action1; action2; action3 } `catchError` handler
--   </pre>
--   
--   where the <tt>action</tt> functions can call <a>throwError</a>. Note
--   that <tt>handler</tt> and the do-block must have the same return type.
catchError :: MonadError e m => m a -> (e -> m a) -> m a

-- | The class of monad transformers. For any monad <tt>m</tt>, the result
--   <tt>t m</tt> should also be a monad, and <a>lift</a> should be a monad
--   transformation from <tt>m</tt> to <tt>t m</tt>, i.e. it should satisfy
--   the following laws:
--   
--   <ul>
--   <li><pre><a>lift</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>lift</a> (m &gt;&gt;= f) = <a>lift</a> m &gt;&gt;=
--   (<a>lift</a> . f)</pre></li>
--   </ul>
--   
--   Since 0.6.0.0 and for GHC 8.6 and later, the requirement that <tt>t
--   m</tt> be a <a>Monad</a> is enforced by the implication constraint
--   <tt>forall m. <a>Monad</a> m =&gt; <a>Monad</a> (t m)</tt> enabled by
--   the <tt>QuantifiedConstraints</tt> extension.
--   
--   <h3><b>Ambiguity error with GHC 9.0 to 9.2.2</b></h3>
--   
--   These versions of GHC have a bug
--   (<a>https://gitlab.haskell.org/ghc/ghc/-/issues/20582</a>) which
--   causes constraints like
--   
--   <pre>
--   (MonadTrans t, forall m. Monad m =&gt; Monad (t m)) =&gt; ...
--   </pre>
--   
--   to be reported as ambiguous. For transformers 0.6 and later, this can
--   be fixed by removing the second constraint, which is implied by the
--   first.
class forall (m :: Type -> Type). Monad m => Monad t m => MonadTrans (t :: Type -> Type -> Type -> Type)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a
class () => Error e
prettyError :: Error e => e -> Doc ann
data () => Doc ann
newtype () => Coin
Coin :: Integer -> Coin
[unCoin] :: Coin -> Integer
data () => PParams era
data () => AcquiringFailure
AFPointTooOld :: AcquiringFailure
AFPointNotOnChain :: AcquiringFailure
data family Hash keyrole
data () => PlutusScriptOrReferenceInput lang
PScript :: PlutusScript lang -> PlutusScriptOrReferenceInput lang
type PoolId = Hash StakePoolKey
data () => ShelleyGenesis
ShelleyGenesis :: !UTCTime -> !Word32 -> !Network -> !PositiveUnitInterval -> !NonZero Word64 -> !EpochSize -> !Word64 -> !Word64 -> !NominalDiffTimeMicro -> !Word64 -> !Word64 -> !PParams ShelleyEra -> !Map (KeyHash 'Genesis) GenDelegPair -> ListMap Addr Coin -> ShelleyGenesisStaking -> ShelleyGenesis
[sgSystemStart] :: ShelleyGenesis -> !UTCTime
[sgNetworkMagic] :: ShelleyGenesis -> !Word32
[sgNetworkId] :: ShelleyGenesis -> !Network
[sgActiveSlotsCoeff] :: ShelleyGenesis -> !PositiveUnitInterval
[sgSecurityParam] :: ShelleyGenesis -> !NonZero Word64
[sgEpochLength] :: ShelleyGenesis -> !EpochSize
[sgSlotsPerKESPeriod] :: ShelleyGenesis -> !Word64
[sgMaxKESEvolutions] :: ShelleyGenesis -> !Word64
[sgSlotLength] :: ShelleyGenesis -> !NominalDiffTimeMicro
[sgUpdateQuorum] :: ShelleyGenesis -> !Word64
[sgMaxLovelaceSupply] :: ShelleyGenesis -> !Word64
[sgProtocolParams] :: ShelleyGenesis -> !PParams ShelleyEra
[sgGenDelegs] :: ShelleyGenesis -> !Map (KeyHash 'Genesis) GenDelegPair
[sgInitialFunds] :: ShelleyGenesis -> ListMap Addr Coin
[sgStaking] :: ShelleyGenesis -> ShelleyGenesisStaking
type family ShelleyLedgerEra era = (ledgerera :: Type) | ledgerera -> era
data family SigningKey keyrole
data () => StakeCredential
StakeCredentialByKey :: Hash StakeKey -> StakeCredential
StakeCredentialByScript :: ScriptHash -> StakeCredential
data family VerificationKey keyrole
data () => Address addrtype
[ByronAddress] :: Address -> Address ByronAddr
[ShelleyAddress] :: Network -> PaymentCredential -> StakeReference -> Address ShelleyAddr
data () => BlockHeader
BlockHeader :: !SlotNo -> !Hash BlockHeader -> !BlockNo -> BlockHeader
data () => ChainPoint
ChainPointAtGenesis :: ChainPoint
ChainPoint :: !SlotNo -> !Hash BlockHeader -> ChainPoint
data () => ExecutionUnits
ExecutionUnits :: Natural -> Natural -> ExecutionUnits
[executionSteps] :: ExecutionUnits -> Natural
[executionMemory] :: ExecutionUnits -> Natural
data () => NetworkId
Mainnet :: NetworkId
Testnet :: !NetworkMagic -> NetworkId
newtype () => NetworkMagic
NetworkMagic :: Word32 -> NetworkMagic
[unNetworkMagic] :: NetworkMagic -> Word32
newtype () => PolicyAssets
PolicyAssets :: Map AssetName Quantity -> PolicyAssets
newtype () => PolicyId
PolicyId :: ScriptHash -> PolicyId
[unPolicyId] :: PolicyId -> ScriptHash
data () => ScriptData
ScriptDataConstructor :: Integer -> [ScriptData] -> ScriptData
ScriptDataMap :: [(ScriptData, ScriptData)] -> ScriptData
ScriptDataList :: [ScriptData] -> ScriptData
ScriptDataNumber :: Integer -> ScriptData
ScriptDataBytes :: ByteString -> ScriptData
data () => ScriptDatum witctx
[ScriptDatumForTxIn] :: Maybe HashableScriptData -> ScriptDatum WitCtxTxIn
[InlineScriptDatum] :: ScriptDatum WitCtxTxIn
[NoScriptDatumForMint] :: ScriptDatum WitCtxMint
[NoScriptDatumForStake] :: ScriptDatum WitCtxStake
newtype () => ScriptHash
ScriptHash :: ScriptHash -> ScriptHash
data () => StakeAddress
newtype () => TxId
TxId :: Hash HASH EraIndependentTxBody -> TxId
data () => TxIn
TxIn :: TxId -> TxIx -> TxIn
data () => TxOutValue era
[TxOutValueByron] :: Coin -> TxOutValue ByronEra
[TxOutValueShelleyBased] :: forall era. (Eq (Value (ShelleyLedgerEra era)), Show (Value (ShelleyLedgerEra era))) => ShelleyBasedEra era -> Value (ShelleyLedgerEra era) -> TxOutValue era
data () => Value
data () => Network
data () => ByronAddr
class () => FromJSON a
class () => ToJSON a
class Typeable a => FromCBOR a
class Typeable a => ToCBOR a
data () => ConwayEra
data () => CtxUTxO
data () => AddressAny
AddressByron :: !Address ByronAddr -> AddressAny
AddressShelley :: !Address ShelleyAddr -> AddressAny
data () => PaymentCredential
PaymentCredentialByKey :: Hash PaymentKey -> PaymentCredential
PaymentCredentialByScript :: ScriptHash -> PaymentCredential
class HasTypeProxy addr => SerialiseAddress addr
serialiseAddress :: SerialiseAddress addr => addr -> Text
deserialiseAddress :: SerialiseAddress addr => AsType addr -> Text -> Maybe addr
data () => ShelleyAddr
newtype () => StakeAddressPointer
StakeAddressPointer :: Ptr -> StakeAddressPointer
[unStakeAddressPointer] :: StakeAddressPointer -> Ptr
data () => StakeAddressReference
StakeAddressByValue :: StakeCredential -> StakeAddressReference
StakeAddressByPointer :: StakeAddressPointer -> StakeAddressReference
NoStakeAddress :: StakeAddressReference
newtype () => AnchorDataHash
AnchorDataHash :: SafeHash AnchorData -> AnchorDataHash
[unAnchorDataHash] :: AnchorDataHash -> SafeHash AnchorData
newtype () => AnchorUrl
AnchorUrl :: Url -> AnchorUrl
[unAnchorUrl] :: AnchorUrl -> Url
data () => BlockInMode
[BlockInMode] :: forall era. CardanoEra era -> Block era -> BlockInMode
data () => ChainTip
ChainTipAtGenesis :: ChainTip
ChainTip :: !SlotNo -> !Hash BlockHeader -> !BlockNo -> ChainTip
class (SerialiseAsRawBytes a, HasTypeProxy a) => Cip129 a
cip129Bech32PrefixFor :: Cip129 a => AsType a -> HumanReadablePart
cip129HeaderHexByte :: Cip129 a => a -> ByteString
cip129Bech32PrefixesPermitted :: Cip129 a => AsType a -> [Text]
data () => AnchorDataFromCertificateError
InvalidPoolMetadataHashError :: Url -> ByteString -> AnchorDataFromCertificateError
data () => Certificate era
[ShelleyRelatedCertificate] :: forall era. Typeable era => ShelleyToBabbageEra era -> ShelleyTxCert (ShelleyLedgerEra era) -> Certificate era
[ConwayCertificate] :: forall era. Typeable era => ConwayEraOnwards era -> ConwayTxCert (ShelleyLedgerEra era) -> Certificate era
data () => CommitteeColdkeyResignationRequirements era
[CommitteeColdkeyResignationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'ColdCommitteeRole -> Maybe Anchor -> CommitteeColdkeyResignationRequirements era
data () => CommitteeHotKeyAuthorizationRequirements era
[CommitteeHotKeyAuthorizationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'ColdCommitteeRole -> Credential 'HotCommitteeRole -> CommitteeHotKeyAuthorizationRequirements era
data () => DRepMetadataReference
data () => DRepRegistrationRequirements era
[DRepRegistrationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'DRepRole -> Coin -> DRepRegistrationRequirements era
data () => DRepUnregistrationRequirements era
[DRepUnregistrationRequirements] :: forall era. ConwayEraOnwards era -> Credential 'DRepRole -> Coin -> DRepUnregistrationRequirements era
data () => DRepUpdateRequirements era
[DRepUpdateRequirements] :: forall era. ConwayEraOnwards era -> Credential 'DRepRole -> DRepUpdateRequirements era
data () => GenesisKeyDelegationRequirements era
[GenesisKeyDelegationRequirements] :: forall era. ShelleyToBabbageEra era -> Hash GenesisKey -> Hash GenesisDelegateKey -> Hash VrfKey -> GenesisKeyDelegationRequirements era
data () => MirCertificateRequirements era
[MirCertificateRequirements] :: forall era. ShelleyToBabbageEra era -> MIRPot -> MIRTarget -> MirCertificateRequirements era
data () => StakeAddressRequirements era
[StakeAddrRegistrationConway] :: forall era. ConwayEraOnwards era -> Coin -> StakeCredential -> StakeAddressRequirements era
[StakeAddrRegistrationPreConway] :: forall era. ShelleyToBabbageEra era -> StakeCredential -> StakeAddressRequirements era
data () => StakeDelegationRequirements era
[StakeDelegationRequirementsConwayOnwards] :: forall era. ConwayEraOnwards era -> StakeCredential -> Delegatee -> StakeDelegationRequirements era
[StakeDelegationRequirementsPreConway] :: forall era. ShelleyToBabbageEra era -> StakeCredential -> PoolId -> StakeDelegationRequirements era
data () => StakePoolMetadataReference
data () => StakePoolParameters
data () => StakePoolRegistrationRequirements era
[StakePoolRegistrationRequirementsConwayOnwards] :: forall era. ConwayEraOnwards era -> PoolParams -> StakePoolRegistrationRequirements era
[StakePoolRegistrationRequirementsPreConway] :: forall era. ShelleyToBabbageEra era -> PoolParams -> StakePoolRegistrationRequirements era
data () => StakePoolRelay
data () => StakePoolRetirementRequirements era
[StakePoolRetirementRequirementsConwayOnwards] :: forall era. ConwayEraOnwards era -> PoolId -> EpochNo -> StakePoolRetirementRequirements era
[StakePoolRetirementRequirementsPreConway] :: forall era. ShelleyToBabbageEra era -> PoolId -> EpochNo -> StakePoolRetirementRequirements era
newtype () => ScriptLockedTxInsError
ScriptLockedTxIns :: [TxIn] -> ScriptLockedTxInsError
data () => TxInsExistError
TxInsDoNotExist :: [TxIn] -> TxInsExistError
EmptyUTxO :: TxInsExistError
data () => QueryConvenienceError
AcqFailure :: AcquiringFailure -> QueryConvenienceError
QueryEraMismatch :: EraMismatch -> QueryConvenienceError
ByronEraNotSupported :: QueryConvenienceError
QceUnsupportedNtcVersion :: !UnsupportedNtcVersionError -> QueryConvenienceError
QceUnexpectedException :: !SomeException -> QueryConvenienceError
newtype () => TxCurrentTreasuryValue
TxCurrentTreasuryValue :: Coin -> TxCurrentTreasuryValue
[unTxCurrentTreasuryValue] :: TxCurrentTreasuryValue -> Coin
data () => DRepMetadata
data () => InputDecodeError
InputTextEnvelopeError :: !TextEnvelopeError -> InputDecodeError
InputBech32DecodeError :: !Bech32DecodeError -> InputDecodeError
InputInvalidError :: InputDecodeError
data () => InputFormat a
[InputFormatBech32] :: forall a. SerialiseAsBech32 a => InputFormat a
[InputFormatHex] :: forall a. SerialiseAsRawBytes a => InputFormat a
[InputFormatTextEnvelope] :: forall a. HasTextEnvelope a => InputFormat a
data () => SomeAddressVerificationKey
AByronVerificationKey :: VerificationKey ByronKey -> SomeAddressVerificationKey
APaymentVerificationKey :: VerificationKey PaymentKey -> SomeAddressVerificationKey
APaymentExtendedVerificationKey :: VerificationKey PaymentExtendedKey -> SomeAddressVerificationKey
AGenesisUTxOVerificationKey :: VerificationKey GenesisUTxOKey -> SomeAddressVerificationKey
AGenesisExtendedVerificationKey :: VerificationKey GenesisExtendedKey -> SomeAddressVerificationKey
AGenesisDelegateExtendedVerificationKey :: VerificationKey GenesisDelegateExtendedKey -> SomeAddressVerificationKey
AKesVerificationKey :: VerificationKey KesKey -> SomeAddressVerificationKey
AVrfVerificationKey :: VerificationKey VrfKey -> SomeAddressVerificationKey
AStakeVerificationKey :: VerificationKey StakeKey -> SomeAddressVerificationKey
AStakeExtendedVerificationKey :: VerificationKey StakeExtendedKey -> SomeAddressVerificationKey
AStakePoolVerificationKey :: VerificationKey StakePoolKey -> SomeAddressVerificationKey
AStakePoolExtendedVerificationKey :: VerificationKey StakePoolExtendedKey -> SomeAddressVerificationKey
ADRepVerificationKey :: VerificationKey DRepKey -> SomeAddressVerificationKey
ADRepExtendedVerificationKey :: VerificationKey DRepExtendedKey -> SomeAddressVerificationKey
ACommitteeColdVerificationKey :: VerificationKey CommitteeColdKey -> SomeAddressVerificationKey
ACommitteeColdExtendedVerificationKey :: VerificationKey CommitteeColdExtendedKey -> SomeAddressVerificationKey
ACommitteeHotVerificationKey :: VerificationKey CommitteeHotKey -> SomeAddressVerificationKey
ACommitteeHotExtendedVerificationKey :: VerificationKey CommitteeHotExtendedKey -> SomeAddressVerificationKey
data () => AllegraEraOnwards era
[AllegraEraOnwardsAllegra] :: AllegraEraOnwards AllegraEra
[AllegraEraOnwardsMary] :: AllegraEraOnwards MaryEra
[AllegraEraOnwardsAlonzo] :: AllegraEraOnwards AlonzoEra
[AllegraEraOnwardsBabbage] :: AllegraEraOnwards BabbageEra
[AllegraEraOnwardsConway] :: AllegraEraOnwards ConwayEra
class IsShelleyBasedEra era => IsAllegraBasedEra era
allegraBasedEra :: IsAllegraBasedEra era => AllegraEraOnwards era
data () => AlonzoEraOnwards era
[AlonzoEraOnwardsAlonzo] :: AlonzoEraOnwards AlonzoEra
[AlonzoEraOnwardsBabbage] :: AlonzoEraOnwards BabbageEra
[AlonzoEraOnwardsConway] :: AlonzoEraOnwards ConwayEra
type AlonzoEraOnwardsConstraints era = (HashAlgorithm HASH, Signable VRF StandardCrypto Seed, PraosProtocolSupportsNode ConsensusProtocol era, ShelleyBlock ConsensusProtocol era ShelleyLedgerEra era ~ ConsensusBlockForEra era, ShelleyCompatible ConsensusProtocol era ShelleyLedgerEra era, ADDRHASH ~ Blake2b_224, AlonzoEraPParams ShelleyLedgerEra era, AlonzoEraTx ShelleyLedgerEra era, AlonzoEraTxBody ShelleyLedgerEra era, AlonzoEraTxOut ShelleyLedgerEra era, AlonzoEraTxWits ShelleyLedgerEra era, Era ShelleyLedgerEra era, EraPParams ShelleyLedgerEra era, EraTx ShelleyLedgerEra era, EraTxBody ShelleyLedgerEra era, EraTxOut ShelleyLedgerEra era, EraUTxO ShelleyLedgerEra era, HashAnnotated TxBody ShelleyLedgerEra era EraIndependentTxBody, MaryEraTxBody ShelleyLedgerEra era, NativeScript ShelleyLedgerEra era ~ Timelock ShelleyLedgerEra era, EraPlutusContext ShelleyLedgerEra era, Script ShelleyLedgerEra era ~ AlonzoScript ShelleyLedgerEra era, ScriptsNeeded ShelleyLedgerEra era ~ AlonzoScriptsNeeded ShelleyLedgerEra era, ShelleyEraTxCert ShelleyLedgerEra era, Value ShelleyLedgerEra era ~ MaryValue, FromCBOR ChainDepState ConsensusProtocol era, FromCBOR DebugLedgerState era, IsCardanoEra era, IsShelleyBasedEra era, ToJSON ChainDepState ConsensusProtocol era, ToJSON DebugLedgerState era, Typeable era, era == ByronEra ~ 'False)
class IsMaryBasedEra era => IsAlonzoBasedEra era
alonzoBasedEra :: IsAlonzoBasedEra era => AlonzoEraOnwards era
data () => BabbageEraOnwards era
[BabbageEraOnwardsBabbage] :: BabbageEraOnwards BabbageEra
[BabbageEraOnwardsConway] :: BabbageEraOnwards ConwayEra
class IsAlonzoBasedEra era => IsBabbageBasedEra era
babbageBasedEra :: IsBabbageBasedEra era => BabbageEraOnwards era
data () => ByronToAlonzoEra era
[ByronToAlonzoEraByron] :: ByronToAlonzoEra ByronEra
[ByronToAlonzoEraShelley] :: ByronToAlonzoEra ShelleyEra
[ByronToAlonzoEraAllegra] :: ByronToAlonzoEra AllegraEra
[ByronToAlonzoEraMary] :: ByronToAlonzoEra MaryEra
[ByronToAlonzoEraAlonzo] :: ByronToAlonzoEra AlonzoEra
class () => Convert (f :: a -> Type) (g :: a -> Type)
convert :: forall (era :: a). Convert f g => f era -> g era
data () => ConwayEraOnwards era
[ConwayEraOnwardsConway] :: ConwayEraOnwards ConwayEra
class IsBabbageBasedEra era => IsConwayBasedEra era
conwayBasedEra :: IsConwayBasedEra era => ConwayEraOnwards era
class IsAllegraBasedEra era => IsMaryBasedEra era
maryBasedEra :: IsMaryBasedEra era => MaryEraOnwards era
data () => MaryEraOnwards era
[MaryEraOnwardsMary] :: MaryEraOnwards MaryEra
[MaryEraOnwardsAlonzo] :: MaryEraOnwards AlonzoEra
[MaryEraOnwardsBabbage] :: MaryEraOnwards BabbageEra
[MaryEraOnwardsConway] :: MaryEraOnwards ConwayEra
data () => AnyShelleyBasedEra
[AnyShelleyBasedEra] :: forall era. Typeable era => ShelleyBasedEra era -> AnyShelleyBasedEra
data () => InAnyShelleyBasedEra (thing :: Type -> Type)
[InAnyShelleyBasedEra] :: forall era (thing :: Type -> Type). Typeable era => ShelleyBasedEra era -> thing era -> InAnyShelleyBasedEra thing
class IsCardanoEra era => IsShelleyBasedEra era
shelleyBasedEra :: IsShelleyBasedEra era => ShelleyBasedEra era
data () => ShelleyBasedEra era
[ShelleyBasedEraShelley] :: ShelleyBasedEra ShelleyEra
[ShelleyBasedEraAllegra] :: ShelleyBasedEra AllegraEra
[ShelleyBasedEraMary] :: ShelleyBasedEra MaryEra
[ShelleyBasedEraAlonzo] :: ShelleyBasedEra AlonzoEra
[ShelleyBasedEraBabbage] :: ShelleyBasedEra BabbageEra
[ShelleyBasedEraConway] :: ShelleyBasedEra ConwayEra
data () => ShelleyEraOnly era
[ShelleyEraOnlyShelley] :: ShelleyEraOnly ShelleyEra
data () => ShelleyToAllegraEra era
[ShelleyToAllegraEraShelley] :: ShelleyToAllegraEra ShelleyEra
[ShelleyToAllegraEraAllegra] :: ShelleyToAllegraEra AllegraEra
data () => ShelleyToAlonzoEra era
[ShelleyToAlonzoEraShelley] :: ShelleyToAlonzoEra ShelleyEra
[ShelleyToAlonzoEraAllegra] :: ShelleyToAlonzoEra AllegraEra
[ShelleyToAlonzoEraMary] :: ShelleyToAlonzoEra MaryEra
[ShelleyToAlonzoEraAlonzo] :: ShelleyToAlonzoEra AlonzoEra
data () => ShelleyToBabbageEra era
[ShelleyToBabbageEraShelley] :: ShelleyToBabbageEra ShelleyEra
[ShelleyToBabbageEraAllegra] :: ShelleyToBabbageEra AllegraEra
[ShelleyToBabbageEraMary] :: ShelleyToBabbageEra MaryEra
[ShelleyToBabbageEraAlonzo] :: ShelleyToBabbageEra AlonzoEra
[ShelleyToBabbageEraBabbage] :: ShelleyToBabbageEra BabbageEra
data () => ShelleyToMaryEra era
[ShelleyToMaryEraShelley] :: ShelleyToMaryEra ShelleyEra
[ShelleyToMaryEraAllegra] :: ShelleyToMaryEra AllegraEra
[ShelleyToMaryEraMary] :: ShelleyToMaryEra MaryEra
data () => AllegraEra
data () => AlonzoEra
data () => AnyCardanoEra
[AnyCardanoEra] :: forall era. Typeable era => CardanoEra era -> AnyCardanoEra
data () => BabbageEra
data () => ByronEra
data () => CardanoEra era
[ByronEra] :: CardanoEra ByronEra
[ShelleyEra] :: CardanoEra ShelleyEra
[AllegraEra] :: CardanoEra AllegraEra
[MaryEra] :: CardanoEra MaryEra
[AlonzoEra] :: CardanoEra AlonzoEra
[BabbageEra] :: CardanoEra BabbageEra
[ConwayEra] :: CardanoEra ConwayEra
class () => Eon (eon :: Type -> Type)
inEonForEra :: Eon eon => a -> (eon era -> a) -> CardanoEra era -> a
data () => EraInEon (eon :: Type -> Type)
[EraInEon] :: forall era (eon :: Type -> Type). (Typeable era, Typeable (eon era), Eon eon) => eon era -> EraInEon eon
data () => InAnyCardanoEra (thing :: Type -> Type)
[InAnyCardanoEra] :: forall era (thing :: Type -> Type). Typeable era => CardanoEra era -> thing era -> InAnyCardanoEra thing
class HasTypeProxy era => IsCardanoEra era
cardanoEra :: IsCardanoEra era => CardanoEra era
data () => MaryEra
data () => ShelleyEra
class () => ToCardanoEra (eon :: Type -> Type)
toCardanoEra :: ToCardanoEra eon => eon era -> CardanoEra era
data () => FileError e
FileError :: FilePath -> e -> FileError e
FileErrorTempFile :: FilePath -> FilePath -> Handle -> FileError e
FileDoesNotExistError :: FilePath -> FileError e
FileIOError :: FilePath -> IOException -> FileError e
data () => Featured (eon :: Type -> Type) era a
[Featured] :: forall (eon :: Type -> Type) era a. eon era -> a -> Featured eon era a
data () => AutoBalanceError era
AutoBalanceEstimationError :: TxFeeEstimationError era -> AutoBalanceError era
AutoBalanceCalculationError :: TxBodyErrorAutoBalance era -> AutoBalanceError era
data () => FeeEstimationMode era
CalculateWithSpendableUTxO :: UTxO era -> SystemStart -> LedgerEpochInfo -> Maybe Word -> FeeEstimationMode era
EstimateWithoutSpendableUTxO :: Coin -> Value -> Map ScriptWitnessIndex ExecutionUnits -> RequiredShelleyKeyWitnesses -> RequiredByronKeyWitnesses -> TotalReferenceScriptsSize -> FeeEstimationMode era
newtype () => RequiredByronKeyWitnesses
RequiredByronKeyWitnesses :: Int -> RequiredByronKeyWitnesses
[unRequiredByronKeyWitnesses] :: RequiredByronKeyWitnesses -> Int
newtype () => RequiredShelleyKeyWitnesses
RequiredShelleyKeyWitnesses :: Int -> RequiredShelleyKeyWitnesses
[unRequiredShelleyKeyWitnesses] :: RequiredShelleyKeyWitnesses -> Int
data () => ResolvablePointers
[ResolvablePointers] :: forall era. (Era (ShelleyLedgerEra era), Show (PlutusPurpose AsIx (ShelleyLedgerEra era)), Show (PlutusPurpose AsItem (ShelleyLedgerEra era)), Show (PlutusScript (ShelleyLedgerEra era))) => ShelleyBasedEra era -> !Map (PlutusPurpose AsIx (ShelleyLedgerEra era)) (PlutusPurpose AsItem (ShelleyLedgerEra era), Maybe (PlutusScriptBytes, Language), ScriptHash) -> ResolvablePointers
data () => ScriptExecutionError
ScriptErrorMissingTxIn :: TxIn -> ScriptExecutionError
ScriptErrorTxInWithoutDatum :: TxIn -> ScriptExecutionError
ScriptErrorWrongDatum :: Hash ScriptData -> ScriptExecutionError
ScriptErrorEvaluationFailed :: DebugPlutusFailure -> ScriptExecutionError
ScriptErrorExecutionUnitsOverflow :: ScriptExecutionError
ScriptErrorNotPlutusWitnessedTxIn :: ScriptWitnessIndex -> ScriptHash -> ScriptExecutionError
ScriptErrorRedeemerPointsToUnknownScriptHash :: ScriptWitnessIndex -> ScriptExecutionError
ScriptErrorMissingScript :: ScriptWitnessIndex -> ResolvablePointers -> ScriptExecutionError
ScriptErrorMissingCostModel :: Language -> ScriptExecutionError
ScriptErrorTranslationError :: ContextError (ShelleyLedgerEra era) -> ScriptExecutionError
newtype () => TotalReferenceScriptsSize
TotalReferenceScriptsSize :: Int -> TotalReferenceScriptsSize
[unTotalReferenceScriptsSize] :: TotalReferenceScriptsSize -> Int
data () => TransactionValidityError era
[TransactionValidityIntervalError] :: forall era. PastHorizonException -> TransactionValidityError era
[TransactionValidityCostModelError] :: forall era. Map AnyPlutusScriptVersion CostModel -> String -> TransactionValidityError era
data () => TxBodyError
TxBodyPlutusScriptDecodeError :: DecoderError -> TxBodyError
TxBodyEmptyTxIns :: TxBodyError
TxBodyEmptyTxInsCollateral :: TxBodyError
TxBodyEmptyTxOuts :: TxBodyError
TxBodyOutputError :: !TxOutputError -> TxBodyError
TxBodyMetadataError :: ![(Word64, TxMetadataRangeError)] -> TxBodyError
TxBodyInIxOverflow :: !TxIn -> TxBodyError
TxBodyMissingProtocolParams :: TxBodyError
TxBodyProtocolParamsConversionError :: !ProtocolParametersConversionError -> TxBodyError
data () => TxBodyErrorAutoBalance era
TxBodyError :: TxBodyError -> TxBodyErrorAutoBalance era
TxBodyScriptExecutionError :: [(ScriptWitnessIndex, ScriptExecutionError)] -> TxBodyErrorAutoBalance era
TxBodyScriptBadScriptValidity :: TxBodyErrorAutoBalance era
TxBodyErrorBalanceNegative :: Coin -> MultiAsset -> TxBodyErrorAutoBalance era
TxBodyErrorAdaBalanceTooSmall :: TxOutInAnyEra -> Coin -> Coin -> TxBodyErrorAutoBalance era
TxBodyErrorByronEraNotSupported :: TxBodyErrorAutoBalance era
TxBodyErrorMissingParamMinUTxO :: TxBodyErrorAutoBalance era
TxBodyErrorMinUTxONotMet :: TxOutInAnyEra -> Coin -> TxBodyErrorAutoBalance era
TxBodyErrorNonAdaAssetsUnbalanced :: Value -> TxBodyErrorAutoBalance era
TxBodyErrorScriptWitnessIndexMissingFromExecUnitsMap :: ScriptWitnessIndex -> Map ScriptWitnessIndex ExecutionUnits -> TxBodyErrorAutoBalance era
data () => TxFeeEstimationError era
TxFeeEstimationTransactionTranslationError :: TransactionValidityError era -> TxFeeEstimationError era
TxFeeEstimationScriptExecutionError :: TxBodyErrorAutoBalance era -> TxFeeEstimationError era
TxFeeEstimationBalanceError :: TxBodyErrorAutoBalance era -> TxFeeEstimationError era
TxFeeEstimationxBodyError :: TxBodyError -> TxFeeEstimationError era
TxFeeEstimationFinalConstructionError :: TxBodyError -> TxFeeEstimationError era
TxFeeEstimationOnlyMaryOnwardsSupportedError :: TxFeeEstimationError era
type AlonzoGenesisFile = File AlonzoGenesisConfig
type ByronGenesisFile = File ByronGenesisConfig
type ConwayGenesisFile = File ConwayGenesisConfig
newtype () => GenesisHashAlonzo
GenesisHashAlonzo :: Hash Blake2b_256 ByteString -> GenesisHashAlonzo
[unGenesisHashAlonzo] :: GenesisHashAlonzo -> Hash Blake2b_256 ByteString
newtype () => GenesisHashByron
GenesisHashByron :: Text -> GenesisHashByron
[unGenesisHashByron] :: GenesisHashByron -> Text
newtype () => GenesisHashConway
GenesisHashConway :: Hash Blake2b_256 ByteString -> GenesisHashConway
[unGenesisHashConway] :: GenesisHashConway -> Hash Blake2b_256 ByteString
newtype () => GenesisHashShelley
GenesisHashShelley :: Hash Blake2b_256 ByteString -> GenesisHashShelley
[unGenesisHashShelley] :: GenesisHashShelley -> Hash Blake2b_256 ByteString
data () => ShelleyConfig
ShelleyConfig :: !ShelleyGenesis -> !GenesisHashShelley -> ShelleyConfig
[scConfig] :: ShelleyConfig -> !ShelleyGenesis
[scGenesisHash] :: ShelleyConfig -> !GenesisHashShelley
type ShelleyGenesisFile = File ShelleyGenesisConfig
data () => GenesisParameters era
GenesisParameters :: UTCTime -> NetworkId -> Rational -> NonZero Word64 -> EpochSize -> NominalDiffTime -> Int -> Int -> Int -> Coin -> PParams (ShelleyLedgerEra era) -> GenesisParameters era
[protocolParamSystemStart] :: GenesisParameters era -> UTCTime
[protocolParamNetworkId] :: GenesisParameters era -> NetworkId
[protocolParamActiveSlotsCoefficient] :: GenesisParameters era -> Rational
[protocolParamSecurity] :: GenesisParameters era -> NonZero Word64
[protocolParamEpochLength] :: GenesisParameters era -> EpochSize
[protocolParamSlotLength] :: GenesisParameters era -> NominalDiffTime
[protocolParamSlotsPerKESPeriod] :: GenesisParameters era -> Int
[protocolParamMaxKESEvolutions] :: GenesisParameters era -> Int
[protocolParamUpdateQuorum] :: GenesisParameters era -> Int
[protocolParamMaxLovelaceSupply] :: GenesisParameters era -> Coin
[protocolInitialUpdateableProtocolParameters] :: GenesisParameters era -> PParams (ShelleyLedgerEra era)
data () => CIP119
DrepRegistrationMetadata :: CIP119
data () => CIP108
BaseGovActionMetadata :: CIP108
class Typeable t => HasTypeProxy t where {
    data family AsType t;
}
proxyToAsType :: HasTypeProxy t => Proxy t -> AsType t
data family AsType t
pattern AsByronAddress :: AsType (Address ByronAddr)
pattern AsShelleyAddress :: AsType (Address ShelleyAddr)
pattern AsAllegraTx :: AsType (Tx AllegraEra)
pattern AsAlonzoTx :: AsType (Tx AlonzoEra)
pattern AsByronTxBody :: AsType (TxBody ByronEra)
pattern AsByronWitness :: AsType (KeyWitness ByronEra)
pattern AsMaryTx :: AsType (Tx MaryEra)
pattern AsMaryTxBody :: AsType (TxBody MaryEra)
pattern AsShelleyTxBody :: AsType (TxBody ShelleyEra)
pattern AsShelleyWitness :: AsType (KeyWitness ShelleyEra)
data () => FromSomeType (c :: Type -> Constraint) b
[FromSomeType] :: forall (c :: Type -> Constraint) a b. c a => AsType a -> (a -> b) -> FromSomeType c b
data () => FileDirection
In :: FileDirection
Out :: FileDirection
InOut :: FileDirection
type SocketPath = File Socket 'InOut
data () => LocalChainSyncClient block point tip (m :: Type -> Type)
NoLocalChainSyncClient :: LocalChainSyncClient block point tip (m :: Type -> Type)
LocalChainSyncClientPipelined :: ChainSyncClientPipelined block point tip m () -> LocalChainSyncClient block point tip (m :: Type -> Type)
LocalChainSyncClient :: ChainSyncClient block point tip m () -> LocalChainSyncClient block point tip (m :: Type -> Type)
data () => LocalNodeClientParams
[LocalNodeClientParamsSingleBlock] :: forall block. (ProtocolClient block, LedgerSupportsProtocol (ShelleyBlock (TPraos StandardCrypto) ShelleyEra)) => ProtocolClientInfoArgs block -> (NodeToClientVersion -> LocalNodeClientProtocolsForBlock block) -> LocalNodeClientParams
[LocalNodeClientParamsCardano] :: forall block. (ProtocolClient block, CardanoHardForkConstraints (ConsensusCryptoForBlock block)) => ProtocolClientInfoArgs block -> (NodeToClientVersion -> LocalNodeClientProtocolsForBlock block) -> LocalNodeClientParams
data () => LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type)
LocalNodeClientProtocols :: LocalChainSyncClient block point tip m -> Maybe (LocalTxSubmissionClient tx txerr m ()) -> Maybe (LocalStateQueryClient block point query m ()) -> Maybe (LocalTxMonitorClient txid tx slot m ()) -> LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type)
[localChainSyncClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> LocalChainSyncClient block point tip m
[localTxSubmissionClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> Maybe (LocalTxSubmissionClient tx txerr m ())
[localStateQueryClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> Maybe (LocalStateQueryClient block point query m ())
[localTxMonitoringClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr (query :: Type -> Type) (m :: Type -> Type) -> Maybe (LocalTxMonitorClient txid tx slot m ())
type LocalNodeClientProtocolsInMode = LocalNodeClientProtocols BlockInMode ChainPoint ChainTip SlotNo TxInMode TxIdInMode TxValidationErrorInCardanoMode QueryInMode IO
data () => LocalNodeConnectInfo
LocalNodeConnectInfo :: ConsensusModeParams -> NetworkId -> SocketPath -> LocalNodeConnectInfo
[localConsensusModeParams] :: LocalNodeConnectInfo -> ConsensusModeParams
[localNodeNetworkId] :: LocalNodeConnectInfo -> NetworkId
[localNodeSocketPath] :: LocalNodeConnectInfo -> SocketPath
data () => LocalTxMonitoringQuery
LocalTxMonitoringQueryTx :: TxIdInMode -> LocalTxMonitoringQuery
LocalTxMonitoringSendNextTx :: LocalTxMonitoringQuery
LocalTxMonitoringMempoolInformation :: LocalTxMonitoringQuery
data () => LocalTxMonitoringResult
LocalTxMonitoringTxExists :: TxId -> SlotNo -> LocalTxMonitoringResult
LocalTxMonitoringTxDoesNotExist :: TxId -> SlotNo -> LocalTxMonitoringResult
LocalTxMonitoringNextTx :: Maybe TxInMode -> SlotNo -> LocalTxMonitoringResult
LocalTxMonitoringMempoolSizeAndCapacity :: MempoolSizeAndCapacity -> SlotNo -> LocalTxMonitoringResult
data () => LocalStateQueryExpr block point (query :: Type -> Type) r (m :: Type -> Type) a
data () => UnsupportedNtcVersionError
UnsupportedNtcVersionError :: !NodeToClientVersion -> ![NodeToClientVersion] -> UnsupportedNtcVersionError
data () => TxIdInMode
[TxIdInMode] :: forall era. CardanoEra era -> TxId -> TxIdInMode
data () => TxInMode
[TxInMode] :: forall era. ShelleyBasedEra era -> Tx era -> TxInMode
[TxInByronSpecial] :: GenTx ByronBlock -> TxInMode
data () => TxValidationErrorInCardanoMode
[TxValidationErrorInCardanoMode] :: forall era. TxValidationError era -> TxValidationErrorInCardanoMode
[TxValidationEraMismatch] :: EraMismatch -> TxValidationErrorInCardanoMode
data () => ByronKey
data () => ByronKeyLegacy
data () => MnemonicSize
MS12 :: MnemonicSize
MS15 :: MnemonicSize
MS18 :: MnemonicSize
MS21 :: MnemonicSize
MS24 :: MnemonicSize
data () => MnemonicToSigningKeyError
InvalidMnemonicError :: String -> MnemonicToSigningKeyError
InvalidAccountNumberError :: Word32 -> MnemonicToSigningKeyError
InvalidPaymentKeyNoError :: Word32 -> MnemonicToSigningKeyError
data () => CommitteeColdExtendedKey
data () => CommitteeColdKey
data () => CommitteeHotExtendedKey
data () => CommitteeHotKey
data () => DRepExtendedKey
data () => DRepKey
data () => GenesisDelegateExtendedKey
data () => GenesisDelegateKey
data () => GenesisExtendedKey
data () => GenesisKey
data () => GenesisUTxOKey
data () => PaymentExtendedKey
data () => PaymentKey
data () => StakeExtendedKey
data () => StakeKey
data () => AnyNewEpochState
[AnyNewEpochState] :: forall era. ShelleyBasedEra era -> NewEpochState (ShelleyLedgerEra era) -> LedgerTables (LedgerState (CardanoBlock StandardCrypto)) ValuesMK -> AnyNewEpochState
data () => ConditionResult
ConditionNotMet :: ConditionResult
ConditionMet :: ConditionResult
data () => Env
Env :: CardanoLedgerConfig StandardCrypto -> CardanoConsensusConfig StandardCrypto -> Env
[envLedgerConfig] :: Env -> CardanoLedgerConfig StandardCrypto
[envConsensusConfig] :: Env -> CardanoConsensusConfig StandardCrypto
data () => FoldBlocksError
FoldBlocksInitialLedgerStateError :: !InitialLedgerStateError -> FoldBlocksError
FoldBlocksApplyBlockError :: !LedgerStateError -> FoldBlocksError
FoldBlocksIOException :: !IOException -> FoldBlocksError
FoldBlocksMuxError :: !Error -> FoldBlocksError
data () => FoldStatus
ContinueFold :: FoldStatus
StopFold :: FoldStatus
DebugFold :: FoldStatus
data () => GenesisConfig
GenesisCardano :: !NodeConfig -> !Config -> !GenesisHashShelley -> !TransitionConfig LatestKnownEra -> GenesisConfig
data () => GenesisConfigError
NEError :: !Text -> GenesisConfigError
NEByronConfig :: !FilePath -> !ConfigurationError -> GenesisConfigError
NEShelleyConfig :: !FilePath -> !Text -> GenesisConfigError
NEAlonzoConfig :: !FilePath -> !Text -> GenesisConfigError
NEConwayConfig :: !FilePath -> !Text -> GenesisConfigError
NECardanoConfig :: !Text -> GenesisConfigError
data () => InitialLedgerStateError
ILSEConfigFile :: Text -> InitialLedgerStateError
ILSEGenesisFile :: GenesisConfigError -> InitialLedgerStateError
ILSELedgerConsensusConfig :: GenesisConfigError -> InitialLedgerStateError
data () => LedgerState
LedgerState :: CardanoLedgerState StandardCrypto EmptyMK -> LedgerTables (LedgerState (HardForkBlock (CardanoEras StandardCrypto))) ValuesMK -> LedgerState
[clsState] :: LedgerState -> CardanoLedgerState StandardCrypto EmptyMK
[clsTables] :: LedgerState -> LedgerTables (LedgerState (HardForkBlock (CardanoEras StandardCrypto))) ValuesMK
pattern LedgerStateAllegra :: LedgerState StandardAllegraBlock EmptyMK -> LedgerState
pattern LedgerStateAlonzo :: LedgerState StandardAlonzoBlock EmptyMK -> LedgerState
pattern LedgerStateBabbage :: LedgerState StandardBabbageBlock EmptyMK -> LedgerState
pattern LedgerStateByron :: LedgerState ByronBlock EmptyMK -> LedgerState
pattern LedgerStateConway :: LedgerState StandardConwayBlock EmptyMK -> LedgerState
pattern LedgerStateMary :: LedgerState StandardMaryBlock EmptyMK -> LedgerState
pattern LedgerStateShelley :: LedgerState StandardShelleyBlock EmptyMK -> LedgerState
data () => LedgerStateError
ApplyBlockHashMismatch :: Text -> LedgerStateError
ApplyBlockError :: CardanoLedgerError StandardCrypto -> LedgerStateError
InvalidRollback :: SlotNo -> ChainPoint -> LedgerStateError
TerminationEpochReached :: EpochNo -> LedgerStateError
UnexpectedLedgerState :: AnyShelleyBasedEra -> NS (Current (Flip LedgerState EmptyMK)) (CardanoEras StandardCrypto) -> LedgerStateError
ByronEraUnsupported :: LedgerStateError
DebugError :: !String -> LedgerStateError
data () => NodeConfig
NodeConfig :: !Maybe Double -> !File ByronGenesisConfig 'In -> !GenesisHashByron -> !File ShelleyGenesisConfig 'In -> !GenesisHashShelley -> !File AlonzoGenesis 'In -> !GenesisHashAlonzo -> !Maybe (File ConwayGenesisConfig 'In) -> !Maybe GenesisHashConway -> !RequiresNetworkMagic -> !ProtocolVersion -> !CardanoHardForkTriggers -> NodeConfig
[ncPBftSignatureThreshold] :: NodeConfig -> !Maybe Double
[ncByronGenesisFile] :: NodeConfig -> !File ByronGenesisConfig 'In
[ncByronGenesisHash] :: NodeConfig -> !GenesisHashByron
[ncShelleyGenesisFile] :: NodeConfig -> !File ShelleyGenesisConfig 'In
[ncShelleyGenesisHash] :: NodeConfig -> !GenesisHashShelley
[ncAlonzoGenesisFile] :: NodeConfig -> !File AlonzoGenesis 'In
[ncAlonzoGenesisHash] :: NodeConfig -> !GenesisHashAlonzo
[ncConwayGenesisFile] :: NodeConfig -> !Maybe (File ConwayGenesisConfig 'In)
[ncConwayGenesisHash] :: NodeConfig -> !Maybe GenesisHashConway
[ncRequiresNetworkMagic] :: NodeConfig -> !RequiresNetworkMagic
[ncByronProtocolVersion] :: NodeConfig -> !ProtocolVersion
[ncHardForkTriggers] :: NodeConfig -> !CardanoHardForkTriggers
type NodeConfigFile = File NodeConfig
data () => ValidationMode
FullValidation :: ValidationMode
QuickValidation :: ValidationMode
type family ChainDepStateProtocol era
type family ConsensusBlockForEra era
data () => ConsensusModeParams
[CardanoModeParams] :: EpochSlots -> ConsensusModeParams
type family ConsensusProtocol era
type MonadIOTransError e (t :: Type -> Type -> Type -> Type) (m :: Type -> Type) = (MonadIO m, MonadIO t m, MonadCatch m, MonadTrans t, MonadError e t m)
type MonadTransError e (t :: Type -> Type -> Type -> Type) (m :: Type -> Type) = (Monad m, MonadTrans t, MonadError e t m)
data () => OperationalCertIssueError
data () => OperationalCertificate
data () => OperationalCertificateIssueCounter
data () => DebugPlutusFailure
DebugPlutusFailure :: EvaluationError -> PlutusWithContext -> ExUnits -> [Text] -> DebugPlutusFailure
[dpfEvaluationError] :: DebugPlutusFailure -> EvaluationError
[dpfScriptWithContext] :: DebugPlutusFailure -> PlutusWithContext
[dpfExecutionUnits] :: DebugPlutusFailure -> ExUnits
[dpfExecutionLogs] :: DebugPlutusFailure -> [Text]
type Ann = AnsiStyle
data () => BlockType blk
[ByronBlockType] :: BlockType (HardForkBlock '[ByronBlock])
[ShelleyBlockType] :: BlockType (HardForkBlock '[ShelleyBlock (TPraos StandardCrypto) ShelleyEra])
[CardanoBlockType] :: BlockType (HardForkBlock (CardanoEras StandardCrypto))
class (RunNode blk, IOLike m) => Protocol (m :: Type -> Type) blk where {
    data family ProtocolInfoArgs blk;
}
protocolInfo :: Protocol m blk => ProtocolInfoArgs blk -> (ProtocolInfo blk, m [BlockForging m blk])
data family ProtocolInfoArgs blk
data () => SomeBlockType
[SomeBlockType] :: forall blk. BlockType blk -> SomeBlockType
newtype () => CostModel
CostModel :: [Int64] -> CostModel
data () => ExecutionUnitPrices
ExecutionUnitPrices :: Rational -> Rational -> ExecutionUnitPrices
[priceExecutionSteps] :: ExecutionUnitPrices -> Rational
[priceExecutionMemory] :: ExecutionUnitPrices -> Rational
data () => PraosNonce
data () => ProtocolParametersConversionError
PpceOutOfBounds :: !ProtocolParameterName -> !Rational -> ProtocolParametersConversionError
PpceVersionInvalid :: !ProtocolParameterVersion -> ProtocolParametersConversionError
PpceInvalidCostModel :: !CostModel -> !CostModelApplyError -> ProtocolParametersConversionError
PpceMissingParameter :: !ProtocolParameterName -> ProtocolParametersConversionError
data () => ProtocolParametersUpdate
ProtocolParametersUpdate :: Maybe (Natural, Natural) -> Maybe Rational -> Maybe (Maybe PraosNonce) -> Maybe Word16 -> Maybe Word32 -> Maybe Word32 -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe Coin -> Maybe EpochInterval -> Maybe Word16 -> Maybe Rational -> Maybe Rational -> Maybe Rational -> Map AnyPlutusScriptVersion CostModel -> Maybe ExecutionUnitPrices -> Maybe ExecutionUnits -> Maybe ExecutionUnits -> Maybe Natural -> Maybe Natural -> Maybe Natural -> Maybe Coin -> ProtocolParametersUpdate
[protocolUpdateProtocolVersion] :: ProtocolParametersUpdate -> Maybe (Natural, Natural)
[protocolUpdateDecentralization] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateExtraPraosEntropy] :: ProtocolParametersUpdate -> Maybe (Maybe PraosNonce)
[protocolUpdateMaxBlockHeaderSize] :: ProtocolParametersUpdate -> Maybe Word16
[protocolUpdateMaxBlockBodySize] :: ProtocolParametersUpdate -> Maybe Word32
[protocolUpdateMaxTxSize] :: ProtocolParametersUpdate -> Maybe Word32
[protocolUpdateTxFeeFixed] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateTxFeePerByte] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateMinUTxOValue] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateStakeAddressDeposit] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateStakePoolDeposit] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdateMinPoolCost] :: ProtocolParametersUpdate -> Maybe Coin
[protocolUpdatePoolRetireMaxEpoch] :: ProtocolParametersUpdate -> Maybe EpochInterval
[protocolUpdateStakePoolTargetNum] :: ProtocolParametersUpdate -> Maybe Word16
[protocolUpdatePoolPledgeInfluence] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateMonetaryExpansion] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateTreasuryCut] :: ProtocolParametersUpdate -> Maybe Rational
[protocolUpdateCostModels] :: ProtocolParametersUpdate -> Map AnyPlutusScriptVersion CostModel
[protocolUpdatePrices] :: ProtocolParametersUpdate -> Maybe ExecutionUnitPrices
[protocolUpdateMaxTxExUnits] :: ProtocolParametersUpdate -> Maybe ExecutionUnits
[protocolUpdateMaxBlockExUnits] :: ProtocolParametersUpdate -> Maybe ExecutionUnits
[protocolUpdateMaxValueSize] :: ProtocolParametersUpdate -> Maybe Natural
[protocolUpdateCollateralPercent] :: ProtocolParametersUpdate -> Maybe Natural
[protocolUpdateMaxCollateralInputs] :: ProtocolParametersUpdate -> Maybe Natural
[protocolUpdateUTxOCostPerByte] :: ProtocolParametersUpdate -> Maybe Coin
data () => UpdateProposal
UpdateProposal :: !Map (Hash GenesisKey) ProtocolParametersUpdate -> !EpochNo -> UpdateProposal
data () => EraHistory
[EraHistory] :: forall (xs :: [Type]). CardanoBlock StandardCrypto ~ HardForkBlock xs => Interpreter xs -> EraHistory
newtype () => LedgerEpochInfo
LedgerEpochInfo :: EpochInfo (Either Text) -> LedgerEpochInfo
[unLedgerEpochInfo] :: LedgerEpochInfo -> EpochInfo (Either Text)
data () => QueryInEra era result
[QueryByronUpdateState] :: QueryInEra ByronEra ByronUpdateState
[QueryInShelleyBasedEra] :: forall era result. ShelleyBasedEra era -> QueryInShelleyBasedEra era result -> QueryInEra era result
data () => QueryInMode result
[QueryCurrentEra] :: QueryInMode AnyCardanoEra
[QueryInEra] :: forall era result1. QueryInEra era result1 -> QueryInMode (Either EraMismatch result1)
[QueryEraHistory] :: QueryInMode EraHistory
[QuerySystemStart] :: QueryInMode SystemStart
[QueryChainBlockNo] :: QueryInMode (WithOrigin BlockNo)
[QueryChainPoint] :: QueryInMode ChainPoint
[QueryLedgerConfig] :: QueryInMode (HardForkLedgerConfig (CardanoEras StandardCrypto))
data () => QueryInShelleyBasedEra era result
[QueryEpoch] :: forall era. QueryInShelleyBasedEra era EpochNo
[QueryGenesisParameters] :: forall era. QueryInShelleyBasedEra era (GenesisParameters ShelleyEra)
[QueryProtocolParameters] :: forall era. QueryInShelleyBasedEra era (PParams (ShelleyLedgerEra era))
[QueryStakeDistribution] :: forall era. QueryInShelleyBasedEra era (Map (Hash StakePoolKey) Rational)
[QueryUTxO] :: forall era. QueryUTxOFilter -> QueryInShelleyBasedEra era (UTxO era)
[QueryStakeAddresses] :: forall era. Set StakeCredential -> NetworkId -> QueryInShelleyBasedEra era (Map StakeAddress Coin, Map StakeAddress PoolId)
[QueryStakePools] :: forall era. QueryInShelleyBasedEra era (Set PoolId)
[QueryStakePoolParameters] :: forall era. Set PoolId -> QueryInShelleyBasedEra era (Map PoolId StakePoolParameters)
[QueryDebugLedgerState] :: forall era. QueryInShelleyBasedEra era (SerialisedDebugLedgerState era)
[QueryProtocolState] :: forall era. QueryInShelleyBasedEra era (ProtocolState era)
[QueryCurrentEpochState] :: forall era. QueryInShelleyBasedEra era (SerialisedCurrentEpochState era)
[QueryPoolState] :: forall era. Maybe (Set PoolId) -> QueryInShelleyBasedEra era (SerialisedPoolState era)
[QueryPoolDistribution] :: forall era. Maybe (Set PoolId) -> QueryInShelleyBasedEra era (SerialisedPoolDistribution era)
[QueryStakeSnapshot] :: forall era. Maybe (Set PoolId) -> QueryInShelleyBasedEra era (SerialisedStakeSnapshots era)
[QueryStakeDelegDeposits] :: forall era. Set StakeCredential -> QueryInShelleyBasedEra era (Map StakeCredential Coin)
[QueryAccountState] :: forall era. QueryInShelleyBasedEra era AccountState
[QueryConstitution] :: forall era. QueryInShelleyBasedEra era (Constitution (ShelleyLedgerEra era))
[QueryGovState] :: forall era. QueryInShelleyBasedEra era (GovState (ShelleyLedgerEra era))
[QueryRatifyState] :: forall era. QueryInShelleyBasedEra era (RatifyState (ShelleyLedgerEra era))
[QueryFuturePParams] :: forall era. QueryInShelleyBasedEra era (Maybe (PParams (ShelleyLedgerEra era)))
[QueryDRepState] :: forall era. Set (Credential 'DRepRole) -> QueryInShelleyBasedEra era (Map (Credential 'DRepRole) DRepState)
[QueryDRepStakeDistr] :: forall era. Set DRep -> QueryInShelleyBasedEra era (Map DRep Coin)
[QuerySPOStakeDistr] :: forall era. Set (KeyHash 'StakePool) -> QueryInShelleyBasedEra era (Map (KeyHash 'StakePool) Coin)
[QueryCommitteeMembersState] :: forall era. Set (Credential 'ColdCommitteeRole) -> Set (Credential 'HotCommitteeRole) -> Set MemberStatus -> QueryInShelleyBasedEra era CommitteeMembersState
[QueryStakeVoteDelegatees] :: forall era. Set StakeCredential -> QueryInShelleyBasedEra era (Map StakeCredential DRep)
[QueryProposals] :: forall era. Set GovActionId -> QueryInShelleyBasedEra era (Seq (GovActionState (ShelleyLedgerEra era)))
[QueryLedgerPeerSnapshot] :: forall era. QueryInShelleyBasedEra era (Serialised LedgerPeerSnapshot)
[QueryStakePoolDefaultVote] :: forall era. KeyHash 'StakePool -> QueryInShelleyBasedEra era DefaultVote
data () => QueryUTxOFilter
QueryUTxOWhole :: QueryUTxOFilter
QueryUTxOByAddress :: Set AddressAny -> QueryUTxOFilter
QueryUTxOByTxIn :: Set TxIn -> QueryUTxOFilter
newtype () => SlotsInEpoch
SlotsInEpoch :: Word64 -> SlotsInEpoch
newtype () => SlotsToEpochEnd
SlotsToEpochEnd :: Word64 -> SlotsToEpochEnd
newtype () => DelegationsAndRewards
DelegationsAndRewards :: (Map StakeAddress Coin, Map StakeAddress PoolId) -> DelegationsAndRewards
data () => AnyPlutusScriptVersion
[AnyPlutusScriptVersion] :: forall lang. IsPlutusScriptLanguage lang => PlutusScriptVersion lang -> AnyPlutusScriptVersion
data () => AnyScriptLanguage
[AnyScriptLanguage] :: forall lang. ScriptLanguage lang -> AnyScriptLanguage
class () => HasScriptLanguageInEra lang era
scriptLanguageInEra :: HasScriptLanguageInEra lang era => ScriptLanguageInEra lang era
class IsScriptLanguage lang => IsPlutusScriptLanguage lang
plutusScriptVersion :: IsPlutusScriptLanguage lang => PlutusScriptVersion lang
class HasTypeProxy lang => IsScriptLanguage lang
scriptLanguage :: IsScriptLanguage lang => ScriptLanguage lang
class () => IsScriptWitnessInCtx ctx
scriptWitnessInCtx :: IsScriptWitnessInCtx ctx => ScriptWitnessInCtx ctx
data () => KeyWitnessInCtx witctx
[KeyWitnessForSpending] :: KeyWitnessInCtx WitCtxTxIn
[KeyWitnessForStakeAddr] :: KeyWitnessInCtx WitCtxStake
data () => PlutusScriptInEra era lang
[PlutusScriptInEra] :: forall lang era. PlutusScript lang -> PlutusScriptInEra era lang
data () => PlutusScriptV1
data () => PlutusScriptV2
data () => PlutusScriptV3
data () => PlutusScriptVersion lang
[PlutusScriptV1] :: PlutusScriptVersion PlutusScriptV1
[PlutusScriptV2] :: PlutusScriptVersion PlutusScriptV2
[PlutusScriptV3] :: PlutusScriptVersion PlutusScriptV3
data () => ScriptInAnyLang
[ScriptInAnyLang] :: forall lang. ScriptLanguage lang -> Script lang -> ScriptInAnyLang
data () => ScriptLanguageInEra lang era
[SimpleScriptInShelley] :: ScriptLanguageInEra SimpleScript' ShelleyEra
[SimpleScriptInAllegra] :: ScriptLanguageInEra SimpleScript' AllegraEra
[SimpleScriptInMary] :: ScriptLanguageInEra SimpleScript' MaryEra
[SimpleScriptInAlonzo] :: ScriptLanguageInEra SimpleScript' AlonzoEra
[SimpleScriptInBabbage] :: ScriptLanguageInEra SimpleScript' BabbageEra
[SimpleScriptInConway] :: ScriptLanguageInEra SimpleScript' ConwayEra
[PlutusScriptV1InAlonzo] :: ScriptLanguageInEra PlutusScriptV1 AlonzoEra
[PlutusScriptV1InBabbage] :: ScriptLanguageInEra PlutusScriptV1 BabbageEra
[PlutusScriptV1InConway] :: ScriptLanguageInEra PlutusScriptV1 ConwayEra
[PlutusScriptV2InBabbage] :: ScriptLanguageInEra PlutusScriptV2 BabbageEra
[PlutusScriptV2InConway] :: ScriptLanguageInEra PlutusScriptV2 ConwayEra
[PlutusScriptV3InConway] :: ScriptLanguageInEra PlutusScriptV3 ConwayEra
type ScriptRedeemer = HashableScriptData
data () => ScriptWitnessInCtx witctx
[ScriptWitnessForSpending] :: ScriptWitnessInCtx WitCtxTxIn
[ScriptWitnessForMinting] :: ScriptWitnessInCtx WitCtxMint
[ScriptWitnessForStakeAddr] :: ScriptWitnessInCtx WitCtxStake
data () => SimpleScript
RequireSignature :: !Hash PaymentKey -> SimpleScript
RequireTimeBefore :: !SlotNo -> SimpleScript
RequireTimeAfter :: !SlotNo -> SimpleScript
RequireAllOf :: ![SimpleScript] -> SimpleScript
RequireAnyOf :: ![SimpleScript] -> SimpleScript
RequireMOf :: !Int -> ![SimpleScript] -> SimpleScript
data () => SimpleScript'
class () => ToAlonzoScript lang era
toLedgerScript :: ToAlonzoScript lang era => PlutusScript lang -> AlonzoScript (ShelleyLedgerEra era)
data () => WitCtx witctx
[WitCtxTxIn] :: WitCtx WitCtxTxIn
[WitCtxMint] :: WitCtx WitCtxMint
[WitCtxStake] :: WitCtx WitCtxStake
data () => WitCtxMint
data () => WitCtxStake
data () => WitCtxTxIn
data () => HashableScriptData
data () => ScriptDataJsonBytesError
ScriptDataJsonBytesErrorValue :: ScriptDataJsonError -> ScriptDataJsonBytesError
ScriptDataJsonBytesErrorInvalid :: ScriptDataRangeError -> ScriptDataJsonBytesError
data () => ScriptDataJsonError
ScriptDataJsonSchemaError :: !Value -> !ScriptDataJsonSchemaError -> ScriptDataJsonError
ScriptDataRangeError :: !Value -> !ScriptDataRangeError -> ScriptDataJsonError
data () => ScriptDataJsonSchema
ScriptDataJsonNoSchema :: ScriptDataJsonSchema
ScriptDataJsonDetailedSchema :: ScriptDataJsonSchema
data () => ScriptDataJsonSchemaError
ScriptDataJsonNullNotAllowed :: ScriptDataJsonSchemaError
ScriptDataJsonBoolNotAllowed :: ScriptDataJsonSchemaError
ScriptDataJsonNumberNotInteger :: !Double -> ScriptDataJsonSchemaError
ScriptDataJsonNotObject :: !Value -> ScriptDataJsonSchemaError
ScriptDataJsonBadObject :: ![(Text, Value)] -> ScriptDataJsonSchemaError
ScriptDataJsonBadMapPair :: !Value -> ScriptDataJsonSchemaError
ScriptDataJsonTypeMismatch :: !Text -> !Value -> ScriptDataJsonSchemaError
newtype () => ScriptDataRangeError
ScriptDataConstructorOutOfRange :: Integer -> ScriptDataRangeError
class HasTypeProxy a => SerialiseAsCBOR a
serialiseToCBOR :: SerialiseAsCBOR a => a -> ByteString
deserialiseFromCBOR :: SerialiseAsCBOR a => AsType a -> ByteString -> Either DecoderError a
data () => Bech32DecodeError
Bech32DecodingError :: !DecodingError -> Bech32DecodeError
Bech32UnexpectedPrefix :: !Text -> !Set Text -> Bech32DecodeError
Bech32DataPartToBytesError :: !Text -> Bech32DecodeError
Bech32DeserialiseFromBytesError :: !ByteString -> Bech32DecodeError
Bech32WrongPrefix :: !Text -> !Text -> Bech32DecodeError
Bech32UnexpectedHeader :: !Text -> !Text -> Bech32DecodeError
class (HasTypeProxy a, SerialiseAsRawBytes a) => SerialiseAsBech32 a
newtype () => JsonDecodeError
JsonDecodeError :: String -> JsonDecodeError
data () => FromSomeTypeCDDL c b
[FromCDDLTx] :: forall b. Text -> (InAnyShelleyBasedEra Tx -> b) -> FromSomeTypeCDDL TextEnvelope b
[FromCDDLWitness] :: forall b. Text -> (InAnyShelleyBasedEra KeyWitness -> b) -> FromSomeTypeCDDL TextEnvelope b
data () => TextEnvelopeCddlError
TextEnvelopeCddlErrCBORDecodingError :: DecoderError -> TextEnvelopeCddlError
TextEnvelopeCddlAesonDecodeError :: FilePath -> String -> TextEnvelopeCddlError
TextEnvelopeCddlUnknownKeyWitness :: TextEnvelopeCddlError
TextEnvelopeCddlTypeError :: [Text] -> Text -> TextEnvelopeCddlError
TextEnvelopeCddlErrUnknownType :: Text -> TextEnvelopeCddlError
TextEnvelopeCddlErrByronKeyWitnessUnsupported :: TextEnvelopeCddlError
data () => RawBytesHexError
RawBytesHexErrorBase16DecodeFail :: ByteString -> String -> RawBytesHexError
RawBytesHexErrorRawBytesDecodeFail :: ByteString -> TypeRep -> SerialiseAsRawBytesError -> RawBytesHexError
class (HasTypeProxy a, Typeable a) => SerialiseAsRawBytes a
serialiseToRawBytes :: SerialiseAsRawBytes a => a -> ByteString
deserialiseFromRawBytes :: SerialiseAsRawBytes a => AsType a -> ByteString -> Either SerialiseAsRawBytesError a
newtype () => SerialiseAsRawBytesError
SerialiseAsRawBytesError :: String -> SerialiseAsRawBytesError
[unSerialiseAsRawBytesError] :: SerialiseAsRawBytesError -> String
class SerialiseAsCBOR a => HasTextEnvelope a
textEnvelopeType :: HasTextEnvelope a => AsType a -> TextEnvelopeType
textEnvelopeDefaultDescr :: HasTextEnvelope a => a -> TextEnvelopeDescr
data () => TextEnvelope
TextEnvelope :: !TextEnvelopeType -> !TextEnvelopeDescr -> !ByteString -> TextEnvelope
[teType] :: TextEnvelope -> !TextEnvelopeType
[teDescription] :: TextEnvelope -> !TextEnvelopeDescr
[teRawCBOR] :: TextEnvelope -> !ByteString
data () => TextEnvelopeDescr
data () => TextEnvelopeError
TextEnvelopeTypeError :: ![TextEnvelopeType] -> !TextEnvelopeType -> TextEnvelopeError
TextEnvelopeDecodeError :: !DecoderError -> TextEnvelopeError
TextEnvelopeAesonDecodeError :: !String -> TextEnvelopeError
newtype () => TextEnvelopeType
TextEnvelopeType :: String -> TextEnvelopeType
newtype () => UsingBech32 a
UsingBech32 :: a -> UsingBech32 a
newtype () => UsingRawBytes a
UsingRawBytes :: a -> UsingRawBytes a
newtype () => UsingRawBytesHex a
UsingRawBytesHex :: a -> UsingRawBytesHex a
data () => StakePoolMetadata
data () => StakePoolMetadataValidationError
StakePoolMetadataJsonDecodeError :: !String -> StakePoolMetadataValidationError
StakePoolMetadataInvalidLengthError :: !Int -> !Int -> StakePoolMetadataValidationError
data () => AnyScriptWitness era
[AnyScriptWitness] :: forall witctx era. Typeable witctx => ScriptWitness witctx era -> AnyScriptWitness era
data () => ScriptWitnessIndex
ScriptWitnessIndexTxIn :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexMint :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexCertificate :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexWithdrawal :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexVoting :: !Word32 -> ScriptWitnessIndex
ScriptWitnessIndexProposing :: !Word32 -> ScriptWitnessIndex
data () => TxCertificates build era
[TxCertificatesNone] :: forall build era. TxCertificates build era
[TxCertificates] :: forall era build. ShelleyBasedEra era -> OMap (Certificate era) (BuildTxWith build (Maybe (StakeCredential, Witness WitCtxStake era))) -> TxCertificates build era
data () => TxProposalProcedures build era
[TxProposalProceduresNone] :: forall build era. TxProposalProcedures build era
[TxProposalProcedures] :: forall era build. EraPParams (ShelleyLedgerEra era) => OMap (ProposalProcedure (ShelleyLedgerEra era)) (BuildTxWith build (Maybe (ScriptWitness WitCtxStake era))) -> TxProposalProcedures build era
data () => TxReturnCollateral ctx era
[TxReturnCollateralNone] :: forall ctx era. TxReturnCollateral ctx era
[TxReturnCollateral] :: forall era ctx. BabbageEraOnwards era -> TxOut ctx era -> TxReturnCollateral ctx era
data () => TxTotalCollateral era
[TxTotalCollateralNone] :: forall era. TxTotalCollateral era
[TxTotalCollateral] :: forall era. BabbageEraOnwards era -> Coin -> TxTotalCollateral era
data () => TxUpdateProposal era
[TxUpdateProposalNone] :: forall era. TxUpdateProposal era
[TxUpdateProposal] :: forall era. ShelleyToBabbageEra era -> UpdateProposal -> TxUpdateProposal era
data () => TxVotingProcedures build era
[TxVotingProceduresNone] :: forall build era. TxVotingProcedures build era
[TxVotingProcedures] :: forall era build. VotingProcedures (ShelleyLedgerEra era) -> BuildTxWith build (Map Voter (ScriptWitness WitCtxStake era)) -> TxVotingProcedures build era
data () => TxWithdrawals build era
[TxWithdrawalsNone] :: forall build era. TxWithdrawals build era
[TxWithdrawals] :: forall era build. ShelleyBasedEra era -> [(StakeAddress, Coin, BuildTxWith build (Witness WitCtxStake era))] -> TxWithdrawals build era
data () => BuildTx
data () => BuildTxWith build a
[ViewTx] :: forall a. BuildTxWith ViewTx a
[BuildTxWith] :: forall a. a -> BuildTxWith BuildTx a
data () => ViewTx
data () => CtxTx
data () => TxOutInAnyEra
[TxOutInAnyEra] :: forall era. CardanoEra era -> TxOut CtxTx era -> TxOutInAnyEra
data () => TxOutputError
TxOutputNegative :: !Quantity -> !TxOutInAnyEra -> TxOutputError
TxOutputOverflow :: !Quantity -> !TxOutInAnyEra -> TxOutputError
data () => ScriptValidity
ScriptInvalid :: ScriptValidity
ScriptValid :: ScriptValidity
data () => ShelleyWitnessSigningKey
WitnessPaymentKey :: SigningKey PaymentKey -> ShelleyWitnessSigningKey
WitnessPaymentExtendedKey :: SigningKey PaymentExtendedKey -> ShelleyWitnessSigningKey
WitnessStakeKey :: SigningKey StakeKey -> ShelleyWitnessSigningKey
WitnessStakeExtendedKey :: SigningKey StakeExtendedKey -> ShelleyWitnessSigningKey
WitnessStakePoolKey :: SigningKey StakePoolKey -> ShelleyWitnessSigningKey
WitnessStakePoolExtendedKey :: SigningKey StakePoolExtendedKey -> ShelleyWitnessSigningKey
WitnessGenesisKey :: SigningKey GenesisKey -> ShelleyWitnessSigningKey
WitnessGenesisExtendedKey :: SigningKey GenesisExtendedKey -> ShelleyWitnessSigningKey
WitnessGenesisDelegateKey :: SigningKey GenesisDelegateKey -> ShelleyWitnessSigningKey
WitnessGenesisDelegateExtendedKey :: SigningKey GenesisDelegateExtendedKey -> ShelleyWitnessSigningKey
WitnessGenesisUTxOKey :: SigningKey GenesisUTxOKey -> ShelleyWitnessSigningKey
WitnessCommitteeColdKey :: SigningKey CommitteeColdKey -> ShelleyWitnessSigningKey
WitnessCommitteeColdExtendedKey :: SigningKey CommitteeColdExtendedKey -> ShelleyWitnessSigningKey
WitnessCommitteeHotKey :: SigningKey CommitteeHotKey -> ShelleyWitnessSigningKey
WitnessCommitteeHotExtendedKey :: SigningKey CommitteeHotExtendedKey -> ShelleyWitnessSigningKey
WitnessDRepKey :: SigningKey DRepKey -> ShelleyWitnessSigningKey
WitnessDRepExtendedKey :: SigningKey DRepExtendedKey -> ShelleyWitnessSigningKey
newtype () => TxIx
TxIx :: Word -> TxIx
class () => AsTxMetadata a
asTxMetadata :: AsTxMetadata a => a -> TxMetadata
newtype () => TxMetadata
TxMetadata :: Map Word64 TxMetadataValue -> TxMetadata
[unTxMetadata] :: TxMetadata -> Map Word64 TxMetadataValue
data () => TxMetadataJsonError
TxMetadataJsonToplevelNotMap :: TxMetadataJsonError
TxMetadataJsonToplevelBadKey :: !Text -> TxMetadataJsonError
TxMetadataJsonSchemaError :: !Word64 -> !Value -> !TxMetadataJsonSchemaError -> TxMetadataJsonError
TxMetadataRangeError :: !Word64 -> !Value -> !TxMetadataRangeError -> TxMetadataJsonError
data () => TxMetadataJsonSchema
TxMetadataJsonNoSchema :: TxMetadataJsonSchema
TxMetadataJsonDetailedSchema :: TxMetadataJsonSchema
data () => TxMetadataJsonSchemaError
TxMetadataJsonNullNotAllowed :: TxMetadataJsonSchemaError
TxMetadataJsonBoolNotAllowed :: TxMetadataJsonSchemaError
TxMetadataJsonNumberNotInteger :: !Double -> TxMetadataJsonSchemaError
TxMetadataJsonNotObject :: !Value -> TxMetadataJsonSchemaError
TxMetadataJsonBadObject :: ![(Text, Value)] -> TxMetadataJsonSchemaError
TxMetadataJsonBadMapPair :: !Value -> TxMetadataJsonSchemaError
TxMetadataJsonTypeMismatch :: !Text -> !Value -> TxMetadataJsonSchemaError
data () => TxMetadataRangeError
TxMetadataNumberOutOfRange :: !Integer -> TxMetadataRangeError
TxMetadataTextTooLong :: !Int -> TxMetadataRangeError
TxMetadataBytesTooLong :: !Int -> TxMetadataRangeError
data () => TxMetadataValue
TxMetaMap :: [(TxMetadataValue, TxMetadataValue)] -> TxMetadataValue
TxMetaList :: [TxMetadataValue] -> TxMetadataValue
TxMetaNumber :: Integer -> TxMetadataValue
TxMetaBytes :: ByteString -> TxMetadataValue
TxMetaText :: Text -> TxMetadataValue
data () => AssetId
AdaAssetId :: AssetId
AssetId :: !PolicyId -> !AssetName -> AssetId
newtype () => AssetName
AssetName :: ByteString -> AssetName
type Lovelace = Coin
newtype () => Quantity
Quantity :: Integer -> Quantity
data () => ValueNestedBundle
ValueNestedBundleAda :: Quantity -> ValueNestedBundle
ValueNestedBundle :: PolicyId -> Map AssetName Quantity -> ValueNestedBundle
newtype () => ValueNestedRep
ValueNestedRep :: [ValueNestedBundle] -> ValueNestedRep
newtype () => ShowOf a
ShowOf :: a -> ShowOf a
data () => CommitteeMembersState
CommitteeMembersState :: !Map (Credential 'ColdCommitteeRole) CommitteeMemberState -> !Maybe UnitInterval -> !EpochNo -> CommitteeMembersState
[csCommittee] :: CommitteeMembersState -> !Map (Credential 'ColdCommitteeRole) CommitteeMemberState
[csThreshold] :: CommitteeMembersState -> !Maybe UnitInterval
[csEpochNo] :: CommitteeMembersState -> !EpochNo
data () => MemberStatus
Active :: MemberStatus
Expired :: MemberStatus
Unrecognized :: MemberStatus
newtype () => EpochSlots
EpochSlots :: Word64 -> EpochSlots
[unEpochSlots] :: EpochSlots -> Word64
class () => Inject t s
inject :: Inject t s => t -> s
data () => MIRPot
ReservesMIR :: MIRPot
TreasuryMIR :: MIRPot
data () => MIRTarget
StakeAddressesMIR :: !Map (Credential 'Staking) DeltaCoin -> MIRTarget
SendToOppositePotMIR :: !Coin -> MIRTarget
newtype () => BlockNo
BlockNo :: Word64 -> BlockNo
[unBlockNo] :: BlockNo -> Word64
newtype () => EpochNo
EpochNo :: Word64 -> EpochNo
[unEpochNo] :: EpochNo -> Word64
newtype () => SlotNo
SlotNo :: Word64 -> SlotNo
[unSlotNo] :: SlotNo -> Word64
newtype () => SystemStart
SystemStart :: UTCTime -> SystemStart
[getSystemStart] :: SystemStart -> UTCTime
data () => NodeToClientVersion
NodeToClientV_16 :: NodeToClientVersion
NodeToClientV_17 :: NodeToClientVersion
NodeToClientV_18 :: NodeToClientVersion
NodeToClientV_19 :: NodeToClientVersion
NodeToClientV_20 :: NodeToClientVersion
newtype () => ChainSyncClient header point tip (m :: Type -> Type) a
ChainSyncClient :: m (ClientStIdle header point tip m a) -> ChainSyncClient header point tip (m :: Type -> Type) a
[runChainSyncClient] :: ChainSyncClient header point tip (m :: Type -> Type) a -> m (ClientStIdle header point tip m a)
newtype () => ChainSyncClientPipelined header point tip (m :: Type -> Type) a
ChainSyncClientPipelined :: m (ClientPipelinedStIdle 'Z header point tip m a) -> ChainSyncClientPipelined header point tip (m :: Type -> Type) a
[runChainSyncClientPipelined] :: ChainSyncClientPipelined header point tip (m :: Type -> Type) a -> m (ClientPipelinedStIdle 'Z header point tip m a)
newtype () => LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a
LocalStateQueryClient :: m (ClientStIdle block point query m a) -> LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a
[runLocalStateQueryClient] :: LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a -> m (ClientStIdle block point query m a)
newtype () => LocalTxMonitorClient txid tx slot (m :: Type -> Type) a
LocalTxMonitorClient :: m (ClientStIdle txid tx slot m a) -> LocalTxMonitorClient txid tx slot (m :: Type -> Type) a
[runLocalTxMonitorClient] :: LocalTxMonitorClient txid tx slot (m :: Type -> Type) a -> m (ClientStIdle txid tx slot m a)
data () => MempoolSizeAndCapacity
MempoolSizeAndCapacity :: !Word32 -> !Word32 -> !Word32 -> MempoolSizeAndCapacity
[capacityInBytes] :: MempoolSizeAndCapacity -> !Word32
[sizeInBytes] :: MempoolSizeAndCapacity -> !Word32
[numberOfTxs] :: MempoolSizeAndCapacity -> !Word32
newtype () => LocalTxSubmissionClient tx reject (m :: Type -> Type) a
LocalTxSubmissionClient :: m (LocalTxClientStIdle tx reject m a) -> LocalTxSubmissionClient tx reject (m :: Type -> Type) a
[runLocalTxSubmissionClient] :: LocalTxSubmissionClient tx reject (m :: Type -> Type) a -> m (LocalTxClientStIdle tx reject m a)
data () => SubmitResult reason
SubmitSuccess :: SubmitResult reason
SubmitFail :: reason -> SubmitResult reason
pattern Block :: BlockHeader -> [Tx era] -> Block era
runParsecParser :: Parser a -> Text -> Parser a
left :: forall (m :: Type -> Type) x a. Monad m => x -> ExceptT x m a
right :: forall (m :: Type -> Type) a x. Monad m => a -> ExceptT x m a

-- | Signal an exception value <tt>e</tt>.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>throwE</a> e) = <a>return</a>
--   (<a>Left</a> e)</pre></li>
--   <li><pre><a>throwE</a> e &gt;&gt;= m = <a>throwE</a> e</pre></li>
--   </ul>
throwE :: forall (m :: Type -> Type) e a. Monad m => e -> ExceptT e m a

-- | Extractor for computations in the exception monad. (The inverse of
--   <a>except</a>).
runExcept :: Except e a -> Either e a

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExcept</a> (<a>mapExcept</a> f m) = f (<a>runExcept</a>
--   m)</pre></li>
--   </ul>
mapExcept :: (Either e a -> Either e' b) -> Except e a -> Except e' b

-- | Transform any exceptions thrown by the computation using the given
--   function (a specialization of <a>withExceptT</a>).
withExcept :: (e -> e') -> Except e a -> Except e' a

-- | The inverse of <a>ExceptT</a>.
runExceptT :: ExceptT e m a -> m (Either e a)

-- | Map the unwrapped computation using the given function.
--   
--   <ul>
--   <li><pre><a>runExceptT</a> (<a>mapExceptT</a> f m) = f
--   (<a>runExceptT</a> m)</pre></li>
--   </ul>
mapExceptT :: (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b

-- | Transform any exceptions thrown by the computation using the given
--   function.
withExceptT :: forall (m :: Type -> Type) e e' a. Functor m => (e -> e') -> ExceptT e m a -> ExceptT e' m a

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: CallCC m (Either e a) (Either e b) -> CallCC (ExceptT e m) a b

-- | Lifts an <tt><a>Either</a> e</tt> into any <tt><a>MonadError</a>
--   e</tt>.
--   
--   <pre>
--   do { val &lt;- liftEither =&lt;&lt; action1; action2 }
--   </pre>
--   
--   where <tt>action1</tt> returns an <a>Either</a> to represent errors.
liftEither :: MonadError e m => Either e a -> m a
modifyError :: forall e' t (m :: Type -> Type) e a. MonadTransError e' t m => (e -> e') -> ExceptT e m a -> t m a
hsep :: [Doc ann] -> Doc ann

-- | Handle an exception.
--   
--   <ul>
--   <li><pre><a>catchE</a> (<a>lift</a> m) h = <a>lift</a> m</pre></li>
--   <li><pre><a>catchE</a> (<a>throwE</a> e) h = h e</pre></li>
--   </ul>
catchE :: forall (m :: Type -> Type) e a e'. Monad m => ExceptT e m a -> (e -> ExceptT e' m a) -> ExceptT e' m a

-- | Constructor for computations in the exception monad. (The inverse of
--   <a>runExcept</a>).
except :: forall (m :: Type -> Type) e a. Monad m => Either e a -> ExceptT e m a

-- | The same as <tt><a>flip</a> <a>catchE</a></tt>, which is useful in
--   situations where the code for the handler is shorter.
handleE :: forall (m :: Type -> Type) e e' a. Monad m => (e -> ExceptT e' m a) -> ExceptT e m a -> ExceptT e' m a

-- | Similar to <a>catchE</a>, but returns an <a>Either</a> result which is
--   <tt>(<a>Right</a> a)</tt> if no exception was thown, or
--   <tt>(<a>Left</a> ex)</tt> if an exception <tt>ex</tt> was thrown.
tryE :: forall (m :: Type -> Type) e a. Monad m => ExceptT e m a -> ExceptT e m (Either e a)

-- | <tt><a>finallyE</a> a b</tt> executes computation <tt>a</tt> followed
--   by computation <tt>b</tt>, even if <tt>a</tt> exits early by throwing
--   an exception. In the latter case, the exception is re-thrown after
--   <tt>b</tt> has been executed.
finallyE :: forall (m :: Type -> Type) e a. Monad m => ExceptT e m a -> ExceptT e m () -> ExceptT e m a

-- | Lift a <tt>listen</tt> operation to the new monad.
liftListen :: Monad m => Listen w m (Either e a) -> Listen w (ExceptT e m) a

-- | Lift a <tt>pass</tt> operation to the new monad.
liftPass :: Monad m => Pass w m (Either e a) -> Pass w (ExceptT e m) a
hoistMaybe :: forall (m :: Type -> Type) x a. Monad m => x -> Maybe a -> ExceptT x m a
mkAdaValue :: ShelleyBasedEra era -> Coin -> Value (ShelleyLedgerEra era)
fromAlonzoCostModels :: CostModels -> Map AnyPlutusScriptVersion CostModel
fromAlonzoPrices :: Prices -> ExecutionUnitPrices
fromPlutusData :: Data -> ScriptData
fromShelleyMetadata :: Map Word64 Metadatum -> Map Word64 TxMetadataValue
toAlonzoPrices :: ExecutionUnitPrices -> Either ProtocolParametersConversionError Prices
toPlutusData :: ScriptData -> Data
toShelleyMetadata :: Map Word64 TxMetadataValue -> Map Word64 Metadatum
toShelleyNetwork :: NetworkId -> Network
txOutValueToValue :: TxOutValue era -> Value
renderTxIn :: TxIn -> Text
renderValue :: Value -> Text
selectLovelace :: Value -> Lovelace
anyAddressInShelleyBasedEra :: ShelleyBasedEra era -> AddressAny -> AddressInEra era
toAddressAny :: Address addr -> AddressAny
lovelaceToTxOutValue :: ShelleyBasedEra era -> Coin -> TxOutValue era
anyAddressInEra :: CardanoEra era -> AddressAny -> Either String (AddressInEra era)
byronAddressInEra :: Address ByronAddr -> AddressInEra era
isKeyAddress :: AddressInEra era -> Bool
lexPlausibleAddressString :: Parser Text
makeByronAddress :: NetworkId -> VerificationKey ByronKey -> Address ByronAddr
makeByronAddressInEra :: NetworkId -> VerificationKey ByronKey -> AddressInEra era
makeShelleyAddress :: NetworkId -> PaymentCredential -> StakeAddressReference -> Address ShelleyAddr
makeShelleyAddressInEra :: ShelleyBasedEra era -> NetworkId -> PaymentCredential -> StakeAddressReference -> AddressInEra era
makeStakeAddress :: NetworkId -> StakeCredential -> StakeAddress
parseAddressAny :: SerialiseAddress addr => Parser addr
shelleyAddressInEra :: ShelleyBasedEra era -> Address ShelleyAddr -> AddressInEra era
stakeAddressCredential :: StakeAddress -> StakeCredential
chainPointToHeaderHash :: ChainPoint -> Maybe (Hash BlockHeader)
chainPointToSlotNo :: ChainPoint -> Maybe SlotNo
chainTipToChainPoint :: ChainTip -> ChainPoint
getBlockHeader :: Block era -> BlockHeader
getBlockTxs :: Block era -> [Tx era]
makeChainTip :: WithOrigin BlockNo -> ChainPoint -> ChainTip
deserialiseFromBech32Cip129 :: Cip129 a => Text -> Either Bech32DecodeError a
deserialiseGovActionIdFromBech32Cip129 :: Text -> Either Bech32DecodeError GovActionId
serialiseGovActionIdToBech32Cip129 :: GovActionId -> Text
serialiseToBech32Cip129 :: Cip129 a => a -> Text
getAnchorDataFromCertificate :: Certificate era -> Either AnchorDataFromCertificateError (Maybe Anchor)
isDRepRegOrUpdateCert :: Certificate era -> Bool
makeCommitteeColdkeyResignationCertificate :: Typeable era => CommitteeColdkeyResignationRequirements era -> Certificate era
makeCommitteeHotKeyAuthorizationCertificate :: Typeable era => CommitteeHotKeyAuthorizationRequirements era -> Certificate era
makeDrepRegistrationCertificate :: Typeable era => DRepRegistrationRequirements era -> Maybe Anchor -> Certificate era
makeDrepUnregistrationCertificate :: Typeable era => DRepUnregistrationRequirements era -> Certificate era
makeDrepUpdateCertificate :: Typeable era => DRepUpdateRequirements era -> Maybe Anchor -> Certificate era
makeGenesisKeyDelegationCertificate :: Typeable era => GenesisKeyDelegationRequirements era -> Certificate era
makeMIRCertificate :: Typeable era => MirCertificateRequirements era -> Certificate era
makeStakeAddressAndDRepDelegationCertificate :: ConwayEraOnwards era -> StakeCredential -> Delegatee -> Coin -> Certificate era
makeStakeAddressDelegationCertificate :: StakeDelegationRequirements era -> Certificate era
makeStakeAddressRegistrationCertificate :: StakeAddressRequirements era -> Certificate era
makeStakeAddressUnregistrationCertificate :: StakeAddressRequirements era -> Certificate era
makeStakePoolRegistrationCertificate :: StakePoolRegistrationRequirements era -> Certificate era
makeStakePoolRetirementCertificate :: StakePoolRetirementRequirements era -> Certificate era
selectStakeCredentialWitness :: Certificate era -> Maybe StakeCredential
constructBalancedTx :: ShelleyBasedEra era -> TxBodyContent BuildTx era -> AddressInEra era -> Maybe Word -> UTxO era -> LedgerProtocolParameters era -> LedgerEpochInfo -> SystemStart -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> [ShelleyWitnessSigningKey] -> Either (TxBodyErrorAutoBalance era) (Tx era)
notScriptLockedTxIns :: [TxIn] -> UTxO era -> Either ScriptLockedTxInsError ()
renderNotScriptLockedTxInsError :: ScriptLockedTxInsError -> Text
renderTxInsExistError :: TxInsExistError -> Text
txInsExistInUTxO :: [TxIn] -> UTxO era -> Either TxInsExistError ()
determineEra :: LocalNodeConnectInfo -> ExceptT AcquiringFailure IO AnyCardanoEra
executeQueryAnyMode :: LocalNodeConnectInfo -> QueryInMode (Either EraMismatch result) -> ExceptT QueryConvenienceError IO result
executeQueryCardanoMode :: SocketPath -> NetworkId -> QueryInMode (Either EraMismatch result) -> ExceptT QueryConvenienceError IO result
queryStateForBalancedTx :: CardanoEra era -> [TxIn] -> [Certificate era] -> LocalStateQueryExpr block point QueryInMode r IO (Either QueryConvenienceError (UTxO era, LedgerProtocolParameters era, EraHistory, SystemStart, Set PoolId, Map StakeCredential Coin, Map (Credential 'DRepRole) Coin, Maybe (Featured ConwayEraOnwards era TxCurrentTreasuryValue)))
renderQueryConvenienceError :: QueryConvenienceError -> Text
hashDRepMetadata :: ByteString -> (DRepMetadata, Hash DRepMetadata)
deserialiseAnyVerificationKey :: ByteString -> Either InputDecodeError SomeAddressVerificationKey
deserialiseAnyVerificationKeyBech32 :: ByteString -> Either Bech32DecodeError SomeAddressVerificationKey
deserialiseAnyVerificationKeyTextEnvelope :: ByteString -> Either TextEnvelopeError SomeAddressVerificationKey
deserialiseInput :: NonEmpty (InputFormat a) -> ByteString -> Either InputDecodeError a
deserialiseInputAnyOf :: [FromSomeType SerialiseAsBech32 b] -> [FromSomeType HasTextEnvelope b] -> ByteString -> Either InputDecodeError b
mapSomeAddressVerificationKey :: (forall keyrole. Key keyrole => VerificationKey keyrole -> a) -> SomeAddressVerificationKey -> a
renderInputDecodeError :: InputDecodeError -> Doc ann
renderSomeAddressVerificationKey :: SomeAddressVerificationKey -> Text
alonzoEraOnwardsConstraints :: AlonzoEraOnwards era -> (AlonzoEraOnwardsConstraints era => a) -> a
alonzoEraOnwardsToShelleyBasedEra :: AlonzoEraOnwards era -> ShelleyBasedEra era
babbageEraOnwardsConstraints :: BabbageEraOnwards era -> (BabbageEraOnwardsConstraints era => a) -> a
babbageEraOnwardsToShelleyBasedEra :: BabbageEraOnwards era -> ShelleyBasedEra era
byronToAlonzoEraConstraints :: ByronToAlonzoEra era -> (ByronToAlonzoEraConstraints era => a) -> a
conwayEraOnwardsConstraints :: ConwayEraOnwards era -> (ConwayEraOnwardsConstraints era => a) -> a
conwayEraOnwardsToBabbageEraOnwards :: ConwayEraOnwards era -> BabbageEraOnwards era
conwayEraOnwardsToShelleyBasedEra :: ConwayEraOnwards era -> ShelleyBasedEra era
maryEraOnwardsConstraints :: MaryEraOnwards era -> (MaryEraOnwardsConstraints era => a) -> a
maryEraOnwardsToShelleyBasedEra :: MaryEraOnwards era -> ShelleyBasedEra era
forShelleyBasedEraInEon :: Eon eon => ShelleyBasedEra era -> a -> (eon era -> a) -> a
forShelleyBasedEraInEonMaybe :: Eon eon => ShelleyBasedEra era -> (eon era -> a) -> Maybe a
forShelleyBasedEraMaybeEon :: Eon eon => ShelleyBasedEra era -> Maybe (eon era)
inAnyShelleyBasedEra :: ShelleyBasedEra era -> thing era -> InAnyShelleyBasedEra thing
inEonForShelleyBasedEra :: Eon eon => a -> (eon era -> a) -> ShelleyBasedEra era -> a
inEonForShelleyBasedEraMaybe :: Eon eon => (eon era -> a) -> ShelleyBasedEra era -> Maybe a
requireShelleyBasedEra :: Applicative m => CardanoEra era -> m (Maybe (ShelleyBasedEra era))
shelleyBasedEraConstraints :: ShelleyBasedEra era -> (ShelleyBasedEraConstraints era => a) -> a
shelleyEraOnlyConstraints :: ShelleyEraOnly era -> (ShelleyEraOnlyConstraints era => a) -> a
shelleyEraOnlyToShelleyBasedEra :: ShelleyEraOnly era -> ShelleyBasedEra era
shelleyToAllegraEraConstraints :: ShelleyToAllegraEra era -> (ShelleyToAllegraEraConstraints era => a) -> a
shelleyToAllegraEraToShelleyBasedEra :: ShelleyToAllegraEra era -> ShelleyBasedEra era
shelleyToAlonzoEraConstraints :: ShelleyToAlonzoEra era -> (ShelleyToAlonzoEraConstraints era => a) -> a
shelleyToAlonzoEraToShelleyBasedEra :: ShelleyToAlonzoEra era -> ShelleyBasedEra era
shelleyToBabbageEraConstraints :: ShelleyToBabbageEra era -> (ShelleyToBabbageEraConstraints era => a) -> a
shelleyToBabbageEraToShelleyBasedEra :: ShelleyToBabbageEra era -> ShelleyBasedEra era
shelleyToMaryEraConstraints :: ShelleyToMaryEra era -> (ShelleyToMaryEraConstraints era => a) -> a
shelleyToMaryEraToShelleyBasedEra :: ShelleyToMaryEra era -> ShelleyBasedEra era
alonzoEraOnwardsToMaryEraOnwards :: AlonzoEraOnwards era -> MaryEraOnwards era
babbageEraOnwardsToAlonzoEraOnwards :: BabbageEraOnwards era -> AlonzoEraOnwards era
babbageEraOnwardsToMaryEraOnwards :: BabbageEraOnwards era -> MaryEraOnwards era
caseByronOrShelleyBasedEra :: a -> (ShelleyBasedEraConstraints era => ShelleyBasedEra era -> a) -> CardanoEra era -> a
caseByronToAlonzoOrBabbageEraOnwards :: (ByronToAlonzoEraConstraints era => ByronToAlonzoEra era -> a) -> (BabbageEraOnwardsConstraints era => BabbageEraOnwards era -> a) -> CardanoEra era -> a
caseShelleyEraOnlyOrAllegraEraOnwards :: (ShelleyEraOnlyConstraints era => ShelleyEraOnly era -> a) -> (AllegraEraOnwardsConstraints era => AllegraEraOnwards era -> a) -> ShelleyBasedEra era -> a
caseShelleyToAllegraOrMaryEraOnwards :: (ShelleyToAllegraEraConstraints era => ShelleyToAllegraEra era -> a) -> (MaryEraOnwardsConstraints era => MaryEraOnwards era -> a) -> ShelleyBasedEra era -> a
caseShelleyToAlonzoOrBabbageEraOnwards :: (ShelleyToAlonzoEraConstraints era => ShelleyToAlonzoEra era -> a) -> (BabbageEraOnwardsConstraints era => BabbageEraOnwards era -> a) -> ShelleyBasedEra era -> a
caseShelleyToBabbageOrConwayEraOnwards :: (ShelleyToBabbageEraConstraints era => ShelleyToBabbageEra era -> a) -> (ConwayEraOnwardsConstraints era => ConwayEraOnwards era -> a) -> ShelleyBasedEra era -> a
caseShelleyToMaryOrAlonzoEraOnwards :: (ShelleyToMaryEraConstraints era => ShelleyToMaryEra era -> a) -> (AlonzoEraOnwardsConstraints era => AlonzoEraOnwards era -> a) -> ShelleyBasedEra era -> a
shelleyToAlonzoEraToShelleyToBabbageEra :: ShelleyToAlonzoEra era -> ShelleyToBabbageEra era
anyCardanoEra :: CardanoEra era -> AnyCardanoEra
cardanoEraConstraints :: CardanoEra era -> (CardanoEraConstraints era => a) -> a
forEraInEon :: Eon eon => CardanoEra era -> a -> (eon era -> a) -> a
forEraInEonMaybe :: Eon eon => CardanoEra era -> (eon era -> a) -> Maybe a
forEraMaybeEon :: Eon eon => CardanoEra era -> Maybe (eon era)
inAnyCardanoEra :: CardanoEra era -> thing era -> InAnyCardanoEra thing
inEonForEraMaybe :: Eon eon => (eon era -> a) -> CardanoEra era -> Maybe a
maybeEon :: (Eon eon, IsCardanoEra era) => Maybe (eon era)
monoidForEraInEon :: (Eon eon, Monoid a) => CardanoEra era -> (eon era -> a) -> a
monoidForEraInEonA :: (Eon eon, Applicative f, Monoid a) => CardanoEra era -> (eon era -> f a) -> f a
throwErrorAsException :: Error e => e -> IO a
asFeaturedInEra :: forall (eon :: Type -> Type) a era. Eon eon => a -> CardanoEra era -> Maybe (Featured eon era a)
asFeaturedInShelleyBasedEra :: forall (eon :: Type -> Type) a era. Eon eon => a -> ShelleyBasedEra era -> Maybe (Featured eon era a)
mkFeatured :: forall (eon :: Type -> Type) era a. (IsCardanoEra era, Eon eon) => a -> Maybe (Featured eon era a)
unFeatured :: forall (eon :: Type -> Type) era a. Featured eon era a -> a
calculateMinTxFee :: ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> UTxO era -> TxBody era -> Word -> Coin
calculateMinimumUTxO :: HasCallStack => ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> TxOut CtxTx era -> Coin
estimateBalancedTxBody :: HasCallStack => MaryEraOnwards era -> TxBodyContent BuildTx era -> PParams (ShelleyLedgerEra era) -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> Map ScriptWitnessIndex ExecutionUnits -> Coin -> Int -> Int -> Int -> AddressInEra era -> Value -> Either (TxFeeEstimationError era) (BalancedTxBody era)
estimateOrCalculateBalancedTxBody :: ShelleyBasedEra era -> FeeEstimationMode era -> PParams (ShelleyLedgerEra era) -> TxBodyContent BuildTx era -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> AddressInEra era -> Either (AutoBalanceError era) (BalancedTxBody era)
estimateTransactionKeyWitnessCount :: TxBodyContent BuildTx era -> Word
evaluateTransactionBalance :: ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> UTxO era -> TxBody era -> TxOutValue era
evaluateTransactionExecutionUnits :: CardanoEra era -> SystemStart -> LedgerEpochInfo -> LedgerProtocolParameters era -> UTxO era -> TxBody era -> Map ScriptWitnessIndex (Either ScriptExecutionError (EvalTxExecutionUnitsLog, ExecutionUnits))
evaluateTransactionFee :: ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> TxBody era -> Word -> Word -> Int -> Coin
makeTransactionBodyAutoBalance :: HasCallStack => ShelleyBasedEra era -> SystemStart -> LedgerEpochInfo -> LedgerProtocolParameters era -> Set PoolId -> Map StakeCredential Coin -> Map (Credential 'DRepRole) Coin -> UTxO era -> TxBodyContent BuildTx era -> AddressInEra era -> Maybe Word -> Either (TxBodyErrorAutoBalance era) (BalancedTxBody era)
getAnchorDataFromGovernanceAction :: GovAction (ShelleyLedgerEra era) -> Maybe Anchor
validateGovActionAnchorData :: FromJSON (GovActionMetadata cip) => cip -> ByteString -> Either String ()
asType :: HasTypeProxy t => AsType t
castHash :: CastHash roleA roleB => Hash roleA -> Hash roleB
renderSafeHashAsHex :: SafeHash tag -> Text
intoFile :: File content 'Out -> content -> (File content 'Out -> stream -> result) -> (content -> stream) -> result
mapFile :: forall content (direction :: FileDirection). (FilePath -> FilePath) -> File content direction -> File content direction
onlyIn :: File content 'InOut -> File content 'In
onlyOut :: File content 'InOut -> File content 'Out
readByteStringFile :: MonadIO m => File content 'In -> m (Either (FileError e) ByteString)
readLazyByteStringFile :: MonadIO m => File content 'In -> m (Either (FileError e) ByteString)
readTextFile :: MonadIO m => File content 'In -> m (Either (FileError e) Text)
writeByteStringFile :: MonadIO m => File content 'Out -> ByteString -> m (Either (FileError e) ())
writeByteStringFileWithOwnerPermissions :: FilePath -> ByteString -> IO (Either (FileError e) ())
writeByteStringOutput :: MonadIO m => Maybe (File content 'Out) -> ByteString -> m (Either (FileError e) ())
writeLazyByteStringFile :: MonadIO m => File content 'Out -> ByteString -> m (Either (FileError e) ())
writeLazyByteStringFileWithOwnerPermissions :: File content 'Out -> ByteString -> IO (Either (FileError e) ())
writeLazyByteStringOutput :: MonadIO m => Maybe (File content 'Out) -> ByteString -> m (Either (FileError e) ())
writeTextFile :: MonadIO m => File content 'Out -> Text -> m (Either (FileError e) ())
writeTextFileWithOwnerPermissions :: File content 'Out -> Text -> IO (Either (FileError e) ())
writeTextOutput :: MonadIO m => Maybe (File content 'Out) -> Text -> m (Either (FileError e) ())
writeSecrets :: FilePath -> [Char] -> [Char] -> (a -> ByteString) -> [a] -> IO ()
connectToLocalNode :: MonadIO m => LocalNodeConnectInfo -> LocalNodeClientProtocolsInMode -> m ()
connectToLocalNodeWithVersion :: MonadIO m => LocalNodeConnectInfo -> (NodeToClientVersion -> LocalNodeClientProtocolsInMode) -> m ()
getLocalChainTip :: MonadIO m => LocalNodeConnectInfo -> m ChainTip
mkLocalNodeClientParams :: ConsensusModeParams -> (NodeToClientVersion -> LocalNodeClientProtocolsInMode) -> LocalNodeClientParams
queryNodeLocalState :: LocalNodeConnectInfo -> Target ChainPoint -> QueryInMode result -> ExceptT AcquiringFailure IO result
queryTxMonitoringLocal :: MonadIO m => LocalNodeConnectInfo -> LocalTxMonitoringQuery -> m LocalTxMonitoringResult
submitTxToNodeLocal :: MonadIO m => LocalNodeConnectInfo -> TxInMode -> m (SubmitResult TxValidationErrorInCardanoMode)
executeLocalStateQueryExpr :: LocalNodeConnectInfo -> Target ChainPoint -> LocalStateQueryExpr BlockInMode ChainPoint QueryInMode () IO a -> IO (Either AcquiringFailure a)
queryExpr :: QueryInMode a -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError a)
castSigningKey :: CastSigningKeyRole keyroleA keyroleB => SigningKey keyroleA -> SigningKey keyroleB
castVerificationKey :: CastVerificationKeyRole keyroleA keyroleB => VerificationKey keyroleA -> VerificationKey keyroleB
generateInsecureSigningKey :: (MonadIO m, Key keyrole, SerialiseAsRawBytes (SigningKey keyrole)) => StdGen -> AsType keyrole -> m (SigningKey keyrole, StdGen)
generateSigningKey :: (MonadIO m, Key keyrole) => AsType keyrole -> m (SigningKey keyrole)
autocompleteMnemonicPrefix :: Text -> Maybe Text
findMnemonicWordsWithPrefix :: Text -> [(Text, Int)]
generateMnemonic :: MonadIO m => MnemonicSize -> m [Text]
signingKeyFromMnemonic :: SigningKeyFromRootKey keyrole => AsType keyrole -> [Text] -> Word32 -> Either MnemonicToSigningKeyError (SigningKey keyrole)
signingKeyFromMnemonicWithPaymentKeyIndex :: IndexedSigningKeyFromRootKey keyrole => AsType keyrole -> [Text] -> Word32 -> Word32 -> Either MnemonicToSigningKeyError (SigningKey keyrole)
readKeyFile :: NonEmpty (InputFormat a) -> FilePath -> IO (Either (FileError InputDecodeError) a)
readKeyFileAnyOf :: forall content b. [FromSomeType SerialiseAsBech32 b] -> [FromSomeType HasTextEnvelope b] -> File content 'In -> IO (Either (FileError InputDecodeError) b)
readKeyFileTextEnvelope :: HasTextEnvelope a => File content 'In -> IO (Either (FileError InputDecodeError) a)
applyBlock :: Env -> LedgerState -> ValidationMode -> BlockInMode -> Either LedgerStateError (LedgerState, [LedgerEvent])
chainSyncClientPipelinedWithLedgerState :: forall (m :: Type -> Type) a. Monad m => Env -> LedgerState -> ValidationMode -> ChainSyncClientPipelined (BlockInMode, Either LedgerStateError (LedgerState, [LedgerEvent])) ChainPoint ChainTip m a -> ChainSyncClientPipelined BlockInMode ChainPoint ChainTip m a
chainSyncClientWithLedgerState :: forall (m :: Type -> Type) a. Monad m => Env -> LedgerState -> ValidationMode -> ChainSyncClient (BlockInMode, Either LedgerStateError (LedgerState, [LedgerEvent])) ChainPoint ChainTip m a -> ChainSyncClient BlockInMode ChainPoint ChainTip m a
decodeLedgerState :: Decoder s LedgerState
encodeLedgerState :: LedgerState -> Encoding
envSecurityParam :: Env -> Word64
foldBlocks :: forall a t (m :: Type -> Type). (Show a, MonadIOTransError FoldBlocksError t m) => NodeConfigFile 'In -> SocketPath -> ValidationMode -> a -> (Env -> LedgerState -> [LedgerEvent] -> BlockInMode -> a -> IO (a, FoldStatus)) -> t m a
foldEpochState :: forall t (m :: Type -> Type) s. MonadIOTransError FoldBlocksError t m => NodeConfigFile 'In -> SocketPath -> ValidationMode -> EpochNo -> s -> (AnyNewEpochState -> SlotNo -> BlockNo -> StateT s IO ConditionResult) -> t m (ConditionResult, s)
fromConditionResult :: ConditionResult -> Bool
genesisConfigToEnv :: GenesisConfig -> Either GenesisConfigError Env
getAnyNewEpochState :: ShelleyBasedEra era -> LedgerState -> Either LedgerStateError AnyNewEpochState
getLedgerTablesUTxOValues :: ShelleyBasedEra era -> LedgerTables (LedgerState (CardanoBlock StandardCrypto)) ValuesMK -> Map TxIn (TxOut CtxUTxO era)
initialLedgerState :: forall t (m :: Type -> Type). MonadIOTransError InitialLedgerStateError t m => NodeConfigFile 'In -> t m (Env, LedgerState)
mkProtocolInfoCardano :: GenesisConfig -> (ProtocolInfo (CardanoBlock StandardCrypto), IO [BlockForging IO (CardanoBlock StandardCrypto)])
readAlonzoGenesisConfig :: forall t (m :: Type -> Type) era. MonadIOTransError GenesisConfigError t m => Maybe (CardanoEra era) -> NodeConfig -> t m AlonzoGenesis
readByronGenesisConfig :: forall t (m :: Type -> Type). MonadIOTransError GenesisConfigError t m => NodeConfig -> t m Config
readCardanoGenesisConfig :: forall t (m :: Type -> Type) era. MonadIOTransError GenesisConfigError t m => Maybe (CardanoEra era) -> NodeConfig -> t m GenesisConfig
readConwayGenesisConfig :: forall t (m :: Type -> Type). MonadIOTransError GenesisConfigError t m => NodeConfig -> t m ConwayGenesis
readNodeConfig :: (MonadError Text m, MonadIO m) => NodeConfigFile 'In -> m NodeConfig
readShelleyGenesisConfig :: forall t (m :: Type -> Type). MonadIOTransError GenesisConfigError t m => NodeConfig -> t m ShelleyConfig
shelleyPraosNonce :: GenesisHashShelley -> Nonce
toConditionResult :: Bool -> ConditionResult
handleIOExceptionsLiftWith :: (MonadIOTransError e' t m, Exception e) => (e -> e') -> m a -> t m a
handleIOExceptionsWith :: (MonadError e' m, MonadCatch m, Exception e) => (e -> e') -> m a -> m a
hoistIOEither :: forall e t (m :: Type -> Type) a. MonadIOTransError e t m => IO (Either e a) -> t m a
liftExceptT :: forall e t (m :: Type -> Type) a. MonadTransError e t m => ExceptT e m a -> t m a
liftMaybe :: MonadError e m => e -> Maybe a -> m a
fromNetworkMagic :: NetworkMagic -> NetworkId
toNetworkMagic :: NetworkId -> NetworkMagic
getHotKey :: OperationalCertificate -> VerificationKey KesKey
getKesPeriod :: OperationalCertificate -> Word
getOpCertCount :: OperationalCertificate -> Word64
issueOperationalCertificate :: VerificationKey KesKey -> Either AnyStakePoolSigningKey (SigningKey GenesisDelegateExtendedKey) -> KESPeriod -> OperationalCertificateIssueCounter -> Either OperationalCertIssueError (OperationalCertificate, OperationalCertificateIssueCounter)
collectPlutusScriptHashes :: AlonzoEraOnwards era -> Tx era -> UTxO era -> Map ScriptWitnessIndex ScriptHash
renderDebugPlutusFailure :: DebugPlutusFailure -> Text
black :: Doc AnsiStyle -> Doc AnsiStyle
cyan :: Doc AnsiStyle -> Doc AnsiStyle
docToLazyText :: Doc AnsiStyle -> Text
docToString :: Doc AnsiStyle -> String
docToText :: Doc AnsiStyle -> Text
magenta :: Doc AnsiStyle -> Doc AnsiStyle
prettyException :: Exception a => a -> Doc ann
pshow :: Show a => a -> Doc ann
white :: Doc AnsiStyle -> Doc AnsiStyle
yellow :: Doc AnsiStyle -> Doc AnsiStyle
reflBlockType :: BlockType blk -> BlockType blk' -> Maybe (blk :~: blk')
fromAlonzoCostModel :: CostModel -> CostModel
makePraosNonce :: ByteString -> PraosNonce
makeShelleyUpdateProposal :: ProtocolParametersUpdate -> [Hash GenesisKey] -> EpochNo -> UpdateProposal
toAlonzoCostModel :: CostModel -> Language -> Either ProtocolParametersConversionError CostModel
toAlonzoCostModels :: Map AnyPlutusScriptVersion CostModel -> Either ProtocolParametersConversionError CostModels
getProgress :: SlotNo -> EraHistory -> Either PastHorizonException (RelativeTime, SlotLength)
getSlotForRelativeTime :: RelativeTime -> EraHistory -> Either PastHorizonException SlotNo
slotToEpoch :: SlotNo -> EraHistory -> Either PastHorizonException (EpochNo, SlotsInEpoch, SlotsToEpochEnd)
toLedgerEpochInfo :: EraHistory -> LedgerEpochInfo
queryAccountState :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch AccountState))
queryChainBlockNo :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (WithOrigin BlockNo))
queryChainPoint :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError ChainPoint)
queryCommitteeMembersState :: ConwayEraOnwards era -> Set (Credential 'ColdCommitteeRole) -> Set (Credential 'HotCommitteeRole) -> Set MemberStatus -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch CommitteeMembersState))
queryConstitution :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Constitution (ShelleyLedgerEra era))))
queryConstitutionHash :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SafeHash AnchorData)))
queryCurrentEpochState :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedCurrentEpochState era)))
queryCurrentEra :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError AnyCardanoEra)
queryDRepStakeDistribution :: ConwayEraOnwards era -> Set DRep -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map DRep Coin)))
queryDRepState :: ConwayEraOnwards era -> Set (Credential 'DRepRole) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map (Credential 'DRepRole) DRepState)))
queryDebugLedgerState :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedDebugLedgerState era)))
queryEpoch :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch EpochNo))
queryFuturePParams :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Maybe (PParams (ShelleyLedgerEra era)))))
queryGenesisParameters :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (GenesisParameters ShelleyEra)))
queryGovState :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (GovState (ShelleyLedgerEra era))))
queryLedgerConfig :: LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (CardanoLedgerConfig StandardCrypto))
queryLedgerPeerSnapshot :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Serialised LedgerPeerSnapshot)))
queryPoolDistribution :: BabbageEraOnwards era -> Maybe (Set PoolId) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedPoolDistribution era)))
queryPoolState :: BabbageEraOnwards era -> Maybe (Set PoolId) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedPoolState era)))
queryProposals :: ConwayEraOnwards era -> Set GovActionId -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Seq (GovActionState (ShelleyLedgerEra era)))))
queryProtocolState :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (ProtocolState era)))
queryRatifyState :: ConwayEraOnwards era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (RatifyState (ShelleyLedgerEra era))))
querySPOStakeDistribution :: ConwayEraOnwards era -> Set (KeyHash 'StakePool) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map (KeyHash 'StakePool) Coin)))
queryStakeAddresses :: ShelleyBasedEra era -> Set StakeCredential -> NetworkId -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map StakeAddress Coin, Map StakeAddress PoolId)))
queryStakeDelegDeposits :: BabbageEraOnwards era -> Set StakeCredential -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map StakeCredential Coin)))
queryStakeDistribution :: ShelleyBasedEra era -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map (Hash StakePoolKey) Rational)))
queryStakePoolDefaultVote :: ConwayEraOnwards era -> KeyHash 'StakePool -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch DefaultVote))
queryStakePoolParameters :: ShelleyBasedEra era -> Set PoolId -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map PoolId StakePoolParameters)))
queryStakeSnapshot :: BabbageEraOnwards era -> Maybe (Set PoolId) -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (SerialisedStakeSnapshots era)))
queryStakeVoteDelegatees :: ConwayEraOnwards era -> Set StakeCredential -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (Map StakeCredential DRep)))
queryUtxo :: ShelleyBasedEra era -> QueryUTxOFilter -> LocalStateQueryExpr block point QueryInMode r IO (Either UnsupportedNtcVersionError (Either EraMismatch (UTxO era)))
mergeDelegsAndRewards :: DelegationsAndRewards -> [(StakeAddress, Maybe Coin, Maybe PoolId)]
eraOfScriptInEra :: ScriptInEra era -> ShelleyBasedEra era
eraOfScriptLanguageInEra :: ScriptLanguageInEra lang era -> ShelleyBasedEra era
examplePlutusScriptAlwaysFails :: WitCtx witctx -> PlutusScript PlutusScriptV1
examplePlutusScriptAlwaysSucceeds :: WitCtx witctx -> PlutusScript PlutusScriptV1
getScriptWitnessReferenceInput :: ScriptWitness witctx era -> Maybe TxIn
getScriptWitnessReferenceInputOrScript :: ScriptWitness witctx era -> Either (ScriptInEra era) TxIn
getScriptWitnessScript :: ScriptWitness witctx era -> Maybe (ScriptInEra era)
hashScript :: Script lang -> ScriptHash
languageOfScriptLanguageInEra :: ScriptLanguageInEra lang era -> ScriptLanguage lang
sbeToSimpleScriptLanguageInEra :: ShelleyBasedEra era -> ScriptLanguageInEra SimpleScript' era
toScriptInAnyLang :: Script lang -> ScriptInAnyLang
toScriptInEra :: ShelleyBasedEra era -> ScriptInAnyLang -> Maybe (ScriptInEra era)
getOriginalScriptDataBytes :: HashableScriptData -> ByteString
getScriptData :: HashableScriptData -> ScriptData
hashScriptDataBytes :: HashableScriptData -> Hash ScriptData
scriptDataFromJson :: ScriptDataJsonSchema -> Value -> Either ScriptDataJsonError HashableScriptData
scriptDataJsonToHashable :: ScriptDataJsonSchema -> Value -> Either ScriptDataJsonBytesError HashableScriptData
scriptDataToJson :: ScriptDataJsonSchema -> HashableScriptData -> Value
unsafeHashableScriptData :: ScriptData -> HashableScriptData
validateScriptData :: ScriptData -> Either ScriptDataRangeError ()
deserialiseAnyOfFromBech32 :: [FromSomeType SerialiseAsBech32 b] -> Text -> Either Bech32DecodeError b
deserialiseFromBech32 :: SerialiseAsBech32 a => Text -> Either Bech32DecodeError a
serialiseToBech32 :: SerialiseAsBech32 a => a -> Text
deserialiseFromJSON :: FromJSON a => ByteString -> Either JsonDecodeError a
prettyPrintJSON :: ToJSON a => a -> ByteString
readFileJSON :: FromJSON a => FilePath -> IO (Either (FileError JsonDecodeError) a)
serialiseToJSON :: ToJSON a => a -> ByteString
writeFileJSON :: ToJSON a => FilePath -> a -> IO (Either (FileError ()) ())
deserialiseByronTxCddl :: TextEnvelope -> Either TextEnvelopeCddlError (ATxAux ByteString)
deserialiseFromTextEnvelopeCddlAnyOf :: [FromSomeTypeCDDL TextEnvelope b] -> TextEnvelope -> Either TextEnvelopeCddlError b
deserialiseWitnessLedgerCddl :: ShelleyBasedEra era -> TextEnvelope -> Either TextEnvelopeCddlError (KeyWitness era)
readFileTextEnvelopeCddlAnyOf :: [FromSomeTypeCDDL TextEnvelope b] -> FilePath -> IO (Either (FileError TextEnvelopeCddlError) b)
serialiseWitnessLedgerCddl :: ShelleyBasedEra era -> KeyWitness era -> TextEnvelope
writeTxFileTextEnvelopeCanonicalCddl :: ShelleyBasedEra era -> File content 'Out -> Tx era -> IO (Either (FileError ()) ())
writeTxFileTextEnvelopeCddl :: ShelleyBasedEra era -> File content 'Out -> Tx era -> IO (Either (FileError ()) ())
writeTxWitnessFileTextEnvelopeCddl :: ShelleyBasedEra era -> File () 'Out -> KeyWitness era -> IO (Either (FileError ()) ())
deserialiseFromRawBytesHex :: SerialiseAsRawBytes a => ByteString -> Either RawBytesHexError a
serialiseToRawBytesHex :: SerialiseAsRawBytes a => a -> ByteString
serialiseToRawBytesHexText :: SerialiseAsRawBytes a => a -> Text
deserialiseFromTextEnvelope :: HasTextEnvelope a => TextEnvelope -> Either TextEnvelopeError a
deserialiseFromTextEnvelopeAnyOf :: [FromSomeType HasTextEnvelope b] -> TextEnvelope -> Either TextEnvelopeError b
readFileTextEnvelope :: HasTextEnvelope a => File content 'In -> IO (Either (FileError TextEnvelopeError) a)
readFileTextEnvelopeAnyOf :: [FromSomeType HasTextEnvelope b] -> File content 'In -> IO (Either (FileError TextEnvelopeError) b)
readTextEnvelopeFromFile :: FilePath -> IO (Either (FileError TextEnvelopeError) TextEnvelope)
readTextEnvelopeOfTypeFromFile :: TextEnvelopeType -> FilePath -> IO (Either (FileError TextEnvelopeError) TextEnvelope)
serialiseToTextEnvelope :: HasTextEnvelope a => Maybe TextEnvelopeDescr -> a -> TextEnvelope
textEnvelopeRawCBOR :: TextEnvelope -> ByteString
textEnvelopeToJSON :: HasTextEnvelope a => Maybe TextEnvelopeDescr -> a -> ByteString
textEnvelopeTypeInEra :: HasTextEnvelope (f era) => CardanoEra era -> AsType (f era) -> TextEnvelopeType
writeFileTextEnvelope :: HasTextEnvelope a => File content 'Out -> Maybe TextEnvelopeDescr -> a -> IO (Either (FileError ()) ())
validateAndHashStakePoolMetadata :: ByteString -> Either StakePoolMetadataValidationError (StakePoolMetadata, Hash StakePoolMetadata)
addTxExtraKeyWits :: IsAlonzoBasedEra era => [Hash PaymentKey] -> TxBodyContent build era -> TxBodyContent build era
addTxIn :: (TxIn, BuildTxWith build (Witness WitCtxTxIn era)) -> TxBodyContent build era -> TxBodyContent build era
addTxInCollateral :: IsAlonzoBasedEra era => TxIn -> TxBodyContent build era -> TxBodyContent build era
addTxInReference :: (Applicative (BuildTxWith build), IsBabbageBasedEra era) => TxIn -> Maybe HashableScriptData -> TxBodyContent build era -> TxBodyContent build era
addTxIns :: TxIns build era -> TxBodyContent build era -> TxBodyContent build era
addTxInsCollateral :: IsAlonzoBasedEra era => [TxIn] -> TxBodyContent build era -> TxBodyContent build era
addTxInsReference :: (Applicative (BuildTxWith build), IsBabbageBasedEra era) => [TxIn] -> Set HashableScriptData -> TxBodyContent build era -> TxBodyContent build era
addTxMintValue :: IsMaryBasedEra era => Map PolicyId (PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era)) -> TxBodyContent build era -> TxBodyContent build era
addTxOut :: TxOut CtxTx era -> TxBodyContent build era -> TxBodyContent build era
addTxOuts :: [TxOut CtxTx era] -> TxBodyContent build era -> TxBodyContent build era
collectTxBodyScriptWitnesses :: ShelleyBasedEra era -> TxBodyContent BuildTx era -> [(ScriptWitnessIndex, AnyScriptWitness era)]
convProposalProcedures :: TxProposalProcedures build era -> OSet (ProposalProcedure (ShelleyLedgerEra era))
createTransactionBody :: HasCallStack => ShelleyBasedEra era -> TxBodyContent BuildTx era -> Either TxBodyError (TxBody era)
defaultTxFee :: ShelleyBasedEra era -> TxFee era
defaultTxValidityUpperBound :: ShelleyBasedEra era -> TxValidityUpperBound era
genesisUTxOPseudoTxIn :: NetworkId -> Hash GenesisUTxOKey -> TxIn
getReferenceInputsSizeForTxIds :: ShelleyLedgerEra era ~ ledgerera => BabbageEraOnwards era -> UTxO ledgerera -> Set TxIn -> Int
getTxBodyContent :: TxBody era -> TxBodyContent ViewTx era
getTxId :: TxBody era -> TxId
getTxIdByron :: ATxAux ByteString -> TxId
indexTxMintValue :: TxMintValue build era -> [(ScriptWitnessIndex, PolicyId, PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era))]
makeByronTransactionBody :: TxIns BuildTx ByronEra -> [TxOut CtxTx ByronEra] -> Either TxBodyError (Annotated Tx ByteString)
mkTxCertificates :: Applicative (BuildTxWith build) => ShelleyBasedEra era -> [(Certificate era, Maybe (ScriptWitness WitCtxStake era))] -> TxCertificates build era
mkTxMintValue :: MaryEraOnwards era -> [(PolicyId, PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era))] -> TxMintValue build era
mkTxProposalProcedures :: forall era build. (Applicative (BuildTxWith build), IsShelleyBasedEra era) => [(ProposalProcedure (ShelleyLedgerEra era), Maybe (ScriptWitness WitCtxStake era))] -> TxProposalProcedures build era
mkTxVotingProcedures :: Applicative (BuildTxWith build) => [(VotingProcedures era, Maybe (ScriptWitness WitCtxStake era))] -> Either (VotesMergingConflict era) (TxVotingProcedures build era)
modTxAuxScripts :: (TxAuxScripts era -> TxAuxScripts era) -> TxBodyContent build era -> TxBodyContent build era
modTxCertificates :: (TxCertificates build era -> TxCertificates build era) -> TxBodyContent build era -> TxBodyContent build era
modTxExtraKeyWits :: (TxExtraKeyWitnesses era -> TxExtraKeyWitnesses era) -> TxBodyContent build era -> TxBodyContent build era
modTxFee :: (TxFee era -> TxFee era) -> TxBodyContent build era -> TxBodyContent build era
modTxIns :: (TxIns build era -> TxIns build era) -> TxBodyContent build era -> TxBodyContent build era
modTxInsCollateral :: (TxInsCollateral era -> TxInsCollateral era) -> TxBodyContent build era -> TxBodyContent build era
modTxInsReference :: (TxInsReference build era -> TxInsReference build era) -> TxBodyContent build era -> TxBodyContent build era
modTxMetadata :: (TxMetadataInEra era -> TxMetadataInEra era) -> TxBodyContent build era -> TxBodyContent build era
modTxMintValue :: (TxMintValue build era -> TxMintValue build era) -> TxBodyContent build era -> TxBodyContent build era
modTxOuts :: ([TxOut CtxTx era] -> [TxOut CtxTx era]) -> TxBodyContent build era -> TxBodyContent build era
modTxReturnCollateral :: (TxReturnCollateral CtxTx era -> TxReturnCollateral CtxTx era) -> TxBodyContent build era -> TxBodyContent build era
modTxScriptValidity :: (TxScriptValidity era -> TxScriptValidity era) -> TxBodyContent build era -> TxBodyContent build era
modTxTotalCollateral :: (TxTotalCollateral era -> TxTotalCollateral era) -> TxBodyContent build era -> TxBodyContent build era
modTxUpdateProposal :: (TxUpdateProposal era -> TxUpdateProposal era) -> TxBodyContent build era -> TxBodyContent build era
modTxValidityLowerBound :: (TxValidityLowerBound era -> TxValidityLowerBound era) -> TxBodyContent build era -> TxBodyContent build era
modTxValidityUpperBound :: (TxValidityUpperBound era -> TxValidityUpperBound era) -> TxBodyContent build era -> TxBodyContent build era
modTxWithdrawals :: (TxWithdrawals build era -> TxWithdrawals build era) -> TxBodyContent build era -> TxBodyContent build era
renderScriptWitnessIndex :: ScriptWitnessIndex -> String
setTxAuxScripts :: TxAuxScripts era -> TxBodyContent build era -> TxBodyContent build era
setTxCertificates :: TxCertificates build era -> TxBodyContent build era -> TxBodyContent build era
setTxCurrentTreasuryValue :: Maybe (Featured ConwayEraOnwards era (Maybe Coin)) -> TxBodyContent build era -> TxBodyContent build era
setTxExtraKeyWits :: TxExtraKeyWitnesses era -> TxBodyContent build era -> TxBodyContent build era
setTxFee :: TxFee era -> TxBodyContent build era -> TxBodyContent build era
setTxIns :: TxIns build era -> TxBodyContent build era -> TxBodyContent build era
setTxInsCollateral :: TxInsCollateral era -> TxBodyContent build era -> TxBodyContent build era
setTxInsReference :: TxInsReference build era -> TxBodyContent build era -> TxBodyContent build era
setTxMetadata :: TxMetadataInEra era -> TxBodyContent build era -> TxBodyContent build era
setTxMintValue :: TxMintValue build era -> TxBodyContent build era -> TxBodyContent build era
setTxOuts :: [TxOut CtxTx era] -> TxBodyContent build era -> TxBodyContent build era
setTxProposalProcedures :: Maybe (Featured ConwayEraOnwards era (TxProposalProcedures build era)) -> TxBodyContent build era -> TxBodyContent build era
setTxProtocolParams :: BuildTxWith build (Maybe (LedgerProtocolParameters era)) -> TxBodyContent build era -> TxBodyContent build era
setTxReturnCollateral :: TxReturnCollateral CtxTx era -> TxBodyContent build era -> TxBodyContent build era
setTxScriptValidity :: TxScriptValidity era -> TxBodyContent build era -> TxBodyContent build era
setTxTotalCollateral :: TxTotalCollateral era -> TxBodyContent build era -> TxBodyContent build era
setTxTreasuryDonation :: Maybe (Featured ConwayEraOnwards era Coin) -> TxBodyContent build era -> TxBodyContent build era
setTxUpdateProposal :: TxUpdateProposal era -> TxBodyContent build era -> TxBodyContent build era
setTxValidityLowerBound :: TxValidityLowerBound era -> TxBodyContent build era -> TxBodyContent build era
setTxValidityUpperBound :: TxValidityUpperBound era -> TxBodyContent build era -> TxBodyContent build era
setTxVotingProcedures :: Maybe (Featured ConwayEraOnwards era (TxVotingProcedures build era)) -> TxBodyContent build era -> TxBodyContent build era
setTxWithdrawals :: TxWithdrawals build era -> TxBodyContent build era -> TxBodyContent build era
subtractTxMintValue :: IsMaryBasedEra era => Map PolicyId (PolicyAssets, BuildTxWith build (ScriptWitness WitCtxMint era)) -> TxBodyContent build era -> TxBodyContent build era
txMintValueToValue :: TxMintValue build era -> Value
buildTxWithToMaybe :: BuildTxWith build a -> Maybe a
fromCtxUTxOTxOut :: TxOut CtxUTxO era -> TxOut CtxTx era
fromLedgerTxOuts :: ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> TxBodyScriptData era -> [TxOut CtxTx era]
parseHash :: SerialiseAsRawBytes (Hash a) => Parser (Hash a)
toCtxUTxOTxOut :: TxOut CtxTx era -> TxOut CtxUTxO era
txOutInAnyEra :: CardanoEra era -> TxOut CtxTx era -> TxOutInAnyEra
txOutValueToLovelace :: TxOutValue era -> Coin
getTxBody :: Tx era -> TxBody era
getTxWitnesses :: Tx era -> [KeyWitness era]
makeByronKeyWitness :: IsByronKey key => NetworkId -> Annotated Tx ByteString -> SigningKey key -> KeyWitness ByronEra
makeShelleyBasedBootstrapWitness :: ShelleyBasedEra era -> WitnessNetworkIdOrByronAddress -> TxBody (ShelleyLedgerEra era) -> SigningKey ByronKey -> KeyWitness era
makeShelleyBootstrapWitness :: ShelleyBasedEra era -> WitnessNetworkIdOrByronAddress -> TxBody era -> SigningKey ByronKey -> KeyWitness era
makeShelleyKeyWitness' :: ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> ShelleyWitnessSigningKey -> KeyWitness era
makeSignedByronTransaction :: [KeyWitness era] -> Annotated Tx ByteString -> ATxAux ByteString
makeSignedTransaction :: [KeyWitness era] -> TxBody era -> Tx era
signByronTransaction :: NetworkId -> Annotated Tx ByteString -> [SigningKey ByronKey] -> ATxAux ByteString
txScriptValidityToScriptValidity :: TxScriptValidity era -> ScriptValidity
makeTransactionMetadata :: Map Word64 TxMetadataValue -> TxMetadata
mergeTransactionMetadata :: (TxMetadataValue -> TxMetadataValue -> TxMetadataValue) -> TxMetadata -> TxMetadata -> TxMetadata
metaBytesChunks :: ByteString -> TxMetadataValue
metaTextChunks :: Text -> TxMetadataValue
metadataFromJson :: TxMetadataJsonSchema -> Value -> Either TxMetadataJsonError TxMetadata
metadataToJson :: TxMetadataJsonSchema -> TxMetadata -> Value
metadataValueFromJsonNoSchema :: Value -> Either TxMetadataJsonSchemaError TxMetadataValue
metadataValueToJsonNoSchema :: TxMetadataValue -> Value
validateTxMetadata :: TxMetadata -> Either [(Word64, TxMetadataRangeError)] ()
textShow :: Show a => a -> Text
unsafeBoundedRational :: (HasCallStack, Typeable r, BoundedRational r) => Rational -> r
filterValue :: (AssetId -> Bool) -> Value -> Value
lovelaceToQuantity :: Lovelace -> Quantity
lovelaceToValue :: Lovelace -> Value
multiAssetToPolicyAssets :: MultiAsset -> Map PolicyId PolicyAssets
negateValue :: Value -> Value
policyAssetsToValue :: PolicyId -> PolicyAssets -> Value
quantityToLovelace :: Quantity -> Lovelace
renderMultiAsset :: MultiAsset -> Text
renderMultiAssetPretty :: MultiAsset -> Text
renderValuePretty :: Value -> Text
scriptPolicyId :: Script lang -> PolicyId
selectAsset :: Value -> AssetId -> Quantity
valueFromList :: [(AssetId, Quantity)] -> Value
valueFromNestedRep :: ValueNestedRep -> Value
valueToList :: Value -> [(AssetId, Quantity)]
valueToLovelace :: Value -> Maybe Lovelace
valueToNestedRep :: Value -> ValueNestedRep
valueToPolicyAssets :: Value -> Map PolicyId PolicyAssets
parseAssetName :: Parser AssetName
parseMintingMultiAssetValue :: MaryEraOnwards era -> Parser MultiAsset
parsePolicyId :: Parser PolicyId
parseTxOutMultiAssetValue :: Parser Value
parseUTxOValue :: Parser Value
vsep :: [Doc ann] -> Doc ann
bimapExceptT :: forall (m :: Type -> Type) x y a b. Functor m => (x -> y) -> (a -> b) -> ExceptT x m a -> ExceptT y m b
bracketExceptT :: forall (m :: Type -> Type) e a b c. Monad m => ExceptT e m a -> (a -> ExceptT e m b) -> (a -> ExceptT e m c) -> ExceptT e m c
bracketExceptionT :: forall (m :: Type -> Type) e a c b. MonadMask m => ExceptT e m a -> (a -> ExceptT e m c) -> (a -> ExceptT e m b) -> ExceptT e m b
catchExceptT :: (MonadCatch m, Exception e) => m a -> (e -> x) -> ExceptT x m a
catchIOExceptT :: forall (m :: Type -> Type) a x. MonadIO m => IO a -> (IOException -> x) -> ExceptT x m a
catchLeftT :: forall (m :: Type -> Type) e a. Monad m => ExceptT e m a -> (e -> ExceptT e m a) -> ExceptT e m a
catchesExceptT :: (Foldable f, MonadCatch m) => m a -> f (Handler m x) -> ExceptT x m a
exceptT :: Monad m => (x -> m b) -> (a -> m b) -> ExceptT x m a -> m b
firstExceptT :: forall (m :: Type -> Type) x y a. Functor m => (x -> y) -> ExceptT x m a -> ExceptT y m a
handleExceptT :: (MonadCatch m, Exception e) => (e -> x) -> m a -> ExceptT x m a
handleIOExceptT :: forall (m :: Type -> Type) x a. MonadIO m => (IOException -> x) -> IO a -> ExceptT x m a
handleLeftT :: forall (m :: Type -> Type) e a. Monad m => (e -> ExceptT e m a) -> ExceptT e m a -> ExceptT e m a
handlesExceptT :: (Foldable f, MonadCatch m) => f (Handler m x) -> m a -> ExceptT x m a
hoistEither :: forall (m :: Type -> Type) x a. Monad m => Either x a -> ExceptT x m a
hoistExceptT :: (forall b. () => m b -> n b) -> ExceptT x m a -> ExceptT x n a
hushM :: Monad m => Either e a -> (e -> m ()) -> m (Maybe a)
newExceptT :: m (Either x a) -> ExceptT x m a
onLeft :: forall e x (m :: Type -> Type) a. Monad m => (e -> ExceptT x m a) -> ExceptT x m (Either e a) -> ExceptT x m a
onNothing :: forall x (m :: Type -> Type) a. Monad m => ExceptT x m a -> ExceptT x m (Maybe a) -> ExceptT x m a
secondExceptT :: forall (m :: Type -> Type) a b x. Functor m => (a -> b) -> ExceptT x m a -> ExceptT x m b


-- | Pretty printing transactions and utxo's
module Hydra.Cardano.Api.Pretty

-- | Obtain a human-readable pretty text representation of a transaction.
renderTx :: Tx -> String

-- | Like <a>renderTx</a>, but uses the given UTxO to resolve inputs.
renderTxWithUTxO :: UTxO -> Tx -> String
