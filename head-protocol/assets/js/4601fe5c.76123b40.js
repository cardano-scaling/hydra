"use strict";(self.webpackChunkhydra_head_protocol_docs=self.webpackChunkhydra_head_protocol_docs||[]).push([[335],{86559:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});var i=s(73029),r=s(74848),t=s(28453);const o={slug:32,title:"32. Network layer properties, implementation using etcd\n",authors:["ch1bo"],tags:["Accepted"]},c=void 0,l={authorsImageUrls:[void 0]},d=[{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Consequences",id:"consequences",level:2}];function a(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"status",children:"Status"}),"\n",(0,r.jsx)(n.p,{children:"Accepted"}),"\n",(0,r.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The communication primitive of ",(0,r.jsx)(n.code,{children:"broadcast"})," is introduced in ",(0,r.jsx)(n.a,{href:"/adr/6",children:"ADR 6"}),". The original protocol design in the ",(0,r.jsx)(n.a,{href:"https://eprint.iacr.org/2020/299.pdf",children:"paper"})," and that ADR implicitly assume a ",(0,r.jsx)(n.strong,{children:"reliable broadcast"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"/adr/27",children:"ADR 27"})," further specifies that the ",(0,r.jsx)(n.code,{children:"hydra-node"})," should be tolerant to the ",(0,r.jsx)(n.em,{children:"fail-recovery"})," failure model, and takes the decision to implement a ",(0,r.jsx)(n.em,{children:"reliable broadcast"})," by persisting outgoing messages and using a ",(0,r.jsx)(n.em,{children:"vector clock"})," and heartbeat mechanism, over a dumb transport layer."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The current transport layer in use is a simple ",(0,r.jsx)(n.em,{children:"FireForget"})," protocol over TCP connections implemented using ",(0,r.jsx)(n.code,{children:"ouroboros-framework"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"/adr/17",children:"ADR 17"})," proposed to use UDP instead"]}),"\n",(0,r.jsx)(n.li,{children:"Either this design or its implementation was discovered to be wrong, because this system did not survive fault injection tests with moderate package drops."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["This ",(0,r.jsx)(n.a,{href:"https://arxiv.org/pdf/1707.01873",children:"research paper"})," explored various consensus protocols used in blockchain space and reminds us of the correspondence between consensus and broadcasts:"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"the form of consensus relevant for blockchain is technically known as atomic broadcast"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"It also states that (back then):"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"The most important and most prominent way to implement atomic broadcast (i.e., consensus) in distributed systems prone to t < n/2 node crashes is the family of protocols known today as Paxos and Viewstamped Replication (VSR)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["We realize that the way the off-chain protocol is specified in the paper, the ",(0,r.jsx)(n.code,{children:"broadcast"})," abstraction required from the ",(0,r.jsx)(n.code,{children:"Network"})," interface is a so-called ",(0,r.jsx)(n.em,{children:"uniform reliable broadcast"}),". Hence, any implementation of ",(0,r.jsx)(n.code,{children:"Network"})," needs to satisfy the following ",(0,r.jsx)(n.strong,{children:"properties"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Validity"}),": If a correct process p broadcasts a message m, then p eventually delivers m."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No duplication"}),": No message is delivered more than once."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No creation"}),": If a process delivers a message m with sender s, then m was previously broadcast by process s."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Agreement"}),": If a message m is delivered by some correct process, then m is eventually delivered by every correct process."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["See also Module 3.3 in ",(0,r.jsx)(n.a,{href:"https://www.distributedprogramming.net",children:"Introduction to Reliable and Secure Distributed Programming"})," by Cachin et al, or ",(0,r.jsx)(n.a,{href:"https://arxiv.org/abs/2001.03244",children:"Self-stabilizing Uniform Reliable Broadcast by Oskar Lundstr\xf6m"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.a,{href:"https://etcd.io/",children:(0,r.jsx)(n.code,{children:"etcd"})})," as a proxy to achieve reliable broadcast via its ",(0,r.jsx)(n.a,{href:"https://raft.github.io/",children:"raft"})," consensus"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Raft is an evolution of Paxos and similar to VSR"}),"\n",(0,r.jsxs)(n.li,{children:['Over-satisfies requirements as it provides "Uniform total order" (satisfies ',(0,r.jsx)(n.a,{href:"https://en.m.wikipedia.org/wiki/Atomic_broadcast",children:"atomic broadcast"})," properties)"]}),"\n",(0,r.jsxs)(n.li,{children:["Each ",(0,r.jsx)(n.code,{children:"hydra-node"})," runs a ",(0,r.jsx)(n.code,{children:"etcd"})," instance to realize its ",(0,r.jsx)(n.code,{children:"Network"})," interface"]}),"\n",(0,r.jsxs)(n.li,{children:["See the following architecture diagram which also contains some notes on ",(0,r.jsx)(n.code,{children:"Network"})," interface properties:"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:s(4381).A+"",width:"3734",height:"1673"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["We supersede ",(0,r.jsx)(n.a,{href:"/adr/17",children:"ADR 17"})," and ",(0,r.jsx)(n.a,{href:"/adr/27",children:"ADR 27"})," decisions on how to implement ",(0,r.jsx)(n.code,{children:"Network"})," with the current ADR.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Drop existing implementation of ",(0,r.jsx)(n.code,{children:"Ouroboros"})," and ",(0,r.jsx)(n.code,{children:"Reliability"})," components"]}),"\n",(0,r.jsx)(n.li,{children:"Could be revisited, as in theory it would satisfy properties if implemented correctly?"}),"\n",(0,r.jsx)(n.li,{children:"Uniform reliable broadcast = only deliver when seen by everyone = not what we had implemented?"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Crash tolerance of up to ",(0,r.jsx)(n.code,{children:"n/2"})," failing nodes"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Using ",(0,r.jsx)(n.code,{children:"etcd"})," as-is adds a run-time dependency onto that binary."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Docker image users should not see any different UX"}),"\n",(0,r.jsxs)(n.li,{children:["We can ship the binary through ",(0,r.jsx)(n.code,{children:"hydra-node"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Introspectability network as the ",(0,r.jsx)(n.code,{children:"etcd"})," cluster is queryable could improve debugging experience"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Persisted state for networking changes as there will be no ",(0,r.jsx)(n.code,{children:"acks"}),", but the ",(0,r.jsx)(n.code,{children:"etcd"})," Write Ahead Log (WAL) and a last seen revision."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Can keep same user experience on configuration"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Full, static topology with listing everyone as ",(0,r.jsx)(n.code,{children:"--peer"})]}),"\n",(0,r.jsxs)(n.li,{children:["Simpler configuration via ",(0,r.jsx)(n.a,{href:"https://etcd.io/docs/v3.5/op-guide/clustering/#discovery",children:"peer discovery"})," possible"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"PeerConnected"})," semantics needs to change to an overall ",(0,r.jsx)(n.code,{children:"HydraNetworkConnected"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"We can only submit / receive messages when connected to the majority cluster"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"etcd"})," has a few features out-of-the-box we could lean into, e.g."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"use TLS to secure peer connections"}),"\n",(0,r.jsx)(n.li,{children:"separate advertised and binding addresses"}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},4381:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/2024-09-19-etcd-network-draft-d6e27ebc7b523df1ba6998ac119b3063.jpg"},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>c});var i=s(96540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}},73029:e=>{e.exports=JSON.parse('{"permalink":"/head-protocol/adr/32","source":"@site/adr/2025-02-12_032-network-properties-etcd.md","title":"32. Network layer properties, implementation using etcd\\n","description":"Status","date":"2025-02-12T00:00:00.000Z","tags":[{"inline":true,"label":"Accepted","permalink":"/head-protocol/adr/tags/accepted"}],"readingTime":3.05,"hasTruncateMarker":false,"authors":[{"name":"Sebastian Nagel","title":"Software Engineering Lead","url":"https://github.com/ch1bo","imageURL":"https://github.com/ch1bo.png","key":"ch1bo","page":null}],"frontMatter":{"slug":"32","title":"32. Network layer properties, implementation using etcd\\n","authors":["ch1bo"],"tags":["Accepted"]},"unlisted":false,"prevItem":{"title":"31. Achieve constant memory in hydra-node\\n","permalink":"/head-protocol/adr/31"}}')}}]);