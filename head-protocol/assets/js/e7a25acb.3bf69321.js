"use strict";(self.webpackChunkhydra_head_protocol_docs=self.webpackChunkhydra_head_protocol_docs||[]).push([[9055],{85523:(e,i,a)=>{a.r(i),a.d(i,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"auctions/always-on-service-multi/index","title":"Always-on delegated auction service (multi-head)","description":"The always-on delegated auction service is a persistent service for DApps, providing auctions-as-a-service across multiple Hydra heads to facilitate delegated auctions.","source":"@site/use-cases/auctions/always-on-service-multi/index.md","sourceDirName":"auctions/always-on-service-multi","slug":"/auctions/always-on-service-multi/","permalink":"/head-protocol/use-cases/auctions/always-on-service-multi/","draft":false,"unlisted":false,"editUrl":"https://github.com/cardano-scaling/hydra/tree/master/docs/use-cases/auctions/always-on-service-multi/index.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_label":"Auctions-as-a-service: multi","sidebar_position":5},"sidebar":"defaultSidebar","previous":{"title":"Auctions-as-a-service: single","permalink":"/head-protocol/use-cases/auctions/always-on-service-single/"},"next":{"title":"Payments","permalink":"/head-protocol/use-cases/payments/"}}');var n=a(74848),t=a(28453);const r={sidebar_label:"Auctions-as-a-service: multi",sidebar_position:5},o="Always-on delegated auction service (multi-head)",d={},c=[{value:"Overview",id:"overview",level:2},{value:"Features and scope",id:"features-and-scope",level:2},{value:"Remaining limitations",id:"remaining-limitations",level:2},{value:"Prerequisites from Hydra technical roadmap",id:"prerequisites-from-hydra-technical-roadmap",level:2}];function l(e){const i={h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",...(0,t.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"always-on-delegated-auction-service-multi-head",children:"Always-on delegated auction service (multi-head)"})}),"\n",(0,n.jsx)(i.p,{children:"The always-on delegated auction service is a persistent service for DApps, providing auctions-as-a-service across multiple Hydra heads to facilitate delegated auctions."}),"\n",(0,n.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,n.jsx)(i.p,{children:"The always-on single-head service is suitable for a wide range of DApps, but some use cases demand an increased level of decentralization beyond the group of delegates in a single Hydra head. By allowing DApps to use multiple Hydra heads for their layer 2 processes, we can distribute the influence of any one head\u2019s delegates. This approach also enhances the robustness of the layer 2 bidding process \u2014 if one Hydra head goes down, bidders can continue on the other Hydra heads."}),"\n",(0,n.jsx)(i.h2,{id:"features-and-scope",children:"Features and scope"}),"\n",(0,n.jsx)(i.p,{children:"To be determined."}),"\n",(0,n.jsx)(i.h2,{id:"remaining-limitations",children:"Remaining limitations"}),"\n",(0,n.jsxs)(i.ol,{children:["\n",(0,n.jsx)(i.li,{children:"Delegates can censor bidders from submitting bids to the auction. However, if bidders are censored by the delegates of one Hydra head, they can participate in another Hydra head to submit their bids."}),"\n",(0,n.jsx)(i.li,{children:"Delegates on layer 2 are responsible for ensuring that the standing bid of the auction can only be replaced by a new bid that exceeds it by the minimum increment defined in the auction terms. However, bidders receive a multi-signed proof for every confirmed bid, which can be used as incontrovertible proof against delegates if there\u2019s any foul play."}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"prerequisites-from-hydra-technical-roadmap",children:"Prerequisites from Hydra technical roadmap"}),"\n",(0,n.jsx)(i.p,{children:"To be determined."})]})}function u(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},28453:(e,i,a)=>{a.d(i,{R:()=>r,x:()=>o});var s=a(96540);const n={},t=s.createContext(n);function r(e){const i=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),s.createElement(t.Provider,{value:i},e.children)}}}]);