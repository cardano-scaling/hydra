"use strict";(self.webpackChunkhydra_head_protocol_docs=self.webpackChunkhydra_head_protocol_docs||[]).push([[3989],{54302:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});var t=i(69527),s=i(74848),r=i(28453);const a={slug:15,title:"15. Configuration Through an Admin API\n",authors:[],tags:["Proposed"]},o=void 0,d={authorsImageUrls:[]},c=[{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Q&amp;A",id:"qa",level:2},{value:"Consequences",id:"consequences",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h2:"h2",img:"img",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"status",children:"Status"}),"\n",(0,s.jsx)(n.p,{children:"Proposed"}),"\n",(0,s.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Hydra-node currently requires a whole slew of command-line arguments to configure properly its networking layer: ",(0,s.jsx)(n.code,{children:"--peer"})," to connect to each peer, ",(0,s.jsx)(n.code,{children:"--cardano-verification-key"})," and ",(0,s.jsx)(n.code,{children:"--hydra-verification-key"})," to identify the peer on the L1 and L2 respectively."]}),"\n",(0,s.jsxs)(n.li,{children:["This poses significant challenges for operating a ",(0,s.jsx)(n.em,{children:"cluster"})," of Hydra nodes as one needs to know beforehand everything about the cluster, then pass a large number of arguments to some program or docker-compose file, before any node can be started","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"This is a pain that's been felt first-hand for benchmarking and testing purpose"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Having static network configuration is probably not sustainable in the long run, even if we don't add any fancy multihead capabilities to the node, as it would make it significantly harder to have automated creation of Heads."}),"\n",(0,s.jsxs)(n.li,{children:["There's been an ",(0,s.jsx)(n.a,{href:"https://github.com/cardano-scaling/hydra/pull/222",children:"attempt"})," at providing a file-based network configuration but this was deemed unconvincing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://eprint.iacr.org/2020/299.pdf",children:"Hydra paper (sec. 4, p. 13)"})," explicitly assumes the existence of a ",(0,s.jsx)(n.em,{children:"setup"})," phase","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["This ",(0,s.jsx)(n.em,{children:"setup"})," is currently left aside, e.g. exchange of keys for setting up multisig and identifying peers. The ",(0,s.jsx)(n.a,{href:"https://github.com/cardano-scaling/hydra/blob/abailly-iohk/admin-api-adr/hydra-node/exe/hydra-node/Main.hs#L41",children:"hydra-node"})," executable is statically configured and those things are assumed to be known beforehand"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Hydra-node exposes an ",(0,s.jsx)(n.em,{children:"Administrative API"}),' to enable configuration of the Hydra network using "standard" tools',"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"API is exposed as a set of HTTP endpoints on some port, consuming and producing JSON data,"}),"\n",(0,s.jsx)(n.li,{children:"It is documented as part of the User's Guide for Hydra Head"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["This API provides ",(0,s.jsx)(n.em,{children:"commands"})," and ",(0,s.jsx)(n.em,{children:"queries"})," to:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Add/remove ",(0,s.jsx)(n.em,{children:"peers"})," providing their address and keys,"]}),"\n",(0,s.jsx)(n.li,{children:"List currently known peers and their connectivity status,"}),"\n",(0,s.jsx)(n.li,{children:"Start/stop/reset the Hydra network"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["This API is implemented by a ",(0,s.jsx)(n.em,{children:"new component"})," accessible through a network port separate from current ",(0,s.jsx)(n.em,{children:"Client API"}),", that ",(0,s.jsx)(n.em,{children:"configures"})," the ",(0,s.jsx)(n.code,{children:"Network"})," component"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The following picture sketches the proposed architectural change:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Architecture change",src:i(67433).A+"",width:"5351",height:"2989"})}),"\n",(0,s.jsx)(n.h2,{id:"qa",children:"Q&A"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Why a REST interface?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["This API is an interface over a specific ",(0,s.jsx)(n.em,{children:"resource"})," controlled by the Hydra node, namely its knowledge of other peers with which new _Head_s can be opened. As such a proper REST interface (",(0,s.jsx)(n.em,{children:"not"})," RPC-in-disguise) seems to make sense here, rather than stream/event-based ",(0,s.jsx)(n.a,{href:"/adr/3",children:"duplex communication channels"})]}),"\n",(0,s.jsx)(n.li,{children:"We can easily extend such an API with WebSockets to provide notifications (e.g. peers connectivity, setup events...)"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Why a separate component?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["We could imagine extending the existing ",(0,s.jsx)(n.a,{href:"https://github.com/cardano-scaling/hydra/blob/9129c7c013fe2cdc77db048a54981e1ace0843b8/hydra-node/src/Hydra/API/Server.hs",children:"APIServer"})," interface with new messages related to this network configuration, however this seems to conflate different responsibilities in a single place: Configuring and managing the Hydra node itself, and configuring, managing, and interacting with the Head itself"]}),"\n",(0,s.jsx)(n.li,{children:'"Physical" separation of endpoints makes it easier to secure a very sensitive part of the node, namely its administration, e.g by ensuring this can only be accessed through a specific network interface, without relying on application level authentication mechanisms'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It's easy to deploy Hydra nodes with some standard configuration, then dynamically configure them, thus reducing the hassle of defining and configuring the Hydra network"}),"\n",(0,s.jsxs)(n.li,{children:["It makes it possible to ",(0,s.jsx)(n.em,{children:"reconfigure"})," a Hydra node with different peers"]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.em,{children:"Client API"})," should reflect the state of the network and disable ",(0,s.jsx)(n.code,{children:"Init"}),"ing a head if the network layer is not started","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["In the long run, it should also have its scope reduced to represent only the possible interactions with a ",(0,s.jsx)(n.em,{children:"Head"}),", moving things related to network connectivity and setup to the Admin API"]}),"\n",(0,s.jsxs)(n.li,{children:["In a ",(0,s.jsx)(n.em,{children:"Managed Head"})," scenario it would even make sense to have another layer of separation between the API to manage the life-cycle of the Head and the API to make transactions within the Head"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Operational tools could be built easily on top of the API, for command-line or Web-based configuration"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},67433:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/0015-architecture-change-18873d5f6fa6f8237431a6cfa83a03e3.jpg"},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var t=i(96540);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}},69527:e=>{e.exports=JSON.parse('{"permalink":"/head-protocol/adr/15","source":"@site/adr/2022-03-17_015-admin-api.md","title":"15. Configuration Through an Admin API\\n","description":"Status","date":"2022-03-17T00:00:00.000Z","tags":[{"inline":true,"label":"Proposed","permalink":"/head-protocol/adr/tags/proposed"}],"readingTime":3.105,"hasTruncateMarker":false,"authors":[],"frontMatter":{"slug":"15","title":"15. Configuration Through an Admin API\\n","authors":[],"tags":["Proposed"]},"unlisted":false,"prevItem":{"title":"14. Token usage in Hydra Scripts\\n","permalink":"/head-protocol/adr/14"},"nextItem":{"title":"16. Keep Rejected ADRs\\n","permalink":"/head-protocol/adr/16"}}')}}]);