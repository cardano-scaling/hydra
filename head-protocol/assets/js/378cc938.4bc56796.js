"use strict";(self.webpackChunkhydra_head_protocol_docs=self.webpackChunkhydra_head_protocol_docs||[]).push([[359],{93496:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>d,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>o});var a=n(13241),s=n(74848),i=n(28453);const c={slug:24,title:"24. Persist state changes incrementally\n",authors:["abailly"],tags:["Accepted"]},d=void 0,r={authorsImageUrls:[void 0]},o=[{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Consequences",id:"consequences",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h2:"h2",li:"li",mermaid:"mermaid",ol:"ol",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"status",children:"Status"}),"\n",(0,s.jsx)(t.p,{children:"Accepted"}),"\n",(0,s.jsx)(t.h2,{id:"context",children:"Context"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["The state of a Hydra Head is currently persisted as a whole upon each ",(0,s.jsx)(t.code,{children:"NewState"})," ",(0,s.jsx)(t.em,{children:"outcome"})," from the ",(0,s.jsx)(t.code,{children:"update"})," function: The new state is serialised and the ",(0,s.jsx)(t.code,{children:"state"})," file is overwritten with the corresponding bytes. While this is a straightforward strategy to implement, it has a huge impact on the performance of a Hydra Head as serialising a large data structure like the ",(0,s.jsx)(t.code,{children:"HeadState"})," and completely overwriting a file is costly","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["We revisited our benchmarks and ",(0,s.jsx)(t.a,{href:"https://github.com/cardano-scaling/hydra/issues/186#issuecomment-1584292265",children:"found"})," that persistence was the major bottleneck when measuring roundtrip confirmation time,e g. the time it takes from a client's perspective to submit a transaction and observe in a ",(0,s.jsx)(t.code,{children:"ConfirmedSnapshot"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["Furthermore, the way we currently handle changes to the ",(0,s.jsx)(t.code,{children:"HeadState"})," in the hydra-node, while conceptually being an ",(0,s.jsx)(t.code,{children:"Effect"})," is handled differently from other ",(0,s.jsx)(t.code,{children:"Effect"}),"s: The state is updated transactionally through a dedicated ",(0,s.jsx)(t.code,{children:"modifyHeadState"})," function in the core loop of processing events, and ",(0,s.jsx)(t.em,{children:"then"})," effects are processed."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsxs)(t.p,{children:["Implement state persistence using ",(0,s.jsx)(t.a,{href:"https://thinkbeforecoding.com/post/2013/07/28/Event-Sourcing-vs-Command-Sourcing",children:(0,s.jsx)(t.em,{children:"Event Sourcing"})}),". Practically, this means:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Replace the ",(0,s.jsx)(t.code,{children:"NewState"})," outcome with a ",(0,s.jsx)(t.code,{children:"StateChanged"})," ",(0,s.jsx)(t.em,{children:"event"})," which can be part of the ",(0,s.jsx)(t.code,{children:"Outcome"})," of ",(0,s.jsx)(t.code,{children:"HeadLogic"}),"'s ",(0,s.jsx)(t.code,{children:"update"})," function, representing the ",(0,s.jsx)(t.em,{children:"change"})," to be applied to the current state."]}),"\n",(0,s.jsxs)(t.li,{children:["Add an ",(0,s.jsx)(t.code,{children:"aggregate"})," function to manage applying ",(0,s.jsx)(t.code,{children:"StateChanged"})," events on top of the current ",(0,s.jsx)(t.code,{children:"HeadState"})," to keep it updated in-memory."]}),"\n",(0,s.jsxs)(t.li,{children:["Persist ",(0,s.jsx)(t.code,{children:"StateChanged"}),"s in an append-only log using a dedicated ",(0,s.jsx)(t.a,{href:"/adr/4",children:"handle"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["Upon node startup, reread ",(0,s.jsx)(t.code,{children:"StateChanged"})," events log and reapply those to reset the ",(0,s.jsx)(t.code,{children:"HeadState"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["The following sequence diagram illustrates new event handling in the ",(0,s.jsx)(t.code,{children:"HeadLogic"}),":"]}),"\n",(0,s.jsx)(t.mermaid,{value:"sequenceDiagram\n   Node ->> Node : nextEvent : event\n   critical modifyHeadState : state -> state';\n     activate Node\n     Node ->>+ HeadLogic: update(state, event)\n     HeadLogic --\x3e>- Node : Outcome (sc: StateChanged, oe: OtherEffect)\n     Node ->>+ HeadLogic: aggregate(state, sc)\n     HeadLogic --\x3e- Node : state'\n   end\n   deactivate Node\n   Node ->> Persistence: append(sc)\n   Node ->> Node: processEffect(oe)"}),"\n",(0,s.jsx)(t.h2,{id:"consequences",children:"Consequences"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["\ud83d\udc0e"," The main expected consequence of this change is an increase of the overall performance of Hydra Head network."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["Need to pattern match twice on the ",(0,s.jsx)(t.code,{children:"HeadState"}),", once in ",(0,s.jsx)(t.code,{children:"update"})," and once in ",(0,s.jsx)(t.code,{children:"aggregate"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["Terms from the specification are distributed over ",(0,s.jsx)(t.code,{children:"update"})," and ",(0,s.jsx)(t.code,{children:"aggregate"})," function. For example, the statements about updating all seen transactions would now be in ",(0,s.jsx)(t.code,{children:"aggregate"})," and not anymore in ",(0,s.jsx)(t.code,{children:"update"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["New possibilities this change introduces with respect to ",(0,s.jsx)(t.code,{children:"ServerOutput"})," handling and client's access to a head's state:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Instead of having the ",(0,s.jsx)(t.code,{children:"HeadLogic"})," emits directly a ",(0,s.jsx)(t.code,{children:"ClientEffect"}),", the latter could be the result of a client-centric ",(0,s.jsx)(t.em,{children:"interpretation"})," of a ",(0,s.jsx)(t.code,{children:"StateChanged"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["Pushing this a little further, we could maintain a ",(0,s.jsx)(t.em,{children:"Query Model"})," for clients with a dedicated ",(0,s.jsx)(t.a,{href:"https://github.com/cardano-scaling/hydra/discussions/686",children:"Query API"})," to ease implementation of stateless clients."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["Calling ",(0,s.jsx)(t.code,{children:"StateChanged"})," an ",(0,s.jsx)(t.em,{children:"event"})," while treating it in the code alongside ",(0,s.jsx)(t.em,{children:"effects"})," might introduce some confusion as we already use the word ",(0,s.jsx)(t.a,{href:"https://github.com/cardano-scaling/hydra/blob/45913954eb18ef550a31017daa443cee6720a00c/hydra-node/src/Hydra/HeadLogic.hs#L64",children:"Event"})," to designate the inputs (a.k.a. commands) to the Head logic state machine. We might want at some later point to unify the terminology."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>d});var a=n(96540);const s={},i=a.createContext(s);function c(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),a.createElement(i.Provider,{value:t},e.children)}},13241:e=>{e.exports=JSON.parse('{"permalink":"/head-protocol/adr/24","source":"@site/adr/2023-06-19_024-event-sourced-persistence.md","title":"24. Persist state changes incrementally\\n","description":"Status","date":"2023-06-19T00:00:00.000Z","tags":[{"inline":true,"label":"Accepted","permalink":"/head-protocol/adr/tags/accepted"}],"readingTime":2.47,"hasTruncateMarker":false,"authors":[{"name":"Arnaud Bailly","title":"Lead Architect","url":"https://github.com/abailly-iohk","imageURL":"https://github.com/abailly-iohk.png","key":"abailly","page":null}],"frontMatter":{"slug":"24","title":"24. Persist state changes incrementally\\n","authors":["abailly"],"tags":["Accepted"]},"unlisted":false,"prevItem":{"title":"23. Local chain state in chain layer\\n","permalink":"/head-protocol/adr/23"},"nextItem":{"title":"25. Event-sourced, resource-based API\\n","permalink":"/head-protocol/adr/25"}}')}}]);