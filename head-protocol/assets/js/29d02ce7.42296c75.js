"use strict";(self.webpackChunkhydra_head_protocol_docs=self.webpackChunkhydra_head_protocol_docs||[]).push([[4001],{73238:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"dev/architecture/networking","title":"Networking","description":"This page provides details about the Hydra networking layer, through which hydra nodes exchange off-chain protocol messages. The off-chain protocol relies heavily on the correct operation of the multicast abstraction (broadcast in our fully connected topology here) in the way it is specified and the following sections explain our realization in the Hydra node implementation.","source":"@site/docs/dev/architecture/networking.md","sourceDirName":"dev/architecture","slug":"/dev/architecture/networking","permalink":"/head-protocol/docs/dev/architecture/networking","draft":false,"unlisted":false,"editUrl":"https://github.com/cardano-scaling/hydra/tree/master/docs/docs/dev/architecture/networking.md","tags":[],"version":"current","frontMatter":{},"sidebar":"developerDocumentation","previous":{"title":"Event sourcing","permalink":"/head-protocol/docs/dev/architecture/event-sourcing"},"next":{"title":"Specification","permalink":"/head-protocol/docs/dev/specification"}}');var i=n(74848),o=n(28453);const r={},a="Networking",l={},c=[{value:"Interface",id:"interface",level:2},{value:"Fault model",id:"fault-model",level:2},{value:"Topology",id:"topology",level:2},{value:"Authentication",id:"authentication",level:2},{value:"Encryption",id:"encryption",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Previous network stack",id:"previous-network-stack",level:3},{value:"Gossip diffusion network (idea)",id:"gossip-diffusion-network-idea",level:3},{value:"Network resilience testing",id:"network-resilience-testing",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",section:"section",strong:"strong",sup:"sup",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"networking",children:"Networking"})}),"\n",(0,i.jsxs)(t.p,{children:["This page provides details about the Hydra networking layer, through which hydra nodes exchange off-chain protocol messages. The off-chain protocol relies heavily on the correct operation of the ",(0,i.jsx)(t.strong,{children:"multicast"})," abstraction (",(0,i.jsx)(t.code,{children:"broadcast"})," in our fully connected topology here) in the way ",(0,i.jsx)(t.a,{href:"../specification",children:"it is specified"})," and the following sections explain our realization in the Hydra node implementation."]}),"\n",(0,i.jsx)(t.h2,{id:"interface",children:"Interface"}),"\n",(0,i.jsxs)(t.p,{children:["Within a ",(0,i.jsx)(t.code,{children:"hydra-node"}),", a ",(0,i.jsx)(t.code,{children:"Network"})," component provides the capability to reliably ",(0,i.jsx)(t.code,{children:"broadcast"})," a message to the whole Hydra network. In turn, when a message is received from the network, the ",(0,i.jsx)(t.code,{children:"NetworkCallback"})," signals this by invoking ",(0,i.jsx)(t.code,{children:"deliver"}),". This interface follows reliable broadcast terminology of distributed systems literature."]}),"\n",(0,i.jsxs)(t.p,{children:["Given the way the ",(0,i.jsx)(t.a,{href:"../specification",children:"off-chain protocol is specified"}),", the ",(0,i.jsx)(t.code,{children:"broadcast"})," abstraction required from the ",(0,i.jsx)(t.code,{children:"Network"})," interface is a so-called ",(0,i.jsx)(t.em,{children:"uniform reliable broadcast"})," with properties:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Validity"}),": If a correct process p broadcasts a message m, then p eventually delivers m."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"No duplication"}),": No message is delivered more than once."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"No creation"}),": If a process delivers a message m with sender s, then m was previously broadcast by process s."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Agreement"}),": If a message m is delivered by some correct process, then m is eventually delivered by every correct process."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["See also Module 3.3 in ",(0,i.jsx)(t.a,{href:"https://www.distributedprogramming.net",children:"Introduction to Reliable and Secure Distributed Programming"})," by Cachin et al, or ",(0,i.jsx)(t.a,{href:"https://arxiv.org/abs/2001.03244",children:"Self-stabilizing Uniform Reliable Broadcast by Oskar Lundstr\xf6m"}),"; or ",(0,i.jsx)(t.a,{href:"https://en.m.wikipedia.org/wiki/Atomic_broadcast",children:"atomic broadcast"})," for an even stronger abstraction."]}),"\n",(0,i.jsx)(t.h2,{id:"fault-model",children:"Fault model"}),"\n",(0,i.jsxs)(t.p,{children:["Although the Hydra protocol can only progress when nodes of all participants are online and responsive, the network layer should still provide a certain level of tolerance to crashes, transient connection problems and ",(0,i.jsx)(t.em,{children:"non-byzantine"})," faults."]}),"\n",(0,i.jsxs)(t.p,{children:["Concretely, this means that a ",(0,i.jsx)(t.em,{children:"fail-recovery"})," distributed systems model (again see Cachin et al) seems to fit these requirements best. This means, that processes may crash and later recover should still be able to participate in the protocol. Processes may forget what they did prior to crashing, but may use stable storage to persist knowledge. Links may fail and are ",(0,i.jsx)(t.em,{children:"fair-loss"}),", where techniques to improve them to ",(0,i.jsx)(t.em,{children:"stubborn"})," or ",(0,i.jsx)(t.em,{children:"perfect"})," links likely will be required."]}),"\n",(0,i.jsxs)(t.p,{children:["See also ",(0,i.jsx)(t.a,{href:"/adr/27",children:"ADR 27 (superseded)"})," and ",(0,i.jsx)(t.a,{href:"/adr/32",children:"ADR 32"})," for more context on required properties of the network layer and attempts to achieve fault tolerance."]}),"\n",(0,i.jsx)(t.h2,{id:"topology",children:"Topology"}),"\n",(0,i.jsxs)(t.p,{children:["Currently, the ",(0,i.jsx)(t.code,{children:"hydra-node"})," operates in a static, ",(0,i.jsx)(t.strong,{children:"fully connected"})," network topology where each node connects to each other node and a message is broadcast to all nodes. For this, we need to pass publicly reachable endpoints of ",(0,i.jsx)(t.em,{children:"all other nodes"})," via ",(0,i.jsx)(t.code,{children:"--peer"})," options to each hydra node and ",(0,i.jsx)(t.em,{children:"all links"})," must be operational to achieve liveness",(0,i.jsx)(t.sup,{children:(0,i.jsx)(t.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Future implementations of a the ",(0,i.jsx)(t.code,{children:"Network"})," interface could improve upon this by enabling ",(0,i.jsx)(t.strong,{children:"mesh"})," topologies where messages are forwarded across links. This would simplify configuration to only need to provide ",(0,i.jsx)(t.em,{children:"at least one"})," ",(0,i.jsx)(t.code,{children:"--peer"}),", while ",(0,i.jsx)(t.em,{children:"peer sharing"})," in such a network could still allow for redundant connections and better fault tolerance."]}),"\n",(0,i.jsx)(t.h2,{id:"authentication",children:"Authentication"}),"\n",(0,i.jsxs)(t.p,{children:["The messages exchanged through the ",(0,i.jsx)(t.em,{children:"Hydra networking"})," layer between participants are authenticated. Each message is ",(0,i.jsx)(t.a,{href:"https://github.com/cardano-scaling/hydra/issues/727",children:"signed"})," using the Hydra signing key of the emitting party, which is identified by the corresponding verification key. When a message with an unknown or incorrect signature is received, it is dropped, and a notification is logged."]}),"\n",(0,i.jsx)(t.h2,{id:"encryption",children:"Encryption"}),"\n",(0,i.jsxs)(t.p,{children:["Currently, communication is ",(0,i.jsx)(t.em,{children:"not"})," encrypted."]}),"\n",(0,i.jsx)(t.p,{children:"If confidentiality is required, two options exist: encrypt individual messages (symmetric block cipher initiated through a key exchange) or establish encrypted channels between peers (e.g. using TLS)."}),"\n",(0,i.jsx)(t.h2,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsxs)(t.p,{children:["The current implementation of the ",(0,i.jsx)(t.a,{href:"pathname:///haddock/hydra-node/Hydra-Node-Network.html",children:"network stack"})," consists of two components:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"pathname:///haddock/hydra-node/Hydra-Network-Authenticate.html",children:(0,i.jsx)(t.code,{children:"Authenticate"})})," component that signs all outgoing and verifies incoming messages using the Hydra snapshot key pair"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"pathname:///haddock/hydra-node/Hydra-Network-Etcd.html",children:(0,i.jsx)(t.code,{children:"Etcd"})})," component that re-uses ",(0,i.jsx)(t.a,{href:"https://etcd.io/",children:"etcd"})," to implement a reliable ",(0,i.jsx)(t.code,{children:"broadcast"})," primitive"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["See ",(0,i.jsx)(t.a,{href:"/adr/32",children:"ADR 32"})," for a rationale of this approach."]}),"\n",(0,i.jsx)(t.h3,{id:"previous-network-stack",children:"Previous network stack"}),"\n",(0,i.jsx)(t.p,{children:'In the past we had a "hand-rolled" network stack to implement reliable broadcast in a fully connected network topology.'}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Hydra nodes form a network of pairwise connected ",(0,i.jsx)(t.em,{children:"peers"})," using point-to-point TCP connections that are expected to remain active at all times"]}),"\n",(0,i.jsxs)(t.li,{children:["Using ",(0,i.jsx)(t.a,{href:"https://github.com/input-output-hk/ouroboros-network/",children:"ouroboros-framework"})," to establish point-to-point stream-based connections in a simple ",(0,i.jsx)(t.code,{children:"FireForget"})," protocol (stateless, just sending messages)."]}),"\n",(0,i.jsx)(t.li,{children:'Nodes keep a "valency" matching the number of other peers and broadcast messages to everyone.'}),"\n",(0,i.jsxs)(t.li,{children:["Implement basic ",(0,i.jsx)(t.em,{children:"failure detection"})," through heartbeats and monitoring exchanged messages."]}),"\n",(0,i.jsx)(t.li,{children:"Reliable broadcast is (attempted to be) realized by storing outgoing messages, acknowledgments via a vector clock transmitted on each message, and message resending if clock is out-of-sync."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"However, it was not as reliable as we hoped (in theory it should have worked) and we pivoted to the current, etcd-based implementation."}),"\n",(0,i.jsx)(t.h3,{id:"gossip-diffusion-network-idea",children:"Gossip diffusion network (idea)"}),"\n",(0,i.jsx)(t.p,{children:"The following diagram illustrates an ideated pull-based messaging system for Hydra. This would follow the design of the Cardano network stack:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Hydra pull-based network",src:n(95320).A+"",width:"5827",height:"2745"})}),"\n",(0,i.jsxs)(t.p,{children:["This was not (yet) pursued as it does not fit the ",(0,i.jsx)(t.a,{href:"#interface",children:"broadcast interface"})," as required by the Hydra Head protocol design. However, we think it ",(0,i.jsx)(t.em,{children:"should"})," be possible to represent the off-chain protocol using pull-based semantics and follow this approach."]}),"\n",(0,i.jsx)(t.h2,{id:"network-resilience-testing",children:"Network resilience testing"}),"\n",(0,i.jsxs)(t.p,{children:["In August 2024 we added some network resilience tests, implemented as a GitHub\naction step in ",(0,i.jsx)(t.a,{href:"https://github.com/cardano-scaling/hydra/blob/master/.github/workflows/network-test.yaml",children:"network-test.yaml"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The approach is to use ",(0,i.jsx)(t.a,{href:"https://github.com/alexei-led/pumba",children:"Pumba"})," to inject\nnetworking faults into a docker-based setup. This is effective, because of the\n",(0,i.jsx)(t.a,{href:"https://srtlab.github.io/srt-cookbook/how-to-articles/using-netem-to-emulate-networks.html",children:"NetEm"}),"\ncapability that allows for very powerful manipulation of the networking stack\nof the containers."]}),"\n",(0,i.jsxs)(t.p,{children:["Initially, we have set up percentage-based loss on some very specific\nscenarios; namely a three-node setup between ",(0,i.jsx)(t.code,{children:"Alice"}),", ",(0,i.jsx)(t.code,{children:"Bob"})," and ",(0,i.jsx)(t.code,{children:"Carol"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"With this setup, we tested the following scenarios:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:'Three nodes, 900 transactions ("scaling=10"):'}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"1% packet loss to both peers: \u2705 Success"}),"\n",(0,i.jsx)(t.li,{children:"2% packet loss to both peers: \u2705 Success"}),"\n",(0,i.jsx)(t.li,{children:"3% packet loss to both peers: \u2705 Success"}),"\n",(0,i.jsx)(t.li,{children:"4% packet loss to both peers: \u2705 Success"}),"\n",(0,i.jsx)(t.li,{children:"5% packet loss to both peers: Sometimes works, sometimes fails"}),"\n",(0,i.jsx)(t.li,{children:"10% packet loss to both peers: Sometimes works, sometimes fails"}),"\n",(0,i.jsx)(t.li,{children:"20% packet loss to both peers: \u274cFailure"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:'Three nodes, 4500 transactions ("scaling=50"):'}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"1% packet loss to both peers: \u2705 Success"}),"\n",(0,i.jsx)(t.li,{children:"2% packet loss to both peers: \u2705 Success"}),"\n",(0,i.jsx)(t.li,{children:"3% packet loss to both peers: \u2705 Success"}),"\n",(0,i.jsx)(t.li,{children:"4% packet loss to both peers: Sometimes works, sometimes fails"}),"\n",(0,i.jsx)(t.li,{children:"5% packet loss to both peers: Sometimes works, sometimes fails"}),"\n",(0,i.jsx)(t.li,{children:"10% packet loss to both peers: \u274cFailure"}),"\n",(0,i.jsx)(t.li,{children:"20% packet loss to both peers: \u274cFailure"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:['"Success" here means that ',(0,i.jsx)(t.em,{children:"all"}),' transactions were processed; "Failure" means\none or more transactions did not get confirmed by all participants within a\nparticular timeframe.']}),"\n",(0,i.jsxs)(t.p,{children:["The main conclusion here is ... there's a limit to the amount of packet loss\nwe can sustain, it's related to how many transactions we are trying to send\n(naturally, ",(0,i.jsx)(t.a,{href:"http://www.voiptroubleshooter.com/indepth/burstloss.html",children:"given the percent of failure is per\npacket"}),".)"]}),"\n",(0,i.jsxs)(t.p,{children:["You can keep an eye on the runs of this action here: ",(0,i.jsx)(t.a,{href:"https://github.com/cardano-scaling/hydra/actions/workflows/network-test.yaml",children:"Network fault\ntolerance"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"The main things to note are:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Overall, the CI job will succeed even if every scenario fails. This is,\nultimately, due to a bug in ",(0,i.jsx)(t.a,{href:"https://github.com/actions/runner/issues/2347",children:"GitHub\nactions"})," that prevents one\nfrom declaring an explicit pass-or-fail expectation per scenario. The impact\nis that you should manually check this job on each of your PRs."]}),"\n",(0,i.jsxs)(t.li,{children:["It's okay to see certain configurations fail, but it's certainly not\nexpected to see them ",(0,i.jsx)(t.em,{children:"all"})," fail; certainly not the zero-loss cases. Anything\nthat looks suspcisious should be investigated."]}),"\n"]}),"\n","\n",(0,i.jsxs)(t.section,{"data-footnotes":!0,className:"footnotes",children:[(0,i.jsx)(t.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{id:"user-content-fn-1",children:["\n",(0,i.jsxs)(t.p,{children:["This is not entirely true anymore as the ",(0,i.jsx)(t.code,{children:"etcd"})," based implementation requires only a connection to the majority of the cluster. ",(0,i.jsx)(t.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},95320:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/hydra-pull-based-network-82c3d214f8e8d9b2054a23a4fadd48db.jpg"},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var s=n(96540);const i={},o=s.createContext(i);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);