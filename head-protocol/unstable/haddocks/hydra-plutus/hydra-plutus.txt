-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Hydra Plutus Contracts
--   
--   Hydra Plutus Contracts
@package hydra-plutus
@version 1.0.0


-- | Simple asserting validators that are primarily useful for testing.
module Hydra.Contract.Dummy
dummyValidatorScript :: PlutusScript
alwaysFailingScript :: () -> () -> ScriptContext -> Bool
dummyValidatorScriptAlwaysFails :: PlutusScript
dummyMintingScript :: PlutusScript
dummyRewardingScript :: PlutusScript


-- | Error codes to be used in plutus scripts.
--   
--   Define a new type and instantiate <a>ToErrorCode</a> for error cases
--   you want to use in scripts.
--   
--   <pre>
--   data MyError = CaseA | CaseB deriving Show
--   
--   instance ToErrorCode MyError where
--     toErrorCode = case
--       CaseA -&gt; <a>CA</a>
--       CaseB -&gt; <a>CB</a>
--   </pre>
--   
--   In plutus-tx, you can then use template haskell to inline the error
--   codes using the '$(errorCode ..)' splice.
--   
--   <pre>
--   validator = traceError $(errorCode CaseA)
--   </pre>
--   
--   This example will have your validator fail with user error <a>CA</a>,
--   which you can match for using 'toErrorCode CaseA' in Haskell.
module Hydra.Contract.Error

-- | Types which are used to describe errors as short error codes in
--   scripts.
class ToErrorCode a

-- | Get the short error code used in a script for given type.
toErrorCode :: ToErrorCode a => a -> Text

-- | Get the string literal from given error <tt>e</tt>. Use this with
--   template haskell splices, e.g. $(errorCode MyError)
errorCode :: ToErrorCode e => e -> Q Exp

module Hydra.Contract.DepositError

-- | Get the string literal from given error <tt>e</tt>. Use this with
--   template haskell splices, e.g. $(errorCode MyError)
errorCode :: ToErrorCode e => e -> Q Exp
data DepositError
DepositPeriodSurpassed :: DepositError
DepositNoUpperBoundDefined :: DepositError
DepositNoLowerBoundDefined :: DepositError
DepositPeriodNotReached :: DepositError
IncorrectDepositHash :: DepositError
WrongHeadIdInDepositDatum :: DepositError
instance GHC.Show.Show Hydra.Contract.DepositError.DepositError
instance Hydra.Contract.Error.ToErrorCode Hydra.Contract.DepositError.DepositError

module Hydra.Contract.CommitError

-- | Get the string literal from given error <tt>e</tt>. Use this with
--   template haskell splices, e.g. $(errorCode MyError)
errorCode :: ToErrorCode e => e -> Q Exp
data CommitError
STNotBurnedError :: CommitError
STIsMissingInTheOutput :: CommitError
instance GHC.Show.Show Hydra.Contract.CommitError.CommitError
instance Hydra.Contract.Error.ToErrorCode Hydra.Contract.CommitError.CommitError

module Hydra.Contract.HeadError

-- | Get the string literal from given error <tt>e</tt>. Use this with
--   template haskell splices, e.g. $(errorCode MyError)
errorCode :: ToErrorCode e => e -> Q Exp
data HeadError
InvalidHeadStateTransition :: HeadError
ChangedParameters :: HeadError
WrongStateInOutputDatum :: HeadError
HeadValueIsNotPreserved :: HeadError
SignerIsNotAParticipant :: HeadError
NoSigners :: HeadError
TooManySigners :: HeadError
ScriptNotSpendingAHeadInput :: HeadError
NoOutputDatumError :: HeadError
UnexpectedNonInlineDatum :: HeadError
NotPayingToHead :: HeadError
SignatureVerificationFailed :: HeadError
MustNotChangeVersion :: HeadError
BurntTokenNumberMismatch :: HeadError
ReimbursedOutputsDontMatch :: HeadError
STNotSpent :: HeadError
IncorrectUtxoHash :: HeadError
MissingCommits :: HeadError
NotAllValueCollected :: HeadError
IncorrectVersion :: HeadError
VersionNotIncremented :: HeadError
HasBoundedValidityCheckFailed :: HeadError
IncorrectClosedContestationDeadline :: HeadError
InfiniteUpperBound :: HeadError
InfiniteLowerBound :: HeadError
ContestersNonEmpty :: HeadError
CloseNoUpperBoundDefined :: HeadError
FailedCloseInitial :: HeadError
FailedCloseAny :: HeadError
TooOldSnapshot :: HeadError
UpperBoundBeyondContestationDeadline :: HeadError
ContestNoUpperBoundDefined :: HeadError
MustNotPushDeadline :: HeadError
MustPushDeadline :: HeadError
ContesterNotIncluded :: HeadError
WrongNumberOfSigners :: HeadError
SignerAlreadyContested :: HeadError
FailedContestCurrent :: HeadError
FailedContestUsedDec :: HeadError
FanoutUTxOHashMismatch :: HeadError
LowerBoundBeforeContestationDeadline :: HeadError
FanoutNoLowerBoundDefined :: HeadError
FanoutUTxOToCommitHashMismatch :: HeadError
FanoutUTxOToDecommitHashMismatch :: HeadError
DepositNotSpent :: HeadError
DepositInputNotFound :: HeadError
HeadInputNotFound :: HeadError
FailedContestUnusedDec :: HeadError
FailedContestUnusedInc :: HeadError
FailedContestUsedInc :: HeadError
FailedCloseUnusedDec :: HeadError
FailedCloseUsedDec :: HeadError
FailedCloseUnusedInc :: HeadError
FailedCloseUsedInc :: HeadError
instance Hydra.Contract.Error.ToErrorCode Hydra.Contract.HeadError.HeadError

module Hydra.Contract.HeadTokensError

-- | Get the string literal from given error <tt>e</tt>. Use this with
--   template haskell splices, e.g. $(errorCode MyError)
errorCode :: ToErrorCode e => e -> Q Exp
data HeadTokensError
SeedNotSpent :: HeadTokensError
WrongNumberOfTokensMinted :: HeadTokensError
MissingST :: HeadTokensError
WrongNumberOfInitialOutputs :: HeadTokensError
WrongDatum :: HeadTokensError
MintingNotAllowed :: HeadTokensError
NoPT :: HeadTokensError
WrongQuantity :: HeadTokensError
ExpectedHeadDatumType :: HeadTokensError
ExpectedInlineDatum :: HeadTokensError
MultipleHeadOutput :: HeadTokensError
WrongInitialDatum :: HeadTokensError
instance GHC.Show.Show Hydra.Contract.HeadTokensError.HeadTokensError
instance Hydra.Contract.Error.ToErrorCode Hydra.Contract.HeadTokensError.HeadTokensError


-- | Datum and redeemer types, as well as helper functions for the commit
--   validator implemented in aiken.
module Hydra.Contract.Initial
type DatumType = CurrencySymbol
type RedeemerType = InitialRedeemer
data InitialRedeemer
ViaAbort :: InitialRedeemer
ViaCommit :: [TxOutRef] -> InitialRedeemer

-- | Points to the committed Utxo.
[committedRefs] :: InitialRedeemer -> [TxOutRef]
datum :: DatumType -> Datum
redeemer :: RedeemerType -> Redeemer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.Initial.InitialRedeemer
instance PlutusTx.IsData.Class.FromData Hydra.Contract.Initial.InitialRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.Initial.InitialRedeemer

module Hydra.Contract.InitialError

-- | Get the string literal from given error <tt>e</tt>. Use this with
--   template haskell splices, e.g. $(errorCode MyError)
errorCode :: ToErrorCode e => e -> Q Exp
data InitialError
STNotBurned :: InitialError
MissingOrInvalidCommitAuthor :: InitialError
LockedValueDoesNotMatch :: InitialError
MismatchCommittedTxOutInDatum :: InitialError
CouldNotFindTheCorrectCurrencySymbolInTokens :: InitialError
MultipleHeadTokensOrMoreThan1PTsFound :: InitialError
MissingCommittedTxOutInOutputDatum :: InitialError
CommittedTxOutMissingInOutputDatum :: InitialError
MissingDatum :: InitialError
UnexpectedNonInlineDatum :: InitialError
ExpectedCommitDatumTypeGotSomethingElse :: InitialError
ExpectedSingleCommitOutput :: InitialError
WrongHeadIdInCommitDatum :: InitialError
MintingOrBurningIsForbidden :: InitialError
OutRefNotFound :: InitialError
instance GHC.Show.Show Hydra.Contract.InitialError.InitialError
instance Hydra.Contract.Error.ToErrorCode Hydra.Contract.InitialError.InitialError


-- | Data type used in <a>HeadTokens</a> as a separate module because of
--   TemplateHaskell stage restriction.
module Hydra.Contract.MintAction
data MintAction
Mint :: MintAction
Burn :: MintAction
instance PlutusTx.IsData.Class.ToData Hydra.Contract.MintAction.MintAction
instance PlutusTx.IsData.Class.FromData Hydra.Contract.MintAction.MintAction
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.MintAction.MintAction

module Hydra.Data.ContestationPeriod
newtype ContestationPeriod
UnsafeContestationPeriod :: DiffMilliSeconds -> ContestationPeriod
[milliseconds] :: ContestationPeriod -> DiffMilliSeconds
contestationPeriodFromDiffTime :: NominalDiffTime -> ContestationPeriod
contestationPeriodToDiffTime :: ContestationPeriod -> NominalDiffTime

-- | Compute the (on-chain) contestation deadline from a given current time
--   and the <a>ContestationPeriod</a>.
addContestationPeriod :: POSIXTime -> ContestationPeriod -> POSIXTime
instance PlutusTx.IsData.Class.ToData Hydra.Data.ContestationPeriod.ContestationPeriod
instance PlutusTx.IsData.Class.FromData Hydra.Data.ContestationPeriod.ContestationPeriod
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Data.ContestationPeriod.ContestationPeriod
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Data.ContestationPeriod.ContestationPeriod
instance PlutusTx.Eq.Eq Hydra.Data.ContestationPeriod.ContestationPeriod
instance GHC.Num.Num Hydra.Data.ContestationPeriod.ContestationPeriod
instance GHC.Show.Show Hydra.Data.ContestationPeriod.ContestationPeriod
instance GHC.Classes.Ord Hydra.Data.ContestationPeriod.ContestationPeriod
instance GHC.Classes.Eq Hydra.Data.ContestationPeriod.ContestationPeriod
instance GHC.Generics.Generic Hydra.Data.ContestationPeriod.ContestationPeriod

module Hydra.Data.Party

-- | On-chain representation of a Hydra party.
--   
--   NOTE: This roughly corresponds to the <a>Party</a> in 'hydra-node',
--   but is simplified to allow usage of this type in plutus-tx. If we
--   would use the complex type directly, which is based on
--   'cardano-crypto-class', we would get errors like "Error: Unsupported
--   feature: Kind: GHC.Types.Nat".
--   
--   The data constructor should not be used to construct this value as it
--   would always come from off-chain code via
--   <a>partyFromVerificationKeyBytes</a>.
newtype Party
UnsafeParty :: BuiltinByteString -> Party
[vkey] :: Party -> BuiltinByteString

-- | Create an on-chain <a>Party</a> from some verification key bytes.
partyFromVerificationKeyBytes :: ByteString -> Party

-- | Get the verification key bytes contained from an on-chain
--   <a>Party</a>.
partyToVerificationKeyBytes :: Party -> ByteString
instance PlutusTx.Eq.Eq Hydra.Data.Party.Party
instance GHC.Show.Show Hydra.Data.Party.Party
instance GHC.Generics.Generic Hydra.Data.Party.Party
instance GHC.Classes.Eq Hydra.Data.Party.Party
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Data.Party.Party
instance PlutusTx.IsData.Class.ToData Hydra.Data.Party.Party
instance PlutusTx.IsData.Class.FromData Hydra.Data.Party.Party
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Data.Party.Party

module Hydra.Contract.HeadState
type SnapshotNumber = Integer
type SnapshotVersion = Integer
type Hash = BuiltinByteString
type Signature = BuiltinByteString

-- | Sub-type for the open state-machine state.
data OpenDatum
OpenDatum :: CurrencySymbol -> [Party] -> ContestationPeriod -> SnapshotVersion -> Hash -> OpenDatum

-- | Spec: cid
[$sel:headId:OpenDatum] :: OpenDatum -> CurrencySymbol

-- | Spec: kH
[$sel:parties:OpenDatum] :: OpenDatum -> [Party]

-- | Spec: T
[$sel:contestationPeriod:OpenDatum] :: OpenDatum -> ContestationPeriod

-- | Spec: v
[$sel:version:OpenDatum] :: OpenDatum -> SnapshotVersion

-- | Spec: η
[$sel:utxoHash:OpenDatum] :: OpenDatum -> Hash

-- | Sub-type for the closed state-machine state.
data ClosedDatum
ClosedDatum :: CurrencySymbol -> [Party] -> ContestationPeriod -> SnapshotVersion -> SnapshotNumber -> Hash -> Hash -> Hash -> [PubKeyHash] -> POSIXTime -> ClosedDatum

-- | Spec: cid
[$sel:headId:ClosedDatum] :: ClosedDatum -> CurrencySymbol

-- | Spec: kH
[$sel:parties:ClosedDatum] :: ClosedDatum -> [Party]

-- | Spec: T
[$sel:contestationPeriod:ClosedDatum] :: ClosedDatum -> ContestationPeriod

-- | Spec: v
[$sel:version:ClosedDatum] :: ClosedDatum -> SnapshotVersion

-- | Spec: s
[$sel:snapshotNumber:ClosedDatum] :: ClosedDatum -> SnapshotNumber

-- | Spec: η. Digest of snapshotted UTxO
[$sel:utxoHash:ClosedDatum] :: ClosedDatum -> Hash
[$sel:alphaUTxOHash:ClosedDatum] :: ClosedDatum -> Hash

-- | Spec: ηΔ. Digest of UTxO still to be distributed
[$sel:omegaUTxOHash:ClosedDatum] :: ClosedDatum -> Hash

-- | Spec: C
[$sel:contesters:ClosedDatum] :: ClosedDatum -> [PubKeyHash]

-- | Spec: tfinal
[$sel:contestationDeadline:ClosedDatum] :: ClosedDatum -> POSIXTime
data State
Initial :: ContestationPeriod -> [Party] -> CurrencySymbol -> TxOutRef -> State
[$sel:contestationPeriod:Initial] :: State -> ContestationPeriod
[$sel:parties:Initial] :: State -> [Party]
[$sel:headId:Initial] :: State -> CurrencySymbol
[$sel:seed:Initial] :: State -> TxOutRef
Open :: OpenDatum -> State
Closed :: ClosedDatum -> State
Final :: State

-- | Sub-type for close transition with auxiliary data as needed.
data CloseRedeemer

-- | Initial snapshot is used to close.
CloseInitial :: CloseRedeemer

-- | Any snapshot which doesn't contain anything to inc/decrement but
--   snapshot number is higher than zero.
CloseAny :: [Signature] -> CloseRedeemer

-- | Multi-signature of a snapshot ξ
[$sel:signature:CloseInitial] :: CloseRedeemer -> [Signature]

-- | Closing snapshot refers to the current state version
CloseUnusedDec :: [Signature] -> CloseRedeemer

-- | Multi-signature of a snapshot ξ
[$sel:signature:CloseInitial] :: CloseRedeemer -> [Signature]

-- | Closing snapshot refers to the previous state version
CloseUsedDec :: [Signature] -> Hash -> CloseRedeemer

-- | Multi-signature of a snapshot ξ
[$sel:signature:CloseInitial] :: CloseRedeemer -> [Signature]

-- | UTxO which was already decommitted ηω
[$sel:alreadyDecommittedUTxOHash:CloseInitial] :: CloseRedeemer -> Hash

-- | Closing snapshot refers to the current state version
CloseUnusedInc :: [Signature] -> Hash -> CloseRedeemer

-- | Multi-signature of a snapshot ξ
[$sel:signature:CloseInitial] :: CloseRedeemer -> [Signature]

-- | UTxO which was signed but not committed ηα
[$sel:alreadyCommittedUTxOHash:CloseInitial] :: CloseRedeemer -> Hash

-- | Closing snapshot refers to the previous state version
CloseUsedInc :: [Signature] -> Hash -> CloseRedeemer

-- | Multi-signature of a snapshot ξ
[$sel:signature:CloseInitial] :: CloseRedeemer -> [Signature]

-- | UTxO which was signed but not committed ηα
[$sel:alreadyCommittedUTxOHash:CloseInitial] :: CloseRedeemer -> Hash

-- | Sub-type for contest transition with auxiliary data as needed.
data ContestRedeemer

-- | Contesting snapshot refers to the current state version
ContestCurrent :: [Signature] -> ContestRedeemer

-- | Multi-signature of a snapshot ξ
[$sel:signature:ContestCurrent] :: ContestRedeemer -> [Signature]

-- | Contesting snapshot refers to the previous state version
ContestUsedDec :: [Signature] -> Hash -> ContestRedeemer

-- | Multi-signature of a snapshot ξ
[$sel:signature:ContestCurrent] :: ContestRedeemer -> [Signature]

-- | UTxO which was already decommitted ηω
[$sel:alreadyDecommittedUTxOHash:ContestCurrent] :: ContestRedeemer -> Hash

-- | Redeemer to use when the decommit was not yet observed but we closed
--   the Head.
ContestUnusedDec :: [Signature] -> ContestRedeemer

-- | Multi-signature of a snapshot ξ
[$sel:signature:ContestCurrent] :: ContestRedeemer -> [Signature]

-- | Redeemer to use when the commit was not yet observed but we closed the
--   Head.
ContestUnusedInc :: [Signature] -> Hash -> ContestRedeemer

-- | Multi-signature of a snapshot ξ
[$sel:signature:ContestCurrent] :: ContestRedeemer -> [Signature]

-- | UTxO which was already committed ηα
[$sel:alreadyCommittedUTxOHash:ContestCurrent] :: ContestRedeemer -> Hash
ContestUsedInc :: [Signature] -> ContestRedeemer

-- | Multi-signature of a snapshot ξ
[$sel:signature:ContestCurrent] :: ContestRedeemer -> [Signature]

-- | Sub-type for increment transition
data IncrementRedeemer
IncrementRedeemer :: [Signature] -> SnapshotNumber -> TxOutRef -> IncrementRedeemer
[$sel:signature:IncrementRedeemer] :: IncrementRedeemer -> [Signature]
[$sel:snapshotNumber:IncrementRedeemer] :: IncrementRedeemer -> SnapshotNumber
[$sel:increment:IncrementRedeemer] :: IncrementRedeemer -> TxOutRef

-- | Sub-type for decrement transition with auxiliary data as needed.
data DecrementRedeemer
DecrementRedeemer :: [Signature] -> SnapshotNumber -> Integer -> DecrementRedeemer

-- | Spec: ξ
[$sel:signature:DecrementRedeemer] :: DecrementRedeemer -> [Signature]

-- | Spec: s
[$sel:snapshotNumber:DecrementRedeemer] :: DecrementRedeemer -> SnapshotNumber

-- | Spec: m
[$sel:numberOfDecommitOutputs:DecrementRedeemer] :: DecrementRedeemer -> Integer
data Input
CollectCom :: Input
Increment :: IncrementRedeemer -> Input
Decrement :: DecrementRedeemer -> Input
Close :: CloseRedeemer -> Input
Contest :: ContestRedeemer -> Input
Abort :: Input
Fanout :: Integer -> Integer -> Integer -> Input
[$sel:numberOfFanoutOutputs:CollectCom] :: Input -> Integer
[$sel:numberOfCommitOutputs:CollectCom] :: Input -> Integer
[$sel:numberOfDecommitOutputs:CollectCom] :: Input -> Integer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.HeadState.Input
instance PlutusTx.IsData.Class.FromData Hydra.Contract.HeadState.Input
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.HeadState.Input
instance GHC.Show.Show Hydra.Contract.HeadState.Input
instance GHC.Generics.Generic Hydra.Contract.HeadState.Input
instance PlutusTx.IsData.Class.ToData Hydra.Contract.HeadState.DecrementRedeemer
instance PlutusTx.IsData.Class.FromData Hydra.Contract.HeadState.DecrementRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.HeadState.DecrementRedeemer
instance GHC.Generics.Generic Hydra.Contract.HeadState.DecrementRedeemer
instance GHC.Show.Show Hydra.Contract.HeadState.DecrementRedeemer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.HeadState.IncrementRedeemer
instance PlutusTx.IsData.Class.FromData Hydra.Contract.HeadState.IncrementRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.HeadState.IncrementRedeemer
instance GHC.Generics.Generic Hydra.Contract.HeadState.IncrementRedeemer
instance GHC.Show.Show Hydra.Contract.HeadState.IncrementRedeemer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.HeadState.ContestRedeemer
instance PlutusTx.IsData.Class.FromData Hydra.Contract.HeadState.ContestRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.HeadState.ContestRedeemer
instance GHC.Generics.Generic Hydra.Contract.HeadState.ContestRedeemer
instance GHC.Show.Show Hydra.Contract.HeadState.ContestRedeemer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.HeadState.CloseRedeemer
instance PlutusTx.IsData.Class.FromData Hydra.Contract.HeadState.CloseRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.HeadState.CloseRedeemer
instance GHC.Generics.Generic Hydra.Contract.HeadState.CloseRedeemer
instance GHC.Show.Show Hydra.Contract.HeadState.CloseRedeemer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.HeadState.State
instance PlutusTx.IsData.Class.FromData Hydra.Contract.HeadState.State
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.HeadState.State
instance GHC.Show.Show Hydra.Contract.HeadState.State
instance GHC.Generics.Generic Hydra.Contract.HeadState.State
instance PlutusTx.IsData.Class.ToData Hydra.Contract.HeadState.ClosedDatum
instance PlutusTx.IsData.Class.FromData Hydra.Contract.HeadState.ClosedDatum
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.HeadState.ClosedDatum
instance GHC.Show.Show Hydra.Contract.HeadState.ClosedDatum
instance GHC.Generics.Generic Hydra.Contract.HeadState.ClosedDatum
instance PlutusTx.IsData.Class.ToData Hydra.Contract.HeadState.OpenDatum
instance PlutusTx.IsData.Class.FromData Hydra.Contract.HeadState.OpenDatum
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.HeadState.OpenDatum
instance GHC.Show.Show Hydra.Contract.HeadState.OpenDatum
instance GHC.Generics.Generic Hydra.Contract.HeadState.OpenDatum


-- | Datum and redeemer types, as well as helper functions for the commit
--   validator implemented in aiken.
module Hydra.Contract.Commit

-- | A data type representing committed outputs on-chain. Besides recording
--   the original <a>TxOutRef</a>, it also stores a binary representation
--   compatible between on- and off-chain code to be hashed in the
--   validators.
data Commit
Commit :: TxOutRef -> BuiltinByteString -> Commit
[input] :: Commit -> TxOutRef
[preSerializedOutput] :: Commit -> BuiltinByteString

-- | Record an off-chain <tt>TxOut</tt> as a <a>Commit</a> on-chain. NOTE:
--   Depends on the <tt>Serialise</tt> instance for Plutus' <tt>Data</tt>.
serializeCommit :: (TxIn, TxOut CtxUTxO) -> Maybe Commit

-- | Decode an on-chain <tt>SerializedTxOut</tt> back into an off-chain
--   <tt>TxOut</tt>. NOTE: Depends on the <tt>Serialise</tt> instance for
--   Plutus' <tt>Data</tt>.
deserializeCommit :: Network -> Commit -> Maybe (TxIn, TxOut CtxUTxO)
type DatumType = (Party, [Commit], CurrencySymbol)
data CommitRedeemer
ViaCollectCom :: CommitRedeemer
ViaAbort :: CommitRedeemer
type RedeemerType = CommitRedeemer
datum :: DatumType -> Datum
redeemer :: RedeemerType -> Redeemer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.Commit.CommitRedeemer
instance PlutusTx.IsData.Class.FromData Hydra.Contract.Commit.CommitRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.Commit.CommitRedeemer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.Commit.Commit
instance PlutusTx.IsData.Class.FromData Hydra.Contract.Commit.Commit
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.Commit.Commit
instance GHC.Classes.Ord Hydra.Contract.Commit.Commit
instance GHC.Show.Show Hydra.Contract.Commit.Commit
instance GHC.Classes.Eq Hydra.Contract.Commit.Commit
instance PlutusTx.Eq.Eq Hydra.Contract.Commit.Commit

module Hydra.Contract.Util
hydraHeadV1 :: BuiltinByteString

-- | Checks that the output contains the state token (ST) with the head
--   <a>CurrencySymbol</a> and <a>TokenName</a> of <a>hydraHeadV1</a>
hasST :: CurrencySymbol -> Value -> Bool

-- | Checks all tokens related to some specific <a>CurrencySymbol</a>.
--   
--   This checks both PTs and ST are burnt.
mustBurnAllHeadTokens :: MintValue -> CurrencySymbol -> [Party] -> Bool
mustNotMintOrBurn :: TxInfo -> Bool

-- | Hash a potentially unordered list of commits by sorting them,
--   concatenating their <a>preSerializedOutput</a> bytes and creating a
--   SHA2_256 digest over that.
--   
--   NOTE: See note from <a>hashTxOuts</a>.
hashPreSerializedCommits :: [Commit] -> BuiltinByteString

-- | Hash a pre-ordered list of transaction outputs by serializing each
--   individual <a>TxOut</a>, concatenating all bytes together and creating
--   a SHA2_256 digest over that.
--   
--   NOTE: In general, from asserting that `hash(x || y) = hash (x' || y')`
--   it is not safe to conclude that `(x,y) = (x', y')` as the same hash
--   could be obtained by moving one or more bytes from the end of
--   <tt>x</tt> to the beginning of <tt>y</tt>, but in the context of Hydra
--   validators it seems impossible to exploit this property without
--   breaking other logic or verification (eg. producing a valid and
--   meaningful <a>TxOut</a>).
hashTxOuts :: [TxOut] -> BuiltinByteString
compareRef :: TxOutRef -> TxOutRef -> Ordering
data UtilError
MintingOrBurningIsForbidden :: UtilError

-- | Get the list of <a>TxOut</a> outputs of the pending transaction at a
--   given script address.
scriptOutputsAt :: ScriptHash -> TxInfo -> [(OutputDatum, Value)]
instance GHC.Show.Show Hydra.Contract.Util.UtilError
instance Hydra.Contract.Error.ToErrorCode Hydra.Contract.Util.UtilError


-- | The validator used to deposit and recover locked funds
module Hydra.Contract.Deposit
data DepositRedeemer

-- | Claims already deposited funds.
Claim :: CurrencySymbol -> DepositRedeemer

-- | Recovers m number of deposited outputs.
Recover :: Integer -> DepositRedeemer

-- | Deposit datum containing HeadId, deadline and a list of deposits.
type DepositDatum = (CurrencySymbol, POSIXTime, [Commit])
datum :: DepositDatum -> Datum
redeemer :: DepositRedeemer -> Redeemer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.Deposit.DepositRedeemer
instance PlutusTx.IsData.Class.FromData Hydra.Contract.Deposit.DepositRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.Deposit.DepositRedeemer

module Hydra.Contract.Head
type DatumType = State
type RedeemerType = Input
headValidator :: State -> Input -> ScriptContext -> Bool

-- | On-Chain verification for <a>Abort</a> transition. It verifies that:
--   
--   <ul>
--   <li>All PTs have been burnt: The right number of Head tokens with the
--   correct head id are burnt, one PT for each party and a state token
--   ST.</li>
--   <li>All committed funds have been redistributed. This is done via
--   v_commit and it only needs to ensure that we have spent all committed
--   outputs, which follows from burning all the PTs.</li>
--   </ul>
checkAbort :: ScriptContext -> CurrencySymbol -> [Party] -> Bool

-- | On-Chain verification for <a>CollectCom</a> transition. It verifies
--   that:
--   
--   <ul>
--   <li>All participants have committed (even empty commits)</li>
--   <li>All commits are properly collected and locked into η as a hash of
--   serialized tx outputs in the same sequence as commit inputs!</li>
--   <li>The transaction is performed (i.e. signed) by one of the head
--   participants</li>
--   <li>State token (ST) is present in the output</li>
--   </ul>
checkCollectCom :: ScriptContext -> (ContestationPeriod, [Party], CurrencySymbol) -> Bool

-- | Try to find the commit datum in the input and if it is there return
--   the committed utxo
commitDatum :: TxOut -> [Commit]

-- | Try to find the deposit datum in the input and if it is there return
--   the committed utxo
depositDatum :: TxOut -> [Commit]

-- | Verify a increment transaction.
checkIncrement :: ScriptContext -> OpenDatum -> IncrementRedeemer -> Bool

-- | Verify a decrement transaction.
checkDecrement :: ScriptContext -> OpenDatum -> DecrementRedeemer -> Bool

-- | Verify a close transaction.
checkClose :: ScriptContext -> OpenDatum -> CloseRedeemer -> Bool

-- | Verify a contest transaction.
checkContest :: ScriptContext -> ClosedDatum -> ContestRedeemer -> Bool

-- | Verify a fanout transaction.
checkFanout :: ScriptContext -> ClosedDatum -> Integer -> Integer -> Integer -> Bool
makeContestationDeadline :: ContestationPeriod -> ScriptContext -> POSIXTime

-- | This is safe only because usually Head transaction only consume one
--   input.
getHeadInput :: ScriptContext -> TxInInfo
getHeadAddress :: ScriptContext -> Address
mustNotChangeParameters :: ([Party], [Party]) -> (ContestationPeriod, ContestationPeriod) -> (CurrencySymbol, CurrencySymbol) -> Bool
mustBeSignedByParticipant :: ScriptContext -> CurrencySymbol -> Bool
findParticipationTokens :: CurrencySymbol -> Value -> [TokenName]
headOutputDatum :: ScriptContext -> Datum
getTxOutDatum :: TxOut -> Datum

-- | Check if <a>TxOut</a> contains the PT token.
hasPT :: CurrencySymbol -> TxOut -> Bool

-- | Verify the multi-signature of a snapshot using given constituents
--   <a>State</a>, <a>ClosedDatum</a>, <tt>number</tt>, <a>ClosedDatum</a>
--   and <tt>utxoToDecommitHash</tt>. See 'SignableRepresentation Snapshot'
--   for more details.
verifySnapshotSignature :: [Party] -> (CurrencySymbol, SnapshotVersion, SnapshotNumber, Hash, Hash, Hash) -> [Signature] -> Bool

-- | Verify individual party signature of a snapshot. See
--   'SignableRepresentation Snapshot' for more details.
verifyPartySignature :: (CurrencySymbol, SnapshotVersion, SnapshotNumber, Hash, Hash, Hash) -> Party -> Signature -> Bool
compiledValidator :: CompiledCode ValidatorType
validatorScript :: PlutusScript
decodeHeadOutputClosedDatum :: ScriptContext -> ClosedDatum
decodeHeadOutputOpenDatum :: ScriptContext -> OpenDatum
emptyHash :: Hash


-- | Module to load and provide the Hydra scripts.
--   
--   The plutus blueprint in 'plutus.json' is embedded in the binary and
--   serves as the ground truth for validator scripts and hashes.
--   
--   NOTE: All scripts are PlutusV3 scripts (defined by the
--   <a>PlutusScript</a> synonym pattern).
--   
--   XXX: We are using a hardcoded indices to access validators in
--   plutus.json. This is fragile and depends on the validator names not
--   changing.
module Hydra.Plutus

-- | Loads the embedded "plutus.json" blueprint and provides the decoded
--   JSON.
blueprintJSON :: Value

-- | Get the commit validator by decoding it from <a>blueprintJSON</a>.
commitValidatorScript :: PlutusScript

-- | Get the initial validator by decoding the parameterized initial
--   validator from the <a>blueprintJSON</a> and applying the
--   <tt>commitValidatorScriptHash</tt> to it.
initialValidatorScript :: PlutusScript

-- | Get the deposit validator by decoding it from <a>blueprintJSON</a>.
depositValidatorScript :: PlutusScript


-- | Minting policy for a single head tokens.
module Hydra.Contract.HeadTokens
validate :: ScriptHash -> ScriptHash -> TxOutRef -> MintAction -> ScriptContext -> Bool

-- | When minting head tokens we want to make sure that:
--   
--   <ul>
--   <li>The number of minted PTs == number of participants (+1 for the ST)
--   evident from the datum.</li>
--   <li>There is single state token that is paid into v_head, which
--   ensures continuity.</li>
--   <li>PTs are distributed to v_initial</li>
--   <li>Each v_initial has the policy id as its datum</li>
--   <li>Ensure out-ref and the headId are in the datum of the first output
--   of the transaction which mints tokens.</li>
--   </ul>
validateTokensMinting :: ScriptHash -> ScriptHash -> TxOutRef -> ScriptContext -> Bool

-- | Token burning check should: * Not restrict burning on the mu_head at
--   all.
--   
--   It is ensured by the v_head validator, when tokens of a specific
--   headId may be burned.
--   
--   <a>validateTokensBurning</a> just makes sure all tokens have negative
--   quantity.
validateTokensBurning :: ScriptContext -> Bool

-- | Raw minting policy code where the <a>TxOutRef</a> is still a
--   parameter.
unappliedMintingPolicy :: CompiledCode (TxOutRef -> MintingPolicyType)

-- | Get the applied head minting policy script given a seed
--   <a>TxOutRef</a>.
mintingPolicyScript :: TxOutRef -> PlutusScript

-- | Get the head policy id (a.k.a headId) given a seed <a>TxIn</a>.
headPolicyId :: TxIn -> PolicyId

-- | Get the applied head minting policy script given a seed <a>TxIn</a>.
mkHeadTokenScript :: TxIn -> PlutusScript


-- | Things related to the Hydra smart contracts / script validators.
module Hydra.Contract

-- | Information about relevant Hydra scripts.
data HydraScriptCatalogue
HydraScriptCatalogue :: ScriptHash -> Int -> ScriptHash -> Int -> ScriptHash -> Int -> ScriptHash -> Int -> ScriptHash -> Int -> HydraScriptCatalogue

-- | Hash of the μHead minting script given some default parameters.
[mintingScriptHash] :: HydraScriptCatalogue -> ScriptHash

-- | Size of the μHead minting script given some default parameters.
[mintingScriptSize] :: HydraScriptCatalogue -> Int
[initialScriptHash] :: HydraScriptCatalogue -> ScriptHash
[initialScriptSize] :: HydraScriptCatalogue -> Int
[commitScriptHash] :: HydraScriptCatalogue -> ScriptHash
[commitScriptSize] :: HydraScriptCatalogue -> Int
[headScriptHash] :: HydraScriptCatalogue -> ScriptHash
[headScriptSize] :: HydraScriptCatalogue -> Int
[depositScriptHash] :: HydraScriptCatalogue -> ScriptHash
[depositScriptSize] :: HydraScriptCatalogue -> Int

-- | Gather <a>HydraScriptCatalogue</a> from the current Hydra scripts.
--   This is useful to determine changes in between version of
--   'hydra-plutus'.
hydraScriptCatalogue :: HydraScriptCatalogue
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Contract.HydraScriptCatalogue
instance GHC.Generics.Generic Hydra.Contract.HydraScriptCatalogue
instance GHC.Show.Show Hydra.Contract.HydraScriptCatalogue
instance GHC.Classes.Eq Hydra.Contract.HydraScriptCatalogue
