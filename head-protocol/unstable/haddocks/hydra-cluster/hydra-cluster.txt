-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Integration test suite using a local cluster of cardano and hydra
--   nodes
@package hydra-cluster
@version 1.2.0


-- | A cardano-node client used in end-to-end tests and benchmarks.
--   
--   This modules contains some more functions besides the re-exported
--   basic querying of hydra-node's <a>CardanoClient</a>.
module CardanoClient
instance GHC.Classes.Eq CardanoClient.RunningNode
instance GHC.Show.Show CardanoClient.RunningNode


-- | Example values and utilities used across hydra-cluster tests and
--   benchmarks.
module Hydra.Cluster.Fixture
alice :: Party
bob :: Party
carol :: Party
aliceSk :: SigningKey HydraKey
bobSk :: SigningKey HydraKey
carolSk :: SigningKey HydraKey
aliceVk :: VerificationKey HydraKey
bobVk :: VerificationKey HydraKey
carolVk :: VerificationKey HydraKey
cperiod :: ContestationPeriod
blockfrostcperiod :: ContestationPeriod
availableInitialFunds :: Num a => a

-- | Enumeration of known actors for which we can get the <tt>keysFor</tt>
--   and <tt>writeKeysFor</tt>.
data Actor
Alice :: Actor
AliceFunds :: Actor
Bob :: Actor
BobFunds :: Actor
Carol :: Actor
CarolFunds :: Actor
Faucet :: Actor
actorName :: Actor -> String
fundsOf :: Actor -> Actor

-- | A network known to the hydra-cluster. That means we have configuration
--   files to connect to at least these networks.
data KnownNetwork
Preview :: KnownNetwork
Preproduction :: KnownNetwork
Mainnet :: KnownNetwork
BlockfrostPreview :: KnownNetwork
BlockfrostPreprod :: KnownNetwork
BlockfrostMainnet :: KnownNetwork
toNetworkId :: KnownNetwork -> NetworkId
instance GHC.Show.Show Hydra.Cluster.Fixture.Actor
instance GHC.Classes.Eq Hydra.Cluster.Fixture.Actor
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Cluster.Fixture.KnownNetwork
instance GHC.Enum.Bounded Hydra.Cluster.Fixture.KnownNetwork
instance GHC.Enum.Enum Hydra.Cluster.Fixture.KnownNetwork
instance GHC.Classes.Eq Hydra.Cluster.Fixture.KnownNetwork
instance GHC.Show.Show Hydra.Cluster.Fixture.KnownNetwork
instance GHC.Generics.Generic Hydra.Cluster.Fixture.KnownNetwork


-- | Mithril client to bootstrap cardano nodes in the hydra-cluster.
module Hydra.Cluster.Mithril
data MithrilLog
StartSnapshotDownload :: KnownNetwork -> FilePath -> MithrilLog
[network] :: MithrilLog -> KnownNetwork
[directory] :: MithrilLog -> FilePath

-- | Output captured directly from mithril-client stderr.
StdErr :: Value -> MithrilLog
[output] :: MithrilLog -> Value

-- | Downloads and unpacks latest snapshot for given network in db/ of
--   given directory.
downloadLatestSnapshotTo :: Tracer IO MithrilLog -> KnownNetwork -> FilePath -> IO ()
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Cluster.Mithril.MithrilLog
instance GHC.Generics.Generic Hydra.Cluster.Mithril.MithrilLog
instance GHC.Show.Show Hydra.Cluster.Mithril.MithrilLog
instance GHC.Classes.Eq Hydra.Cluster.Mithril.MithrilLog

module Hydra.Cluster.Options
data Options
Options :: Maybe KnownNetwork -> Maybe FilePath -> PublishOrReuse -> UseMithril -> Scenario -> Maybe (Positive Natural) -> Options
[knownNetwork] :: Options -> Maybe KnownNetwork
[stateDirectory] :: Options -> Maybe FilePath
[publishHydraScripts] :: Options -> PublishOrReuse
[useMithril] :: Options -> UseMithril
[scenario] :: Options -> Scenario
[persistenceRotateAfter] :: Options -> Maybe (Positive Natural)
data PublishOrReuse
Publish :: PublishOrReuse
Reuse :: [TxId] -> PublishOrReuse
data UseMithril
NotUseMithril :: UseMithril
UseMithril :: UseMithril
data Scenario
Idle :: Scenario
RespendUTxO :: Scenario
parseOptions :: Parser Options
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Cluster.Options.PublishOrReuse
instance GHC.Generics.Generic Hydra.Cluster.Options.PublishOrReuse
instance GHC.Classes.Eq Hydra.Cluster.Options.PublishOrReuse
instance GHC.Show.Show Hydra.Cluster.Options.PublishOrReuse
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Cluster.Options.UseMithril
instance GHC.Generics.Generic Hydra.Cluster.Options.UseMithril
instance GHC.Classes.Eq Hydra.Cluster.Options.UseMithril
instance GHC.Show.Show Hydra.Cluster.Options.UseMithril
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Cluster.Options.Scenario
instance GHC.Generics.Generic Hydra.Cluster.Options.Scenario
instance GHC.Classes.Eq Hydra.Cluster.Options.Scenario
instance GHC.Show.Show Hydra.Cluster.Options.Scenario
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Cluster.Options.Options
instance GHC.Generics.Generic Hydra.Cluster.Options.Options
instance GHC.Classes.Eq Hydra.Cluster.Options.Options
instance GHC.Show.Show Hydra.Cluster.Options.Options

module Paths_hydra_cluster
version :: Version
getBinDir :: IO FilePath
getLibDir :: IO FilePath
getDynLibDir :: IO FilePath
getDataDir :: IO FilePath
getLibexecDir :: IO FilePath
getDataFileName :: FilePath -> IO FilePath
getSysconfDir :: IO FilePath


-- | Utilities used across hydra-cluster
module Hydra.Cluster.Util

-- | Lookup a config file similar reading a file from disk. If the env
--   variable <tt>HYDRA_CONFIG_DIR</tt> is set, filenames will be resolved
--   relative to its value otherwise they will be looked up in the
--   package's data path.
readConfigFile :: FilePath -> IO ByteString

-- | Get the "well-known" keys for given actor.
keysFor :: Actor -> IO (VerificationKey PaymentKey, SigningKey PaymentKey)

-- | Create and save new signing key at the provided path. NOTE: Uses
--   <tt>TextEnvelope</tt> format.
createAndSaveSigningKey :: FilePath -> IO (SigningKey PaymentKey)
chainConfigFor :: ChainBackend backend => HasCallStack => Actor -> FilePath -> backend -> [TxId] -> [Actor] -> ContestationPeriod -> IO ChainConfig
chainConfigFor' :: ChainBackend backend => HasCallStack => Actor -> FilePath -> backend -> [TxId] -> [Actor] -> ContestationPeriod -> DepositPeriod -> IO ChainConfig
modifyConfig :: (CardanoChainConfig -> CardanoChainConfig) -> ChainConfig -> ChainConfig
setNetworkId :: NetworkId -> ChainConfig -> ChainConfig

module Hydra.Cluster.Faucet
data FaucetException
FaucetHasNotEnoughFunds :: UTxO -> FaucetException
[$sel:faucetUTxO:FaucetHasNotEnoughFunds] :: FaucetException -> UTxO
FaucetFailedToBuildTx :: TxBodyErrorAutoBalance Era -> FaucetException
[$sel:reason:FaucetHasNotEnoughFunds] :: FaucetException -> TxBodyErrorAutoBalance Era
FaucetBlockfrostError :: Text -> FaucetException
[$sel:blockFrostError:FaucetHasNotEnoughFunds] :: FaucetException -> Text
data FaucetLog
TraceResourceExhaustedHandled :: Text -> FaucetLog
ReturnedFunds :: Coin -> FaucetLog
[$sel:returnAmount:TraceResourceExhaustedHandled] :: FaucetLog -> Coin
delayBF :: (MonadDelay m, ChainBackend backend) => backend -> m ()
seedFromFaucet :: ChainBackend backend => backend -> VerificationKey PaymentKey -> Value -> Tracer IO FaucetLog -> IO UTxO

-- | Create a specially marked "seed" UTXO containing requested
--   <a>Value</a> by redeeming funds available to the well-known faucet.
seedFromFaucetWithMinting :: ChainBackend backend => backend -> VerificationKey PaymentKey -> Value -> Tracer IO FaucetLog -> Maybe PlutusScript -> IO UTxO
findFaucetUTxO :: ChainBackend backend => NetworkId -> backend -> Coin -> IO UTxO
seedFromFaucetBlockfrost :: BlockfrostOptions -> VerificationKey PaymentKey -> Coin -> BlockfrostClientT IO UTxO

-- | Like <a>seedFromFaucet</a>, but without returning the seeded
--   <a>UTxO</a>.
seedFromFaucet_ :: ChainBackend backend => backend -> VerificationKey PaymentKey -> Coin -> Tracer IO FaucetLog -> IO ()

-- | Return the remaining funds to the faucet
returnFundsToFaucet :: ChainBackend backend => Tracer IO FaucetLog -> backend -> Actor -> IO ()
returnFundsToFaucet' :: ChainBackend backend => Tracer IO FaucetLog -> backend -> SigningKey PaymentKey -> IO Coin
createOutputAtAddress :: ChainBackend backend => NetworkId -> backend -> AddressInEra -> TxOutDatum CtxTx -> Value -> IO (TxIn, TxOut CtxUTxO)

-- | Try to submit tx and retry when some caught exception/s take place.
retryOnExceptions :: (MonadCatch m, MonadDelay m, ChainBackend backend) => Tracer m FaucetLog -> backend -> m a -> m a

-- | Publish current Hydra scripts as scripts outputs for later referencing
--   them.
--   
--   The key of the given Actor is used to pay for fees in required
--   transactions, it is expected to have sufficient funds.
publishHydraScriptsAs :: ChainBackend backend => backend -> Actor -> IO [TxId]
instance GHC.Show.Show Hydra.Cluster.Faucet.FaucetException
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Cluster.Faucet.FaucetLog
instance GHC.Generics.Generic Hydra.Cluster.Faucet.FaucetLog
instance GHC.Show.Show Hydra.Cluster.Faucet.FaucetLog
instance GHC.Classes.Eq Hydra.Cluster.Faucet.FaucetLog
instance GHC.Exception.Type.Exception Hydra.Cluster.Faucet.FaucetException

module Hydra.Generator
networkId :: NetworkId

-- | A <a>Dataset</a> that can be run for testing purpose. Each
--   <a>Dataset</a> represents a complete scenario where several
--   <a>ClientDataset</a> are run concurrently against one or more
--   <tt>HydraNode</tt>s. A dataset can optionally have a <a>title</a> and
--   <a>description</a> which will be used to report results.
data Dataset
Dataset :: Tx -> [SigningKey PaymentKey] -> [ClientDataset] -> Maybe Text -> Maybe Text -> Dataset
[fundingTransaction] :: Dataset -> Tx

-- | Cardano signing keys that will hold fuel.
[hydraNodeKeys] :: Dataset -> [SigningKey PaymentKey]
[clientDatasets] :: Dataset -> [ClientDataset]
[title] :: Dataset -> Maybe Text
[description] :: Dataset -> Maybe Text
data ClientDataset
ClientDataset :: SigningKey PaymentKey -> UTxO -> [Tx] -> ClientDataset
[paymentKey] :: ClientDataset -> SigningKey PaymentKey
[initialUTxO] :: ClientDataset -> UTxO
[txSequence] :: ClientDataset -> [Tx]

-- | Generate a <a>Dataset</a> which does not grow the per-client UTXO set
--   over time. This version provided faucet key owns funds on the initial
--   funds of the devnet (See <a>availableInitialFunds</a> and
--   'genesis-shelley.json'). Then for a given number of clients a number
--   of transactions are generated.
generateConstantUTxODataset :: SigningKey PaymentKey -> Int -> Int -> Gen Dataset
generateGrowingUTxODataset :: SigningKey PaymentKey -> Int -> Int -> Gen Dataset

-- | Generate a <a>Dataset</a> from an already running network by querying
--   available funds of the well-known 'faucet.sk' and assuming the
--   hydra-nodes we connect to have fuel available. Then for a given number
--   of clients a number of transactions are generated.
generateDemoUTxODataset :: NetworkId -> SocketPath -> SigningKey PaymentKey -> Int -> Int -> IO Dataset
withInitialUTxO :: SigningKey PaymentKey -> Tx -> UTxO
genClientFunds :: [SigningKey PaymentKey] -> Integer -> Gen [(VerificationKey PaymentKey, Coin)]
generateClientDataset :: NetworkId -> Tx -> Int -> SigningKey PaymentKey -> Gen ClientDataset
instance GHC.Generics.Generic Hydra.Generator.ClientDataset
instance GHC.Show.Show Hydra.Generator.ClientDataset
instance GHC.Generics.Generic Hydra.Generator.Dataset
instance GHC.Show.Show Hydra.Generator.Dataset
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Generator.Dataset
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Generator.Dataset
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Generator.Dataset
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Generator.ClientDataset
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Generator.ClientDataset

module CardanoNode
data NodeLog
MsgNodeCmdSpec :: Text -> NodeLog
[$sel:cmd:MsgNodeCmdSpec] :: NodeLog -> Text
MsgCLI :: [Text] -> NodeLog
MsgCLIStatus :: Text -> Text -> NodeLog
MsgCLIRetry :: Text -> NodeLog
MsgCLIRetryResult :: Text -> Int -> NodeLog
MsgNodeStarting :: FilePath -> NodeLog
[$sel:stateDirectory:MsgNodeCmdSpec] :: NodeLog -> FilePath
MsgSocketIsReady :: SocketPath -> NodeLog
MsgSynchronizing :: Centi -> NominalDiffTime -> NominalDiffTime -> NominalDiffTime -> NominalDiffTime -> NodeLog
[$sel:percentDone:MsgNodeCmdSpec] :: NodeLog -> Centi
[$sel:timeDifference:MsgNodeCmdSpec] :: NodeLog -> NominalDiffTime
[$sel:blockTime:MsgNodeCmdSpec] :: NodeLog -> NominalDiffTime
[$sel:tipTime:MsgNodeCmdSpec] :: NodeLog -> NominalDiffTime
[$sel:targetTime:MsgNodeCmdSpec] :: NodeLog -> NominalDiffTime
MsgQueryGenesisParametersFailed :: Text -> NodeLog
[$sel:err:MsgNodeCmdSpec] :: NodeLog -> Text
type Port = Int
newtype NodeId
NodeId :: Int -> NodeId

-- | Configuration parameters for a single node devnet
data DevnetConfig
DevnetConfig :: FilePath -> UTCTime -> PortsConfig -> DevnetConfig

-- | Parent state directory
[$sel:stateDirectory:DevnetConfig] :: DevnetConfig -> FilePath

-- | Blockchain start time
[$sel:systemStart:DevnetConfig] :: DevnetConfig -> UTCTime

-- | A list of port
[$sel:ports:DevnetConfig] :: DevnetConfig -> PortsConfig

-- | Arguments given to the 'cardano-node' command-line to run a node.
data CardanoNodeArgs
CardanoNodeArgs :: FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe Port -> CardanoNodeArgs
[$sel:nodeSocket:CardanoNodeArgs] :: CardanoNodeArgs -> FilePath
[$sel:nodeConfigFile:CardanoNodeArgs] :: CardanoNodeArgs -> FilePath
[$sel:nodeByronGenesisFile:CardanoNodeArgs] :: CardanoNodeArgs -> FilePath
[$sel:nodeShelleyGenesisFile:CardanoNodeArgs] :: CardanoNodeArgs -> FilePath
[$sel:nodeAlonzoGenesisFile:CardanoNodeArgs] :: CardanoNodeArgs -> FilePath
[$sel:nodeConwayGenesisFile:CardanoNodeArgs] :: CardanoNodeArgs -> FilePath
[$sel:nodeDijkstraGenesisFile:CardanoNodeArgs] :: CardanoNodeArgs -> FilePath
[$sel:nodeTopologyFile:CardanoNodeArgs] :: CardanoNodeArgs -> FilePath
[$sel:nodeDatabaseDir:CardanoNodeArgs] :: CardanoNodeArgs -> FilePath
[$sel:nodeDlgCertFile:CardanoNodeArgs] :: CardanoNodeArgs -> Maybe FilePath
[$sel:nodeSignKeyFile:CardanoNodeArgs] :: CardanoNodeArgs -> Maybe FilePath
[$sel:nodeOpCertFile:CardanoNodeArgs] :: CardanoNodeArgs -> Maybe FilePath
[$sel:nodeKesKeyFile:CardanoNodeArgs] :: CardanoNodeArgs -> Maybe FilePath
[$sel:nodeVrfKeyFile:CardanoNodeArgs] :: CardanoNodeArgs -> Maybe FilePath
[$sel:nodePort:CardanoNodeArgs] :: CardanoNodeArgs -> Maybe Port
defaultCardanoNodeArgs :: CardanoNodeArgs

-- | Configuration of ports from the perspective of a peer in the context
--   of a fully sockected topology.
data PortsConfig
PortsConfig :: Port -> [Port] -> PortsConfig

-- | Our node TCP port.
[$sel:ours:PortsConfig] :: PortsConfig -> Port

-- | Other peers TCP ports.
[$sel:peers:PortsConfig] :: PortsConfig -> [Port]
getCardanoNodeVersion :: IO String

-- | Tries to find an communicate with an existing cardano-node running in
--   given work directory. NOTE: This is using the default node socket name
--   as defined by <a>defaultCardanoNodeArgs</a>.
findRunningCardanoNode :: Tracer IO NodeLog -> FilePath -> KnownNetwork -> IO (Maybe (NominalDiffTime, DirectBackend))

-- | Tries to find an communicate with an existing cardano-node running in
--   given network id and socket path.
findRunningCardanoNode' :: Tracer IO NodeLog -> NetworkId -> SocketPath -> IO (Maybe (NominalDiffTime, DirectBackend))

-- | Start a single cardano-node devnet using the config from config/ and
--   credentials from config<i>credentials</i>. Only the <tt>Faucet</tt>
--   actor will receive "initialFunds". Use <tt>seedFromFaucet</tt> to
--   distribute funds other wallets.
withCardanoNodeDevnet :: Tracer IO NodeLog -> FilePath -> (NominalDiffTime -> DirectBackend -> IO a) -> IO a
withBlockfrostBackend :: Tracer IO NodeLog -> FilePath -> (NominalDiffTime -> BlockfrostBackend -> IO a) -> IO a

-- | Find the given file in the current directory or its parents.
--   
--   This function starts from the current working directory and checks if
--   the specified file exists there. If not found, it recursively checks
--   the parent directories up to the given maximum depth.
findFileStartingAtDirectory :: Int -> FilePath -> IO FilePath
withBackend :: forall a. Tracer IO NodeLog -> FilePath -> (forall backend. ChainBackend backend => NominalDiffTime -> backend -> IO a) -> IO a

-- | Run a cardano-node as normal network participant on a known network.
withCardanoNodeOnKnownNetwork :: Tracer IO NodeLog -> FilePath -> KnownNetwork -> (NominalDiffTime -> DirectBackend -> IO a) -> IO a

-- | Setup the cardano-node to run a local devnet producing blocks. This
--   copies the appropriate files and prepares <a>CardanoNodeArgs</a> for
--   <a>withCardanoNode</a>.
setupCardanoDevnet :: FilePath -> IO CardanoNodeArgs
withCardanoNode :: Tracer IO NodeLog -> FilePath -> CardanoNodeArgs -> (NominalDiffTime -> DirectBackend -> IO a) -> IO a
getShelleyGenesisBlockTime :: Value -> NominalDiffTime

-- | Compute the block time (expected time between blocks) given a slot
--   length as diff time and active slot coefficient.
computeBlockTime :: NominalDiffTime -> Rational -> NominalDiffTime

-- | Wait until the node is fully caught up with the network. This can take
--   a while!
waitForFullySynchronized :: ChainBackend backend => Tracer IO NodeLog -> backend -> IO ()

-- | Wait for the node socket file to become available.
waitForSocket :: SocketPath -> IO ()

-- | Generate command-line arguments for launching <tt>cardano-node</tt>.
cardanoNodeProcess :: Maybe FilePath -> CardanoNodeArgs -> CreateProcess

-- | Initialize the system start time to now (modulo a small offset needed
--   to give time to the system to bootstrap correctly).
initSystemStart :: IO UTCTime

-- | Re-generate configuration and genesis files with fresh system start
--   times.
refreshSystemStart :: FilePath -> CardanoNodeArgs -> IO ()

-- | Generate a topology file from a list of peers.
mkTopology :: [Port] -> Value
data ProcessHasExited
ProcessHasExited :: Text -> ExitCode -> ProcessHasExited

-- | Cardano-cli wrapper to query protocol parameters. While we have also
--   client functions in Hydra.Chain.CardanoClient and
--   Hydra.Cluster.CardanoClient, sometimes we deliberately want to use the
--   cardano-cli to ensure compatibility.
cliQueryProtocolParameters :: SocketPath -> NetworkId -> IO Value
unsafeDecodeJson :: FromJSON a => ByteString -> IO a
unsafeDecodeJsonFile :: FromJSON a => FilePath -> IO a
instance Data.Aeson.Types.ToJSON.ToJSON CardanoNode.NodeLog
instance GHC.Generics.Generic CardanoNode.NodeLog
instance GHC.Show.Show CardanoNode.NodeLog
instance GHC.Classes.Eq CardanoNode.NodeLog
instance GHC.Num.Num CardanoNode.NodeId
instance GHC.Show.Show CardanoNode.NodeId
instance GHC.Classes.Eq CardanoNode.NodeId
instance GHC.Generics.Generic CardanoNode.PortsConfig
instance GHC.Classes.Eq CardanoNode.PortsConfig
instance GHC.Show.Show CardanoNode.PortsConfig
instance GHC.Generics.Generic CardanoNode.DevnetConfig
instance GHC.Show.Show CardanoNode.DevnetConfig
instance GHC.Classes.Eq CardanoNode.DevnetConfig
instance GHC.Show.Show CardanoNode.ProcessHasExited

module HydraNode
data HydraClient
HydraClient :: Int -> Host -> Connection -> Tracer IO HydraNodeLog -> HydraClient
[$sel:hydraNodeId:HydraClient] :: HydraClient -> Int
[$sel:apiHost:HydraClient] :: HydraClient -> Host
[$sel:connection:HydraClient] :: HydraClient -> Connection
[$sel:tracer:HydraClient] :: HydraClient -> Tracer IO HydraNodeLog

-- | Create an input as expected by <a>send</a>.
input :: Text -> [Pair] -> Value
send :: HydraClient -> Value -> IO ()
waitNext :: HasCallStack => HydraClient -> IO Value

-- | Create an output as expected by <a>waitFor</a> and <a>waitForAll</a>.
output :: Text -> [Pair] -> Value
setupBFDelay :: NominalDiffTime -> IO NominalDiffTime

-- | Wait some time for a single API server output from each of given
--   nodes. This function waits for <tt>delay</tt> seconds for message
--   <tt>expected</tt> to be seen by all given <tt>nodes</tt>.
waitFor :: HasCallStack => Tracer IO HydraNodeLog -> NominalDiffTime -> [HydraClient] -> Value -> IO ()

-- | Wait up to some time and succeed if no API server output matches the
--   given predicate.
waitNoMatch :: HasCallStack => NominalDiffTime -> HydraClient -> (Value -> Maybe a) -> IO ()

-- | Wait up to some time for an API server output to match the given
--   predicate.
waitMatch :: HasCallStack => NominalDiffTime -> HydraClient -> (Value -> Maybe a) -> IO a

-- | Wait up to some <tt>delay</tt> for some JSON <a>Value</a> to match
--   given function.
--   
--   This is a generalisation of <a>waitMatch</a> to multiple nodes.
waitForAllMatch :: (Eq a, Show a, HasCallStack) => NominalDiffTime -> [HydraClient] -> (Value -> Maybe a) -> IO a

-- | Wait some time for a list of outputs from each of given nodes. This
--   function is the generalised version of <a>waitFor</a>, allowing
--   several messages to be waited for and received in <i>any order</i>.
waitForAll :: HasCallStack => Tracer IO HydraNodeLog -> NominalDiffTime -> [HydraClient] -> [Value] -> IO ()

-- | Helper to make it easy to obtain a commit tx using some wallet utxo
requestCommitTx :: HydraClient -> UTxO -> IO Tx

-- | Submit a decommit transaction to the hydra-node.
postDecommit :: HydraClient -> Tx -> IO ()

-- | Get the protocol-parameters from the hydra-node.
getProtocolParameters :: HydraClient -> IO (PParams LedgerEra)

-- | Get the latest snapshot UTxO from the hydra-node. NOTE: While we
--   usually avoid parsing responses using the same data types as the
--   system under test, this parses the response as a <a>UTxO</a> type as
--   we often need to pick it apart.
getSnapshotUTxO :: HydraClient -> IO UTxO

-- | Get the latest snapshot from the hydra-node. NOTE: While we usually
--   avoid parsing responses using the same data types as the system under
--   test, this parses the response as a <a>ConfirmedSnapshot</a> type as
--   we often need to pick it apart.
getSnapshotConfirmed :: HydraClient -> IO (ConfirmedSnapshot Tx)

-- | Get the latest seen snapshot from the hydra-node.
getSnapshotLastSeen :: HydraClient -> IO (SeenSnapshot Tx)
getMetrics :: HasCallStack => HydraClient -> IO ByteString
withHydraCluster :: HasCallStack => Tracer IO HydraNodeLog -> NominalDiffTime -> FilePath -> SocketPath -> Int -> [(VerificationKey PaymentKey, SigningKey PaymentKey)] -> [SigningKey HydraKey] -> [TxId] -> ContestationPeriod -> (NonEmpty HydraClient -> IO a) -> IO a

-- | Prepare protocol-parameters to run a hydra-node with given
--   <a>ChainConfig</a> and using the config from config/.
preparePParams :: ChainConfig -> FilePath -> (Value -> Value) -> IO FilePath

-- | Prepare <a>RunOptions</a> to run a hydra-node with given
--   <a>ChainConfig</a> and using the config from config/.
prepareHydraNode :: HasCallStack => ChainConfig -> FilePath -> Int -> SigningKey HydraKey -> [VerificationKey HydraKey] -> [Int] -> (Value -> Value) -> IO RunOptions

-- | Run a hydra-node with given <a>RunOptions</a> and in sync with chain
--   backend.
withPreparedHydraNodeInSync :: HasCallStack => Tracer IO HydraNodeLog -> NominalDiffTime -> FilePath -> Int -> RunOptions -> (HydraClient -> IO a) -> IO a

-- | Run a hydra-node with given <a>RunOptions</a>.
withPreparedHydraNode :: HasCallStack => Tracer IO HydraNodeLog -> FilePath -> Int -> RunOptions -> (HydraClient -> IO a) -> IO a

-- | Run a hydra-node with given <a>ChainConfig</a> and using the config
--   from config/.
withHydraNode :: HasCallStack => Tracer IO HydraNodeLog -> NominalDiffTime -> ChainConfig -> FilePath -> Int -> SigningKey HydraKey -> [VerificationKey HydraKey] -> [Int] -> (HydraClient -> IO a) -> IO a

-- | Run a hydra-node with given <a>ChainConfig</a> and using the config
--   from config and catching up with chain backend/.
withHydraNodeCatchingUp :: HasCallStack => Tracer IO HydraNodeLog -> ChainConfig -> FilePath -> Int -> SigningKey HydraKey -> [VerificationKey HydraKey] -> [Int] -> (HydraClient -> IO a) -> IO a
withConnectionToNode :: forall a. Tracer IO HydraNodeLog -> Int -> (HydraClient -> IO a) -> IO a
withConnectionToNodeHost :: forall a. Tracer IO HydraNodeLog -> Int -> Host -> Maybe String -> (HydraClient -> IO a) -> IO a
waitForNodesConnected :: Tracer IO HydraNodeLog -> NominalDiffTime -> NonEmpty HydraClient -> IO ()
waitForNodesDisconnected :: Tracer IO HydraNodeLog -> NominalDiffTime -> NonEmpty HydraClient -> IO ()
waitForNodesSynced :: NominalDiffTime -> NonEmpty HydraClient -> IO ()
data HydraNodeLog
HydraNodeCommandSpec :: Text -> HydraNodeLog
[$sel:cmd:HydraNodeCommandSpec] :: HydraNodeLog -> Text
NodeStarted :: Int -> HydraNodeLog
[$sel:nodeId:HydraNodeCommandSpec] :: HydraNodeLog -> Int
SentMessage :: Int -> Value -> HydraNodeLog
[$sel:nodeId:HydraNodeCommandSpec] :: HydraNodeLog -> Int
[$sel:message:HydraNodeCommandSpec] :: HydraNodeLog -> Value
StartWaiting :: [Int] -> [Value] -> HydraNodeLog
[$sel:nodeIds:HydraNodeCommandSpec] :: HydraNodeLog -> [Int]
[$sel:messages:HydraNodeCommandSpec] :: HydraNodeLog -> [Value]
ReceivedMessage :: Int -> Value -> HydraNodeLog
[$sel:nodeId:HydraNodeCommandSpec] :: HydraNodeLog -> Int
[$sel:message:HydraNodeCommandSpec] :: HydraNodeLog -> Value
EndWaiting :: Int -> HydraNodeLog
[$sel:nodeId:HydraNodeCommandSpec] :: HydraNodeLog -> Int
instance Data.Aeson.Types.ToJSON.ToJSON HydraNode.HydraNodeLog
instance GHC.Generics.Generic HydraNode.HydraNodeLog
instance GHC.Show.Show HydraNode.HydraNodeLog
instance GHC.Classes.Eq HydraNode.HydraNodeLog

module Hydra.Cluster.Scenarios
data EndToEndLog
ClusterOptions :: Options -> EndToEndLog
[$sel:options:ClusterOptions] :: EndToEndLog -> Options
FromCardanoNode :: NodeLog -> EndToEndLog
FromFaucet :: FaucetLog -> EndToEndLog
FromHydraNode :: HydraNodeLog -> EndToEndLog
FromMithril :: MithrilLog -> EndToEndLog
StartingFunds :: String -> UTxO -> EndToEndLog
[$sel:actor:ClusterOptions] :: EndToEndLog -> String
[$sel:utxo:ClusterOptions] :: EndToEndLog -> UTxO
RefueledFunds :: String -> Coin -> UTxO -> EndToEndLog
[$sel:actor:ClusterOptions] :: EndToEndLog -> String
[$sel:refuelingAmount:ClusterOptions] :: EndToEndLog -> Coin
[$sel:utxo:ClusterOptions] :: EndToEndLog -> UTxO
RemainingFunds :: String -> UTxO -> EndToEndLog
[$sel:actor:ClusterOptions] :: EndToEndLog -> String
[$sel:utxo:ClusterOptions] :: EndToEndLog -> UTxO
PublishedHydraScriptsAt :: [TxId] -> EndToEndLog
[$sel:hydraScriptsTxId:ClusterOptions] :: EndToEndLog -> [TxId]
UsingHydraScriptsAt :: [TxId] -> EndToEndLog
[$sel:hydraScriptsTxId:ClusterOptions] :: EndToEndLog -> [TxId]
CreatedKey :: FilePath -> EndToEndLog
[$sel:keyPath:ClusterOptions] :: EndToEndLog -> FilePath
oneOfThreeNodesStopsForAWhile :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()
restartedNodeCanObserveCommitTx :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()
resumeFromLatestKnownPoint :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()
restartedNodeCanAbort :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()
nodeReObservesOnChainTxs :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()

-- | Step through the full life cycle of a Hydra Head with only a single
--   participant. This scenario is also used by the smoke test run via the
--   `hydra-cluster` executable.
singlePartyHeadFullLifeCycle :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()

-- | Open a Hydra Head with only a single participant but some arbitrary
--   UTxO committed.
singlePartyOpenAHead :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> Maybe (Positive Natural) -> (HydraClient -> SigningKey PaymentKey -> HeadId -> IO a) -> IO a

-- | Single hydra-node where the commit is done using some wallet UTxO.
singlePartyCommitsFromExternal :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()
singlePartyUsesScriptOnL2 :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()

-- | Open a head and run a script using <tt>Rewarding</tt> script purpose
--   and a zero lovelace withdrawal.
singlePartyUsesWithdrawZeroTrick :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()

-- | Compute the integrity hash of a transaction using a list of plutus
--   languages.
recomputeIntegrityHash :: (AlonzoEraPParams ppera, AlonzoEraTxWits txera, AlonzoEraTxBody txera, EraTx txera) => PParams ppera -> [Language] -> Tx txera -> Tx txera
singlePartyCommitsScriptBlueprint :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()
singlePartyDepositReferenceScript :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()
singlePartyCommitsScriptToTheRightHead :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()
persistenceCanLoadWithEmptyCommit :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()

-- | Single hydra-node where the commit is done from a raw transaction
--   blueprint.
singlePartyCommitsFromExternalTxBlueprint :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()

-- | Initialize open and close a head on a real network and ensure
--   contestation period longer than the time horizon is possible. For this
--   it is enough that we can close a head and not wait for the deadline.
canCloseWithLongContestationPeriod :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()
canSubmitTransactionThroughAPI :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()

-- | Three hydra nodes open a head and we assert that none of them sees
--   errors. This was particularly misleading when everyone tries to post
--   the collect transaction concurrently.
threeNodesNoErrorsOnOpen :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()

-- | Hydra nodes ABC run on ABC cluster and connect to each other. Hydra
--   nodes BC shut down. Hydra nodes BC run on BC cluster and connect to
--   each other. Hydra nodes BC shut down. Hydra nodes BC run and connect
--   ABC cluster again.
nodeCanSupportMultipleEtcdClusters :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()

-- | Two hydra node setup where Alice is wrongly configured to use Carol's
--   cardano keys instead of Bob's which will prevent him to be notified
--   the <tt>HeadIsInitializing</tt> but he should still receive some
--   notification.
initWithWrongKeys :: ChainBackend backend => FilePath -> Tracer IO EndToEndLog -> backend -> [TxId] -> IO ()
startWithWrongPeers :: ChainBackend backend => FilePath -> Tracer IO EndToEndLog -> backend -> [TxId] -> IO ()

-- | Open a a two participant head and incrementally commit to it.
canCommit :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> NominalDiffTime -> backend -> [TxId] -> IO ()

-- | Open a a two participant head and incrementally commit part of the
--   UTxO.
canDepositPartially :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> NominalDiffTime -> backend -> [TxId] -> IO ()
rejectCommit :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> NominalDiffTime -> backend -> [TxId] -> IO ()

-- | Open a a single participant head, deposit and then recover it.
canRecoverDeposit :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()

-- | Open a single-participant head, perform 3 deposits, and then: 1. Close
--   the head and recover deposit #1 2. Fanout the head and recover deposit
--   #2 3. Open a new head and recover deposit #3
canRecoverDepositInAnyState :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()

-- | Make sure to be able to see pending deposits.
canSeePendingDeposits :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> NominalDiffTime -> backend -> [TxId] -> IO ()

-- | Open a a single participant head with some UTxO and incrementally
--   decommit it.
canDecommit :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()

-- | Can side load snapshot and resume agreement after a peer comes back
--   online with healthy configuration
canSideLoadSnapshot :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()
canResumeOnMemberAlreadyBootstrapped :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()
waitsForChainInSyncAndSecure :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()

-- | Three hydra nodes open a head and we assert that none of them sees
--   errors if a party is duplicated.
threeNodesWithMirrorParty :: ChainBackend backend => Tracer IO EndToEndLog -> FilePath -> backend -> [TxId] -> IO ()

-- | Finds UTxO owned by given key in the head and creates transactions
--   respending it to the same address as fast as possible, forever. NOTE:
--   This relies on zero-fee protocol parameters.
respendUTxO :: HydraClient -> SigningKey PaymentKey -> NominalDiffTime -> IO ()

-- | Refuel given <a>Actor</a> with given <tt>Lovelace</tt> if current
--   marked UTxO is below that amount.
refuelIfNeeded :: ChainBackend backend => Tracer IO EndToEndLog -> backend -> Actor -> Coin -> IO ()

-- | Return the remaining funds to the faucet
returnFundsToFaucet :: ChainBackend backend => Tracer IO EndToEndLog -> backend -> Actor -> IO ()
headIsInitializingWith :: Set Party -> Value -> Maybe HeadId
checkFanout :: HeadId -> UTxO -> Value -> Maybe ()
expectErrorStatus :: Int -> Maybe ByteString -> HttpException -> Bool

-- | Get the base URL for HTTP API calls to a hydra-node.
hydraNodeBaseUrl :: HydraClient -> String
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Cluster.Scenarios.EndToEndLog
instance GHC.Generics.Generic Hydra.Cluster.Scenarios.EndToEndLog
instance GHC.Show.Show Hydra.Cluster.Scenarios.EndToEndLog
instance GHC.Classes.Eq Hydra.Cluster.Scenarios.EndToEndLog
