"use strict";(self.webpackChunkhydra_head_protocol_docs=self.webpackChunkhydra_head_protocol_docs||[]).push([[7053],{65613:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"dev/architecture/event-sourcing","title":"Event sourcing","description":"The hydra-node is an event sourced application. This means that the main logic is processing inputs (also called commands) and produces events. These events are saved and loaded to persist application state across restarts. Also, most events are transformed to outputs and can be observed on the hydra-node API.","source":"@site/docs/dev/architecture/event-sourcing.md","sourceDirName":"dev/architecture","slug":"/dev/architecture/event-sourcing","permalink":"/head-protocol/unstable/docs/dev/architecture/event-sourcing","draft":false,"unlisted":false,"editUrl":"https://github.com/cardano-scaling/hydra/tree/master/docs/docs/dev/architecture/event-sourcing.md","tags":[],"version":"current","frontMatter":{},"sidebar":"developerDocumentation","previous":{"title":"Architecture","permalink":"/head-protocol/unstable/docs/dev/architecture/"},"next":{"title":"Networking","permalink":"/head-protocol/unstable/docs/dev/architecture/networking"}}');var a=s(74848),r=s(28453);const o={},i="Event sourcing",d={},c=[{value:"Default event source and sinks",id:"default-event-source-and-sinks",level:2},{value:"Examples",id:"examples",level:2},{value:"What to test",id:"what-to-test",level:3},{value:"Event Log Rotation",id:"event-log-rotation",level:3}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"event-sourcing",children:"Event sourcing"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"hydra-node"})," is an event sourced application. This means that the main logic is processing ",(0,a.jsx)(t.em,{children:"inputs"})," (also called commands) and produces ",(0,a.jsx)(t.em,{children:"events"}),". These events are saved and loaded to persist application state across restarts. Also, most events are transformed to ",(0,a.jsx)(t.em,{children:"outputs"})," and can be observed on the ",(0,a.jsx)(t.code,{children:"hydra-node"})," API."]}),"\n",(0,a.jsxs)(t.p,{children:["On application startup, the ",(0,a.jsx)(t.a,{href:"https://hydra.family/head-protocol/haddock/hydra-node/Hydra-Node.html#v:hydrate",children:(0,a.jsx)(t.code,{children:"hydrate"})})," function is called to load all events using a given ",(0,a.jsx)(t.a,{href:"https://hydra.family/head-protocol/haddock/hydra-node/Hydra-Events.html#t:EventSource",children:(0,a.jsx)(t.code,{children:"EventSource"})})," and while doing so, re-emits those events to all provided ",(0,a.jsx)(t.a,{href:"https://hydra.family/head-protocol/haddock/hydra-node/Hydra-Events.html#t:EventSink",children:(0,a.jsx)(t.code,{children:"EventSink"})})," instances. The resulting ",(0,a.jsx)(t.a,{href:"https://hydra.family/head-protocol/haddock/hydra-node/Hydra-Node.html#t:HydraNode",children:(0,a.jsx)(t.code,{children:"HydraNode"})})," will then enter the main loop of ",(0,a.jsx)(t.code,{children:"hydra-node"})," and process inputs into state changes and effects via function ",(0,a.jsx)(t.a,{href:"https://hydra.family/head-protocol/haddock/hydra-node/Hydra-Node.html#v:stepHydraNode",children:(0,a.jsx)(t.code,{children:"stepHydraNode"})}),". All state changes of a Hydra node are based on ",(0,a.jsx)(t.a,{href:"https://hydra.family/head-protocol/haddock/hydra-node/Hydra-Events.html#t:StateEvent",children:(0,a.jsx)(t.code,{children:"StateEvent"})})," values and consequently get emitted to all ",(0,a.jsx)(t.code,{children:"eventSinks"})," of the ",(0,a.jsx)(t.code,{children:"HydraNode"})," handle. Also, the ",(0,a.jsx)(t.code,{children:"eventSource"})," of the same may be used later to to load events on-demand, for example to produce a history of server outputs."]}),"\n",(0,a.jsx)(t.h2,{id:"default-event-source-and-sinks",children:"Default event source and sinks"}),"\n",(0,a.jsxs)(t.p,{children:["The default event source and sink used by the ",(0,a.jsx)(t.code,{children:"hydra-node"})," is ",(0,a.jsx)(t.code,{children:"FileBased"}),", which uses an append-only plain JSON file to persist events in a file name ",(0,a.jsx)(t.code,{children:"state"}),". This single file is located in the ",(0,a.jsx)(t.code,{children:"hydra-node"})," persistence directory, which is specified by the ",(0,a.jsx)(t.code,{children:"--persistence-dir"})," command line option."]}),"\n",(0,a.jsxs)(t.p,{children:["As explained in the consequences of ",(0,a.jsx)(t.a,{href:"https://hydra.family/head-protocol/adr/29",children:"ADR29"}),", the API server of the ",(0,a.jsx)(t.code,{children:"hydra-node"})," is also an event sink, which means that all events are sent to the API server and may be further submitted as ",(0,a.jsx)(t.a,{href:"https://hydra.family/head-protocol/haddock/hydra-node/Hydra-API-ServerOutput.html#t:ServerOutput",children:(0,a.jsx)(t.code,{children:"ServerOutput"})})," to clients of the API server. See ",(0,a.jsx)(t.a,{href:"https://hydra.family/head-protocol/haddock/hydra-node/Hydra-API-Server.html#v:mkTimedServerOutputFromStateEvent",children:(0,a.jsx)(t.code,{children:"mkTimedServerOutputFromStateEvent"})})," for which events are mapped to server outputs."]}),"\n",(0,a.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,a.jsxs)(t.p,{children:["Besides the efault event source and sinks, there are two examples in the ",(0,a.jsx)(t.code,{children:"hydra-node:examples"})," library:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://github.com/cardano-scaling/hydra/blob/master/hydra-node/examples/Hydra/Events/UDP.hs",children:(0,a.jsx)(t.code,{children:"Hydra.Events.UDP"})}),": A simple UDP sink that sends all events to a UDP socket. This is a simple example of an event sink that can be used to send events to other applications or services."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://github.com/cardano-scaling/hydra/blob/master/hydra-node/examples/Hydra/Events/S3.hs",children:(0,a.jsx)(t.code,{children:"Hydra.Events.S3"})}),": This example shows how to use AWS S3 to create a complete event store - that is, an event source and sink. It uses the ",(0,a.jsx)(t.code,{children:"amazonka"})," to interact with S3 and store events in a bucket. This is a more complex example that demonstrates how to use an external service to store events."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"what-to-test",children:"What to test"}),"\n",(0,a.jsx)(t.p,{children:"When implementing an event source or sink, you might want to consider testing the following, as also demonstrated by the main implementations and examples above:"}),"\n",(0,a.jsxs)(t.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(t.li,{className:"task-list-item",children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Event store (sink + source)"]}),"\n",(0,a.jsxs)(t.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(t.li,{className:"task-list-item",children:[(0,a.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Completeness: Any events stored by ",(0,a.jsx)(t.code,{children:"putEvent"})," are returned by ",(0,a.jsx)(t.code,{children:"getEvents"}),"/",(0,a.jsx)(t.code,{children:"sourceEvents"}),"\n",(0,a.jsxs)(t.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(t.li,{className:"task-list-item",children:[(0,a.jsx)(t.input,{type:"checkbox",disabled:!0})," ","For continuous, non-continuous and sequences of duplicate events"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{className:"task-list-item",children:[(0,a.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Concurrent use of ",(0,a.jsx)(t.code,{children:"putEvent"})," and ",(0,a.jsx)(t.code,{children:"sourceEvents"})," is possible"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{className:"task-list-item",children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Event sink only"]}),"\n",(0,a.jsxs)(t.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(t.li,{className:"task-list-item",children:[(0,a.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Whether ",(0,a.jsx)(t.code,{children:"putEvent"})," results in desired effect"]}),"\n",(0,a.jsxs)(t.li,{className:"task-list-item",children:[(0,a.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Concurrent use of ",(0,a.jsx)(t.code,{children:"putEvent"})," is possible"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{className:"task-list-item",children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Event source only"]}),"\n",(0,a.jsxs)(t.ul,{className:"contains-task-list",children:["\n",(0,a.jsxs)(t.li,{className:"task-list-item",children:[(0,a.jsx)(t.input,{type:"checkbox",disabled:!0})," ",'Whether previously "primed" events are loaded by ',(0,a.jsx)(t.code,{children:"sourceEvents"})]}),"\n",(0,a.jsxs)(t.li,{className:"task-list-item",children:[(0,a.jsx)(t.input,{type:"checkbox",disabled:!0})," ","Concurrent use of ",(0,a.jsx)(t.code,{children:"sourceEvents"})," is possible"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{className:"task-list-item",children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.input,{type:"checkbox",disabled:!0})," ","General: allocated resources are released (use with/bracket pattern)"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"event-log-rotation",children:"Event Log Rotation"}),"\n",(0,a.jsx)(t.p,{children:"Long-living heads may produce a large number of persisted events, which can impact the restart time of the hydra-node as it needs to read in all the previous to recreate its state."}),"\n",(0,a.jsx)(t.p,{children:"Event log rotation was introduced to improve recovery times by reducing the number of events that need to be replayed on startup. This is achieved by periodically replacing the current event log with a new one that starts from a checkpoint event, which captures the latest aggregated head state."}),"\n",(0,a.jsxs)(t.p,{children:["Only rotated log files are saved with an incrementing ",(0,a.jsx)(t.code,{children:"logId"})," suffix in their names, while the main ",(0,a.jsx)(t.code,{children:"state"})," log file remains unchanged to preserve backward compatibility. This ",(0,a.jsx)(t.code,{children:"logId"})," suffix corresponds to the ID of the last event included in that file.\nRotation can be enabled via the optional ",(0,a.jsx)(t.code,{children:"--persistence-rotate-after"})," command-line argument, which specifies the number of events after which rotation should occur."]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["For example, with ",(0,a.jsx)(t.code,{children:"--persistence-rotate-after 100"}),", you\u2019ll get rotated files named: state-99, state-199, state-299, and so on, each containing 100 events. This is because event IDs start at 0."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Note that, depending on the rotation configuration used, the current ",(0,a.jsx)(t.code,{children:"state"})," file may already contain more events than the specified threshold, causing a rotation to occur immediately on startup before any new inputs are processed."]}),"\n",(0,a.jsx)(t.p,{children:"Upon rotation, a server output is produced to notify external agents when a checkpoint occurs, allowing them to perform archival or cleanup actions without interrupting the Hydra Head."}),"\n",(0,a.jsxs)(t.p,{children:["The appropriate value for ",(0,a.jsx)(t.code,{children:"--persistence-rotate-after"})," depends on your specific use case and the expected transaction volume."]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["As a rough guideline, in a simple scenario (running a single party on devnet that repeatedly re-spends the same committed UTxO) we observed that setting ",(0,a.jsx)(t.code,{children:"--persistence-rotate-after 10000"})," results in rotated log files of about 8\u202fMB every 3 minutes."]}),"\n",(0,a.jsx)(t.p,{children:"Keep in mind that the size and frequency of rotated files will vary depending on several factors:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Transaction sizes: Larger transactions result in larger event payloads."}),"\n",(0,a.jsx)(t.li,{children:"Number of party members: More parties increase the number of L2 protocol messages per snapshot, generating more events."}),"\n",(0,a.jsx)(t.li,{children:"Ledger UTxO size: A higher number of UTxOs increases the size of certain events like snapshots."}),"\n",(0,a.jsx)(t.li,{children:"Transaction throughput (TPS): Higher TPS leads to more events being produced over time."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>i});var n=s(96540);const a={},r=n.createContext(a);function o(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);