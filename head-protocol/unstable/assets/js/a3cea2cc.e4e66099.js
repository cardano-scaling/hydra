"use strict";(self.webpackChunkhydra_head_protocol_docs=self.webpackChunkhydra_head_protocol_docs||[]).push([[5408],{30540:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"how-to/best-practise-dapp","title":"Commit/Deposit from a dApp","description":"- Developers building decentralized applications (dApps) on the Hydra protocol","source":"@site/docs/how-to/best-practise-dapp.md","sourceDirName":"how-to","slug":"/how-to/best-practise-dapp","permalink":"/head-protocol/unstable/docs/how-to/best-practise-dapp","draft":false,"unlisted":false,"editUrl":"https://github.com/cardano-scaling/hydra/tree/master/docs/docs/how-to/best-practise-dapp.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"userDocumentation","previous":{"title":"Sideload Snapshot","permalink":"/head-protocol/unstable/docs/how-to/sideload-snapshot"},"next":{"title":"Deposit tutorial with JavaScript SDK","permalink":"/head-protocol/unstable/docs/how-to/deposit-with-javascript-sdk"}}');var a=i(74848),s=i(28453);const o={sidebar_position:9},r="Commit/Deposit from a dApp",d={},c=[{value:"Committing to a Hydra Head",id:"committing-to-a-hydra-head",level:2},{value:"Depositing to a Hydra Head",id:"depositing-to-a-hydra-head",level:2},{value:"Building a secure validator",id:"building-a-secure-validator",level:3},{value:"Commit validator checks",id:"commit-validator-checks",level:3},{value:"Deposit validator checks",id:"deposit-validator-checks",level:3}];function l(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"commitdeposit-from-a-dapp",children:"Commit/Deposit from a dApp"})}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Developers building decentralized applications (dApps) on the Hydra protocol\nwould greatly benefit from clear guidance and examples detailing the validator\nchecks required to ensure that committed/deposited funds are accurately directed to the\nintended Hydra Head instance."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"This document aims to outline essential validator checks needed for\nuser-written validators, providing concrete examples implemented using PlutusTx\nand briefly explaining how the commit/deposit transaction looks like."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"committing-to-a-hydra-head",children:"Committing to a Hydra Head"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["To begin, let us examine the diagram illustrating the on-chain commit process in detail:\n",(0,a.jsx)(t.img,{src:i(7555).A+"",width:"4963",height:"2063"})]}),"\n"]}),"\n",(0,a.jsx)("sub",{children:" Here rectangulars represent transactions and you can see the UTxO (with rounded corners) depicting transaction inputs and outputs together with their contents (datums, redeemers and assets)"}),"\n",(0,a.jsxs)(t.p,{children:["The commit transaction utilizes an initial output specifically crafted for each Hydra Head participant. This initial output includes the ",(0,a.jsx)(t.code,{children:"HeadId"})," in its datum, while the redeemer contains details about the specific ",(0,a.jsx)(t.code,{children:"TxOutRef"})," values to be committed, which are pre-sorted."]}),"\n",(0,a.jsx)(t.p,{children:"The initial validator is parameterized by the commit validator hash. In the user-defined validator, it is sufficient to verify that:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"There is only one output at commit script address containing the PT (participation) token + the change output."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"dApp developers can leverage the script redeemer to convey the necessary information."}),"\n",(0,a.jsx)(t.p,{children:"Let us now proceed with constructing the validator from the user\u2019s perspective!"}),"\n",(0,a.jsx)(t.h2,{id:"depositing-to-a-hydra-head",children:"Depositing to a Hydra Head"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["The process that serves the purpose of bringing in more funds to L2 Hydra network once the Head is already open is referred to as ",(0,a.jsx)(t.strong,{children:"depositing"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"This is the diagram explaining the on-chain deposit process:"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:i(63080).A+"",width:"5108",height:"2004"})}),"\n",(0,a.jsxs)(t.p,{children:["The deposit transaction takes a provided UTxO and ",(0,a.jsx)(t.em,{children:"locks"})," it into a deposit address where the datum contains serialized Plutus ",(0,a.jsx)(t.code,{children:"TxOutRef"}),"'s.\nDeposit transaction has its upper validity slot set so the whole deposit process has a deadline. After hydra-node observes the deposit transaction\nit will post an ",(0,a.jsx)(t.code,{children:"increment"})," transaction which will actually bring the funds locked at the deposit address to L2 after deposit validator check that\nmakes sure the Head currency symbol is the same in both the datum and redeemer and that the deposit deadline slot is not surpassed."]}),"\n",(0,a.jsx)(t.p,{children:"Unclaimed deposits can be recovered and this works in any Hydra Head state (even after closing the Head). The only validator check that needs to\nbe satisfied is that the current slot is after the deposit deadline slot."}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsxs)(t.p,{children:["Please make sure to use ",(0,a.jsx)(t.a,{href:"./../configuration#deposit-period",children:(0,a.jsx)(t.em,{children:"correct"})})," ",(0,a.jsx)(t.code,{children:"--deposit-period"})," value."]})}),"\n",(0,a.jsx)(t.h3,{id:"building-a-secure-validator",children:"Building a secure validator"}),"\n",(0,a.jsx)(t.p,{children:"To develop a dApp using the Hydra protocol, users must commit/deposit their scripts to a Hydra Head."}),"\n",(0,a.jsx)(t.p,{children:"This enables custom programmability within the Head protocol, unlocking the potential for a wide range of dApp implementations."}),"\n",(0,a.jsx)(t.p,{children:"As an initial step, we will focus on constructing a validator along with its essential checks."}),"\n",(0,a.jsx)(t.p,{children:"To begin, we will examine a basic exampleValidator that currently performs no operations:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-Haskell",children:"exampleValidator ::\n  () ->\n  () ->\n  ScriptContext ->\n  Bool\nexampleValidator _ _ _ = True\n\nexampleSecureValidatorScript :: PlutusScript\nexampleSecureValidatorScript =\n  PlutusScriptSerialised $\n    serialiseCompiledCode\n      $$( PlutusTx.compile\n            [||wrap exampleValidator||]\n        )\n where\n  wrap = wrapValidator @() @()\n"})}),"\n",(0,a.jsx)(t.admonition,{type:"warning",children:(0,a.jsx)(t.p,{children:"Code examples here are just explanatory and are not suitable for production use!\nThey serve the purpose of giving dApp developers a general idea on how to check that commit or deposit goes to the right Head instance."})}),"\n",(0,a.jsxs)(t.admonition,{type:"info",children:[(0,a.jsx)(t.p,{children:"If you need to get the information on Hydra scripts hashes you can use hydra-node:"}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:'./hydra-node -- --hydra-script-catalogue\n{\n "commitScriptHash": "61458bc2f297fff3cc5df6ac7ab57cefd87763b0b7bd722146a1035c",\n "commitScriptSize": 685,\n "depositScriptHash": "ae01dade3a9c346d5c93ae3ce339412b90a0b8f83f94ec6baa24e30c",\n "depositScriptSize": 1102,\n "headScriptHash": "a1442faf26d4ec409e2f62a685c1d4893f8d6bcbaf7bcb59d6fa1340",\n "headScriptSize": 14599,\n "initialScriptHash": "c8a101a5c8ac4816b0dceb59ce31fc2258e387de828f02961d2f2045",\n "initialScriptSize": 2652,\n "mintingScriptHash": "fd173b993e12103cd734ca6710d364e17120a5eb37a224c64ab2b188",\n "mintingScriptSize": 5284\n}\n'})})]}),"\n",(0,a.jsxs)(t.p,{children:["To get the information on ",(0,a.jsx)(t.code,{children:"HeadId"})," easiest is to look at the persistence\nfolder of your hydra-node and in the ",(0,a.jsx)(t.code,{children:"state"})," file you should be able to find\nthe headId. (NOTE: You need to initialize the Head first)"]}),"\n",(0,a.jsx)(t.p,{children:"Now we are able to start working on our validator checks."}),"\n",(0,a.jsx)(t.h3,{id:"commit-validator-checks",children:"Commit validator checks"}),"\n",(0,a.jsx)(t.p,{children:"To ensure correct dApp validator checks when committing we must verify that an output exists containing a single PT token with the correct policy ID (head ID).\nThis condition implicitly confirms that the initial validator has executed, as its output has been consumed,\nand the commit transaction now includes an output with the PT token bearing the expected policy ID."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-Haskell",children:"  checkCorrectHeadId =\n    let outputValue = foldMap txOutValue (txInfoOutputs (scriptContextTxInfo ctx))\n        pts = findParticipationToken expectedHeadId outputValue\n     in L.length pts == 1\n\n  findParticipationToken :: CurrencySymbol -> Value -> [TokenName]\n  findParticipationToken headCurrency (Value val) =\n    case AssocMap.toList <$> AssocMap.lookup headCurrency val of\n      Just tokens ->\n        mapMaybe (\\(tokenName, n) -> if n == 1 then Just tokenName else Nothing) tokens\n      _ ->\n        []\n  {-# INLINEABLE findParticipationTokens #-}\n\n  R{expectedHeadId} = redeemer\n\n"})}),"\n",(0,a.jsx)(t.p,{children:"This check is all we need in order to add some security to our validators and make sure our commit will end up in the correct Head instance."}),"\n",(0,a.jsx)(t.h3,{id:"deposit-validator-checks",children:"Deposit validator checks"}),"\n",(0,a.jsxs)(t.p,{children:["To ensure correct dApp validator checks when depositing we must make sure the deposit datum contains the correct Head id. Since hydra-node is the one building a deposit\ntransaction from the user provided UTxO we can feel safe the datum is correct if we are using official release of ",(0,a.jsx)(t.code,{children:"hydra-node"})," binary.\nThis means that it would be enough to check that there is a output present at the ",(0,a.jsx)(t.strong,{children:"correct"})," deposit script address."]}),"\n",(0,a.jsxs)(t.p,{children:["We mentioned before how to get the correct script hashes from your hydra-node (",(0,a.jsx)(t.code,{children:"./hydra-node -- --hydra-script-catalogue"}),"). With this information\nit is sufficient to make sure the deposit script has the expected hash."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-Haskell",children:"\n  depositOutput = findDepositOutput expectedDepositValidator\n\n  findDepositOutput :: ScriptHash -> List.List TxOut\n  findDepositOutput depositScriptHash =\n     let allOutputs = List.fromSOP $ txInfoOutputs info\n       in List.filter (isScriptAddress depositScriptHash . txOutAddress) allOutputs\n\n  isScriptAddress :: ScriptHash -> Address -> Bool\n  isScriptAddress expectedHash addr =\n    case addressCredential addr of\n      ScriptCredential vh -> vh == expectedHash\n      PubKeyCredential _ -> False\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The following step is to build a ",(0,a.jsx)(t.em,{children:"blueprint"})," transaction as a recipe for committing/depositing your script UTxO into a Head. This is only needed in case\nyou want to introduce some transaction context (like validity range, extra signers etc). We already have some guides on that\n",(0,a.jsx)(t.a,{href:"./commit-script-utxo#step-5-prepare-the-blueprint",children:"here"})," and ",(0,a.jsx)(t.a,{href:"./incremental-commit",children:"here"})," but you would of course need to make some changes\nwhich is left as an exercise to the reader."]}),"\n",(0,a.jsxs)(n,{children:[(0,a.jsx)("summary",{children:"Complete commit validator example "}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-haskell",children:"{-# LANGUAGE TemplateHaskell #-}\n{-# OPTIONS_GHC -fplugin PlutusTx.Plugin #-}\n{-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:defer-errors #-}\n{-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:target-version=1.1.0 #-}\n\nmodule Example where\n\nimport Hydra.Cardano.Api (PlutusScript, pattern PlutusScriptSerialised)\nimport Hydra.Plutus.Extras (wrapValidator)\nimport PlutusLedgerApi.V3 (\n  CurrencySymbol,\n  ScriptContext (..),\n  ScriptInfo (..),\n  TokenName,\n  Value (..),\n  serialiseCompiledCode,\n  txInfoOutputs,\n  txOutValue,\n  unsafeFromBuiltinData,\n )\nimport PlutusTx (compile, unstableMakeIsData)\nimport PlutusTx.AssocMap qualified as AssocMap\nimport PlutusTx.Eq ((==))\nimport PlutusTx.Foldable (foldMap)\nimport PlutusTx.Functor ((<$>))\nimport PlutusTx.List qualified as L\nimport PlutusTx.Prelude (check, traceIfFalse)\n\nnewtype R = R\n  { expectedHeadId :: CurrencySymbol\n  }\n  deriving stock (Show, Generic)\n\nunstableMakeIsData ''R\n\nexampleCommitValidator ::\n  () ->\n  R ->\n  ScriptContext ->\n  Bool\nexampleCommitValidator _ redeemer ctx =\n  checkCorrectHeadId\n where\n  checkCorrectHeadId =\n    let outputValue = foldMap txOutValue (txInfoOutputs (scriptContextTxInfo ctx))\n        pts = findParticipationToken expectedHeadId outputValue\n     in traceIfFalse \"HeadId is not correct\" (L.length pts == 1)\n\n  findParticipationToken :: CurrencySymbol -> Value -> [(TokenName, Integer)]\n  findParticipationToken headCurrency (Value val) =\n    case AssocMap.toList <$> AssocMap.lookup headCurrency val of\n      Just tokens ->\n        L.filter (\\(_, n) -> n == 1) tokens\n      _ ->\n        []\n  {-# INLINEABLE findParticipationToken #-}\n\n  R{expectedHeadId} = redeemer\n\nexampleSecureValidatorScript :: PlutusScript\nexampleSecureValidatorScript =\n  PlutusScriptSerialised $\n    serialiseCompiledCode\n      $$( PlutusTx.compile\n            [||wrap exampleCommitValidator||]\n        )\n where\n  wrap = wrapValidator @() @R\n"})})]}),"\n",(0,a.jsxs)(n,{children:[(0,a.jsx)("summary",{children:"Complete deposit validator example "}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-haskell",children:"{-# LANGUAGE TemplateHaskell #-}\n{-# OPTIONS_GHC -fplugin PlutusTx.Plugin #-}\n{-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:defer-errors #-}\n{-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:target-version=1.1.0 #-}\n\nmodule Example where\n\nimport Hydra.Cardano.Api (PlutusScript, pattern PlutusScriptSerialised)\nimport Hydra.Plutus.Extras (wrapValidator)\nimport PlutusLedgerApi.V3 (\n  Address (addressCredential),\n  Credential (..),\n  ScriptContext (..),\n  ScriptInfo (..),\n  TxOut,\n  serialiseCompiledCode,\n  txInfoOutputs,\n  txOutAddress,\n  unsafeFromBuiltinData,\n )\nimport PlutusTx (compile, unstableMakeIsData)\nimport PlutusTx.Eq ((==))\n+import PlutusTx.Data.List qualified as List\nimport PlutusTx.Prelude (check, traceIfFalse)\n\nnewtype R = R\n  { expectedDepositValidator :: ScriptHash\n  }\n  deriving stock (Show, Generic)\n\nunstableMakeIsData ''R\n\nexampleDepositValidator ::\n  () ->\n  R ->\n  ScriptContext ->\n  Bool\nexampleDepositValidator _ redeemer ctx =\n  checkDepositHash\n where\n  checkDepositHash =\n    traceIfFalse \"Invalid deposit script hash\" (List.length depositOutput == 1)\n\n  depositOutput = findDepositOutput expectedDepositValidator\n\n  findDepositOutput :: ScriptHash -> List.List TxOut\n  findDepositOutput depositScriptHash =\n    let allOutputs = List.fromSOP $ txInfoOutputs info\n     in List.filter (isScriptAddress depositScriptHash . txOutAddress) allOutputs\n\n  isScriptAddress :: ScriptHash -> Address -> Bool\n  isScriptAddress expectedHash addr =\n    case addressCredential addr of\n      ScriptCredential vh -> vh == expectedHash\n      PubKeyCredential _ -> False\n\n  R{expectedDepositValidator} = redeemer\n\n  info = scriptContextTxInfo ctx\n\nexampleSecureValidatorScript :: PlutusScript\nexampleSecureValidatorScript =\n  PlutusScriptSerialised $\n    serialiseCompiledCode\n      $$( PlutusTx.compile\n            [||wrap exampleDepositValidator||]\n        )\n where\n  wrap = wrapValidator @() @R\n"})})]})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},7555:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/commit-process-ef3b6de32f6948127cb43023a17b9ad6.jpg"},63080:(e,t,i)=>{i.d(t,{A:()=>n});const n=i.p+"assets/images/deposit-process-021d10eeb5bb05108635f9e72a33ca70.jpg"},28453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>r});var n=i(96540);const a={},s=n.createContext(a);function o(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);