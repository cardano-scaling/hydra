"use strict";(self.webpackChunkhydra_head_protocol_docs=self.webpackChunkhydra_head_protocol_docs||[]).push([[8884],{66225:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var o=t(74849),s=t(74848),r=t(28453);const a={slug:31,title:"31. Achieve constant memory in hydra-node\n",authors:["v0d1ch"],tags:["Accepted"]},i=void 0,c={authorsImageUrls:[void 0]},d=[{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Consequences",id:"consequences",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"status",children:"Status"}),"\n",(0,s.jsx)(n.p,{children:"Accepted"}),"\n",(0,s.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,s.jsx)(n.p,{children:"When testing out hydra-node operation under heavy or increased load we are\nnoticing that memory consumption is far from ideal. So far we didn't bother\nthinking about the performance so much but time has come to try and reduce\nmemory footprint of a running hydra-node."}),"\n",(0,s.jsx)(n.p,{children:"There are some quick points to be scored here since our projections that are\nused to serve in-memory data are using a common haskell list as a data\nstructure. We should stream the data keeping the memory bounded as the first\noptimisation."}),"\n",(0,s.jsxs)(n.p,{children:["It is also not necessary to output the whole history of messages by default and\nonly do that if clients request to see the whole history. Internally our\n",(0,s.jsx)(n.code,{children:"ServerOutput"})," type could be remapped to ",(0,s.jsx)(n.code,{children:"StateChanged"})," since the two are\nalmost identical. Any new information must be streamed to the clients\nautomatically."]}),"\n",(0,s.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Re-map ",(0,s.jsx)(n.code,{children:"ServerOutput"})," to ",(0,s.jsx)(n.code,{children:"StateChanged"})," by adding any missing constructor to ",(0,s.jsx)(n.code,{children:"StateChanged"})," (eg. ",(0,s.jsx)(n.code,{children:"PeerConnected"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:["Output new client messages on ",(0,s.jsx)(n.code,{children:"newState"})," changes instead of using ",(0,s.jsx)(n.code,{children:"ClientEffect"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"StateChanged"})," in all projections we server from the API (re-use ",(0,s.jsx)(n.code,{children:"eventId"})," as sequence number)."]}),"\n",(0,s.jsx)(n.li,{children:"Make hydra-node output history of messages only on demand (breaking change is to be communicated in the changelog)."}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"conduit"})," library to achieve constant memory by streaming the data in our projections."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,s.jsxs)(n.p,{children:["This should lead to much better performance of hydra-node in terms of used\nmemory for the running process. This should be also confirmed by running the\nrelevant ",(0,s.jsx)(n.a,{href:"https://github.com/cardano-scaling/hydra/issues/1724",children:"benchmarks"})," and\ndo a test (even manual or a script) to assert that the memory consumption is\nactually reduced."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var o=t(96540);const s={},r=o.createContext(s);function a(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(r.Provider,{value:n},e.children)}},74849:e=>{e.exports=JSON.parse('{"permalink":"/head-protocol/unstable/adr/31","source":"@site/adr/2024-01-27_031-constant-memory.md","title":"31. Achieve constant memory in hydra-node\\n","description":"Status","date":"2024-01-27T00:00:00.000Z","tags":[{"inline":true,"label":"Accepted","permalink":"/head-protocol/unstable/adr/tags/accepted"}],"readingTime":1.345,"hasTruncateMarker":false,"authors":[{"name":"Sasha Bogicevic","title":"Senior Software Engineer","url":"https://github.com/v0d1ch","imageURL":"https://github.com/v0d1ch.png","key":"v0d1ch","page":null}],"frontMatter":{"slug":"31","title":"31. Achieve constant memory in hydra-node\\n","authors":["v0d1ch"],"tags":["Accepted"]},"unlisted":false,"prevItem":{"title":"30. Use CBOR in external representation of Cardano transactions\\n","permalink":"/head-protocol/unstable/adr/30"},"nextItem":{"title":"32. Network layer properties, implementation using etcd\\n","permalink":"/head-protocol/unstable/adr/32"}}')}}]);