"use strict";(self.webpackChunkhydra_head_protocol_docs=self.webpackChunkhydra_head_protocol_docs||[]).push([[3091],{76020:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>l});var t=i(69795),s=i(74848),a=i(28453);const d={slug:26,title:"26. Stateless transaction observation & construction\n",authors:["ch1bo"],tags:["Proposed"]},c=void 0,r={authorsImageUrls:[void 0]},l=[{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Changes internal to Direct chain layer",id:"changes-internal-to-direct-chain-layer",level:3},{value:"Chain interface changes",id:"chain-interface-changes",level:3},{value:"Consequences",id:"consequences",level:2}];function o(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"status",children:"Status"}),"\n",(0,s.jsx)(n.p,{children:"Proposed"}),"\n",(0,s.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/adr/18",children:"ADR 18"})," merged both ",(0,s.jsx)(n.code,{children:"headState"})," and ",(0,s.jsx)(n.code,{children:"chainState"})," into one single\nstate in the Hydra node, giving the chain layer a way to ",(0,s.jsx)(n.em,{children:"fetch"})," and update\nthe ",(0,s.jsx)(n.code,{children:"chainState"})," when observing a chain event."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/adr/23",children:"ADR 23"})," outlined the need for a local chain state in the chain layer\nagain to correctly handle correct observation of multiple relevant\ntransactions and the resulting ",(0,s.jsx)(n.code,{children:"chainState"})," updates."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"ChainStateType tx"}),' for our "actual" Cardano chain layer is currently:']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-haskell",children:"data ChainStateAt = ChainStateAt\n  { chainState :: ChainState\n  , recordedAt :: Maybe ChainPoint\n  }\n\ndata ChainState\n  = Idle\n  | Initial InitialState\n  | Open OpenState\n  | Closed ClosedState\n"})}),"\n",(0,s.jsxs)(n.p,{children:["where ",(0,s.jsx)(n.code,{children:"InitialState"}),", ",(0,s.jsx)(n.code,{children:"OpenState"})," and ",(0,s.jsx)(n.code,{children:"ClosedState"})," hold elaborate information\nabout the currently tracked Hydra head."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["We face ",(0,s.jsx)(n.a,{href:"https://github.com/cardano-scaling/hydra/issues/529",children:"difficulties"})," to\nprovide sufficient user feedback when an ",(0,s.jsx)(n.code,{children:"initTx"})," was observed but (for\nexample) keys do not match our expectation."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Core problem is, that ",(0,s.jsx)(n.code,{children:"observeInit"}),' is required to take a decision whether\nit wants to "adopt" the Head by returning an ',(0,s.jsx)(n.code,{children:"InitialState"})," or not."]}),"\n",(0,s.jsxs)(n.li,{children:["This makes it impossible to provide user feedback through the ",(0,s.jsx)(n.code,{children:"HeadLogic"}),"\nand ",(0,s.jsx)(n.code,{children:"API"})," layers."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["We want to build a ",(0,s.jsx)(n.a,{href:"https://github.com/cardano-scaling/hydra/issues/696",children:"Hydra head\nexplorer"}),", which should\nbe able to keep track and discover Hydra heads and their state changes even\nwhen the heads were initialized before starting the explorer."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["We supersede ",(0,s.jsx)(n.a,{href:"/adr/18",children:"ADR 18"})," with the current ADR."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"changes-internal-to-direct-chain-layer",children:"Changes internal to Direct chain layer"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Introduce a ",(0,s.jsx)(n.code,{children:"ResolvedTx"})," type that has its inputs resolved. Where a normal\n",(0,s.jsx)(n.code,{children:"Tx"})," will only contain ",(0,s.jsx)(n.code,{children:"TxIn"})," information of its inputs, a ",(0,s.jsx)(n.code,{children:"ResolvedTx"})," also\nincludes the ",(0,s.jsx)(n.code,{children:"TxOut"})," for each input."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Change ",(0,s.jsx)(n.code,{children:"ChainSyncHandler"})," signature to ",(0,s.jsx)(n.code,{children:"onRollForward :: BlockHeader -> [ResolvedTx] -> m ()"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Change observing function signature to ",(0,s.jsx)(n.code,{children:"observeSomeTx :: ChainContext -> ResolvedTx -> Maybe (OnChainTx Tx)"}),". Notably there is no ",(0,s.jsx)(n.code,{children:"ChainState"}),"\ninvolved."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Do not guard observation by ",(0,s.jsx)(n.code,{children:"HeadId"})," in the chain layer and instead do it in the ",(0,s.jsx)(n.code,{children:"HeadLogic"})," layer."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Define a ",(0,s.jsx)(n.code,{children:"SpendableUTxO"})," type that is a ",(0,s.jsx)(n.code,{children:"UTxO"})," with potentially needed datums included."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["TBD: instead we could decide to use inline datums and rely on ",(0,s.jsx)(n.code,{children:"UTxO"})," containing them"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Change transaction creation functions ",(0,s.jsx)(n.code,{children:"initialize"}),", ",(0,s.jsx)(n.code,{children:"commit"}),", ",(0,s.jsx)(n.code,{children:"abort"}),",\n",(0,s.jsx)(n.code,{children:"collect"}),", ",(0,s.jsx)(n.code,{children:"close"}),", ",(0,s.jsx)(n.code,{children:"contest"})," and ",(0,s.jsx)(n.code,{children:"fanout"})," in ",(0,s.jsx)(n.code,{children:"Hydra.Direct.Chain.State"})," to\ntake ",(0,s.jsx)(n.code,{children:"SpendableUTxO"})," and ",(0,s.jsx)(n.code,{children:"HeadId"}),"/",(0,s.jsx)(n.code,{children:"HeadParameters"})," as needed."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Extend ",(0,s.jsx)(n.code,{children:"IsChainState"})," type class to enforce that it can be updated by\nconcurrent transactions ",(0,s.jsx)(n.code,{children:"update :: ChainStateType tx -> [tx] -> ChainStateType tx"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'While this is not strictly needed "outside" of the chain layer, it will have\nus not fall into the same pit again.'}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Change ",(0,s.jsx)(n.code,{children:"ChainStateAt"})," to only hold a ",(0,s.jsx)(n.code,{children:"spendableUTxO"})," and the ",(0,s.jsx)(n.code,{children:"recordedAt"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Update the ",(0,s.jsx)(n.code,{children:"LocalChainState"})," in ",(0,s.jsx)(n.code,{children:"onRollForward"})," by using ",(0,s.jsx)(n.code,{children:"update"})," and pushing\na new ",(0,s.jsx)(n.code,{children:"ChainStateAt"})," generically."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"TBD:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Impact on generators"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"chain-interface-changes",children:"Chain interface changes"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Add ",(0,s.jsx)(n.code,{children:"HeadId"})," and ",(0,s.jsx)(n.code,{children:"HeadParameters"})," to ",(0,s.jsx)(n.code,{children:"PostChainTx"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Add ",(0,s.jsx)(n.code,{children:"HeadId"})," to all ",(0,s.jsx)(n.code,{children:"OnChainTx"})," constructors."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Extend ",(0,s.jsx)(n.code,{children:"OnInitTx"})," with observed chain participants."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["TBD: How are ",(0,s.jsx)(n.em,{children:"cardano"})," verification keys generically represented in ",(0,s.jsx)(n.code,{children:"HeadLogic"}),"?"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Extend ",(0,s.jsx)(n.code,{children:"OnContestTx"})," with new deadline and a list of contesters."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:['Move off-chain checks for what makes a "proper head" to ',(0,s.jsx)(n.code,{children:"HeadLogic"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"TBD:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Merge ",(0,s.jsx)(n.code,{children:"HeadSeed"})," and ",(0,s.jsx)(n.code,{children:"HeadId"}),"? How to abstract?"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"All logic is kept in the logic layer and no protocol decisions (i.e. whether\nto adopt or ignore a head initialization) are taken in the chain layer."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"HeadLogic"})," gets informed of any proper ",(0,s.jsx)(n.code,{children:"initTx"})," and can log that it is\nignored and for what reason."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:'The transaction observation and construction functions can be moved into a\ndedicated package that is cardano-specific, but not requires special state\nknowledge of the "direct chain following" and can be re-used as a library.'}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["All transaction observation functions used by ",(0,s.jsx)(n.code,{children:"observeSomeTx"})," will need to be\nable to identify a Hydra Head transaction from only the ",(0,s.jsx)(n.code,{children:"ResolvedTx"})," and the\n",(0,s.jsx)(n.code,{children:"ChainContext"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Any ",(0,s.jsx)(n.code,{children:"Chain Tx"})," implementation wanting to re-use existing transaction\nobservation functions must be able to resolve transaction inputs (against some\nledger state) and produce ",(0,s.jsx)(n.code,{children:"ResolvedTx"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A chain-following implementation (as ",(0,s.jsx)(n.code,{children:"Hydra.Chain.Direct"}),") can keep previous\ntransactions around."]}),"\n",(0,s.jsx)(n.li,{children:'A chain indexer on "interesting" protocol addresses can be used to\nefficiently query most inputs.'}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["We can get rid of the ",(0,s.jsx)(n.code,{children:"Hydra.Chain.Direct.State"})," glue code altogether."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["While this does not directly supersede ",(0,s.jsx)(n.a,{href:"/adr/23",children:"ADR23"}),", it paves the way to\nremove ",(0,s.jsx)(n.code,{children:"LocalChainState"})," again as the ",(0,s.jsx)(n.code,{children:"ChainStateAt"})," is now combinable from\nmultiple transactions (see ",(0,s.jsx)(n.code,{children:"update"})," above) and we can keep the state (again)\nonly in the ",(0,s.jsx)(n.code,{children:"HeadState"})," aggregate. Note that this would shift the rollback\nhandling back into the logic layer."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>c});var t=i(96540);const s={},a=t.createContext(s);function d(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),t.createElement(a.Provider,{value:n},e.children)}},69795:e=>{e.exports=JSON.parse('{"permalink":"/head-protocol/unstable/adr/26","source":"@site/adr/2023-09-08_026-stateless-observation-construction.md","title":"26. Stateless transaction observation & construction\\n","description":"Status","date":"2023-09-08T00:00:00.000Z","tags":[{"inline":true,"label":"Proposed","permalink":"/head-protocol/unstable/adr/tags/proposed"}],"readingTime":3.74,"hasTruncateMarker":false,"authors":[{"name":"Sebastian Nagel","title":"Software Engineering Lead","url":"https://github.com/ch1bo","imageURL":"https://github.com/ch1bo.png","key":"ch1bo","page":null}],"frontMatter":{"slug":"26","title":"26. Stateless transaction observation & construction\\n","authors":["ch1bo"],"tags":["Proposed"]},"unlisted":false,"prevItem":{"title":"25. Event-sourced, resource-based API\\n","permalink":"/head-protocol/unstable/adr/25"},"nextItem":{"title":"27. Network failures model\\n","permalink":"/head-protocol/unstable/adr/27"}}')}}]);