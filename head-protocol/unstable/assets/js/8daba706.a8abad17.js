"use strict";(self.webpackChunkhydra_head_protocol_docs=self.webpackChunkhydra_head_protocol_docs||[]).push([[3356],{89720:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"dev/protocol","title":"Protocol","description":"Additional implementation-specific documentation for the Hydra Head protocol and extensions like incremental decommits.","source":"@site/docs/dev/protocol.md","sourceDirName":"dev","slug":"/dev/protocol","permalink":"/head-protocol/unstable/docs/dev/protocol","draft":false,"unlisted":false,"editUrl":"https://github.com/cardano-scaling/hydra/tree/master/docs/docs/dev/protocol.md","tags":[],"version":"current","frontMatter":{},"sidebar":"developerDocumentation","previous":{"title":"Specification","permalink":"/head-protocol/unstable/docs/dev/specification"},"next":{"title":"Commit funds to a Head","permalink":"/head-protocol/unstable/docs/dev/commit"}}');var o=i(74848),s=i(28453);const d={},a="Protocol",r={},c=[{value:"General notes on incremental commits/decommits",id:"general-notes-on-incremental-commitsdecommits",level:2},{value:"Incremental commits",id:"incremental-commits",level:2},{value:"Deposit flow",id:"deposit-flow",level:3},{value:"Tracking deposits",id:"tracking-deposits",level:3},{value:"Recover flow",id:"recover-flow",level:3},{value:"Rollback resistance",id:"rollback-resistance",level:3},{value:"Incremental decommits",id:"incremental-decommits",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",mermaid:"mermaid",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"protocol",children:"Protocol"})}),"\n",(0,o.jsx)(n.p,{children:"Additional implementation-specific documentation for the Hydra Head protocol and extensions like incremental decommits."}),"\n",(0,o.jsx)(n.h2,{id:"general-notes-on-incremental-commitsdecommits",children:"General notes on incremental commits/decommits"}),"\n",(0,o.jsxs)(n.p,{children:["Especially, incremental commit and decommit are additions to the originally researched ",(0,o.jsx)(n.a,{href:"https://eprint.iacr.org/2020/299.pdf",children:"Hydra Head protocol"})," and deserve more explanation how they work under the hood."]}),"\n",(0,o.jsx)(n.p,{children:"For now these two new additions run sequentially so we are doing one thing at a time, at least for now, while we will think about batching certain actions in the future if the need for that arises."}),"\n",(0,o.jsx)(n.p,{children:"It is only possible to either commit or decommit - we don't allow snapshots with both fields specified for simplicity. This restriction might be lifted later on - once we are sure this simpler version works nicely."}),"\n",(0,o.jsx)(n.h2,{id:"incremental-commits",children:"Incremental commits"}),"\n",(0,o.jsxs)(n.p,{children:["Incremental commits allow anyone to lock up ",(0,o.jsx)(n.code,{children:"UTxO"})," from L1 and make it available on L2 for transacting inside of a running Hydra Head. For a user, the process of doing an incremental commit is very similar to doing a normal commit before the Head is in the ",(0,o.jsx)(n.code,{children:"Open"})," state. From a protocol standpoint though, the process is quite different as it requires users to first lock up funds in a ",(0,o.jsx)(n.code,{children:"deposit"})," transaction before the head can collect it in an ",(0,o.jsx)(n.code,{children:"incrementTx"}),". Should the depositted UTxO not be collected, a user can recover their funds in a ",(0,o.jsx)(n.code,{children:"recoverTx"}),"."]}),"\n",(0,o.jsx)(n.mermaid,{value:"stateDiagram\n    [*] --\x3e Depositted : depositTx\n    Depositted --\x3e Incremented : incrementTx\n    Depositted --\x3e Recovered : recoverTx"}),"\n",(0,o.jsx)(n.h3,{id:"deposit-flow",children:"Deposit flow"}),"\n",(0,o.jsxs)(n.p,{children:["The nominal case of depositing and later incrementing funds starts with a user request to ",(0,o.jsx)(n.code,{children:"POST /commit"}),", which will draft a ",(0,o.jsx)(n.code,{children:"depositTx"})," analogously what users know from the normal commit workflow."]}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"/head-protocol/unstable/docs/dev/commit",children:"commit"})," for more details about the commit API."]})}),"\n",(0,o.jsxs)(n.p,{children:["A successful API response includes a ",(0,o.jsx)(n.code,{children:"depositTx"})," that needs to be signed and submitted by the user in order to lock the specified ",(0,o.jsx)(n.code,{children:"UTxO"})," at a deposit script address. The ",(0,o.jsx)(n.code,{children:"hydra-node"})," of all participants will observe the deposit transaction and the snapshot leader ",(0,o.jsx)(n.em,{children:"should"})," request inclusion of the UTxO via a snapshot. With this snapshot an ",(0,o.jsx)(n.code,{children:"incrementTx"})," can be posted that will update the Head state ",(0,o.jsx)(n.code,{children:"UTxO"})," on L1 and upon observing this make the committed ",(0,o.jsx)(n.code,{children:"UTxO"})," available on L2."]}),"\n",(0,o.jsxs)(n.p,{children:["The overall sequence diagram of a deposit and later increment across the ",(0,o.jsx)(n.code,{children:"hydra-node"}),":"]}),"\n",(0,o.jsx)(n.mermaid,{value:"sequenceDiagram\n    Alice->>+Node A: POST /commit UTxO\n    Node A--\x3e>-Alice: depositTx\n\n    Alice ->> Alice: sign depositTx\n    Alice ->> Chain: submit depositTx\n\n    Chain ->>+ Node A: OnDepositTx utxo\n    Chain ->>+ Node B: OnDepositTx utxo\n\n    Node A --\x3e> Alice: CommitRecorded\n\n    par Alice isLeader\n        Node A->>Node A: ReqSn utxoToCommit\n    and\n        Node A->>Node B: ReqSn utxoToCommit\n    end\n\n    Node A->>Node A: sig = sign snapshot incl. utxoToCommit\n\n    par broadcast\n        Node A->>Node A: AckSn sig\n    and\n        Node A->>Node B: AckSn sig\n    end\n    Node B->>Node A: AckSn sig\n    Node A --\x3e> Alice: SnapshotConfirmed\n\n    Node A --\x3e> Alice: CommitApproved\n\n    Node A ->> Chain: IncrementTx snapshot sig\n    Chain ->> Node A: OnIncrementTx\n    Node A --\x3e> Alice: CommitFinalized"}),"\n",(0,o.jsx)(n.h3,{id:"tracking-deposits",children:"Tracking deposits"}),"\n",(0,o.jsx)(n.p,{children:"Once a hydra-node observes a deposit transaction it will record the deposit as pending in its local state. There can be many pending deposits but the new Snapshot will include them one by one."}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsx)(n.p,{children:"Note that any node that posts increment transaction will also pay the fees even if the deposit will not be owned by them on L2."})}),"\n",(0,o.jsx)(n.p,{children:"Upon observing increment transaction we remove the corresponding deposit from the local pending deposits and the process can start again."}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["Since we can potentially request many deposits, the leader will increment only one of them. While others stay pending. An honest snapshot leader ",(0,o.jsx)(n.em,{children:"should"})," consider all pending deposit and try to include it in a snapshot."]})}),"\n",(0,o.jsxs)(n.p,{children:["To avoid potential races between observing the ",(0,o.jsx)(n.code,{children:"depositTx"})," and adding the funds via an ",(0,o.jsx)(n.code,{children:"incrementTx"})," to the Head, each deposit locks up funds until a ",(0,o.jsx)(n.strong,{children:"deposit deadline"}),". If that deposit deadline is sufficiently far enough in the future, a ",(0,o.jsx)(n.code,{children:"hydra-node"})," will be picking up the deposit. Users, however, may only ",(0,o.jsx)(n.a,{href:"#recover-flow",children:"recover"})," the funds ",(0,o.jsx)(n.em,{children:"after"})," the deadline has passed."]}),"\n",(0,o.jsx)(n.h3,{id:"recover-flow",children:"Recover flow"}),"\n",(0,o.jsxs)(n.p,{children:["If a deposit was not picked up by the head participants, the user can recover their funds ",(0,o.jsx)(n.em,{children:"after the deposit deadline"})," by sending a ",(0,o.jsx)(n.code,{children:"DELETE /commits/<tx-id>"})," request to the ",(0,o.jsx)(n.code,{children:"hydra-node"}),". This will trigger a ",(0,o.jsx)(n.code,{children:"recoverTx"})," to be created and submitted to the L1 chain."]}),"\n",(0,o.jsx)(n.mermaid,{value:"sequenceDiagram\n    Alice->>+Node A: DELETE /commits/<tx-id>\n    Node A->>Chain: recoverTx\n    Chain ->>+ Node A: OnRecoverTx utxo\n    Chain ->>+ Node B: OnRecoverTx utxo\n    Node A --\x3e>- Alice: CommitRecovered\n    Node B --\x3e>- Bob: CommitRecovered\n    Node A--\x3e>-Alice: OK\n"}),"\n",(0,o.jsx)(n.h3,{id:"rollback-resistance",children:"Rollback resistance"}),"\n",(0,o.jsxs)(n.p,{children:["In a perfect world the processes as explained above would be sufficient. However, the Cardano L1 is evolved using a probabilistic consensus algorithm and ",(0,o.jsx)(n.a,{href:"./rollbacks",children:"rollbacks"})," need to be considered."]}),"\n",(0,o.jsx)(n.p,{children:"Lets consider this example scenario of depositing funds into a head as an L1 transaction trace with L2 snapshots:"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:i(42098).A+"",width:"841",height:"576"})}),"\n",(0,o.jsxs)(n.p,{children:['The biggest risk of chain re-organization attacks, which would be "adversarial rollbacks", comes from an attacker to be able to trick an honest ',(0,o.jsx)(n.code,{children:"hydra-node"})," into making a funds on the L2 available which are in fact not locked up on the L1; i.e. a double spend of deposited funds."]}),"\n",(0,o.jsxs)(n.p,{children:["As indicated on the transaction trace example above, a successful incremental commit consists of two sequential L1 transactions: ",(0,o.jsx)(n.code,{children:"depositTx"})," and ",(0,o.jsx)(n.code,{children:"incrementTx"}),". Malicious rollbacks and double spending of their inputs need to be considered."]}),"\n",(0,o.jsxs)(n.p,{children:["For ",(0,o.jsx)(n.code,{children:"incrementTx"}),", the input is governed by the deposit validator which ensures funds can only be spent into the destined head before the ",(0,o.jsx)(n.strong,{children:"deposit deadline"})," (by anyone using a ",(0,o.jsx)(n.code,{children:"recoverTx"})," after the deadline). Hence, any rollbacks ",(0,o.jsx)(n.em,{children:"before"})," this deadline can be mitigated by re-submitting the same (or a new) ",(0,o.jsx)(n.code,{children:"incrementTx"}),". It is vital though, that the deadline is ",(0,o.jsx)(n.em,{children:"far enough"})," in the future to not be prone to yet more chain re-organization and run out of time mitigating eventually. As the deposit deadline is only relevant for the pessimistic case, we can pick fairly ",(0,o.jsx)(n.em,{children:"high values"})," without affecting user experience. For example: ",(0,o.jsx)(n.strong,{children:"1 week"}),", equating to roughly 5x the worst case settlement time of Cardano."]}),"\n",(0,o.jsxs)(n.p,{children:["For ",(0,o.jsx)(n.code,{children:"depositTx"}),", the inputs may very well be spent by an attacker and an honest ",(0,o.jsx)(n.code,{children:"hydra-node"})," should be cautious in observing a deposit as settled before signing a snapshot that authorizes addition of those funds to the L2 state. To mitigate this, a ",(0,o.jsx)(n.strong,{children:"deposit period"})," analogous to the contestation period of close/contest phase is introduced. A valid deposit must have an upper validity to indicate when it was created (at latest) and record the deposit deadline in the output datum (see ",(0,o.jsx)(n.a,{href:"/head-protocol/unstable/docs/dev/specification",children:"specification"}),"). An honest ",(0,o.jsx)(n.code,{children:"hydra-node"})," will only consider deposits that are ",(0,o.jsx)(n.strong,{children:"older"})," than the deposit period and when the deadline is ",(0,o.jsx)(n.strong,{children:"further out"})," than the deposit period. While the deposit period will delay all increments by at least that time, a ",(0,o.jsx)(n.code,{children:"hydra-node"})," can configure the risk it is willing to take using this period. For example: ",(0,o.jsx)(n.strong,{children:"1 hour"})," means that roughly after 180 blocks on ",(0,o.jsx)(n.code,{children:"mainnet"})," we would only see a rollback including the ",(0,o.jsx)(n.code,{children:"depositTx"})," with ",(0,o.jsx)(n.code,{children:"0.01%"})," likelihood, assuming a ",(0,o.jsx)(n.code,{children:"15%"})," adversarial stake fairly conservative grinding power. See ",(0,o.jsx)(n.a,{href:"https://aiken-lang.org/fundamentals/what-i-wish-i-knew#transaction-latency-vs-finality",children:"this excellent explanation and calculator"})," in the Aiken docs."]}),"\n",(0,o.jsxs)(n.p,{children:["In summary, a deposit may only be picked up while ",(0,o.jsx)(n.code,{children:"Active"})," in the following deposit life cycle:"]}),"\n",(0,o.jsx)(n.mermaid,{value:"stateDiagram\n    direction LR\n    [*] --\x3e Inactive : observeDepositTx{depositTime}\n    Inactive --\x3e Active : Tick{chainTime} > depositTime + depositPeriod\n    Active --\x3e Expired : Tick{chainTime} > deadline - depositPeriod\n    Inactive --\x3e Expired : Tick{chainTime} > deadline - depositPeriod\n    Active --\x3e [*] : incrementTx\n    Expired --\x3e [*] : recoverTx"}),"\n",(0,o.jsx)(n.h2,{id:"incremental-decommits",children:"Incremental decommits"}),"\n",(0,o.jsxs)(n.p,{children:["Incremental decommits allow us to take some L2 ",(0,o.jsx)(n.code,{children:"UTxO"})," and bring it to the L1 while the Head protocol is running."]}),"\n",(0,o.jsxs)(n.p,{children:["Users of a Hydra head can request decommits UTxO from L1 by sending a ",(0,o.jsx)(n.code,{children:"POST /decommit"})," request with a so-called ",(0,o.jsx)(n.strong,{children:"decommit transaction"})," in the request body. Hydra node validates this transaction by applying it to its local ",(0,o.jsx)(n.code,{children:"UTxO"})," set. If it applies, it will broadcast a ",(0,o.jsx)(n.code,{children:"ReqDec"})," message signalling to other parties that we want to produce a new ",(0,o.jsx)(n.code,{children:"Snapshot"})," that contains the same ",(0,o.jsx)(n.code,{children:"UTxO"})," to decommit. The snapshot leader may request such a snapshot and once it is signed by everyone, any of the participant nodes posts a ",(0,o.jsx)(n.code,{children:"decrementTx"})," that will produce a corresponding output on the L1."]}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsx)(n.p,{children:"The decommit transaction is necessary to prove to the head participants that the decommitted UTxO can be spent by the requestor."})}),"\n",(0,o.jsx)(n.p,{children:"As the decommit is first decided on the L2 with full consensus and no honest node would approve further spending of funds to be decommitted, we do not need to specially consider rollbacks in this scenario."}),"\n",(0,o.jsx)(n.mermaid,{value:"sequenceDiagram\n    Alice->>+Node A: POST /decommit (decTx)\n    Node A--\x3e>-Alice: OK\n\n    Node A->>Node A: canApply decTx\n\n    par broadcast\n        Node A->>Node A: ReqDec decTx\n    and\n        Node A->>Node B: ReqDec decTx\n    end\n\n    Node A --\x3e> Alice: DecommitRequested\n\n    par Alice isLeader\n        Node A->>Node A: ReqSn decTx\n    and\n        Node A->>Node B: ReqSn decTx\n    end\n\n    Node A->>Node A: canApply decTx, decUTxO =  outputs(decTx)\n    Node A->>Node A: sig = sign snapshot incl. decUTxO\n\n    par broadcast\n        Node A->>Node A: AckSn sig\n    and\n        Node A->>Node B: AckSn sig\n    end\n\n    Node B->>Node A: AckSn sig\n\n    Node A --\x3e> Alice: SnapshotConfirmed\n    Node A --\x3e> Alice: DecommitApproved\n\n    Node A ->> Chain: DecrementTx snapshot sig\n    Chain ->> Node A: OnDecrementTx\n    Node A --\x3e> Alice: DecommitFinalized"})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},42098:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/deposit-increment-a27ac32d371e5d5b6e6416efa023977f.svg"},28453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>a});var t=i(96540);const o={},s=t.createContext(o);function d(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:d(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);