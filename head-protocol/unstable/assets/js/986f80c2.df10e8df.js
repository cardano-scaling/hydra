"use strict";(self.webpackChunkhydra_head_protocol_docs=self.webpackChunkhydra_head_protocol_docs||[]).push([[3483],{67461:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});var i=t(79289),s=t(74848),o=t(28453);const r={slug:21,title:"21. Bounded transaction validity on Hydra protocol transactions\n",authors:["ch1bo","pgrange","ffakenz","abailly","v0d1ch"],tags:["Accepted"]},c=void 0,a={authorsImageUrls:[void 0,void 0,void 0,void 0,void 0]},d=[{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Current state of things:",id:"current-state-of-things",level:4},{value:"What we want to achieve:",id:"what-we-want-to-achieve",level:4},{value:"Decision",id:"decision",level:2},{value:"Consequences",id:"consequences",level:2}];function l(e){const n={code:"code",em:"em",h2:"h2",h4:"h4",input:"input",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"status",children:"Status"}),"\n",(0,s.jsx)(n.p,{children:"Accepted"}),"\n",(0,s.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The HydraHeadV1 formal specification contains a ",(0,s.jsx)(n.em,{children:"bounded confirmation window"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// Deadline\n\nT_max <= T_min + L // Bounded confirmation window\nDL\u2019 = T_max + L    // The latest possible deadline is 2*L\n\n"})}),"\n",(0,s.jsxs)(n.p,{children:["with ",(0,s.jsx)(n.code,{children:"T_min"})," and ",(0,s.jsx)(n.code,{children:"T_max"})," being the tx validity bounds and ",(0,s.jsx)(n.code,{children:"L"})," being the\ncontestation period."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"This is to avoid attacks with specified upper validity bound being too far\nin the future and denial of service the head with this (e.g. 10 years)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"current-state-of-things",children:"Current state of things:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"The contestation period and upper tx validity is used for computing the\ncontestation deadline."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["There is a ",(0,s.jsx)(n.code,{children:"closeGraceTime"})," currently hard-coded (to ",(0,s.jsx)(n.code,{children:"100"})," slots) to set some\nupper bound on the ",(0,s.jsx)(n.code,{children:"closeTx"}),". This was also required so far to compute the\ncontestation deadline."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Different networks (chains) have different slot lengths, e.g. the preview\nnetwork has a slot every ",(0,s.jsx)(n.code,{children:"1s"}),", while our local devnets use ",(0,s.jsx)(n.code,{children:"0.1s"}),". This means\nhardcoded values like ",(0,s.jsx)(n.code,{children:"closeGraceTime"})," need to be ",(0,s.jsx)(n.em,{children:"in sync"})," with the\nunderlying network."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"contestationPeriod"})," can be configured by users via the ",(0,s.jsx)(n.code,{children:"Init"})," client\ninput. For example, the hydra-cluster test suite uses a hardcoded ",(0,s.jsx)(n.code,{children:"cperiod"})," on\nthe client side."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Default value for ",(0,s.jsx)(n.code,{children:"T_Min"})," is negative infinity."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Lower tx validity being in the future does not pose a problem since other\nparticipant is able to close a head."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"what-we-want-to-achieve",children:"What we want to achieve:"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"We want to enforce topmost formula in this file in our code on-chain."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Introduce ",(0,s.jsx)(n.code,{children:"maxGraceTime"})," expressed in seconds in place of ",(0,s.jsx)(n.code,{children:"closeGraceTime"})," and adjust to\nappropriate value."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The contestation period is to be used to create bounded close transaction\n(together with ",(0,s.jsx)(n.code,{children:"maxGraceTime"}),"). Before it was only used for computing the\ncontestation deadline."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","If contestation period is higher than ",(0,s.jsx)(n.code,{children:"maxGraceTime"})," we will pick the\nlatter. We still need ",(0,s.jsx)(n.code,{children:"maxGraceTime"})," since if ",(0,s.jsx)(n.code,{children:"contestationPeriod"})," is low for\nthe current network our txs reach the upper bound fast and become invalid.\nThat is why we set the upper tx bound to be minimum between\n",(0,s.jsx)(n.code,{children:"contestationPeriod"})," and ",(0,s.jsx)(n.code,{children:"maxGraceTime"})," so that txs have high enough upper\nbound."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Make sure all head participants use the same value for ",(0,s.jsx)(n.code,{children:"contestationPeriod"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Attack vector has a corresponding mutation test."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Use the specification formula on-chain."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Configure the contestation period (number of seconds) on the ",(0,s.jsx)(n.code,{children:"hydra-node"}),",\ne.g. via a ",(0,s.jsx)(n.code,{children:"--contestation-period"})," command line option."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Lower tx bound should be the last known slot as reported by the\n",(0,s.jsx)(n.code,{children:"cardano-node"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Upper tx bound is the current time + minimum between ",(0,s.jsx)(n.code,{children:"contestationPeriod"})," and\n",(0,s.jsx)(n.code,{children:"maxGraceTime"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["When submitting the ",(0,s.jsx)(n.code,{children:"InitTx"})," make sure to use ",(0,s.jsx)(n.code,{children:"--contestation-period"})," value\nfrom our node's flag."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["If other nodes observe ",(0,s.jsx)(n.code,{children:"OnInitTx"})," and the ",(0,s.jsx)(n.code,{children:"contestationPeriod"})," value does not\nmatch with their ",(0,s.jsx)(n.code,{children:"--contestation-period"})," setting - ignore ",(0,s.jsx)(n.code,{children:"InitTx"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Rename ",(0,s.jsx)(n.code,{children:"closeGraceTime"})," to ",(0,s.jsx)(n.code,{children:"maxGraceTime"})," since we are using it also for upper\nbound of a contest tx."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Not any positive number of seconds is a valid contestation period any more!"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Upper tx validity of close transaction is the minimum between ",(0,s.jsx)(n.code,{children:"maxGraceTime"}),"\nand ",(0,s.jsx)(n.code,{children:"contestationPeriod"})," and this needs to be ",(0,s.jsx)(n.em,{children:"good enough"})," value with respect\nto running network. This is a consequence required by the ledger when\nconstructing transactions since we cannot convert arbitrary point in times to\nslots."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"All parties need to agree on contestation period before trying to run a Head\nprotocol otherwise InitTx will be ignored."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var i=t(96540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}},79289:e=>{e.exports=JSON.parse('{"permalink":"/head-protocol/unstable/adr/21","source":"@site/adr/2022-12-05_021-Bounded-transaction-validity-on-Hydra-protocol-transactions.md","title":"21. Bounded transaction validity on Hydra protocol transactions\\n","description":"Status","date":"2022-12-05T00:00:00.000Z","tags":[{"inline":true,"label":"Accepted","permalink":"/head-protocol/unstable/adr/tags/accepted"}],"readingTime":2.81,"hasTruncateMarker":false,"authors":[{"name":"Sebastian Nagel","title":"Software Engineering Lead","url":"https://github.com/ch1bo","imageURL":"https://github.com/ch1bo.png","key":"ch1bo","page":null},{"name":"Pascal Grange","title":"Senior Software Engineer","url":"https://github.com/pgrange","imageURL":"https://github.com/pgrange.png","key":"pgrange","page":null},{"name":"Franco Testagrossa","title":"Senior Software Engineer","url":"https://github.com/ffakenz","imageURL":"https://github.com/ffakenz.png","key":"ffakenz","page":null},{"name":"Arnaud Bailly","title":"Lead Architect","url":"https://github.com/abailly-iohk","imageURL":"https://github.com/abailly-iohk.png","key":"abailly","page":null},{"name":"Sasha Bogicevic","title":"Senior Software Engineer","url":"https://github.com/v0d1ch","imageURL":"https://github.com/v0d1ch.png","key":"v0d1ch","page":null}],"frontMatter":{"slug":"21","title":"21. Bounded transaction validity on Hydra protocol transactions\\n","authors":["ch1bo","pgrange","ffakenz","abailly","v0d1ch"],"tags":["Accepted"]},"unlisted":false,"prevItem":{"title":"20. Handling time\\n","permalink":"/head-protocol/unstable/adr/20"},"nextItem":{"title":"22. Test High-level Properties using Model-Based Testing\\n","permalink":"/head-protocol/unstable/adr/22"}}')}}]);