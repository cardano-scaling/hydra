"use strict";(self.webpackChunkhydra_head_protocol_docs=self.webpackChunkhydra_head_protocol_docs||[]).push([[8605],{63425:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>s,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"other/poker-game/index","title":"Poker game","description":"The poker game is a prototypical example of a multi-party state channel.","source":"@site/use-cases/other/poker-game/index.md","sourceDirName":"other/poker-game","slug":"/other/poker-game/","permalink":"/head-protocol/unstable/use-cases/other/poker-game/","draft":false,"unlisted":false,"editUrl":"https://github.com/cardano-scaling/hydra/tree/master/docs/use-cases/other/poker-game/index.md","tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"Lightning network payments","permalink":"/head-protocol/unstable/use-cases/payments/lighting-network-like-payments/"}}');var o=a(74848),r=a(28453);const s={},i="Poker game",c={},h=[];function d(e){const t={a:"a",admonition:"admonition",em:"em",h1:"h1",header:"header",img:"img",p:"p",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"poker-game",children:"Poker game"})}),"\n",(0,o.jsx)(t.p,{children:"The poker game is a prototypical example of a multi-party state channel."}),"\n",(0,o.jsxs)(t.p,{children:["We often use the analogy of a ",(0,o.jsx)(t.em,{children:"poker game"})," to explain how Hydra heads function, as it closely aligns with the fundamentals of the Hydra Head protocol. A poker game, like any game, has a clear start and end, and progresses according to a set of agreed-upon rules. In poker, the monetary component is central; players place bids and exchange money throughout the game. Moreover, the game involves a fixed number of players who have conflicting goals (ie, to win the game), may not fully trust each other, but are willing to cooperate within the established rules."]}),"\n",(0,o.jsx)(t.admonition,{title:"Decentralized randomness and multi-party computation",type:"tip",children:(0,o.jsxs)(t.p,{children:["For this use case, we consider the possibility of implementing a decentralized poker game with pseudo-randomness or multi-party computation (refer to ",(0,o.jsx)(t.a,{href:"https://eprint.iacr.org/2018/157",children:"ROYALE by David & al"}),"). We focus here on the state channel aspect, for which Hydra heads provide a robust solution."]})}),"\n",(0,o.jsx)(t.p,{children:"In this scenario, each player represents a member of a Hydra head, operating their own Hydra node. The game begins with each participant committing funds to the head, which serve as their chips. Once the head is active, participants can start the game, utilizing on-head Plutus contracts to facilitate gameplay. Players can instantly process fund transfers within the head, with the script acting as the game dealer \u2014 ensuring adherence to rules and smooth game progression."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{src:a(45690).A+"",width:"1043",height:"601"})}),"\n",(0,o.jsx)(t.p,{children:"Ultimately, the game concludes with a well-defined distribution of funds. Participants can choose to play another game or close the head and record the final outcomes on layer 1. The entire gameplay remains opaque to layer 1; only the ultimate UTXO distribution is known."}),"\n",(0,o.jsx)(t.p,{children:"While it is technically feasible to conduct this game entirely on layer 1, using a Hydra head offers significant advantages. It enables fast-paced transactions throughout the game and minimizes transaction fees beyond the initial costs needed to establish the Hydra head."})]})}function l(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},45690:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/poker-5da0a259ae448b547c2059af88b66f2b.webp"},28453:(e,t,a)=>{a.d(t,{R:()=>s,x:()=>i});var n=a(96540);const o={},r=n.createContext(o);function s(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);