-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Hydra transaction library
--   
--   Hydra transaction library
@package hydra-tx
@version 0.22.2


-- | Utilities to building transactions on top of the cardano-api.
module Hydra.Ledger.Cardano.Builder

-- | Construct a transaction from a builder. It is said <tt>unsafe</tt>
--   because the underlying implementation will perform some sanity check
--   on a transaction; for example, check that it has at least one input,
--   that no outputs are negatives and whatnot.
--   
--   We use the builder only internally for on-chain transaction crafted in
--   the context of Hydra.
unsafeBuildTransaction :: HasCallStack => TxBodyContent BuildTx -> Tx

-- | A runtime exception to capture (programmer) failures when building
--   transactions. This should never happened in practice (famous last
--   words...)!
data InvalidTransactionException
InvalidTransactionException :: TxBodyError -> TxBodyContent BuildTx -> InvalidTransactionException
[$sel:txBodyError:InvalidTransactionException] :: InvalidTransactionException -> TxBodyError
[$sel:builder:InvalidTransactionException] :: InvalidTransactionException -> TxBodyContent BuildTx

-- | Like <tt>addInputs</tt> but only for vk inputs which requires no
--   additional data.
addTxInsSpending :: [TxIn] -> TxBodyContent BuildTx -> TxBodyContent BuildTx

-- | Mint tokens with given plutus minting script and redeemer.
mintTokens :: ToScriptData redeemer => PlutusScript -> redeemer -> PolicyAssets -> TxBodyContent BuildTx -> TxBodyContent BuildTx

-- | Burn tokens with given plutus minting script and redeemer. This is
--   really just <a>mintTokens</a> with negated <a>Quantity</a>.
burnTokens :: ToScriptData redeemer => PlutusScript -> redeemer -> PolicyAssets -> TxBodyContent BuildTx -> TxBodyContent BuildTx
instance GHC.Show.Show Hydra.Ledger.Cardano.Builder.InvalidTransactionException
instance GHC.Exception.Type.Exception Hydra.Ledger.Cardano.Builder.InvalidTransactionException


-- | Module containing time conversion functions. These functions are
--   assuming that there is never going to be a different slot or epoch
--   length and project a slot/time accordingly.
--   
--   See Hydra.Chain.Direct.TimeHandle for an alternative that uses the
--   cardano-node provided <tt>EraSummary</tt> to do "correct" translation
--   on time.
module Hydra.Ledger.Cardano.Time

-- | Convert a <a>SlotNo</a> to a <a>UTCTime</a> using given
--   <a>SystemStart</a> and <a>SlotLength</a>. This assumes the slot length
--   never changes!
slotNoToUTCTime :: SystemStart -> SlotLength -> SlotNo -> UTCTime

-- | Convert a <a>UTCTime</a> to a <a>SlotNo</a> using given
--   <a>SystemStart</a> and <a>SlotLength</a>. This assumes the slot length
--   never changes! Also if the UTCTime is before the systemStart it will
--   truncate to slot 0.
slotNoFromUTCTime :: SystemStart -> SlotLength -> UTCTime -> SlotNo

module Hydra.Tx.ContestationPeriod

-- | A positive, non-zero number of seconds. Use <a>fromInteger</a> on
--   positive literals, <a>fromEnum</a> via [1..] syntax or
--   <a>fromNominalDiffTime</a> to create values of unknown sign.
newtype ContestationPeriod
UnsafeContestationPeriod :: Natural -> ContestationPeriod

-- | Create a <a>ContestationPeriod</a> from a <a>NominalDiffTime</a>. This
--   will fail if a negative NominalDiffTime is provided and truncates to
--   1s if values &lt; 1s are given.
fromNominalDiffTime :: MonadFail m => NominalDiffTime -> m ContestationPeriod
toNominalDiffTime :: ContestationPeriod -> NominalDiffTime

-- | Convert an off-chain contestation period to its on-chain
--   representation.
toChain :: ContestationPeriod -> ContestationPeriod

-- | Convert an on-chain contestation period to its off-chain
--   representation. NOTE: Does truncate to whole seconds.
fromChain :: ContestationPeriod -> ContestationPeriod
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.ContestationPeriod.ContestationPeriod
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.ContestationPeriod.ContestationPeriod
instance GHC.Real.Integral Hydra.Tx.ContestationPeriod.ContestationPeriod
instance GHC.Real.Real Hydra.Tx.ContestationPeriod.ContestationPeriod
instance GHC.Classes.Ord Hydra.Tx.ContestationPeriod.ContestationPeriod
instance GHC.Classes.Eq Hydra.Tx.ContestationPeriod.ContestationPeriod
instance GHC.Show.Show Hydra.Tx.ContestationPeriod.ContestationPeriod
instance GHC.Enum.Enum Hydra.Tx.ContestationPeriod.ContestationPeriod
instance GHC.Num.Num Hydra.Tx.ContestationPeriod.ContestationPeriod
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Tx.ContestationPeriod.ContestationPeriod


-- | Simplified interface to phase-2 validation of transactions, eg.
--   evaluation of Plutus scripts.
--   
--   The <a>evaluateTx</a> function simplifies the call to ledger and
--   plutus providing an <a>EvaluationReport</a> using pre-canned
--   <tt>ProtocolParameters</tt>. This should only be used for
--   <i>testing</i> or <i>benchmarking</i> purpose as the real evaluation
--   parameters are set when the Hydra node starts.
--   
--   <b>NOTE</b>: The reason this module is here instead of part of `test/`
--   directory is to be used in <tt>tx-cost</tt> executable.
module Hydra.Ledger.Cardano.Evaluate

-- | Thin wrapper around <a>evaluateTransactionExecutionUnits</a>, using
--   fixtures from this module for <a>systemStart</a>, <tt>eraHistory</tt>
--   and <a>pparams</a>.
--   
--   Additionally, this function checks the overall execution units are not
--   exceeding <a>maxTxExecutionUnits</a>.
evaluateTx :: Tx -> UTxO -> Either EvaluationError EvaluationReport

-- | Like <a>evaluateTx</a>, but with a configurable maximum transaction
--   <a>ExecutionUnits</a>.
evaluateTx' :: ExecutionUnits -> Tx -> UTxO -> Either EvaluationError EvaluationReport

-- | Check the budget used by provided <a>EvaluationReport</a> does not
--   exceed given maximum <a>ExecutionUnits</a>.
checkBudget :: ExecutionUnits -> EvaluationReport -> Either EvaluationError EvaluationReport

-- | Errors returned by <a>evaluateTx</a> extending the upstream
--   <a>TransactionValidityError</a> with additional cases.
data EvaluationError
TransactionBudgetOverspent :: ExecutionUnits -> ExecutionUnits -> EvaluationError
[$sel:used:TransactionBudgetOverspent] :: EvaluationError -> ExecutionUnits
[$sel:available:TransactionBudgetOverspent] :: EvaluationError -> ExecutionUnits
TransactionInvalid :: TransactionValidityError Era -> EvaluationError
PParamsConversion :: ProtocolParametersConversionError -> EvaluationError

-- | Evaluation result for each of the included scripts. Either they failed
--   evaluation or used a number of <a>ExecutionUnits</a>.
type EvaluationReport = (Map ScriptWitnessIndex (Either ScriptExecutionError ExecutionUnits))

-- | Render the <a>EvaluationReport</a> as a pretty multi-line text.
renderEvaluationReport :: EvaluationReport -> Text

-- | Get the total used <a>ExecutionUnits</a> from an
--   <a>EvaluationReport</a>. Useful to further process the result of
--   <a>evaluateTx</a>.
usedExecutionUnits :: EvaluationReport -> ExecutionUnits

-- | Estimate minimum fee for given transaction and evaluated redeemers.
--   Instead of using the budgets from the transaction (which are usually
--   set to 0 until balancing), this directly computes the fee from
--   transaction size and the units of the <a>EvaluationReport</a>. Note
--   that this function only provides a rough estimate using this modules'
--   <a>pparams</a> and likely under-estimates cost as we have no witnesses
--   on this <a>Tx</a>.
estimateMinFee :: Tx -> EvaluationReport -> Coin

-- | Current (2023-04-12) mainchain protocol parameters. XXX: Avoid
--   specifying not required parameters here (e.g. max block units should
--   not matter). XXX: Load and use mainnet parameters from a file which we
--   can easily review to be in sync with mainnet.
pparams :: PParams LedgerEra
maxTxSize :: Natural

-- | Max transaction execution unit budget of the current <a>pparams</a>.
maxTxExecutionUnits :: ExecutionUnits

-- | Max memory and cpu units of the current <a>pparams</a>.
maxMem :: Natural

-- | Max memory and cpu units of the current <a>pparams</a>.
maxCpu :: Natural

-- | An artificial <a>EpochInfo</a> comprised by a single never ending
--   (forking) era, with fixed <a>epochSize</a> and <a>slotLength</a>.
epochInfo :: Monad m => EpochInfo m

-- | An era history with a single era which will end at some point.
--   
--   A "real" <a>EraHistory</a> received from the cardano-node will have
--   the <a>eraEnd</a> at a known or earliest possible end of the current
--   era + a safe zone.
--   
--   See <a>EraParams</a> for details.
--   
--   NOTE: This era is using not so realistic epoch sizes of 1 and sets a
--   slot length of 1
eraHistoryWithHorizonAt :: SlotNo -> EraHistory
eraHistoryWithoutHorizon :: EraHistory
epochSize :: EpochSize
slotLength :: SlotLength
systemStart :: SystemStart

-- | Expect a given <a>Tx</a> and <a>UTxO</a> to pass evaluation.
propTransactionEvaluates :: (Tx, UTxO) -> Property

-- | Expect a given <a>Tx</a> and <a>UTxO</a> to fail phase 1 or phase 2
--   evaluation.
propTransactionFailsEvaluation :: (Tx, UTxO) -> Property

-- | Parameter here is the contestation period (cp) so we need to generate
--   start (tMin) and end (tMax) tx validity bound such that their
--   difference is not higher than the cp. Returned slots are tx validity
--   bounds
genValidityBoundsFromContestationPeriod :: ContestationPeriod -> Gen (SlotNo, (SlotNo, UTCTime))
genPointInTimeBefore :: UTCTime -> Gen (SlotNo, UTCTime)

-- | Current (2024-10-03) mainnet PlutusV3 cost model.
plutusV3CostModel :: CostModel

-- | Current (2023-08-04) mainnet PlutusV2 cost model.
plutusV2CostModel :: CostModel
instance GHC.Show.Show Hydra.Ledger.Cardano.Evaluate.EvaluationError


-- | Hydra multi-signature credentials and cryptographic primitives used to
--   sign and verify snapshots (or any messages) within the Hydra protocol.
--   
--   We are re-using the <a>Key</a> interface of 'cardano-api' for a
--   consistent representation. For example: Cardano credentials are
--   'VerificationKey PaymentKey', Hydra credentials are 'VerificationKey
--   HydraKey'.
--   
--   Currently <a>MultiSignature</a> interface is only supporting naiive,
--   concatenated multi-signatures and will change when we adopt aggregated
--   multi-signatures including aggregate keys.
module Hydra.Tx.Crypto
class (Eq VerificationKey keyrole, Show VerificationKey keyrole, SerialiseAsRawBytes Hash keyrole, HasTextEnvelope VerificationKey keyrole, HasTextEnvelope SigningKey keyrole) => Key keyrole where {
    data family VerificationKey keyrole;
    data family SigningKey keyrole;
}
getVerificationKey :: Key keyrole => SigningKey keyrole -> VerificationKey keyrole
deterministicSigningKey :: Key keyrole => AsType keyrole -> Seed -> SigningKey keyrole
deterministicSigningKeySeedSize :: Key keyrole => AsType keyrole -> Word
verificationKeyHash :: Key keyrole => VerificationKey keyrole -> Hash keyrole
data family Hash keyrole
data family AsType t
data family SigningKey keyrole
data family VerificationKey keyrole

-- | Naiively aggregated multi-signatures.
newtype MultiSignature a
HydraMultiSignature :: [Signature a] -> MultiSignature a
[$sel:multiSignature:HydraMultiSignature] :: MultiSignature a -> [Signature a]

-- | Hydra keys (keyrole) which can be used to <a>sign</a> and
--   <a>verify</a> messages, as well as <a>aggregate</a> multi-signatures.
data HydraKey

-- | Signature of <tt>a</tt>, not containing the actual payload.
newtype Signature a
HydraSignature :: SigDSIGN Ed25519DSIGN -> Signature a

-- | A result type for multisigs verification providing some information in
--   case of failure.
--   
--   This type is of course structurally equivalent to `Maybe
--   [VerificationKey HydraKey]` but it's much more explicit.
data Verified
Verified :: Verified
FailedKeys :: [VerificationKey HydraKey] -> Verified
[$sel:failedKeys:Verified] :: Verified -> [VerificationKey HydraKey]
KeyNumberMismatch :: Verified
pattern HydraKeyHash :: () => Hash Blake2b_256 (VerificationKey HydraKey) -> Hash HydraKey
pattern AsHydraKey :: () => AsType HydraKey
pattern HydraSigningKey :: () => SignKeyDSIGN Ed25519DSIGN -> SigningKey HydraKey
pattern HydraVerificationKey :: () => VerKeyDSIGN Ed25519DSIGN -> VerificationKey HydraKey

-- | Sign some value <tt>a</tt> with the provided <a>SigningKey</a>.
sign :: SignableRepresentation a => SigningKey HydraKey -> a -> Signature a
toPlutusSignatures :: MultiSignature a -> [Signature]

-- | Combine multiple signatures of <tt>a</tt> into a 'MultiSignature a'.
aggregate :: [Signature a] -> MultiSignature a

-- | Create a new <a>SigningKey</a> from a <a>ByteString</a> seed. The
--   created keys are not random and insecure, so don't use this in
--   production code!
generateSigningKey :: ByteString -> SigningKey HydraKey

-- | Verify a given 'Signature a' and value <tt>a</tt> using provided
--   <a>VerificationKey</a>.
verify :: SignableRepresentation a => VerificationKey HydraKey -> Signature a -> a -> Bool

-- | Like aggregate, but use order of given list of keys instead.
--   FIXME(AB): This function exists solely because the order of signatures
--   matters on-chain, and it should match the order of parties as declared
--   in the initTx. This should disappear once we use a proper
--   multisignature scheme
aggregateInOrder :: Ord k => Map k (Signature a) -> [k] -> MultiSignature a

-- | Verify a given 'MultiSignature a' and value <tt>a</tt> provided a list
--   of <a>VerificationKey</a>.
--   
--   Note that order of keys is relevant and that length of signature and
--   multisignature list needs to be the same.
verifyMultiSignature :: SignableRepresentation a => [VerificationKey HydraKey] -> MultiSignature a -> a -> Verified
instance GHC.Show.Show (Cardano.Api.Internal.Hash.Hash Hydra.Tx.Crypto.HydraKey)
instance GHC.Classes.Eq (Cardano.Api.Internal.Hash.Hash Hydra.Tx.Crypto.HydraKey)
instance GHC.Classes.Ord (Cardano.Api.Internal.Hash.Hash Hydra.Tx.Crypto.HydraKey)
instance Cardano.Api.Internal.Serialise.Cbor.SerialiseAsCBOR (Cardano.Api.Internal.Keys.Class.SigningKey Hydra.Tx.Crypto.HydraKey)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Api.Internal.Keys.Class.SigningKey Hydra.Tx.Crypto.HydraKey)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Api.Internal.Keys.Class.SigningKey Hydra.Tx.Crypto.HydraKey)
instance Data.String.IsString (Cardano.Api.Internal.Keys.Class.SigningKey Hydra.Tx.Crypto.HydraKey)
instance GHC.Show.Show (Cardano.Api.Internal.Keys.Class.SigningKey Hydra.Tx.Crypto.HydraKey)
instance (TypeError ...) => GHC.Classes.Ord (Cardano.Api.Internal.Keys.Class.SigningKey Hydra.Tx.Crypto.HydraKey)
instance GHC.Classes.Eq (Cardano.Api.Internal.Keys.Class.SigningKey Hydra.Tx.Crypto.HydraKey)
instance Cardano.Api.Internal.Serialise.Cbor.SerialiseAsCBOR (Cardano.Api.Internal.Keys.Class.VerificationKey Hydra.Tx.Crypto.HydraKey)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Api.Internal.Keys.Class.VerificationKey Hydra.Tx.Crypto.HydraKey)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Api.Internal.Keys.Class.VerificationKey Hydra.Tx.Crypto.HydraKey)
instance Data.String.IsString (Cardano.Api.Internal.Keys.Class.VerificationKey Hydra.Tx.Crypto.HydraKey)
instance GHC.Show.Show (Cardano.Api.Internal.Keys.Class.VerificationKey Hydra.Tx.Crypto.HydraKey)
instance (TypeError ...) => GHC.Classes.Ord (Cardano.Api.Internal.Keys.Class.VerificationKey Hydra.Tx.Crypto.HydraKey)
instance GHC.Classes.Eq (Cardano.Api.Internal.Keys.Class.VerificationKey Hydra.Tx.Crypto.HydraKey)
instance forall k (a :: k). (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable k) => Cardano.Binary.FromCBOR.FromCBOR (Hydra.Tx.Crypto.Signature a)
instance forall k (a :: k). (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable k) => Cardano.Binary.ToCBOR.ToCBOR (Hydra.Tx.Crypto.Signature a)
instance forall k (a :: k). GHC.Classes.Eq (Hydra.Tx.Crypto.Signature a)
instance forall k (a :: k). GHC.Base.Monoid (Hydra.Tx.Crypto.MultiSignature a)
instance forall k (a :: k). GHC.Base.Semigroup (Hydra.Tx.Crypto.MultiSignature a)
instance forall k (a :: k). GHC.Generics.Generic (Hydra.Tx.Crypto.MultiSignature a)
instance forall k (a :: k). GHC.Show.Show (Hydra.Tx.Crypto.MultiSignature a)
instance forall k (a :: k). GHC.Classes.Eq (Hydra.Tx.Crypto.MultiSignature a)
instance GHC.Generics.Generic Hydra.Tx.Crypto.Verified
instance GHC.Show.Show Hydra.Tx.Crypto.Verified
instance GHC.Classes.Eq Hydra.Tx.Crypto.Verified
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Tx.Crypto.MultiSignature a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Tx.Crypto.MultiSignature a)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Cardano.Crypto.Util.SignableRepresentation a) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Tx.Crypto.MultiSignature a)
instance forall k (a :: k). GHC.Show.Show (Hydra.Tx.Crypto.Signature a)
instance forall k (a :: k). Data.Hashable.Class.Hashable (Hydra.Tx.Crypto.Signature a)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, Cardano.Crypto.Util.SignableRepresentation a) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Tx.Crypto.Signature a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Tx.Crypto.Signature a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Tx.Crypto.Signature a)
instance Cardano.Api.Internal.HasTypeProxy.HasTypeProxy Hydra.Tx.Crypto.HydraKey
instance Cardano.Api.Internal.SerialiseRaw.SerialiseAsRawBytes (Cardano.Api.Internal.Hash.Hash Hydra.Tx.Crypto.HydraKey)
instance Cardano.Api.Internal.Keys.Class.Key Hydra.Tx.Crypto.HydraKey
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Api.Internal.Keys.Class.SigningKey Hydra.Tx.Crypto.HydraKey)
instance Cardano.Api.Internal.SerialiseTextEnvelope.HasTextEnvelope (Cardano.Api.Internal.Keys.Class.SigningKey Hydra.Tx.Crypto.HydraKey)
instance Cardano.Api.Internal.SerialiseRaw.SerialiseAsRawBytes (Cardano.Api.Internal.Keys.Class.SigningKey Hydra.Tx.Crypto.HydraKey)
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Api.Internal.Keys.Class.VerificationKey Hydra.Tx.Crypto.HydraKey)
instance Cardano.Api.Internal.SerialiseRaw.SerialiseAsRawBytes (Cardano.Api.Internal.Keys.Class.VerificationKey Hydra.Tx.Crypto.HydraKey)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Internal.Keys.Class.VerificationKey Hydra.Tx.Crypto.HydraKey)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.Internal.Keys.Class.VerificationKey Hydra.Tx.Crypto.HydraKey)
instance Cardano.Api.Internal.SerialiseTextEnvelope.HasTextEnvelope (Cardano.Api.Internal.Keys.Class.VerificationKey Hydra.Tx.Crypto.HydraKey)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Internal.Keys.Class.SigningKey Hydra.Tx.Crypto.HydraKey)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Api.Internal.Keys.Class.SigningKey Hydra.Tx.Crypto.HydraKey)

module Hydra.Tx.HeadId

-- | Uniquely identifies a Hydra Head.
newtype HeadId
UnsafeHeadId :: ByteString -> HeadId
currencySymbolToHeadId :: MonadFail m => CurrencySymbol -> m HeadId
headIdToPolicyId :: MonadFail m => HeadId -> m PolicyId
headIdToCurrencySymbol :: HeadId -> CurrencySymbol
mkHeadId :: PolicyId -> HeadId

-- | Unique seed to create a <a>HeadId</a>
--   
--   XXX: This might actually be the <a>HeadId</a> to the protocol and
--   users? Then the policy id of the cardano-specific implementation
--   (being the result of minting policy + seed) stays internal. A drawback
--   is, that the seed is not such a good "key" to find things about this
--   head on explorers and indexers.
newtype HeadSeed
UnsafeHeadSeed :: ByteString -> HeadSeed
headSeedToTxIn :: MonadFail m => HeadSeed -> m TxIn
txInToHeadSeed :: TxIn -> HeadSeed
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.HeadId.HeadId
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.HeadId.HeadId
instance GHC.Generics.Generic Hydra.Tx.HeadId.HeadId
instance GHC.Classes.Ord Hydra.Tx.HeadId.HeadId
instance GHC.Classes.Eq Hydra.Tx.HeadId.HeadId
instance GHC.Show.Show Hydra.Tx.HeadId.HeadId
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.HeadId.HeadSeed
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.HeadId.HeadSeed
instance GHC.Generics.Generic Hydra.Tx.HeadId.HeadSeed
instance GHC.Classes.Ord Hydra.Tx.HeadId.HeadSeed
instance GHC.Classes.Eq Hydra.Tx.HeadId.HeadSeed
instance GHC.Show.Show Hydra.Tx.HeadId.HeadSeed
instance Data.String.IsString Hydra.Tx.HeadId.HeadSeed
instance Cardano.Api.Internal.SerialiseRaw.SerialiseAsRawBytes Hydra.Tx.HeadId.HeadSeed
instance Cardano.Api.Internal.HasTypeProxy.HasTypeProxy Hydra.Tx.HeadId.HeadSeed
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Tx.HeadId.HeadSeed
instance Cardano.Api.Internal.SerialiseRaw.SerialiseAsRawBytes Hydra.Tx.HeadId.HeadId
instance Cardano.Api.Internal.HasTypeProxy.HasTypeProxy Hydra.Tx.HeadId.HeadId
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Tx.HeadId.HeadId

module Hydra.Tx.IsTx

-- | Types of transactions that can be used by the Head protocol. The
--   associated types and methods of this type class represent the whole
--   interface of what the Head protocol needs from a transaction. This
--   ensure the off-chain protocol stays fairly independent of a concrete
--   transaction type.
class (Eq tx, Show tx, Typeable tx, FromCBOR tx, ToCBOR tx, FromJSON tx, ToJSON tx, Eq (TxIdType tx), Ord (TxIdType tx), Show (TxIdType tx), Typeable (TxIdType tx), FromJSON (TxIdType tx), ToJSON (TxIdType tx), FromCBOR (TxIdType tx), ToCBOR (TxIdType tx), FromJSONKey (TxIdType tx), ToJSONKey (TxIdType tx), Eq (TxOutType tx), Show (TxOutType tx), ToJSON (TxOutType tx), FromJSON (TxOutType tx), Eq (UTxOType tx), Show (UTxOType tx), Monoid (UTxOType tx), FromJSON (UTxOType tx), ToJSON (UTxOType tx), FromCBOR (UTxOType tx), ToCBOR (UTxOType tx)) => IsTx tx where {
    
    -- | Type which identifies a transaction
    type TxIdType tx;
    
    -- | Type for individual transaction outputs.
    type TxOutType tx = out | out -> tx;
    
    -- | Type for a set of unspent transaction outputs.
    type UTxOType tx = utxo | utxo -> tx;
    
    -- | Type representing a value on the ledger.
    type ValueType tx;
}
txId :: IsTx tx => tx -> TxIdType tx
balance :: IsTx tx => UTxOType tx -> ValueType tx

-- | Hash a utxo set to be able to sign (off-chain) and verify it
--   (on-chain).
hashUTxO :: IsTx tx => UTxOType tx -> ByteString
txSpendingUTxO :: IsTx tx => UTxOType tx -> tx

-- | Get the UTxO produced by given transaction.
utxoFromTx :: IsTx tx => tx -> UTxOType tx

-- | Get only the outputs in given UTxO.
outputsOfUTxO :: IsTx tx => UTxOType tx -> [TxOutType tx]

-- | Return the left-hand side without the right-hand side.
withoutUTxO :: IsTx tx => UTxOType tx -> UTxOType tx -> UTxOType tx
type ArbitraryIsTx tx = (IsTx tx, Arbitrary tx, Arbitrary (UTxOType tx), Arbitrary (TxIdType tx), Arbitrary (TxOutType tx))
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Cardano.Api.Tx
instance Hydra.Tx.IsTx.IsTx Hydra.Cardano.Api.Tx
instance Cardano.Api.Internal.Eon.ShelleyBasedEra.IsShelleyBasedEra era => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Api.Internal.Tx.Sign.Tx era)
instance Cardano.Api.Internal.Eon.ShelleyBasedEra.IsShelleyBasedEra era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Api.Internal.Tx.Sign.Tx era)
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Cardano.Api.Tx
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Api.UTxO.UTxO
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Api.UTxO.UTxO

module Hydra.Tx.BlueprintTx

-- | _Blueprint/Draft_ transaction paired with the <tt>UTxO</tt> which
--   resolves it's inputs. The transaction inputs are committed to a
--   <tt>Head</tt> and the <a>$sel:lookupUTxO:CommitBlueprintTx</a> is
--   expected to contain these inputs.
data CommitBlueprintTx tx
CommitBlueprintTx :: UTxOType tx -> tx -> CommitBlueprintTx tx
[$sel:lookupUTxO:CommitBlueprintTx] :: CommitBlueprintTx tx -> UTxOType tx
[$sel:blueprintTx:CommitBlueprintTx] :: CommitBlueprintTx tx -> tx
mkSimpleBlueprintTx :: IsTx tx => UTxOType tx -> CommitBlueprintTx tx


-- | Identifier or Head participants on-chain. That is, a participant in
--   the Hydra Head protocol which authorizes protocol transitions
--   on-chain.
module Hydra.Tx.OnChainId

-- | Identifier for a Hydra Head participant on-chain.
newtype OnChainId
UnsafeOnChainId :: ByteString -> OnChainId

-- | Generate an arbitrary <a>OnChainId</a> of 28 bytes length.
genOnChainId :: Gen OnChainId
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.OnChainId.OnChainId
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.OnChainId.OnChainId
instance GHC.Generics.Generic Hydra.Tx.OnChainId.OnChainId
instance GHC.Classes.Ord Hydra.Tx.OnChainId.OnChainId
instance GHC.Classes.Eq Hydra.Tx.OnChainId.OnChainId
instance GHC.Show.Show Hydra.Tx.OnChainId.OnChainId
instance Cardano.Api.Internal.SerialiseRaw.SerialiseAsRawBytes Hydra.Tx.OnChainId.OnChainId
instance Cardano.Api.Internal.HasTypeProxy.HasTypeProxy Hydra.Tx.OnChainId.OnChainId
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Tx.OnChainId.OnChainId


-- | Types and functions revolving around a Hydra <a>Party</a>. That is, a
--   participant in a Hydra Head, which signs transactions or snapshots in
--   the Hydra protocol.
module Hydra.Tx.Party

-- | Identifies a party in a Hydra head by it's <a>VerificationKey</a>.
newtype Party
Party :: VerificationKey HydraKey -> Party
[$sel:vkey:Party] :: Party -> VerificationKey HydraKey

-- | Get the <a>Party</a> given some Hydra <a>SigningKey</a>.
deriveParty :: SigningKey HydraKey -> Party

-- | Convert "high-level" <a>Party</a> to the "low-level" representation as
--   used on-chain. See <a>Party</a> for an explanation why this is a
--   distinct type.
partyToChain :: Party -> Party

-- | Retrieve the "high-level" 'Party from the "low-level" on-chain
--   representation. This can fail because of the lower type-safety used
--   on-chain and a non-guaranteed verification key length. See
--   <a>Party</a> for an explanation why this is a distinct type.
partyFromChain :: MonadFail m => Party -> m Party

-- | Type class to retrieve the <a>Party</a> from some type.
class HasParty a
getParty :: HasParty a => a -> Party
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Tx.Party.Party
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.Party.Party
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.Party.Party
instance GHC.Generics.Generic Hydra.Tx.Party.Party
instance GHC.Show.Show Hydra.Tx.Party.Party
instance GHC.Classes.Eq Hydra.Tx.Party.Party
instance Data.Aeson.Types.ToJSON.ToJSONKey Hydra.Tx.Party.Party
instance Data.Aeson.Types.FromJSON.FromJSONKey Hydra.Tx.Party.Party
instance GHC.Classes.Ord Hydra.Tx.Party.Party
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Tx.Party.Party
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Tx.Party.Party

module Hydra.Tx.HeadParameters

-- | Contains the head's parameters as established in the initial
--   transaction.
data HeadParameters
HeadParameters :: ContestationPeriod -> [Party] -> HeadParameters
[$sel:contestationPeriod:HeadParameters] :: HeadParameters -> ContestationPeriod
[$sel:parties:HeadParameters] :: HeadParameters -> [Party]
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.HeadParameters.HeadParameters
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.HeadParameters.HeadParameters
instance GHC.Generics.Generic Hydra.Tx.HeadParameters.HeadParameters
instance GHC.Show.Show Hydra.Tx.HeadParameters.HeadParameters
instance GHC.Classes.Eq Hydra.Tx.HeadParameters.HeadParameters
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Tx.HeadParameters.HeadParameters


-- | A data-type to keep track of reference Hydra scripts published
--   on-chain, and needed to construct transactions leveraging reference
--   inputs.
module Hydra.Tx.ScriptRegistry

-- | Hydra scripts published as reference scripts at these UTxO.
data ScriptRegistry
ScriptRegistry :: (TxIn, TxOut CtxUTxO) -> (TxIn, TxOut CtxUTxO) -> (TxIn, TxOut CtxUTxO) -> ScriptRegistry
[$sel:initialReference:ScriptRegistry] :: ScriptRegistry -> (TxIn, TxOut CtxUTxO)
[$sel:commitReference:ScriptRegistry] :: ScriptRegistry -> (TxIn, TxOut CtxUTxO)
[$sel:headReference:ScriptRegistry] :: ScriptRegistry -> (TxIn, TxOut CtxUTxO)
data NewScriptRegistryException
MissingScript :: Text -> ScriptHash -> Set ScriptHash -> NewScriptRegistryException
[$sel:scriptName:MissingScript] :: NewScriptRegistryException -> Text
[$sel:scriptHash:MissingScript] :: NewScriptRegistryException -> ScriptHash
[$sel:discoveredScripts:MissingScript] :: NewScriptRegistryException -> Set ScriptHash

-- | Create a script registry from a UTxO containing outputs with reference
--   scripts. This will return <a>Nothing</a> if one or all of the
--   references could not be found.
newScriptRegistry :: UTxO -> Either NewScriptRegistryException ScriptRegistry

-- | Get the UTxO that corresponds to a script registry.
--   
--   <ul>
--   <li>*Property**:newScriptRegistry (registryUTxO r) === Just r</li>
--   </ul>
registryUTxO :: ScriptRegistry -> UTxO
instance GHC.Generics.Generic Hydra.Tx.ScriptRegistry.ScriptRegistry
instance GHC.Show.Show Hydra.Tx.ScriptRegistry.ScriptRegistry
instance GHC.Classes.Eq Hydra.Tx.ScriptRegistry.ScriptRegistry
instance GHC.Show.Show Hydra.Tx.ScriptRegistry.NewScriptRegistryException
instance GHC.Classes.Eq Hydra.Tx.ScriptRegistry.NewScriptRegistryException
instance GHC.Exception.Type.Exception Hydra.Tx.ScriptRegistry.NewScriptRegistryException

module Hydra.Tx.Snapshot
newtype SnapshotNumber
UnsafeSnapshotNumber :: Natural -> SnapshotNumber
fromChainSnapshotNumber :: SnapshotNumber -> SnapshotNumber
newtype SnapshotVersion
UnsafeSnapshotVersion :: Natural -> SnapshotVersion
fromChainSnapshotVersion :: SnapshotVersion -> SnapshotVersion
data Snapshot tx
Snapshot :: HeadId -> SnapshotVersion -> SnapshotNumber -> [tx] -> UTxOType tx -> Maybe (UTxOType tx) -> Maybe (UTxOType tx) -> Snapshot tx
[$sel:headId:Snapshot] :: Snapshot tx -> HeadId

-- | Open state version this snapshot is based on. Spec: v
[$sel:version:Snapshot] :: Snapshot tx -> SnapshotVersion

-- | Monotonically increasing snapshot number. Spec: s
[$sel:number:Snapshot] :: Snapshot tx -> SnapshotNumber

-- | The set of transactions that lead to <a>$sel:utxo:Snapshot</a>. Spec:
--   T
[$sel:confirmed:Snapshot] :: Snapshot tx -> [tx]

-- | Snaspshotted UTxO set. Spec: U
[$sel:utxo:Snapshot] :: Snapshot tx -> UTxOType tx

-- | UTxO to be committed. Spec: Uα
[$sel:utxoToCommit:Snapshot] :: Snapshot tx -> Maybe (UTxOType tx)

-- | UTxO to be decommitted. Spec: Uω
[$sel:utxoToDecommit:Snapshot] :: Snapshot tx -> Maybe (UTxOType tx)

-- | A snapshot that can be used to close a head with. Either the initial
--   one, or when it was signed by all parties, i.e. it is confirmed.
data ConfirmedSnapshot tx
InitialSnapshot :: HeadId -> UTxOType tx -> ConfirmedSnapshot tx
[$sel:headId:InitialSnapshot] :: ConfirmedSnapshot tx -> HeadId
[$sel:initialUTxO:InitialSnapshot] :: ConfirmedSnapshot tx -> UTxOType tx
ConfirmedSnapshot :: Snapshot tx -> MultiSignature (Snapshot tx) -> ConfirmedSnapshot tx
[$sel:snapshot:InitialSnapshot] :: ConfirmedSnapshot tx -> Snapshot tx
[$sel:signatures:InitialSnapshot] :: ConfirmedSnapshot tx -> MultiSignature (Snapshot tx)

-- | Safely get a <a>Snapshot</a> from a confirmed snapshot.
--   
--   NOTE: While we could use <a>$sel:snapshot:InitialSnapshot</a>
--   directly, this is a record-field accessor which may become partial
--   (and lead to unnoticed runtime errors) if we ever add a new branch to
--   the sumtype. So, we explicitly define a getter which will force us
--   into thinking about changing the signature properly if this happens.
getSnapshot :: ConfirmedSnapshot tx -> Snapshot tx
genConfirmedSnapshot :: IsTx tx => HeadId -> SnapshotVersion -> SnapshotNumber -> UTxOType tx -> Maybe (UTxOType tx) -> Maybe (UTxOType tx) -> [SigningKey HydraKey] -> Gen (ConfirmedSnapshot tx)
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Tx.Snapshot.SnapshotNumber
instance GHC.Real.Integral Hydra.Tx.Snapshot.SnapshotNumber
instance GHC.Enum.Enum Hydra.Tx.Snapshot.SnapshotNumber
instance GHC.Num.Num Hydra.Tx.Snapshot.SnapshotNumber
instance GHC.Real.Real Hydra.Tx.Snapshot.SnapshotNumber
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Tx.Snapshot.SnapshotNumber
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Tx.Snapshot.SnapshotNumber
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.Snapshot.SnapshotNumber
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.Snapshot.SnapshotNumber
instance GHC.Show.Show Hydra.Tx.Snapshot.SnapshotNumber
instance GHC.Generics.Generic Hydra.Tx.Snapshot.SnapshotNumber
instance GHC.Classes.Ord Hydra.Tx.Snapshot.SnapshotNumber
instance GHC.Classes.Eq Hydra.Tx.Snapshot.SnapshotNumber
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Tx.Snapshot.SnapshotVersion
instance GHC.Real.Integral Hydra.Tx.Snapshot.SnapshotVersion
instance GHC.Enum.Enum Hydra.Tx.Snapshot.SnapshotVersion
instance GHC.Num.Num Hydra.Tx.Snapshot.SnapshotVersion
instance GHC.Real.Real Hydra.Tx.Snapshot.SnapshotVersion
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Tx.Snapshot.SnapshotVersion
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Tx.Snapshot.SnapshotVersion
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.Snapshot.SnapshotVersion
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.Snapshot.SnapshotVersion
instance GHC.Show.Show Hydra.Tx.Snapshot.SnapshotVersion
instance GHC.Generics.Generic Hydra.Tx.Snapshot.SnapshotVersion
instance GHC.Classes.Ord Hydra.Tx.Snapshot.SnapshotVersion
instance GHC.Classes.Eq Hydra.Tx.Snapshot.SnapshotVersion
instance GHC.Generics.Generic (Hydra.Tx.Snapshot.Snapshot tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Tx.Snapshot.ConfirmedSnapshot tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Tx.Snapshot.ConfirmedSnapshot tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Show.Show (Hydra.Tx.Snapshot.ConfirmedSnapshot tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Classes.Eq (Hydra.Tx.Snapshot.ConfirmedSnapshot tx)
instance GHC.Generics.Generic (Hydra.Tx.Snapshot.ConfirmedSnapshot tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Classes.Eq (Hydra.Tx.Snapshot.Snapshot tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Show.Show (Hydra.Tx.Snapshot.Snapshot tx)
instance (Test.QuickCheck.Arbitrary.Arbitrary tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Tx.IsTx.UTxOType tx), Hydra.Tx.IsTx.IsTx tx) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Tx.Snapshot.ConfirmedSnapshot tx)
instance Hydra.Tx.IsTx.IsTx tx => Cardano.Crypto.Util.SignableRepresentation (Hydra.Tx.Snapshot.Snapshot tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Tx.Snapshot.Snapshot tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Tx.Snapshot.Snapshot tx)
instance (Test.QuickCheck.Arbitrary.Arbitrary tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Tx.IsTx.UTxOType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Tx.Snapshot.Snapshot tx)

module Hydra.Tx

module Hydra.Chain.ChainState

-- | A generic description for a chain slot all implementations need to
--   use.
newtype ChainSlot
ChainSlot :: Natural -> ChainSlot

-- | Types that can be used on-chain by the Hydra protocol. XXX: Find a
--   better name for this. Maybe IsChainTx or IsL1Tx?
class (IsTx tx, Eq (ChainStateType tx), Show (ChainStateType tx), FromJSON (ChainStateType tx), ToJSON (ChainStateType tx), Arbitrary (ChainStateType tx)) => IsChainState tx where {
    
    -- | Type of what to keep as L1 chain state. XXX: Why is this not always
    --   UTxOType?
    type ChainStateType tx = c | c -> tx;
}

-- | Get the chain slot for a chain state. NOTE: For any sequence of
--   <tt>a</tt> encountered, we assume monotonically increasing slots.
chainStateSlot :: IsChainState tx => ChainStateType tx -> ChainSlot
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Chain.ChainState.ChainSlot
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Chain.ChainState.ChainSlot
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.ChainState.ChainSlot
instance GHC.Num.Num Hydra.Chain.ChainState.ChainSlot
instance GHC.Generics.Generic Hydra.Chain.ChainState.ChainSlot
instance GHC.Show.Show Hydra.Chain.ChainState.ChainSlot
instance GHC.Classes.Eq Hydra.Chain.ChainState.ChainSlot
instance GHC.Classes.Ord Hydra.Chain.ChainState.ChainSlot

module Hydra.Tx.Utils

-- | Type to encapsulate one of the two possible incremental actions or a
--   regular snapshot. This actually signals that our snapshot modeling is
--   likely not ideal but for now we want to keep track of both fields
--   (de/commit) since we might want to support batch de/commits too in the
--   future, but having both fields be Maybe UTxO introduces a lot of
--   checks if the value is Nothing or mempty.
data IncrementalAction
ToCommit :: UTxO -> IncrementalAction
ToDecommit :: UTxO -> IncrementalAction
NoThing :: IncrementalAction

-- | Find (if it exists) the head identifier contained in given
--   <a>TxOut</a>.
findStateToken :: TxOut ctx -> Maybe HeadId
headTokensFromValue :: PlutusScript -> Value -> PolicyAssets

-- | Create a transaction metadata entry to identify Hydra transactions
--   (for informational purposes).
mkHydraHeadV1TxName :: Text -> TxMetadata
addMetadata :: TxMetadata -> Tx -> AlonzoTx ConwayEra -> AlonzoTx ConwayEra
assetNameToOnChainId :: AssetName -> OnChainId

-- | Find first occurrence including a transformation.
findFirst :: Foldable t => (a -> Maybe b) -> t a -> Maybe b
hydraHeadV1AssetName :: AssetName
onChainIdToAssetName :: OnChainId -> AssetName

-- | The metadata label used for identifying Hydra protocol transactions.
--   As suggested by a friendly large language model: The number most
--   commonly associated with <a>Hydra</a> is 5, as in the mythological
--   creature Hydra, which had multiple heads, and the number 5 often
--   symbolizes multiplicity or diversity. However, there is no specific
--   numerical association for Hydra smaller than 10000 beyond this
--   mythological reference.
hydraMetadataLabel :: Word64

-- | Derive the <a>OnChainId</a> from a Cardano <a>PaymentKey</a>. The
--   on-chain identifier is the public key hash as it is also available to
--   plutus validators.
verificationKeyToOnChainId :: VerificationKey PaymentKey -> OnChainId

-- | Split a given UTxO into two, such that the second UTxO is non-empty.
--   This is useful to pick a UTxO to decommit.
splitUTxO :: UTxO -> (UTxO, UTxO)
adaOnly :: TxOut CtxUTxO -> TxOut CtxUTxO
setIncrementalActionMaybe :: Maybe UTxO -> Maybe UTxO -> Maybe IncrementalAction
findHeadAssetId :: TxOut ctx -> Maybe (PolicyId, AssetName)
dummyValidatorScript :: PlutusScript
instance GHC.Show.Show Hydra.Tx.Utils.IncrementalAction
instance GHC.Classes.Eq Hydra.Tx.Utils.IncrementalAction

module Hydra.Tx.Recover

-- | Builds a recover transaction to recover locked funds from the
--   v_deposit script.
recoverTx :: TxId -> UTxO -> SlotNo -> Tx
data RecoverObservation
RecoverObservation :: HeadId -> TxId -> UTxO -> RecoverObservation
[$sel:headId:RecoverObservation] :: RecoverObservation -> HeadId
[$sel:recoveredTxId:RecoverObservation] :: RecoverObservation -> TxId
[$sel:recoveredUTxO:RecoverObservation] :: RecoverObservation -> UTxO
observeRecoverTx :: NetworkId -> UTxO -> Tx -> Maybe RecoverObservation
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.Recover.RecoverObservation
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.Recover.RecoverObservation
instance GHC.Generics.Generic Hydra.Tx.Recover.RecoverObservation
instance GHC.Classes.Eq Hydra.Tx.Recover.RecoverObservation
instance GHC.Show.Show Hydra.Tx.Recover.RecoverObservation

module Hydra.Tx.Init

-- | Create the init transaction from some <a>HeadParameters</a> and a
--   single TxIn which will be used as unique parameter for minting NFTs.
initTx :: NetworkId -> TxIn -> [OnChainId] -> HeadParameters -> Tx
mkHeadOutput :: NetworkId -> PolicyId -> TxOutDatum ctx -> TxOut ctx
mkHeadOutputInitial :: NetworkId -> TxIn -> HeadParameters -> TxOut CtxTx
mkInitialOutput :: NetworkId -> TxIn -> OnChainId -> TxOut CtxTx

-- | Data which can be observed from an <a>initTx</a>.
data InitObservation
InitObservation :: HeadId -> HeadSeed -> HeadParameters -> [OnChainId] -> InitObservation
[$sel:headId:InitObservation] :: InitObservation -> HeadId
[$sel:headSeed:InitObservation] :: InitObservation -> HeadSeed
[$sel:headParameters:InitObservation] :: InitObservation -> HeadParameters
[$sel:participants:InitObservation] :: InitObservation -> [OnChainId]
data NotAnInitReason
NoHeadOutput :: NotAnInitReason
NotAHeadDatum :: NotAnInitReason
InvalidPartyInDatum :: NotAnInitReason
NoSTFound :: NotAnInitReason
NotAHeadPolicy :: NotAnInitReason

-- | Identify a init tx by checking the output value for holding tokens
--   that are valid head tokens (checked by seed + policy).
observeInitTx :: Tx -> Either NotAnInitReason InitObservation
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.Init.InitObservation
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.Init.InitObservation
instance GHC.Generics.Generic Hydra.Tx.Init.InitObservation
instance GHC.Classes.Eq Hydra.Tx.Init.InitObservation
instance GHC.Show.Show Hydra.Tx.Init.InitObservation
instance GHC.Generics.Generic Hydra.Tx.Init.NotAnInitReason
instance GHC.Classes.Eq Hydra.Tx.Init.NotAnInitReason
instance GHC.Show.Show Hydra.Tx.Init.NotAnInitReason

module Hydra.Tx.Increment

-- | Construct a _increment_ transaction which takes as input some
--   <a>UTxO'</a> locked at v_deposit and make it available on L2.
incrementTx :: ScriptRegistry -> VerificationKey PaymentKey -> HeadId -> HeadParameters -> (TxIn, TxOut CtxUTxO) -> Snapshot Tx -> UTxO -> SlotNo -> MultiSignature (Snapshot Tx) -> Tx
data IncrementObservation
IncrementObservation :: HeadId -> SnapshotVersion -> TxId -> IncrementObservation
[$sel:headId:IncrementObservation] :: IncrementObservation -> HeadId
[$sel:newVersion:IncrementObservation] :: IncrementObservation -> SnapshotVersion
[$sel:depositTxId:IncrementObservation] :: IncrementObservation -> TxId
observeIncrementTx :: UTxO -> Tx -> Maybe IncrementObservation
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.Increment.IncrementObservation
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.Increment.IncrementObservation
instance GHC.Generics.Generic Hydra.Tx.Increment.IncrementObservation
instance GHC.Classes.Eq Hydra.Tx.Increment.IncrementObservation
instance GHC.Show.Show Hydra.Tx.Increment.IncrementObservation

module Hydra.Tx.Fanout

-- | Create the fanout transaction, which distributes the closed state
--   accordingly. The head validator allows fanout only &gt; deadline, so
--   we need to set the lower bound to be deadline + 1 slot.
fanoutTx :: ScriptRegistry -> UTxO -> Maybe UTxO -> Maybe UTxO -> (TxIn, TxOut CtxUTxO) -> SlotNo -> PlutusScript -> Tx
data FanoutObservation
FanoutObservation :: HeadId -> UTxO -> FanoutObservation
[$sel:headId:FanoutObservation] :: FanoutObservation -> HeadId
[$sel:fanoutUTxO:FanoutObservation] :: FanoutObservation -> UTxO

-- | Identify a fanout tx by lookup up the input spending the Head output
--   and decoding its redeemer.
observeFanoutTx :: UTxO -> Tx -> Maybe FanoutObservation
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.Fanout.FanoutObservation
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.Fanout.FanoutObservation
instance GHC.Generics.Generic Hydra.Tx.Fanout.FanoutObservation
instance GHC.Show.Show Hydra.Tx.Fanout.FanoutObservation
instance GHC.Classes.Eq Hydra.Tx.Fanout.FanoutObservation

module Hydra.Tx.Deposit

-- | Builds a deposit transaction to lock funds into the v_deposit script.
depositTx :: NetworkId -> HeadId -> CommitBlueprintTx Tx -> SlotNo -> UTCTime -> Tx
mkDepositOutput :: NetworkId -> HeadId -> UTxO -> UTCTime -> TxOut ctx
depositAddress :: NetworkId -> AddressInEra
data DepositObservation
DepositObservation :: HeadId -> TxId -> UTxO -> SlotNo -> UTCTime -> DepositObservation
[$sel:headId:DepositObservation] :: DepositObservation -> HeadId
[$sel:depositTxId:DepositObservation] :: DepositObservation -> TxId
[$sel:deposited:DepositObservation] :: DepositObservation -> UTxO
[$sel:created:DepositObservation] :: DepositObservation -> SlotNo
[$sel:deadline:DepositObservation] :: DepositObservation -> UTCTime

-- | Observe a deposit transaction by decoding the target head id, deposit
--   deadline and deposited utxo in the datum.
--   
--   This includes checking whether - the first output is a deposit output
--   - all inputs of deposited utxo are actually spent, - the deposit
--   script output actually contains the deposited value, - an upper
--   validity bound has been set (used as creation slot).
observeDepositTx :: NetworkId -> Tx -> Maybe DepositObservation
observeDepositTxOut :: Network -> TxOut CtxUTxO -> Maybe (HeadId, UTxO, POSIXTime)
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.Deposit.DepositObservation
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.Deposit.DepositObservation
instance GHC.Generics.Generic Hydra.Tx.Deposit.DepositObservation
instance GHC.Classes.Eq Hydra.Tx.Deposit.DepositObservation
instance GHC.Show.Show Hydra.Tx.Deposit.DepositObservation

module Hydra.Tx.Decrement

-- | Construct a _decrement_ transaction which takes as input some
--   <a>UTxO'</a> present in the L2 ledger state and makes it available on
--   L1.
decrementTx :: ScriptRegistry -> VerificationKey PaymentKey -> HeadId -> HeadParameters -> (TxIn, TxOut CtxUTxO) -> Snapshot Tx -> MultiSignature (Snapshot Tx) -> Tx
data DecrementObservation
DecrementObservation :: HeadId -> SnapshotVersion -> UTxO -> DecrementObservation
[$sel:headId:DecrementObservation] :: DecrementObservation -> HeadId
[$sel:newVersion:DecrementObservation] :: DecrementObservation -> SnapshotVersion
[$sel:distributedUTxO:DecrementObservation] :: DecrementObservation -> UTxO
observeDecrementTx :: UTxO -> Tx -> Maybe DecrementObservation
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.Decrement.DecrementObservation
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.Decrement.DecrementObservation
instance GHC.Generics.Generic Hydra.Tx.Decrement.DecrementObservation
instance GHC.Classes.Eq Hydra.Tx.Decrement.DecrementObservation
instance GHC.Show.Show Hydra.Tx.Decrement.DecrementObservation

module Hydra.Tx.Commit

-- | Craft a commit transaction which includes the "committed" utxo as a
--   datum.
commitTx :: NetworkId -> ScriptRegistry -> HeadId -> Party -> CommitBlueprintTx Tx -> (TxIn, TxOut CtxUTxO, Hash PaymentKey) -> Tx
mkCommitDatum :: Party -> UTxO -> CurrencySymbol -> Datum

-- | Full observation of a commit transaction.
data CommitObservation
CommitObservation :: Party -> UTxO -> HeadId -> CommitObservation

-- | Hydra participant who committed the UTxO.
[$sel:party:CommitObservation] :: CommitObservation -> Party
[$sel:committed:CommitObservation] :: CommitObservation -> UTxO
[$sel:headId:CommitObservation] :: CommitObservation -> HeadId

-- | Identify a commit tx by:
--   
--   <ul>
--   <li>Check that its spending from the init validator,</li>
--   <li>Find the outputs which pays to the commit validator,</li>
--   <li>Using the datum of that output, deserialize the committed
--   output,</li>
--   <li>Reconstruct the committed UTxO from both values (tx input and
--   output).</li>
--   </ul>
observeCommitTx :: NetworkId -> UTxO -> Tx -> Maybe CommitObservation
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.Commit.CommitObservation
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.Commit.CommitObservation
instance GHC.Generics.Generic Hydra.Tx.Commit.CommitObservation
instance GHC.Show.Show Hydra.Tx.Commit.CommitObservation
instance GHC.Classes.Eq Hydra.Tx.Commit.CommitObservation

module Hydra.Tx.CollectCom

-- | Create a transaction collecting all "committed" utxo and opening a
--   Head, i.e. driving the Head script state.
collectComTx :: NetworkId -> ScriptRegistry -> VerificationKey PaymentKey -> HeadId -> HeadParameters -> (TxIn, TxOut CtxUTxO) -> Map TxIn (TxOut CtxUTxO) -> UTxO -> Tx
newtype UTxOHash
UTxOHash :: ByteString -> UTxOHash
data CollectComObservation
CollectComObservation :: HeadId -> UTxOHash -> CollectComObservation
[$sel:headId:CollectComObservation] :: CollectComObservation -> HeadId
[$sel:utxoHash:CollectComObservation] :: CollectComObservation -> UTxOHash

-- | Identify a collectCom tx by lookup up the input spending the Head
--   output and decoding its redeemer.
observeCollectComTx :: UTxO -> Tx -> Maybe CollectComObservation
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.CollectCom.UTxOHash
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.CollectCom.UTxOHash
instance GHC.Generics.Generic Hydra.Tx.CollectCom.UTxOHash
instance GHC.Show.Show Hydra.Tx.CollectCom.UTxOHash
instance GHC.Classes.Eq Hydra.Tx.CollectCom.UTxOHash
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.CollectCom.CollectComObservation
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.CollectCom.CollectComObservation
instance GHC.Generics.Generic Hydra.Tx.CollectCom.CollectComObservation
instance GHC.Classes.Eq Hydra.Tx.CollectCom.CollectComObservation
instance GHC.Show.Show Hydra.Tx.CollectCom.CollectComObservation
instance Cardano.Api.Internal.HasTypeProxy.HasTypeProxy Hydra.Tx.CollectCom.UTxOHash
instance Cardano.Api.Internal.SerialiseRaw.SerialiseAsRawBytes Hydra.Tx.CollectCom.UTxOHash
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Tx.CollectCom.UTxOHash

module Hydra.Tx.Close
type PointInTime = (SlotNo, UTCTime)

-- | Representation of the Head output after a CollectCom transaction.
data OpenThreadOutput
OpenThreadOutput :: (TxIn, TxOut CtxUTxO) -> ContestationPeriod -> [Party] -> OpenThreadOutput
[$sel:openThreadUTxO:OpenThreadOutput] :: OpenThreadOutput -> (TxIn, TxOut CtxUTxO)
[$sel:openContestationPeriod:OpenThreadOutput] :: OpenThreadOutput -> ContestationPeriod
[$sel:openParties:OpenThreadOutput] :: OpenThreadOutput -> [Party]

-- | Create a transaction closing a head with either the initial snapshot
--   or with a multi-signed confirmed snapshot.
closeTx :: ScriptRegistry -> VerificationKey PaymentKey -> HeadId -> SnapshotVersion -> ConfirmedSnapshot Tx -> SlotNo -> PointInTime -> OpenThreadOutput -> IncrementalAction -> Tx
data CloseObservation
CloseObservation :: HeadId -> SnapshotNumber -> UTCTime -> CloseObservation
[$sel:headId:CloseObservation] :: CloseObservation -> HeadId
[$sel:snapshotNumber:CloseObservation] :: CloseObservation -> SnapshotNumber
[$sel:contestationDeadline:CloseObservation] :: CloseObservation -> UTCTime

-- | Identify a close tx by lookup up the input spending the Head output
--   and decoding its redeemer.
observeCloseTx :: UTxO -> Tx -> Maybe CloseObservation
instance GHC.Generics.Generic Hydra.Tx.Close.OpenThreadOutput
instance GHC.Show.Show Hydra.Tx.Close.OpenThreadOutput
instance GHC.Classes.Eq Hydra.Tx.Close.OpenThreadOutput
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.Close.CloseObservation
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.Close.CloseObservation
instance GHC.Generics.Generic Hydra.Tx.Close.CloseObservation
instance GHC.Classes.Eq Hydra.Tx.Close.CloseObservation
instance GHC.Show.Show Hydra.Tx.Close.CloseObservation

module Hydra.Tx.Contest
data ClosedThreadOutput
ClosedThreadOutput :: (TxIn, TxOut CtxUTxO) -> [Party] -> POSIXTime -> [PubKeyHash] -> ClosedThreadOutput
[$sel:closedThreadUTxO:ClosedThreadOutput] :: ClosedThreadOutput -> (TxIn, TxOut CtxUTxO)
[$sel:closedParties:ClosedThreadOutput] :: ClosedThreadOutput -> [Party]
[$sel:closedContestationDeadline:ClosedThreadOutput] :: ClosedThreadOutput -> POSIXTime
[$sel:closedContesters:ClosedThreadOutput] :: ClosedThreadOutput -> [PubKeyHash]
contestTx :: ScriptRegistry -> VerificationKey PaymentKey -> HeadId -> ContestationPeriod -> SnapshotVersion -> Snapshot Tx -> MultiSignature (Snapshot Tx) -> PointInTime -> ClosedThreadOutput -> IncrementalAction -> Tx
data ContestObservation
ContestObservation :: HeadId -> SnapshotNumber -> UTCTime -> [PubKeyHash] -> ContestObservation
[$sel:headId:ContestObservation] :: ContestObservation -> HeadId
[$sel:snapshotNumber:ContestObservation] :: ContestObservation -> SnapshotNumber
[$sel:contestationDeadline:ContestObservation] :: ContestObservation -> UTCTime
[$sel:contesters:ContestObservation] :: ContestObservation -> [PubKeyHash]

-- | Identify a close tx by lookup up the input spending the Head output
--   and decoding its redeemer.
observeContestTx :: UTxO -> Tx -> Maybe ContestObservation
instance GHC.Generics.Generic Hydra.Tx.Contest.ClosedThreadOutput
instance GHC.Show.Show Hydra.Tx.Contest.ClosedThreadOutput
instance GHC.Classes.Eq Hydra.Tx.Contest.ClosedThreadOutput
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.Contest.ContestObservation
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.Contest.ContestObservation
instance GHC.Generics.Generic Hydra.Tx.Contest.ContestObservation
instance GHC.Classes.Eq Hydra.Tx.Contest.ContestObservation
instance GHC.Show.Show Hydra.Tx.Contest.ContestObservation

module Hydra.Tx.Abort
data AbortTxError
OverlappingInputs :: AbortTxError
CannotFindHeadOutputToAbort :: AbortTxError

-- | Create transaction which aborts a head by spending the Head output and
--   all other "initial" outputs.
abortTx :: UTxO -> ScriptRegistry -> VerificationKey PaymentKey -> (TxIn, TxOut CtxUTxO) -> PlutusScript -> Map TxIn (TxOut CtxUTxO) -> Map TxIn (TxOut CtxUTxO) -> Either AbortTxError Tx
newtype AbortObservation
AbortObservation :: HeadId -> AbortObservation
[$sel:headId:AbortObservation] :: AbortObservation -> HeadId

-- | Identify an abort tx by looking up the input spending the Head output
--   and decoding its redeemer.
observeAbortTx :: UTxO -> Tx -> Maybe AbortObservation
instance GHC.Show.Show Hydra.Tx.Abort.AbortTxError
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.Abort.AbortObservation
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.Abort.AbortObservation
instance GHC.Generics.Generic Hydra.Tx.Abort.AbortObservation
instance GHC.Show.Show Hydra.Tx.Abort.AbortObservation
instance GHC.Classes.Eq Hydra.Tx.Abort.AbortObservation


-- | Observe hydra transactions
module Hydra.Tx.Observe

-- | Generalised type for arbitrary Head observations on-chain.
data HeadObservation
NoHeadTx :: HeadObservation
Init :: InitObservation -> HeadObservation
Abort :: AbortObservation -> HeadObservation
Commit :: CommitObservation -> HeadObservation
CollectCom :: CollectComObservation -> HeadObservation
Deposit :: DepositObservation -> HeadObservation
Recover :: RecoverObservation -> HeadObservation
Increment :: IncrementObservation -> HeadObservation
Decrement :: DecrementObservation -> HeadObservation
Close :: CloseObservation -> HeadObservation
Contest :: ContestObservation -> HeadObservation
Fanout :: FanoutObservation -> HeadObservation

-- | Observe any Hydra head transaction.
observeHeadTx :: NetworkId -> UTxO -> Tx -> HeadObservation

-- | Data which can be observed from an <a>initTx</a>.
data InitObservation
InitObservation :: HeadId -> HeadSeed -> HeadParameters -> [OnChainId] -> InitObservation
[$sel:headId:InitObservation] :: InitObservation -> HeadId
[$sel:headSeed:InitObservation] :: InitObservation -> HeadSeed
[$sel:headParameters:InitObservation] :: InitObservation -> HeadParameters
[$sel:participants:InitObservation] :: InitObservation -> [OnChainId]
data NotAnInitReason
NoHeadOutput :: NotAnInitReason
NotAHeadDatum :: NotAnInitReason
InvalidPartyInDatum :: NotAnInitReason
NoSTFound :: NotAnInitReason
NotAHeadPolicy :: NotAnInitReason

-- | Identify a init tx by checking the output value for holding tokens
--   that are valid head tokens (checked by seed + policy).
observeInitTx :: Tx -> Either NotAnInitReason InitObservation
newtype AbortObservation
AbortObservation :: HeadId -> AbortObservation
[$sel:headId:AbortObservation] :: AbortObservation -> HeadId

-- | Identify an abort tx by looking up the input spending the Head output
--   and decoding its redeemer.
observeAbortTx :: UTxO -> Tx -> Maybe AbortObservation

-- | Full observation of a commit transaction.
data CommitObservation
CommitObservation :: Party -> UTxO -> HeadId -> CommitObservation

-- | Hydra participant who committed the UTxO.
[$sel:party:CommitObservation] :: CommitObservation -> Party
[$sel:committed:CommitObservation] :: CommitObservation -> UTxO
[$sel:headId:CommitObservation] :: CommitObservation -> HeadId

-- | Identify a commit tx by:
--   
--   <ul>
--   <li>Check that its spending from the init validator,</li>
--   <li>Find the outputs which pays to the commit validator,</li>
--   <li>Using the datum of that output, deserialize the committed
--   output,</li>
--   <li>Reconstruct the committed UTxO from both values (tx input and
--   output).</li>
--   </ul>
observeCommitTx :: NetworkId -> UTxO -> Tx -> Maybe CommitObservation
data CollectComObservation
CollectComObservation :: HeadId -> UTxOHash -> CollectComObservation
[$sel:headId:CollectComObservation] :: CollectComObservation -> HeadId
[$sel:utxoHash:CollectComObservation] :: CollectComObservation -> UTxOHash

-- | Identify a collectCom tx by lookup up the input spending the Head
--   output and decoding its redeemer.
observeCollectComTx :: UTxO -> Tx -> Maybe CollectComObservation
data DecrementObservation
DecrementObservation :: HeadId -> SnapshotVersion -> UTxO -> DecrementObservation
[$sel:headId:DecrementObservation] :: DecrementObservation -> HeadId
[$sel:newVersion:DecrementObservation] :: DecrementObservation -> SnapshotVersion
[$sel:distributedUTxO:DecrementObservation] :: DecrementObservation -> UTxO
observeDecrementTx :: UTxO -> Tx -> Maybe DecrementObservation
data DepositObservation
DepositObservation :: HeadId -> TxId -> UTxO -> SlotNo -> UTCTime -> DepositObservation
[$sel:headId:DepositObservation] :: DepositObservation -> HeadId
[$sel:depositTxId:DepositObservation] :: DepositObservation -> TxId
[$sel:deposited:DepositObservation] :: DepositObservation -> UTxO
[$sel:created:DepositObservation] :: DepositObservation -> SlotNo
[$sel:deadline:DepositObservation] :: DepositObservation -> UTCTime

-- | Observe a deposit transaction by decoding the target head id, deposit
--   deadline and deposited utxo in the datum.
--   
--   This includes checking whether - the first output is a deposit output
--   - all inputs of deposited utxo are actually spent, - the deposit
--   script output actually contains the deposited value, - an upper
--   validity bound has been set (used as creation slot).
observeDepositTx :: NetworkId -> Tx -> Maybe DepositObservation
data IncrementObservation
IncrementObservation :: HeadId -> SnapshotVersion -> TxId -> IncrementObservation
[$sel:headId:IncrementObservation] :: IncrementObservation -> HeadId
[$sel:newVersion:IncrementObservation] :: IncrementObservation -> SnapshotVersion
[$sel:depositTxId:IncrementObservation] :: IncrementObservation -> TxId
observeIncrementTx :: UTxO -> Tx -> Maybe IncrementObservation
data RecoverObservation
RecoverObservation :: HeadId -> TxId -> UTxO -> RecoverObservation
[$sel:headId:RecoverObservation] :: RecoverObservation -> HeadId
[$sel:recoveredTxId:RecoverObservation] :: RecoverObservation -> TxId
[$sel:recoveredUTxO:RecoverObservation] :: RecoverObservation -> UTxO
observeRecoverTx :: NetworkId -> UTxO -> Tx -> Maybe RecoverObservation
data CloseObservation
CloseObservation :: HeadId -> SnapshotNumber -> UTCTime -> CloseObservation
[$sel:headId:CloseObservation] :: CloseObservation -> HeadId
[$sel:snapshotNumber:CloseObservation] :: CloseObservation -> SnapshotNumber
[$sel:contestationDeadline:CloseObservation] :: CloseObservation -> UTCTime

-- | Identify a close tx by lookup up the input spending the Head output
--   and decoding its redeemer.
observeCloseTx :: UTxO -> Tx -> Maybe CloseObservation
data ContestObservation
ContestObservation :: HeadId -> SnapshotNumber -> UTCTime -> [PubKeyHash] -> ContestObservation
[$sel:headId:ContestObservation] :: ContestObservation -> HeadId
[$sel:snapshotNumber:ContestObservation] :: ContestObservation -> SnapshotNumber
[$sel:contestationDeadline:ContestObservation] :: ContestObservation -> UTCTime
[$sel:contesters:ContestObservation] :: ContestObservation -> [PubKeyHash]

-- | Identify a close tx by lookup up the input spending the Head output
--   and decoding its redeemer.
observeContestTx :: UTxO -> Tx -> Maybe ContestObservation
data FanoutObservation
FanoutObservation :: HeadId -> UTxO -> FanoutObservation
[$sel:headId:FanoutObservation] :: FanoutObservation -> HeadId
[$sel:fanoutUTxO:FanoutObservation] :: FanoutObservation -> UTxO

-- | Identify a fanout tx by lookup up the input spending the Head output
--   and decoding its redeemer.
observeFanoutTx :: UTxO -> Tx -> Maybe FanoutObservation
instance GHC.Generics.Generic Hydra.Tx.Observe.HeadObservation
instance GHC.Show.Show Hydra.Tx.Observe.HeadObservation
instance GHC.Classes.Eq Hydra.Tx.Observe.HeadObservation
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Tx.Observe.HeadObservation
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Tx.Observe.HeadObservation
