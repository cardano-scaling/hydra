-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Hydra node
@package hydra-node
@version 0.22.2

module Hydra.API.ClientInputSpec
spec :: Spec

module Hydra.API.ServerOutputSpec
spec :: Spec

module Hydra.API.ServerSpec
spec :: Spec
sendsAnErrorWhenInputCannotBeDecoded :: PortNumber -> Expectation
matchGreetings :: Value -> Bool
waitForClients :: (MonadSTM m, Ord a, Num a) => TVar m a -> m ()
testClient :: TQueue IO Value -> TVar IO Int -> Connection -> IO ()
dummyChainHandle :: Chain tx IO
allowEverythingServerOutputFilter :: ServerOutputFilter tx
noop :: Applicative m => a -> m ()
withTestAPIServer :: PortNumber -> Party -> EventSource (StateEvent SimpleTx) IO -> Tracer IO APIServerLog -> ((EventSink (StateEvent SimpleTx) IO, Server SimpleTx IO) -> IO ()) -> IO ()

-- | Connect to a websocket server running at given path. Fails if not
--   connected within 2 seconds.
withClient :: PortNumber -> String -> (Connection -> IO ()) -> IO ()
mockSource :: Monad m => [a] -> EventSource a m
waitForValue :: HasCallStack => PortNumber -> (Value -> Maybe ()) -> IO ()

-- | Wait up to some time for an API server output to match the given
--   predicate.
waitMatch :: HasCallStack => Natural -> Connection -> (Value -> Maybe a) -> IO a
shouldSatisfyAll :: forall a. HasCallStack => Show a => [a] -> [a -> Bool] -> Expectation
genStateEventForApi :: Gen (StateEvent SimpleTx)

module Hydra.Chain.Direct.HandlersSpec
genTimeHandleWithSlotInsideHorizon :: Gen (TimeHandle, SlotNo)
genTimeHandleWithSlotPastHorizon :: Gen (TimeHandle, SlotNo)
spec :: Spec

-- | Create a chain sync handler which records events as they are called
--   back.
recordEventsHandler :: ChainContext -> ChainStateAt -> GetTimeHandle IO -> IO (ChainSyncHandler IO, IO [ChainEvent Tx])

-- | A block used for testing. This is a simpler version of the cardano-api
--   <tt>Block</tt> and can be de-/constructed easily.
data TestBlock
TestBlock :: BlockHeader -> [Tx] -> TestBlock

-- | Thin wrapper which generates a <a>TestBlock</a> at some specific slot.
genBlockAt :: SlotNo -> [Tx] -> Gen TestBlock

-- | Pick a block point in a list of blocks.
genRollbackPoint :: [TestBlock] -> Gen ChainPoint

-- | Pick a rollback point from a list of blocks and also yield the tail of
--   blocks to be replayed.
genRollbackBlocks :: [TestBlock] -> Gen (ChainPoint, [TestBlock])

-- | Generate a non-sparse sequence of blocks each containing an observable
--   transaction, starting from the returned on-chain head state.
--   
--   Note that this does not generate the entire spectrum of observable
--   transactions in Hydra, but only init and commits, which is already
--   sufficient to observe at least one state transition and different
--   levels of rollback.
genSequenceOfObservableBlocks :: Gen (ChainContext, ChainStateAt, [TestBlock])

module Hydra.Chain.Direct.ScriptRegistrySpec
spec :: Spec

module Hydra.Chain.Direct.StateSpec
spec :: Spec
genInitTxMutation :: TxIn -> Tx -> Gen (Mutation, String, NotAnInitReason)
genCommitTxMutation :: UTxO -> Tx -> Gen Mutation
genAdaOnlyUTxOOnMainnetWithAmountBiggerThanOutLimit :: Gen UTxO

-- | Given any Head protocol state and the transaction corresponding a
--   protocol transition we should be able to observe this transition
--   correctly even in presence of other valid Hydra Head protocol states
--   in the used lookup utxo.
prop_observeAnyTx :: Property

-- | Given a UTxO with more than one entry, we can split it into two
--   non-empty UTxO.
prop_splitUTxO :: UTxO -> Property
prop_canCloseFanoutEveryCollect :: Property
prop_incrementObservesCorrectUTxO :: Property
propBelowSizeLimit :: Natural -> ((UTxO -> Tx -> Property) -> Property) -> SpecWith ()
propIsValid :: ((UTxO -> Tx -> Property) -> Property) -> SpecWith ()
forAllInit :: Testable property => (UTxO -> Tx -> property) -> Property
forAllCommit :: Testable property => (UTxO -> Tx -> property) -> Property
forAllCommit' :: Testable property => (ChainContext -> InitialState -> UTxO -> Tx -> property) -> Property
forAllAbort :: Testable property => (UTxO -> Tx -> property) -> Property
forAllCollectCom :: Testable property => (UTxO -> Tx -> property) -> Property
forAllDeposit :: Testable property => (UTxO -> Tx -> property) -> Property
forAllRecover :: Testable property => (UTxO -> Tx -> property) -> Property
forAllIncrement :: Testable property => (UTxO -> Tx -> property) -> Property
forAllIncrement' :: Testable property => (UTxO -> Tx -> property) -> Property
forAllDecrement :: Testable property => (UTxO -> Tx -> property) -> Property
forAllDecrement' :: Testable property => (UTxO -> UTxO -> Tx -> property) -> Property
forAllClose :: Testable property => (UTxO -> Tx -> property) -> Property
forAllContest :: Testable property => (UTxO -> Tx -> property) -> Property
forAllFanout :: Testable property => (UTxO -> Tx -> property) -> Property

-- | Generate an init tx with the used seed TxIn.
genInitTxWithSeed :: HydraContext -> Gen (Tx, TxIn)
mfail :: MonadFail m => Maybe a -> m a

module Hydra.Chain.Direct.TimeHandleSpec
spec :: Spec


-- | Remainder of tests covering observation and tx creation by the
--   "direct" chain component. XXX: This does not have a corresponding
--   "source" module which it tests.
module Hydra.Chain.Direct.TxSpec
spec :: Spec

-- | Check auxiliary data of a transaction against <a>pparams</a> and
--   whether the aux data hash is consistent.
propHasValidAuxData :: Tx -> Property

-- | Check whether one set <tt>isSubsetOf</tt> of another with nice counter
--   examples.
propIsSubsetOf :: (Show a, Ord a) => Set a -> Set a -> Property

-- | Check whether one map <tt>isSubmapOf</tt> of another with nice counter
--   examples.
propIsSubmapOf :: (Show k, Show v, Ord k, Eq v) => Map k v -> Map k v -> Property
genBlueprintTxWithUTxO :: Gen (UTxO, Tx)
genMetadata :: Gen TxMetadataInEra
getAuxMetadata :: Tx -> Map Word64 Metadatum
prop_interestingBlueprintTx :: Property

module Hydra.Chain.Direct.WalletSpec
spec :: Spec
setupQuery :: VerificationKey PaymentKey -> IO (ChainQuery IO, QueryPoint -> Expectation)
mockChainQuery :: VerificationKey PaymentKey -> ChainQuery IO
mockQueryEpochInfo :: IO (EpochInfo (Either Text))
mockQueryPParams :: IO (PParams ConwayEra)
prop_wellSuitedGenerators :: Property
prop_reducesWhenNotOurs :: Property
prop_seenInputsAreConsumed :: Property
prop_setsMinUTxOValue :: Property
prop_balanceTransaction :: Property
hasLowFees :: PParams LedgerEra -> Tx LedgerEra -> Property
isBalanced :: Map TxIn TxOut -> Tx LedgerEra -> Tx LedgerEra -> Property
prop_picksLargestUTxOToPayTheFees :: Property

-- | Generate an arbitrary list of transactions from a UTXO set such that,
--   transactions may *sometimes* consume given UTXO and produce new ones.
--   The generator is geared towards certain use-cases,
genTxsSpending :: Map TxIn TxOut -> Gen [Tx LedgerEra]
genUTxO :: Gen (Map TxIn TxOut)
genOutputsForInputs :: Tx LedgerEra -> Gen (Map TxIn TxOut)
genLedgerTx :: Gen (Tx LedgerEra)
allTxIns :: [Tx LedgerEra] -> Set TxIn
allTxOuts :: [Tx LedgerEra] -> [TxOut]
isOurs :: Map TxIn TxOut -> Address -> Bool
ourDirectInputs :: Map TxIn TxOut -> [Tx LedgerEra] -> [TxIn]
ourOutputs :: Map TxIn TxOut -> [Tx LedgerEra] -> [TxOut]
getValue :: TxOut -> Value LedgerEra
deltaValue :: Value LedgerEra -> Value LedgerEra -> Value LedgerEra

-- | NOTE: This does not account for withdrawals
knownInputBalance :: Map TxIn TxOut -> Tx LedgerEra -> Value LedgerEra

-- | NOTE: This does not account for deposits
outputBalance :: Tx LedgerEra -> Value LedgerEra


-- | Tests for the <a>EventSource</a> and <a>EventSink</a> implementation
--   in <a>FileBased</a>.
module Hydra.Events.FileBasedSpec
spec :: Spec
genContinuousEvents :: Gen [StateEvent SimpleTx]
withEventSourceAndSink :: (EventSource (StateEvent SimpleTx) IO -> EventSink (StateEvent SimpleTx) IO -> IO b) -> IO b


-- | Tests for the AWS S3 example event source and sink.
module Hydra.Events.S3Spec
spec :: Spec
genContinuousEvents :: Gen [EventId]


-- | Tests for the UDP example event sink.
module Hydra.Events.UDPSpec
spec :: Spec


-- | Tests our JSON schema test utilities.
module Hydra.JSONSchemaSpec
spec :: Spec

module Hydra.Ledger.Cardano.TimeSpec
spec :: Spec

-- | Generate a UTCTime using millisecond precision time since epoch.
genUTCTime :: Gen UTCTime
genSlotLength :: Gen SlotLength
genSystemStart :: Gen SystemStart


-- | Unit tests of the protocol logic in <tt>HeadLogic</tt>. These are very
--   fine grained and specific to individual steps in the protocol. More
--   high-level of the protocol logic, especially between multiple parties
--   can be found in <a>BehaviorSpec</a>.
module Hydra.HeadLogicSpec
spec :: Spec
prop_ignoresUnrelatedOnInitTx :: Property
genClosedState :: Gen (HeadState SimpleTx)

-- | Create a network input about a received protocol message with default
--   ttl and <a>alice</a> as the sender.
receiveMessage :: Message tx -> Input tx

-- | Create a network input about a received protocol message with default
--   ttl from given sender.
receiveMessageFrom :: Party -> Message tx -> Input tx

-- | Create a chain effect with fixed chain state and slot.
chainEffect :: PostChainTx SimpleTx -> Effect SimpleTx

-- | Create an observation chain input with chain state at given slot.
observeTxAtSlot :: Natural -> OnChainTx SimpleTx -> Input SimpleTx

-- | Create an observation chain input with fixed chain state and slot.
observeTx :: OnChainTx SimpleTx -> Input SimpleTx
connectivityChanged :: TTL -> Connectivity -> Input SimpleTx
inIdleState :: HeadState SimpleTx
inInitialState :: [Party] -> HeadState SimpleTx
inOpenState :: [Party] -> HeadState SimpleTx
inOpenState' :: [Party] -> CoordinatedHeadState SimpleTx -> HeadState SimpleTx
inClosedState :: [Party] -> HeadState SimpleTx
inClosedState' :: [Party] -> ConfirmedSnapshot SimpleTx -> HeadState SimpleTx
getConfirmedSnapshot :: HeadState tx -> Maybe (Snapshot tx)
data StepState tx
StepState :: HeadState tx -> Environment -> Ledger tx -> StepState tx
[$sel:headState:StepState] :: StepState tx -> HeadState tx
[$sel:env:StepState] :: StepState tx -> Environment
[$sel:ledger:StepState] :: StepState tx -> Ledger tx
runHeadLogic :: Monad m => Environment -> Ledger tx -> HeadState tx -> StateT (StepState tx) m a -> m a

-- | Retrieves the latest <a>HeadState</a> from within <a>runHeadLogic</a>.
getState :: MonadState (StepState tx) m => m (HeadState tx)

-- | Calls <a>update</a> and <a>aggregate</a> to drive the
--   <a>runHeadLogic</a> monad forward.
step :: (MonadState (StepState tx) m, IsChainState tx) => Input tx -> m (Outcome tx)
hasEffect :: (HasCallStack, IsChainState tx) => Outcome tx -> Effect tx -> IO ()
assertWait :: (HasCallStack, IsChainState tx) => Outcome tx -> WaitReason tx -> IO ()
hasEffectSatisfying :: (HasCallStack, IsChainState tx) => Outcome tx -> (Effect tx -> Bool) -> IO ()
hasNoEffectSatisfying :: (HasCallStack, IsChainState tx) => Outcome tx -> (Effect tx -> Bool) -> IO ()
hasStateChangedSatisfying :: (HasCallStack, IsChainState tx) => Outcome tx -> (StateChanged tx -> Bool) -> IO ()
hasNoStateChangedSatisfying :: (HasCallStack, IsChainState tx) => Outcome tx -> (StateChanged tx -> Bool) -> IO ()
testSnapshot :: Monoid (UTxOType tx) => SnapshotNumber -> SnapshotVersion -> [tx] -> UTxOType tx -> Snapshot tx

module Hydra.HeadLogicSnapshotSpec
spec :: Spec
prop_singleMemberHeadAlwaysSnapshotOnReqTx :: ConfirmedSnapshot SimpleTx -> Property
prop_thereIsAlwaysALeader :: Property

module Hydra.API.HTTPServerSpec
spec :: Spec
apiServerSpec :: Spec

-- | Create a <a>ResponseMatcher</a> or <a>MatchBody</a> from a JSON
--   serializable value (using their <a>IsString</a> instances).
matchJSON :: (IsString s, ToJSON a) => a -> s

-- | Create a <a>MatchBody</a> that validates the returned JSON response
--   against a schema. NOTE: This raises impure exceptions, so only use it
--   in this test suite.
matchValidJSON :: FilePath -> SchemaSelector -> MatchBody

module Hydra.Ledger.SimpleSpec
spec :: Spec
prop_validateCorrectTransactions :: Property
shrinkSequence :: [SimpleTx] -> [[SimpleTx]]
genSequenceOfValidTransactions :: UTxOType SimpleTx -> Gen [SimpleTx]

module Hydra.Logging.MonitoringSpec
spec :: Spec

module Hydra.LoggingSpec
spec :: Spec


-- | A simplistic type of transactions useful for modelling purpose. a
--   <a>Payment</a> is a simple transaction type that moves some amount of
--   ADAs between to <a>CardanoSigningKey</a>.
module Hydra.Model.Payment
newtype CardanoSigningKey
CardanoSigningKey :: SigningKey PaymentKey -> CardanoSigningKey
[$sel:signingKey:CardanoSigningKey] :: CardanoSigningKey -> SigningKey PaymentKey

-- | A single Ada-payment only transaction in our model.
data Payment
Payment :: CardanoSigningKey -> CardanoSigningKey -> Value -> Payment
[$sel:from:Payment] :: Payment -> CardanoSigningKey
[$sel:to:Payment] :: Payment -> CardanoSigningKey
[$sel:value:Payment] :: Payment -> Value
applyTx :: UTxOType Payment -> Payment -> UTxOType Payment
genAdaValue :: Gen Value
instance GHC.Show.Show Hydra.Model.Payment.CardanoSigningKey
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Model.Payment.Payment
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Model.Payment.Payment
instance GHC.Generics.Generic Hydra.Model.Payment.Payment
instance GHC.Classes.Eq Hydra.Model.Payment.Payment
instance GHC.Show.Show Hydra.Model.Payment.Payment
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Model.Payment.Payment
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Model.Payment.Payment
instance Hydra.Tx.IsTx.IsTx Hydra.Model.Payment.Payment
instance GHC.Classes.Eq Hydra.Model.Payment.CardanoSigningKey
instance GHC.Classes.Ord Hydra.Model.Payment.CardanoSigningKey
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Model.Payment.CardanoSigningKey
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Model.Payment.CardanoSigningKey
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Model.Payment.CardanoSigningKey
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Model.Payment.CardanoSigningKey
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Model.Payment.CardanoSigningKey
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Api.Internal.Value.Value
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Api.Internal.Value.Value
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Api.Internal.Value.Value

module Hydra.NetworkVersionsSpec
spec :: Spec
propParseNetworkTxIds :: Version -> String -> Property

module Hydra.Node.RunSpec
spec :: Spec
aConfigurationException :: Selector ConfigurationException

module Hydra.OptionsSpec
spec :: Spec
canRoundtripRunOptionsAndPrettyPrinting :: RunOptions -> Property
shouldParse :: HasCallStack => [String] -> Command -> Expectation
shouldNotParse :: HasCallStack => [String] -> Expectation

module Hydra.PartySpec
spec :: Spec

module Hydra.PersistenceSpec
spec :: Spec
genPersistenceItem :: Gen Value
genSomeText :: Gen Text
containsNewLine :: [Value] -> Bool

module Hydra.UtilsSpec
spec :: Spec

module Paths_hydra_node
version :: Version
getBinDir :: IO FilePath
getLibDir :: IO FilePath
getDynLibDir :: IO FilePath
getDataDir :: IO FilePath
getLibexecDir :: IO FilePath
getDataFileName :: FilePath -> IO FilePath
getSysconfDir :: IO FilePath

module Test.Util
noopCallback :: Applicative m => NetworkCallback msg m

-- | Run given <tt>action</tt> in <a>IOSim</a> and rethrow any exceptions.
shouldRunInSim :: (forall s. IOSim s a) -> IO a

-- | Run given <tt>action</tt> in <a>IOSim</a> as a <a>Property</a>
--   including the whole <a>HydraNodeLog</a> trace as a counterexample.
propRunInSim :: Testable prop => (forall s. IOSim s prop) -> Property

-- | Utility function to dump logs given a <a>SimTrace</a>.
printTrace :: forall log a. (Typeable log, ToJSON log) => Proxy log -> SimTrace a -> Text

-- | Lifted variant of Hspec's <a>shouldBe</a>.
shouldBe :: (HasCallStack, MonadThrow m, Eq a, Show a) => a -> a -> m ()

-- | Lifted variant of Hspec's <a>shouldNotBe</a>.
shouldNotBe :: (HasCallStack, MonadThrow m, Eq a, Show a) => a -> a -> m ()

-- | Lifted variant of Hspec's <a>shouldSatisfy</a>.
shouldSatisfy :: (HasCallStack, MonadThrow m, Show a) => a -> (a -> Bool) -> m ()

-- | A <a>Tracer</a> that works in <a>IOSim</a> monad. This tracer uses the
--   <tt>Output</tt> event which uses converts value traced to
--   <tt>Dynamic</tt> which requires <a>Typeable</a> constraint. To
--   retrieve the trace use <tt>selectTraceEventsDynamic</tt> applied to
--   the correct type.
traceInIOSim :: Typeable a => Tracer (IOSim s) a

-- | Useful when one needs to <i>also</i> trace logs to <a>stderr</a>.
--   Thanks to the monoidal nature of <a>Tracer</a> it's straightforward to
--   add this to any existing tracer:
--   
--   @<tt> someCode tracer = do foo &lt;- makeFoo withTracer (tr &lt;&gt;
--   traceDebug) SomeTraceFoo ... </tt>@
traceDebug :: (Applicative m, ToJSON a) => Tracer m a

-- | This creates an hspec test case about a property which ensures the
--   given generator does not produce equals values within a reasonable
--   number of generated values.
propCollisionResistant :: (Show a, Eq a) => String -> Gen a -> Spec

-- | Predicate which decides whether given list is continuous.
isContinuous :: (Eq a, Enum a) => [a] -> Bool

-- | Predicate which decides whether given list is strictly monotonic.
isStrictlyMonotonic :: Ord a => [a] -> Bool

-- | Wait up to some time for a function to yield an equal value.
waitEq :: (HasCallStack, Eq a, Show a) => IO a -> NominalDiffTime -> a -> IO ()

-- | Wait up to some time for a function to return a value that satisfies
--   given predicate.
waitMatch :: (HasCallStack, Show a) => IO a -> NominalDiffTime -> (a -> Maybe b) -> IO b

module Hydra.NodeSpec
spec :: Spec

-- | Add given list of inputs to the <a>InputQueue</a>. This is returning
--   the node to allow for chaining with <a>runToCompletion</a>.
primeWith :: Monad m => [Input tx] -> HydraNode tx m -> m (HydraNode tx m)

-- | Convert a <a>DraftHydraNode</a> to a <a>HydraNode</a> by providing
--   mock implementations.
notConnect :: MonadThrow m => DraftHydraNode tx m -> m (HydraNode tx m)
mockServer :: Monad m => Server tx m
mockNetwork :: Monad m => Network m (Message tx)
mockChain :: MonadThrow m => Chain tx m
mockSink :: Monad m => EventSink a m
mockEventStore :: forall a m. Monad m => [a] -> EventStore a m
mockSource :: Monad m => [a] -> EventSource a m
createRecordingSink :: IO (EventSink a IO, IO [a])
createMockEventStore :: MonadLabelledSTM m => m (EventStore a m)
inputsToOpenHead :: [Input SimpleTx]
observationInput :: OnChainTx SimpleTx -> Input SimpleTx
runToCompletion :: IsChainState tx => HydraNode tx IO -> IO ()

-- | Creates a full <a>HydraNode</a> with given parameters and primed
--   <a>Input</a>s. Note that this node is <a>notConnect</a>ed to any
--   components.
testHydraNode :: (MonadDelay m, MonadAsync m, MonadLabelledSTM m, MonadThrow m, MonadUnliftIO m) => Tracer m (HydraNodeLog SimpleTx) -> SigningKey HydraKey -> [Party] -> ContestationPeriod -> [Input SimpleTx] -> m (HydraNode SimpleTx m)

-- | A lot shorter than the real world ttl which requires to be long to
--   overcome some longer chain observation delays, but would just make
--   tests longer.
testTTL :: TTL
recordNetwork :: HydraNode tx IO -> IO (HydraNode tx IO, IO [Message tx])
recordServerOutputs :: IsChainState tx => HydraNode tx IO -> IO (HydraNode tx IO, IO [Either (ServerOutput tx) (ClientMessage tx)])
messageRecorder :: IO (msg -> IO (), IO [msg])
throwExceptionOnPostTx :: IsChainState tx => PostTxError tx -> HydraNode tx IO -> IO (HydraNode tx IO)

module Hydra.Events.RotationSpec
spec :: Spec
newtype TrivialEvent
TrivialEvent :: Word64 -> TrivialEvent
trivialCheckpoint :: [TrivialEvent] -> TrivialEvent
mkAggregator :: IsChainState tx => HeadState tx -> StateEvent tx -> HeadState tx
instance GHC.Classes.Eq Hydra.Events.RotationSpec.TrivialEvent
instance GHC.Show.Show Hydra.Events.RotationSpec.TrivialEvent
instance GHC.Num.Num Hydra.Events.RotationSpec.TrivialEvent
instance Hydra.Events.HasEventId Hydra.Events.RotationSpec.TrivialEvent

module Hydra.Node.InputQueueSpec
spec :: Spec
newtype DummyInput
DummyInput :: Int -> DummyInput
prop_identify_enqueued_items :: NonEmptyList Int -> Property
instance GHC.Show.Show Hydra.Node.InputQueueSpec.DummyInput
instance GHC.Classes.Eq Hydra.Node.InputQueueSpec.DummyInput


-- | Test the real networking layer
module Hydra.NetworkSpec
spec :: Spec
lo :: IsString s => s
data PeerConfig2
PeerConfig2 :: NetworkConfiguration -> NetworkConfiguration -> PeerConfig2
[$sel:aliceConfig:PeerConfig2] :: PeerConfig2 -> NetworkConfiguration
[$sel:bobConfig:PeerConfig2] :: PeerConfig2 -> NetworkConfiguration
setup2Peers :: FilePath -> IO PeerConfig2
data PeerConfig3
PeerConfig3 :: NetworkConfiguration -> NetworkConfiguration -> NetworkConfiguration -> PeerConfig3
[$sel:aliceConfig:PeerConfig3] :: PeerConfig3 -> NetworkConfiguration
[$sel:bobConfig:PeerConfig3] :: PeerConfig3 -> NetworkConfiguration
[$sel:carolConfig:PeerConfig3] :: PeerConfig3 -> NetworkConfiguration
setup3Peers :: FilePath -> IO PeerConfig3
prop_canRoundtripCBOREncoding :: (ToCBOR a, FromCBOR a, Eq a, Show a) => a -> Property
newRecordingCallback :: MonadSTM m => m (NetworkCallback msg m, m msg, m Connectivity)

module Hydra.Network.AuthenticateSpec
spec :: Spec
newtype Msg
Msg :: ByteString -> Msg
instance Cardano.Crypto.Util.SignableRepresentation Hydra.Network.AuthenticateSpec.Msg
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Network.AuthenticateSpec.Msg
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Network.AuthenticateSpec.Msg
instance GHC.Show.Show Hydra.Network.AuthenticateSpec.Msg
instance GHC.Classes.Eq Hydra.Network.AuthenticateSpec.Msg
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Network.AuthenticateSpec.Msg

module Hydra.Ledger.CardanoSpec
spec :: Spec
shouldParseJSONAs :: forall a. (HasCallStack, FromJSON a) => LByteString -> Expectation

-- | Test that the <a>PParams</a> To/FromJSON instances to roundtrip.
roundtripPParams :: PParams LedgerEra -> Property
appliesValidTransaction :: Property
appliesValidTransactionFromJSON :: Property

-- | A transaction or transaction output can usually only contain a
--   realistic number of native asset entries. This property checks a
--   realistic order of magnitude (100).
propRealisticValue :: Value -> Property

-- | Check that an output has enough lovelace to cover asset deposits.
propHasEnoughLovelace :: TxOut CtxUTxO -> Property

-- | Check that the given <a>TxOut</a> fulfills several requirements and
--   does not use unsupported features. See <a>genTxOut</a> for rationale.
propGeneratesGoodTxOut :: TxOut CtxUTxO -> Property

module Hydra.CryptoSpec
spec :: Spec
specSigningKey :: Spec
specVerificationKey :: Spec
specSignature :: Spec
specMultiSignature :: Spec

module Hydra.BehaviorSpec
spec :: Spec

-- | Wait for some output at some node(s) to be produced <i>eventually</i>.
--   See <a>waitUntilMatch</a> for how long it waits.
waitUntil :: (HasCallStack, MonadThrow m, MonadAsync m, MonadTimer m, IsChainState tx) => [TestHydraClient tx m] -> ServerOutput tx -> m ()

-- | Wait for a server output to match some predicate <i>eventually</i>. If
--   a client message is received instead, this fails. This will not wait
--   forever, but for a long time (1 month) to get a nice error location.
--   Should not be an issue when used within <a>shouldRunInSim</a>, this
--   was even 1000 years before - but we since we are having the protocol
--   produce <a>Tick</a> events constantly this would be fully simulated to
--   the end.
waitUntilMatch :: (Show (ServerOutput tx), HasCallStack, MonadThrow m, MonadAsync m, MonadTimer m, Eq a, Show a, IsChainState tx) => [TestHydraClient tx m] -> (ServerOutput tx -> Maybe a) -> m a
newtype NodeId
Node :: Natural -> NodeId

-- | A thin client layer around <a>HydraNode</a> to be interact with it
--   through <a>$sel:send:TestHydraClient</a>,
--   <a>$sel:waitForNext:TestHydraClient</a>, access all outputs and inject
--   events through the test chain.
data TestHydraClient tx m
TestHydraClient :: (ClientInput tx -> m ()) -> m (ServerOutput tx) -> m (ClientMessage tx) -> (ChainEvent tx -> m ()) -> m [ServerOutput tx] -> m (HeadState tx) -> TestHydraClient tx m
[$sel:send:TestHydraClient] :: TestHydraClient tx m -> ClientInput tx -> m ()
[$sel:waitForNext:TestHydraClient] :: TestHydraClient tx m -> m (ServerOutput tx)
[$sel:waitForNextMessage:TestHydraClient] :: TestHydraClient tx m -> m (ClientMessage tx)
[$sel:injectChainEvent:TestHydraClient] :: TestHydraClient tx m -> ChainEvent tx -> m ()
[$sel:serverOutputs:TestHydraClient] :: TestHydraClient tx m -> m [ServerOutput tx]
[$sel:queryState:TestHydraClient] :: TestHydraClient tx m -> m (HeadState tx)

-- | A simulated chain that just echoes <a>PostChainTx</a> as
--   <a>Observation</a>s of <a>OnChainTx</a> onto all connected nodes. It
--   can also <a>$sel:rollbackAndForward:SimulatedChainNetwork</a> any
--   number of these "transactions".
data SimulatedChainNetwork tx m
SimulatedChainNetwork :: (DraftHydraNode tx m -> m (HydraNode tx m)) -> Async m () -> (Natural -> m ()) -> (HeadId -> Party -> UTxOType tx -> m ()) -> (HeadId -> UTxOType tx -> UTCTime -> m (TxIdType tx)) -> ((Party, UTxOType tx) -> m ()) -> SimulatedChainNetwork tx m
[$sel:connectNode:SimulatedChainNetwork] :: SimulatedChainNetwork tx m -> DraftHydraNode tx m -> m (HydraNode tx m)
[$sel:tickThread:SimulatedChainNetwork] :: SimulatedChainNetwork tx m -> Async m ()
[$sel:rollbackAndForward:SimulatedChainNetwork] :: SimulatedChainNetwork tx m -> Natural -> m ()
[$sel:simulateCommit:SimulatedChainNetwork] :: SimulatedChainNetwork tx m -> HeadId -> Party -> UTxOType tx -> m ()
[$sel:simulateDeposit:SimulatedChainNetwork] :: SimulatedChainNetwork tx m -> HeadId -> UTxOType tx -> UTCTime -> m (TxIdType tx)
[$sel:closeWithInitialSnapshot:SimulatedChainNetwork] :: SimulatedChainNetwork tx m -> (Party, UTxOType tx) -> m ()
dummySimulatedChainNetwork :: SimulatedChainNetwork tx m

-- | With-pattern wrapper around <a>simulatedChainAndNetwork</a> which does
--   <a>cancel</a> the <a>$sel:tickThread:SimulatedChainNetwork</a>. Also,
--   this will fix tx to <a>SimpleTx</a> so that it can pick an initial
--   chain state to play back to our test nodes. NOTE: The simulated
--   network has a block time of 20 (simulated) seconds.
withSimulatedChainAndNetwork :: (MonadTime m, MonadDelay m, MonadAsync m, MonadThrow m) => (SimulatedChainNetwork SimpleTx m -> m a) -> m a

-- | Creates a simulated chain and network to which <a>HydraNode</a>s can
--   be connected to using <a>$sel:connectNode:SimulatedChainNetwork</a>.
--   NOTE: The <a>$sel:tickThread:SimulatedChainNetwork</a> needs to be
--   <a>cancel</a>ed after use. Use <a>withSimulatedChainAndNetwork</a>
--   instead where possible.
simulatedChainAndNetwork :: forall m. (MonadTime m, MonadDelay m, MonadAsync m) => ChainStateType SimpleTx -> m (SimulatedChainNetwork SimpleTx m)
handleChainEvent :: HydraNode tx m -> ChainEvent tx -> m ()
createMockNetwork :: MonadSTM m => DraftHydraNode tx m -> TVar m [HydraNode tx m] -> Network m (Message tx)

-- | Derive an <a>OnChainTx</a> from <a>PostChainTx</a> to simulate a
--   "perfect" chain. NOTE: This implementation announces hard-coded
--   contestationDeadlines. Also, all heads will have the same
--   <a>OpenState</a> and <a>OpenState</a>.
toOnChainTx :: IsTx tx => UTCTime -> PostChainTx tx -> OnChainTx tx
newDeadlineFarEnoughFromNow :: MonadTime m => m UTCTime
nothingHappensFor :: (MonadTimer m, MonadThrow m, IsChainState tx) => TestHydraClient tx m -> NominalDiffTime -> m ()
withHydraNode :: forall s a. SigningKey HydraKey -> [Party] -> SimulatedChainNetwork SimpleTx (IOSim s) -> (TestHydraClient SimpleTx (IOSim s) -> IOSim s a) -> IOSim s a
withHydraNode' :: DepositPeriod -> SigningKey HydraKey -> [Party] -> SimulatedChainNetwork SimpleTx (IOSim s) -> (TestHydraClient SimpleTx (IOSim s) -> IOSim s b) -> IOSim s b
createTestHydraClient :: MonadSTM m => TQueue m (ServerOutput tx) -> TQueue m (ClientMessage tx) -> TVar m [ServerOutput tx] -> HydraNode tx m -> TestHydraClient tx m
createHydraNode :: (IsTx tx, MonadDelay m, MonadAsync m, MonadLabelledSTM m, MonadThrow m) => Tracer m (HydraNodeLog tx) -> Ledger tx -> ChainStateType tx -> SigningKey HydraKey -> [Party] -> TQueue m (ServerOutput tx) -> TQueue m (ClientMessage tx) -> TVar m [ServerOutput tx] -> SimulatedChainNetwork tx m -> ContestationPeriod -> DepositPeriod -> m (HydraNode tx m)
openHead :: SimulatedChainNetwork SimpleTx (IOSim s) -> TestHydraClient SimpleTx (IOSim s) -> IOSim s ()
openHead2 :: SimulatedChainNetwork SimpleTx (IOSim s) -> TestHydraClient SimpleTx (IOSim s) -> TestHydraClient SimpleTx (IOSim s) -> IOSim s ()
assertHeadIsClosed :: (HasCallStack, MonadThrow m) => ServerOutput tx -> m ()
assertHeadIsClosedWith :: (HasCallStack, MonadThrow m) => SnapshotNumber -> ServerOutput tx -> m ()

-- | Provide a quick and dirty to way to label stuff from a signing key
shortLabel :: SigningKey HydraKey -> String

-- | Get the head <tt>UTxO</tt> from open <a>HeadState</a>.
getHeadUTxO :: IsTx tx => HeadState tx -> Maybe (UTxOType tx)
instance GHC.Show.Show Hydra.BehaviorSpec.NodeId
instance GHC.Enum.Enum Hydra.BehaviorSpec.NodeId

module Hydra.Model.MockChain

-- | Create a mocked chain which connects nodes through
--   <a>ChainSyncHandler</a> and <a>Chain</a> interfaces. It calls
--   connected chain sync handlers
--   <a>$sel:onRollForward:ChainSyncHandler</a> on every <tt>blockTime</tt>
--   and performs <a>$sel:rollbackAndForward:SimulatedChainNetwork</a>
--   every couple blocks.
mockChainAndNetwork :: forall m. (MonadTimer m, MonadAsync m, MonadMask m, MonadThrow (STM m), MonadLabelledSTM m, MonadFork m, MonadDelay m) => Tracer m CardanoChainLog -> [(SigningKey HydraKey, CardanoSigningKey)] -> UTxO -> m (SimulatedChainNetwork Tx m)

-- | Construct fixed <a>TimeHandle</a> that starts from 0 and has the era
--   horizon far in the future. This is used in our <tt>Model</tt> tests
--   and we want to make sure the tests finish before the horizon is
--   reached to prevent the <tt>PastHorizon</tt> exceptions.
fixedTimeHandleIndefiniteHorizon :: Gen TimeHandle

-- | A trimmed down ledger whose only purpose is to validate on-chain
--   scripts.
scriptLedger :: Ledger Tx

-- | Find Cardano vkey corresponding to our Hydra vkey using signing keys
--   lookup. This is a bit cumbersome and a tribute to the fact the
--   <a>HydraNode</a> itself has no direct knowledge of the cardano keys
--   which are stored only at the <tt>ChainComponent</tt> level.
findOwnCardanoKey :: Party -> [(SigningKey HydraKey, CardanoSigningKey)] -> (VerificationKey PaymentKey, [VerificationKey PaymentKey])
createMockNetwork :: MonadSTM m => DraftHydraNode Tx m -> TVar m [MockHydraNode m] -> Network m (Message Tx)
data MockHydraNode m
MockHydraNode :: HydraNode Tx m -> ChainSyncHandler m -> MockHydraNode m
[$sel:node:MockHydraNode] :: MockHydraNode m -> HydraNode Tx m
[$sel:chainHandler:MockHydraNode] :: MockHydraNode m -> ChainSyncHandler m
createMockChain :: (MonadTimer m, MonadThrow (STM m)) => Tracer m CardanoChainLog -> ChainContext -> SubmitTx m -> m TimeHandle -> TxIn -> LocalChainState m Tx -> Chain Tx m
flushQueue :: MonadSTM m => TQueue m a -> STM m [a]

module Hydra.Model.MockChainSpec
spec :: Spec
appliesValidTransaction :: Property
isOutputOfLastTransaction :: [Tx] -> UTxO -> Property


-- | A <i>Model</i> of the Hydra head Protocol.
--   
--   This model integrates in a single state-machine like abstraction the
--   whole behaviour of a Hydra Head, taking into account both on-chain
--   state and contracts, and off-chain interactions. It is written from
--   the point of view of a pre-defined set of Hydra node <i>operators</i>
--   that want to create a channel between them. It's a "happy path" model
--   that does not implement any kind of adversarial behaviour and whose
--   transactions are very simple: Each tx is a payment of one Ada-only
--   UTxO transferred to another party in full, without any change.
--   
--   More intricate and specialised models shall be developed once we get a
--   firmer grasp of the whole framework, injecting faults, taking into
--   account more parts of the stack, modelling more complex transactions
--   schemes...
module Hydra.Model

-- | State maintained by the model.
data WorldState
WorldState :: [(SigningKey HydraKey, CardanoSigningKey)] -> GlobalState -> UTxOType Payment -> WorldState

-- | List of parties identified by both signing keys required to run
--   protocol. This list must not contain any duplicated key.
[$sel:hydraParties:WorldState] :: WorldState -> [(SigningKey HydraKey, CardanoSigningKey)]

-- | Expected consensus state All nodes should be in the same state.
[$sel:hydraState:WorldState] :: WorldState -> GlobalState

-- | UTxO available to be committed incrementally. NOTE: We must not add
--   UTxO we decommitted to this as the <a>Payment</a> transaction model
--   results in non-unique transaction ids when running the model.
[$sel:availableToDeposit:WorldState] :: WorldState -> UTxOType Payment

-- | Global state of the Head protocol. While each participant in the Hydra
--   Head protocol has its own private view of the state, we model the
--   expected global state whose properties stem from the consensus built
--   into the Head protocol. In other words, this state is what each node's
--   local state should be <i>eventually</i>.
data GlobalState

-- | Start of the "world". This state is left implicit in the node's logic
--   as it represents that state where the node does not even exist.
Start :: GlobalState
Idle :: [Party] -> [VerificationKey PaymentKey] -> ContestationPeriod -> Uncommitted -> GlobalState
[$sel:idleParties:Start] :: GlobalState -> [Party]
[$sel:cardanoKeys:Start] :: GlobalState -> [VerificationKey PaymentKey]
[$sel:contestationPeriod:Start] :: GlobalState -> ContestationPeriod
[$sel:toCommit:Start] :: GlobalState -> Uncommitted
Initial :: Var HeadId -> HeadParameters -> Committed Payment -> Uncommitted -> GlobalState
[$sel:headIdVar:Start] :: GlobalState -> Var HeadId
[$sel:headParameters:Start] :: GlobalState -> HeadParameters
[$sel:commits:Start] :: GlobalState -> Committed Payment
[$sel:pendingCommits:Start] :: GlobalState -> Uncommitted
Open :: Var HeadId -> HeadParameters -> OffChainState -> Committed Payment -> GlobalState
[$sel:headIdVar:Start] :: GlobalState -> Var HeadId
[$sel:headParameters:Start] :: GlobalState -> HeadParameters
[$sel:offChainState:Start] :: GlobalState -> OffChainState
[$sel:committed:Start] :: GlobalState -> Committed Payment
Closed :: HeadParameters -> UTxOType Payment -> GlobalState
[$sel:headParameters:Start] :: GlobalState -> HeadParameters
[$sel:closedUTxO:Start] :: GlobalState -> UTxOType Payment
Final :: UTxOType Payment -> GlobalState
[$sel:finalUTxO:Start] :: GlobalState -> UTxOType Payment
type Uncommitted = Map Party (UTxOType Payment)
newtype OffChainState
OffChainState :: UTxOType Payment -> OffChainState
[$sel:confirmedUTxO:OffChainState] :: OffChainState -> UTxOType Payment
type ActualCommitted = UTxOType Payment
genSeed :: Gen (Action WorldState ())
genToCommit :: (SigningKey HydraKey, CardanoSigningKey) -> Gen (Map Party [(CardanoSigningKey, Value)])
genContestationPeriod :: Gen ContestationPeriod
genInit :: [(SigningKey HydraKey, b)] -> Gen (Action WorldState HeadId)
genPayment :: WorldState -> Gen (Party, Payment)
unsafeConstructorName :: Show a => a -> String

-- | Generate a list of pairs of Hydra/Cardano signing keys. All the keys
--   in this list are guaranteed to be unique.
partyKeys :: Gen [(SigningKey HydraKey, CardanoSigningKey)]

-- | Concrete state needed to run actions against the implementation. This
--   state is used and might be updated when actually <a>perform</a>ing
--   actions generated from the <a>StateModel</a>.
data Nodes m
Nodes :: Map Party (TestHydraClient Tx m) -> Tracer m (HydraLog Tx) -> [Async m ()] -> SimulatedChainNetwork Tx m -> Nodes m

-- | Map from party identifiers to a <i>handle</i> for interacting with a
--   node.
[$sel:nodes:Nodes] :: Nodes m -> Map Party (TestHydraClient Tx m)

-- | Logger used by each node. The reason we put this here is because the
--   concrete value needs to be instantiated upon the test run
--   initialisation, outiside of the model.
[$sel:logger:Nodes] :: Nodes m -> Tracer m (HydraLog Tx)

-- | List of threads spawned when executing <a>RunMonad</a>
[$sel:threads:Nodes] :: Nodes m -> [Async m ()]
[$sel:chain:Nodes] :: Nodes m -> SimulatedChainNetwork Tx m
newtype RunState m
RunState :: TVar m (Nodes m) -> RunState m
[$sel:nodesState:RunState] :: RunState m -> TVar m (Nodes m)

-- | Our execution <a>MonadTrans</a>former.
--   
--   This type is needed in order to keep the execution monad <tt>m</tt>
--   abstract and thus simplify the definition of the <a>RunModel</a>
--   instance which requires a proper definition of <a>Realized</a> type
--   family. See <a>this issue</a> for a discussion on why this monad is
--   needed.
--   
--   We could perhaps getaway with it and just have a type based on
--   <tt>IOSim</tt> monad but this is cumbersome to write.
newtype RunMonad m a
RunMonad :: ReaderT (RunState m) m a -> RunMonad m a
[$sel:runMonad:RunMonad] :: RunMonad m a -> ReaderT (RunState m) m a
data RunException
TransactionNotObserved :: Payment -> UTxO -> RunException
UnexpectedParty :: Party -> RunException
UnknownAddress :: AddressInEra -> [(AddressInEra, CardanoSigningKey)] -> RunException
CannotFindSpendableUTxO :: Payment -> UTxO -> RunException
sortTxOuts :: [TxOut ctx] -> [TxOut ctx]

-- | Deposit period used by all nodes and the <a>performDeposit</a>.
testDepositPeriod :: DepositPeriod
seedWorld :: (MonadAsync m, MonadTimer m, MonadThrow (STM m), MonadLabelledSTM m, MonadFork m, MonadMask m, MonadDelay m, MonadTime m) => [(SigningKey HydraKey, CardanoSigningKey)] -> ContestationPeriod -> Uncommitted -> RunMonad m ()
performCommit :: (MonadThrow m, MonadTimer m, MonadAsync m) => HeadId -> Party -> [(CardanoSigningKey, Value)] -> RunMonad m ()
performDeposit :: (MonadThrow m, MonadTimer m, MonadAsync m, MonadTime m) => HeadId -> [(CardanoSigningKey, Value)] -> RunMonad m ()
performDecommit :: (MonadThrow m, MonadTimer m, MonadAsync m, MonadDelay m) => Party -> Payment -> RunMonad m ()
performNewTx :: (MonadThrow m, MonadAsync m, MonadTimer m, MonadDelay m) => Party -> Payment -> RunMonad m Payment

-- | Wait for the head to be open by searching from the beginning. Note
--   that there rollbacks or multiple life-cycles of heads are not handled
--   here.
waitForOpen :: MonadDelay m => TestHydraClient tx m -> RunMonad m ()

-- | Wait for the head to be closed by searching from the beginning. Note
--   that there rollbacks or multiple life-cycles of heads are not handled
--   here.
waitForReadyToFanout :: MonadDelay m => TestHydraClient tx m -> RunMonad m ()
sendsInput :: (MonadSTM m, MonadThrow m) => Party -> ClientInput Tx -> RunMonad m ()
getActorNode :: (MonadSTM m, MonadThrow m) => Party -> RunMonad m (TestHydraClient Tx m)
performInit :: (MonadThrow m, MonadAsync m, MonadTimer m) => Party -> RunMonad m HeadId
performAbort :: (MonadThrow m, MonadAsync m, MonadTimer m) => Party -> RunMonad m ()
performClose :: (MonadThrow m, MonadAsync m, MonadTimer m, MonadDelay m) => Party -> RunMonad m ()
performFanout :: (MonadThrow m, MonadAsync m, MonadDelay m) => Party -> RunMonad m UTxO
performCloseWithInitialSnapshot :: (MonadThrow m, MonadTimer m, MonadDelay m, MonadAsync m) => WorldState -> Party -> RunMonad m ()
performRollbackAndForward :: (MonadThrow m, MonadTimer m) => Natural -> RunMonad m ()
stopTheWorld :: MonadAsync m => RunMonad m ()

-- | Convert payment-style utxos into transaction outputs.
toTxOuts :: [(CardanoSigningKey, Value)] -> [TxOut CtxUTxO]

-- | Convert payment-style utxos into real utxos. The <a>Payment</a> tx
--   domain is smaller than UTxO and we map every unique signer + value
--   entry to a mocked <a>TxIn</a> on the real cardano domain.
toRealUTxO :: UTxOType Payment -> UTxOType Tx
mkTxOut :: CardanoSigningKey -> Value -> TxOut CtxUTxO
mkMockTxIn :: CardanoSigningKey -> Word -> TxIn

-- | Like <a>===</a>, but works in PostconditionM.
(===) :: (Eq a, Show a, Monad m) => a -> a -> PostconditionM m Bool
waitForUTxOToSpend :: forall m. MonadDelay m => UTxO -> CardanoSigningKey -> Value -> TestHydraClient Tx m -> m (Either UTxO (TxIn, TxOut CtxUTxO))
headUTxO :: (IsTx tx, MonadDelay m) => TestHydraClient tx m -> m (UTxOType tx)
isOwned :: CardanoSigningKey -> (TxIn, TxOut ctx) -> Bool
headIsOpen :: ServerOutput tx -> Bool
headIsReadyToFanout :: ServerOutput tx -> Bool
instance GHC.Show.Show Hydra.Model.OffChainState
instance GHC.Classes.Eq Hydra.Model.OffChainState
instance GHC.Show.Show Hydra.Model.GlobalState
instance GHC.Classes.Eq Hydra.Model.GlobalState
instance GHC.Show.Show Hydra.Model.WorldState
instance GHC.Classes.Eq Hydra.Model.WorldState
instance Control.Monad.Class.MonadTime.MonadTime m => Control.Monad.Class.MonadTime.MonadTime (Hydra.Model.RunMonad m)
instance Control.Monad.Class.MonadThrow.MonadThrow m => Control.Monad.Class.MonadThrow.MonadThrow (Hydra.Model.RunMonad m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader (Hydra.Model.RunState m) (Hydra.Model.RunMonad m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hydra.Model.RunMonad m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Hydra.Model.RunMonad m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hydra.Model.RunMonad m)
instance GHC.Show.Show Hydra.Model.RunException
instance GHC.Classes.Eq Hydra.Model.RunException
instance GHC.Show.Show (Test.QuickCheck.StateModel.Action Hydra.Model.WorldState a)
instance GHC.Classes.Eq (Test.QuickCheck.StateModel.Action Hydra.Model.WorldState a)
instance GHC.Exception.Type.Exception Hydra.Model.RunException
instance (Control.Monad.Class.MonadAsync.MonadAsync m, Control.Monad.Class.MonadFork.MonadFork m, Control.Monad.Class.MonadThrow.MonadMask m, Control.Monad.Class.MonadTimer.SI.MonadTimer m, Control.Monad.Class.MonadThrow.MonadThrow (Control.Monad.Class.MonadSTM.Internal.STM m), Control.Monad.Class.MonadSTM.Internal.MonadLabelledSTM m, Control.Monad.Class.MonadTimer.SI.MonadDelay m, Control.Monad.Class.MonadTime.MonadTime m) => Test.QuickCheck.StateModel.RunModel Hydra.Model.WorldState (Hydra.Model.RunMonad m)
instance Control.Monad.Trans.Class.MonadTrans Hydra.Model.RunMonad
instance Control.Monad.Class.MonadSTM.Internal.MonadSTM m => Control.Monad.State.Class.MonadState (Hydra.Model.Nodes m) (Hydra.Model.RunMonad m)
instance Test.QuickCheck.DynamicLogic.Internal.DynLogicModel Hydra.Model.WorldState
instance Test.QuickCheck.StateModel.StateModel Hydra.Model.WorldState
instance Test.QuickCheck.StateModel.Variables.HasVariables Hydra.Model.WorldState
instance Test.QuickCheck.StateModel.Variables.HasVariables (Test.QuickCheck.StateModel.Action Hydra.Model.WorldState a)


-- | Model-Based testing of Hydra Head protocol implementation.
--   
--   <ul>
--   <li>Troubleshooting</li>
--   <li>* Deadlocks</li>
--   </ul>
--   
--   One of the most annoying problems one can face with those very high
--   level properties involving multithreading and a lot of complex moving
--   parts is when the test execution deadlocks. Here is a short guide on
--   what one can do to troubleshoort this kind of issue:
--   
--   <ul>
--   <li>**Check generators**: <tt>suchThat</tt> combinator from QuickCheck
--   is useful when one wants to refine another <a>Gen</a>erator's
--   behaviour but it can lead to deadlock if the filtering leads to no
--   value being generated. Avoid it.</li>
--   <li>**Dump nodes' logs**: In case of a "normal" failure of the tests,
--   the logs from the nodes are dumped. However, if the test does not even
--   complete then no logs are produced because they are kept in memory. In
--   this case. replacing <a>traceInIOSim</a> with `traceInIOSim &lt;&gt;
--   traceDebug` will ensure the logs are dumped on the <a>stderr</a>. It
--   could be a good idea to store them in a file as they can be quite
--   large.</li>
--   <li>**Use** <a>trace</a> liberally: Because getting a proper stack
--   trace is hard in Haskell, esp. in pure code, sprinkling <a>trace</a>
--   statements at key points might help understand what's going on and
--   zoom in on the culprits</li>
--   <li>**Dump IOSim trace**: In case the deadlock (or race condition) is
--   caused by having two or more concurrent threads competing to access a
--   resource, dumping the trace of IOSim's runtime scheduleer execution
--   can help. io-sim generate its trace lazily which means that even when
--   it deadlocks, one can capture at least a significant prefix of the
--   trace and dump it to <a>stderr</a>. One can `map ( t -&gt; trace
--   (ppEvents t) t) . traceEvents` over the <a>SimTrace</a> returned by
--   <a>runSimTrace</a> to get some pretty-printed output similar to:</li>
--   </ul>
--   
--   @<tt> Time 380.1s - ThreadId [4] node-94455e3e - EventThrow
--   AsyncCancelled Time 380.1s - ThreadId [4] node-94455e3e - EventMask
--   MaskedInterruptible Time 380.1s - ThreadId [4] node-94455e3e -
--   EventMask MaskedInterruptible Time 380.1s - ThreadId [4] node-94455e3e
--   - EventDeschedule Interruptible Time 380.1s - ThreadId [4]
--   node-94455e3e - EventTxCommitted [Labelled (TVarId 25) (Just
--   "async-ThreadId [4]")] [] Nothing Time 380.1s - ThreadId [] main -
--   EventTxWakeup [Labelled (TVarId 25) (Just "async-ThreadId [4]")] Time
--   380.1s - ThreadId [4] node-94455e3e - EventUnblocked [ThreadId []]
--   Time 380.1s - ThreadId [4] node-94455e3e - EventDeschedule Yield Time
--   380.1s - ThreadId [] main - EventTxCommitted [] [] Nothing Time 380.1s
--   - ThreadId [] main - EventUnblocked [] Time 380.1s - ThreadId [] main
--   - EventDeschedule Yield Time 380.1s - ThreadId [4] node-94455e3e -
--   EventThreadFinished Time 380.1s - ThreadId [4] node-94455e3e -
--   EventDeschedule Terminated Time 380.1s - ThreadId [] main -
--   EventThreadFinished </tt>@
--   
--   <ul>
--   <li>* Recording trace failures</li>
--   </ul>
--   
--   When a property fails it will dump the sequence of actions leading to
--   the failure:
--   
--   @<tt> do action $ Seed {seedKeys =
--   [("8bbc9f32e4faff669ed1561025f243649f1332902aa79ad7e6e6bbae663f332d",CardanoSigningKey
--   {signingKey =
--   "0400020803030302070808060405040001050408070401040604000005010603"})],
--   seedContestationPeriod = 46s, seedDepositDeadline = 50s, toCommit =
--   fromList [(Party {vkey =
--   "b4ea494b4bda6281899727bf4cfef5cdeba8fb3fec4edebc408aa72dfd6ad4f0"},[(CardanoSigningKey
--   {signingKey =
--   "0400020803030302070808060405040001050408070401040604000005010603"},valueFromList
--   [(AdaAssetId,54862683)])])]} var2 &lt;- action $ Init (Party {vkey =
--   "b4ea494b4bda6281899727bf4cfef5cdeba8fb3fec4edebc408aa72dfd6ad4f0"})
--   action $ Commit {headIdVar = var2, party = Party {vkey =
--   "b4ea494b4bda6281899727bf4cfef5cdeba8fb3fec4edebc408aa72dfd6ad4f0"},
--   utxoToCommit = [(CardanoSigningKey {signingKey =
--   "0400020803030302070808060405040001050408070401040604000005010603"},valueFromList
--   [(AdaAssetId,54862683)])]} action $ Decommit {party = Party {vkey =
--   "b4ea494b4bda6281899727bf4cfef5cdeba8fb3fec4edebc408aa72dfd6ad4f0"},
--   decommitTx = Payment { from = CardanoSigningKey {signingKey =
--   "0400020803030302070808060405040001050408070401040604000005010603"},
--   to = CardanoSigningKey {signingKey =
--   "0702050602000101050108060302010707060007020308080801060700030306"},
--   value = valueFromList [(AdaAssetId,54862683)] }} action $ Deposit
--   {headIdVar = var2, utxoToDeposit = [(CardanoSigningKey {signingKey =
--   "0400020803030302070808060405040001050408070401040604000005010603"},valueFromList
--   [(AdaAssetId,54862683)])], deadline = 1864-06-06 08:24:08.669152896211
--   UTC} pure () </tt>@
--   
--   Which can be turned into a unit test after resolving most of the
--   imports. Common pitfalls are incorrect show instances (e.g. the
--   UTCTime in deadline above). Should the variables not be bound
--   correctly, double check HasVariables instances. A working example of
--   the above output would be:
--   
--   @<tt> it "troubleshoot" . withMaxSuccess 1 . flip forAllDL
--   propHydraModel $ do action $ Seed{seedKeys =
--   [("8bbc9f32e4faff669ed1561025f243649f1332902aa79ad7e6e6bbae663f332d",
--   CardanoSigningKey{signingKey =
--   "0400020803030302070808060405040001050408070401040604000005010603"})],
--   seedContestationPeriod = UnsafeContestationPeriod 46,
--   seedDepositDeadline = UnsafeDepositDeadline 50, toCommit = fromList
--   [(Party{vkey =
--   "b4ea494b4bda6281899727bf4cfef5cdeba8fb3fec4edebc408aa72dfd6ad4f0"},
--   [(CardanoSigningKey{signingKey =
--   "0400020803030302070808060405040001050408070401040604000005010603"},
--   valueFromList [(AdaAssetId, 54862683)])])]} var2 &lt;- action $ Init
--   (Party{vkey =
--   "b4ea494b4bda6281899727bf4cfef5cdeba8fb3fec4edebc408aa72dfd6ad4f0"})
--   action $ Commit{headIdVar = var2, party = Party{vkey =
--   "b4ea494b4bda6281899727bf4cfef5cdeba8fb3fec4edebc408aa72dfd6ad4f0"},
--   utxoToCommit = [(CardanoSigningKey{signingKey =
--   "0400020803030302070808060405040001050408070401040604000005010603"},
--   valueFromList [(AdaAssetId, 54862683)])]} action $ Decommit{party =
--   Party{vkey =
--   "b4ea494b4bda6281899727bf4cfef5cdeba8fb3fec4edebc408aa72dfd6ad4f0"},
--   decommitTx = Payment{from = CardanoSigningKey{signingKey =
--   "0400020803030302070808060405040001050408070401040604000005010603"},
--   to = CardanoSigningKey{signingKey =
--   "0702050602000101050108060302010707060007020308080801060700030306"},
--   value = valueFromList [(AdaAssetId, 54862683)]}} action $
--   Deposit{headIdVar = var2, utxoToDeposit =
--   [(CardanoSigningKey{signingKey =
--   "0400020803030302070808060405040001050408070401040604000005010603"},
--   valueFromList [(AdaAssetId, 54862683)])], deadline = read "1864-06-06
--   08:24:08.669152896211 UTC"} pure () </tt>@
module Hydra.ModelSpec
spec :: Spec
propDL :: DL WorldState () -> Property
propHydraModel :: Actions WorldState -> Property
propCheckModelBalances :: Property
assertBalancesInOpenHeadAreConsistent :: GlobalState -> Map Party (TestHydraClient Tx (IOSim s)) -> Party -> PropertyM (RunMonad (IOSim s)) ()
propIsDistributive :: (Show b, Eq b, Semigroup a, Semigroup b) => (a -> b) -> a -> a -> Property

-- | Expect to see contestations when trying to close with an old snapshot
partyContestsToWrongClosedSnapshot :: DL WorldState ()

-- | Given any random walk of the model, if the Head is open a NewTx
--   getting confirmed must be part of the UTxO after finalization.
fanoutContainsWholeConfirmedUTxO :: DL WorldState ()
nonConflictingTx :: WorldState -> Quantification (Party, Payment)
headOpensIfAllPartiesCommit :: DL WorldState ()
conflictFreeLiveness :: DL WorldState ()
propDoesNotGenerate0AdaUTxO :: Actions WorldState -> Property

-- | Specialised runner similar to
--   <a>https://hackage.haskell.org/package/QuickCheck-2.14.3/docs/Test-QuickCheck-Monadic.html#v:monadicST</a>.
runIOSimProp :: Testable a => (forall s. PropertyM (RunMonad (IOSim s)) a) -> Property

-- | Similar to
--   <a>https://hackage.haskell.org/package/QuickCheck-2.14.3/docs/Test-QuickCheck-Monadic.html#v:runSTGen</a>
--   
--   It returns <a>Property</a> rather than `Gen a`, what allows to enhance
--   the logging in case of failures.
runRunMonadIOSimGen :: forall a. Testable a => (forall s. Gen (RunMonad (IOSim s) a)) -> Gen Property
eventually :: Action WorldState () -> DL WorldState ()
action_ :: Typeable a => Action WorldState a -> DL WorldState ()


-- | Stateful model-based testing of the transactions created by the
--   <a>Direct</a> chain modules.
--   
--   The model is focusing on transitions between Open and Closed states of
--   the head.
--   
--   Given an initial UTxO, the model generates a plausible sequence of
--   snapshots that an honest node would approve. That is, the total
--   balance of UTxO remains constant and utxoToDecommit is only allowed to
--   clear if the version is incremented. Consequently, also all snapshots
--   are correctly signed (we don't test handling of adverarial
--   signatures). UTxOs are simplified such that they are A-E items, where
--   each maps to an arbitrary real UTxO.
--   
--   From this sequence of valid snapshots, possible Decrement and Close
--   actions are generated, along with occasional Contest and consequential
--   Fanout.
module Hydra.Chain.Direct.TxTraceSpec
spec :: Spec
coversInterestingActions :: Testable p => Actions Model -> p -> Property
prop_runActions :: Actions Model -> Property
data SingleUTxO
A :: SingleUTxO
B :: SingleUTxO
C :: SingleUTxO
D :: SingleUTxO
E :: SingleUTxO
F :: SingleUTxO
G :: SingleUTxO
H :: SingleUTxO
I :: SingleUTxO
type ModelUTxO = [SingleUTxO]
data Model
Model :: State -> [ModelSnapshot] -> SnapshotVersion -> SnapshotNumber -> SnapshotNumber -> [Actor] -> ModelUTxO -> ModelUTxO -> ModelUTxO -> Model
[$sel:headState:Model] :: Model -> State

-- | List of off-chain snapshots, from most recent to oldest.
[$sel:knownSnapshots:Model] :: Model -> [ModelSnapshot]
[$sel:currentVersion:Model] :: Model -> SnapshotVersion
[$sel:currentSnapshotNumber:Model] :: Model -> SnapshotNumber
[$sel:closedSnapshotNumber:Model] :: Model -> SnapshotNumber
[$sel:alreadyContested:Model] :: Model -> [Actor]
[$sel:utxoInHead:Model] :: Model -> ModelUTxO
[$sel:pendingDeposit:Model] :: Model -> ModelUTxO
[$sel:pendingDecommit:Model] :: Model -> ModelUTxO
latestSnapshotNumber :: [ModelSnapshot] -> SnapshotNumber

-- | Model of a real snapshot which contains a <a>SnapshotNumber</a> but
--   also our simplified form of <a>UTxO</a>.
data ModelSnapshot
ModelSnapshot :: SnapshotVersion -> SnapshotNumber -> ModelUTxO -> ModelUTxO -> ModelUTxO -> ModelSnapshot
[$sel:version:ModelSnapshot] :: ModelSnapshot -> SnapshotVersion
[$sel:number:ModelSnapshot] :: ModelSnapshot -> SnapshotNumber
[$sel:inHead:ModelSnapshot] :: ModelSnapshot -> ModelUTxO
[$sel:toCommit:ModelSnapshot] :: ModelSnapshot -> ModelUTxO
[$sel:toDecommit:ModelSnapshot] :: ModelSnapshot -> ModelUTxO
data State
Open :: State
Closed :: State
Final :: State
data Actor
Alice :: Actor
Bob :: Actor
Carol :: Actor

-- | Result of constructing and performing a transaction. Notably there are
--   three stages to this which can fail: construction, validation, and
--   observation. Results from all stages are needed to express
--   post-conditions.
data TxResult
TxResult :: Either String Tx -> UTxO -> Maybe String -> HeadObservation -> TxResult
[$sel:constructedTx:TxResult] :: TxResult -> Either String Tx
[$sel:spendableUTxO:TxResult] :: TxResult -> UTxO
[$sel:validationError:TxResult] :: TxResult -> Maybe String
[$sel:observation:TxResult] :: TxResult -> HeadObservation

-- | Application monad to perform model actions. Currently it only keeps a
--   <a>UTxO</a> which is updated whenever transactions are valid in
--   <a>performTx</a>.
newtype AppM a
AppM :: ReaderT (IORef (Maybe TxId, UTxO)) IO a -> AppM a
[$sel:runAppM:AppM] :: AppM a -> ReaderT (IORef (Maybe TxId, UTxO)) IO a

-- | Perform a transaction by evaluating and observing it. This updates the
--   <a>UTxO</a> in the <a>AppM</a> if a transaction is valid and produces
--   a <a>TxResult</a> that can be used to assert expected success /
--   failure.
performTx :: Show err => Action Model a -> Either err Tx -> AppM TxResult
getValidationError :: Tx -> UTxO -> Maybe String

-- | List of all model actors corresponding to the fixtures used.
allActors :: [Actor]

-- | Map a <a>ModelUTxO</a> to a real-world <a>UTxO</a>.
realWorldModelUTxO :: ModelUTxO -> UTxO

-- | A correctly signed snapshot. Given a snapshot number a snapshot signed
--   by all participants (alice, bob and carol) with some UTxO contained is
--   produced.
signedSnapshot :: ModelSnapshot -> (Snapshot Tx, MultiSignature (Snapshot Tx))

-- | A confirmed snapshot (either initial or later confirmed), based
--   onTxTra <a>signedSnapshot</a>.
confirmedSnapshot :: ModelSnapshot -> ConfirmedSnapshot Tx

-- | UTxO of the open head on-chain. NOTE: This uses fixtures for headId,
--   parties, and cperiod.
openHeadUTxO :: UTxO

-- | Creates a deposit transaction using given UTxO.
newDepositTx :: Action Model a -> ModelUTxO -> AppM (Either String Tx)

-- | Creates a increment transaction using given utxo and given snapshot.
newIncrementTx :: Actor -> ConfirmedSnapshot Tx -> AppM (Either IncrementTxError Tx)

-- | Creates a decrement transaction using given utxo and given snapshot.
newDecrementTx :: Actor -> ConfirmedSnapshot Tx -> AppM (Either DecrementTxError Tx)

-- | Creates a transaction that closes <a>openHeadUTxO</a> with given the
--   snapshot. NOTE: This uses fixtures for headId, parties (alice, bob,
--   carol), contestation period and also claims to close at time 0
--   resulting in a contestation deadline of 0 + cperiod.
newCloseTx :: Actor -> SnapshotVersion -> ConfirmedSnapshot Tx -> AppM (Either CloseTxError Tx)

-- | Creates a contest transaction using given utxo and contesting with
--   given snapshot. NOTE: This uses fixtures for headId, contestation
--   period and also claims to contest at time 0.
newContestTx :: Actor -> SnapshotVersion -> ConfirmedSnapshot Tx -> AppM (Either ContestTxError Tx)

-- | Creates a fanout transaction using given utxo. NOTE: This uses
--   fixtures for seedTxIn and contestation period. Consequently, the lower
--   bound used is precisely at the maximum deadline slot as if everyone
--   contested.
newFanoutTx :: Actor -> ModelUTxO -> ModelUTxO -> ModelUTxO -> AppM (Either FanoutTxError Tx)

-- | Cardano payment keys for <a>alice</a>, <a>bob</a>, and <a>carol</a>.
alicePVk :: VerificationKey PaymentKey

-- | Cardano payment keys for <a>alice</a>, <a>bob</a>, and <a>carol</a>.
bobPVk :: VerificationKey PaymentKey

-- | Cardano payment keys for <a>alice</a>, <a>bob</a>, and <a>carol</a>.
carolPVk :: VerificationKey PaymentKey

-- | Fixture for the chain context of a model <a>Actor</a> on
--   <a>testNetworkId</a>. Uses a generated <a>ScriptRegistry</a>.
actorChainContext :: Actor -> ChainContext
testScriptRegistry :: ScriptRegistry

-- | Run a short-cutting variant of PostconditionM which produces
--   <a>True</a> if it reaches the end, or <a>False</a> if <a>fail</a> is
--   used.
runPostconditionM' :: Monad m => PostconditionM' m () -> PostconditionM m Bool
newtype PostconditionM' m a
PostconditionM' :: ExceptT (Maybe String) (PostconditionM m) a -> PostconditionM' m a

-- | Short-cut a postcondition monad like <a>fail</a>, but in a successful
--   way. This is useful to not have unrelated counterexample' outputs.
fulfilled :: Monad m => PostconditionM' m ()

-- | Add given message in case the postcondition fails.
counterexample' :: Monad m => String -> PostconditionM' m ()

-- | Assertion helper to check whether a <a>TxResult</a> was valid and the
--   expected <a>HeadObservation</a> could be made. To be used in
--   <a>postcondition</a>.
expectValid :: Monad m => TxResult -> (HeadObservation -> PostconditionM' m a) -> PostconditionM' m a

-- | Assertion helper to check whether a <a>TxResult</a> was invalid or
--   construction failed.
expectInvalid :: Monad m => TxResult -> PostconditionM' m ()
instance GHC.Generics.Generic Hydra.Chain.Direct.TxTraceSpec.SingleUTxO
instance GHC.Enum.Enum Hydra.Chain.Direct.TxTraceSpec.SingleUTxO
instance GHC.Classes.Ord Hydra.Chain.Direct.TxTraceSpec.SingleUTxO
instance GHC.Classes.Eq Hydra.Chain.Direct.TxTraceSpec.SingleUTxO
instance GHC.Show.Show Hydra.Chain.Direct.TxTraceSpec.SingleUTxO
instance GHC.Generics.Generic Hydra.Chain.Direct.TxTraceSpec.ModelSnapshot
instance GHC.Classes.Ord Hydra.Chain.Direct.TxTraceSpec.ModelSnapshot
instance GHC.Classes.Eq Hydra.Chain.Direct.TxTraceSpec.ModelSnapshot
instance GHC.Show.Show Hydra.Chain.Direct.TxTraceSpec.ModelSnapshot
instance GHC.Classes.Eq Hydra.Chain.Direct.TxTraceSpec.State
instance GHC.Show.Show Hydra.Chain.Direct.TxTraceSpec.State
instance GHC.Classes.Eq Hydra.Chain.Direct.TxTraceSpec.Actor
instance GHC.Show.Show Hydra.Chain.Direct.TxTraceSpec.Actor
instance GHC.Show.Show Hydra.Chain.Direct.TxTraceSpec.Model
instance GHC.Show.Show Hydra.Chain.Direct.TxTraceSpec.TxResult
instance GHC.Classes.Eq Hydra.Chain.Direct.TxTraceSpec.TxResult
instance Control.Monad.Class.MonadThrow.MonadThrow Hydra.Chain.Direct.TxTraceSpec.AppM
instance Control.Monad.Fail.MonadFail Hydra.Chain.Direct.TxTraceSpec.AppM
instance Control.Monad.IO.Class.MonadIO Hydra.Chain.Direct.TxTraceSpec.AppM
instance GHC.Base.Monad Hydra.Chain.Direct.TxTraceSpec.AppM
instance GHC.Base.Applicative Hydra.Chain.Direct.TxTraceSpec.AppM
instance GHC.Base.Functor Hydra.Chain.Direct.TxTraceSpec.AppM
instance GHC.Base.Monad m => GHC.Base.Monad (Hydra.Chain.Direct.TxTraceSpec.PostconditionM' m)
instance GHC.Base.Monad m => GHC.Base.Alternative (Hydra.Chain.Direct.TxTraceSpec.PostconditionM' m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hydra.Chain.Direct.TxTraceSpec.PostconditionM' m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hydra.Chain.Direct.TxTraceSpec.PostconditionM' m)
instance GHC.Classes.Eq (Test.QuickCheck.StateModel.Action Hydra.Chain.Direct.TxTraceSpec.Model a)
instance GHC.Show.Show (Test.QuickCheck.StateModel.Action Hydra.Chain.Direct.TxTraceSpec.Model a)
instance GHC.Base.Monad m => Control.Monad.Fail.MonadFail (Hydra.Chain.Direct.TxTraceSpec.PostconditionM' m)
instance Control.Monad.Reader.Class.MonadReader (GHC.Maybe.Maybe Cardano.Api.Internal.TxIn.TxId, Cardano.Api.UTxO.UTxO) Hydra.Chain.Direct.TxTraceSpec.AppM
instance Control.Monad.State.Class.MonadState (GHC.Maybe.Maybe Cardano.Api.Internal.TxIn.TxId, Cardano.Api.UTxO.UTxO) Hydra.Chain.Direct.TxTraceSpec.AppM
instance Test.QuickCheck.StateModel.RunModel Hydra.Chain.Direct.TxTraceSpec.Model Hydra.Chain.Direct.TxTraceSpec.AppM
instance Test.QuickCheck.StateModel.StateModel Hydra.Chain.Direct.TxTraceSpec.Model
instance Test.QuickCheck.StateModel.Variables.HasVariables Hydra.Chain.Direct.TxTraceSpec.Model
instance Test.QuickCheck.StateModel.Variables.HasVariables (Test.QuickCheck.StateModel.Action Hydra.Chain.Direct.TxTraceSpec.Model a)
instance GHC.Num.Num Hydra.Chain.Direct.TxTraceSpec.ModelSnapshot
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Chain.Direct.TxTraceSpec.SingleUTxO

module Spec
main :: IO ()
spec :: Spec

module Main
main :: IO ()
