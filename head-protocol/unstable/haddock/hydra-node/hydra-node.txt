-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Hydra node
--   
--   The Hydra node
@package hydra-node
@version 0.22.2

module Hydra.API.ClientInput
data ClientInput tx
Init :: ClientInput tx
Abort :: ClientInput tx
NewTx :: tx -> ClientInput tx
[$sel:transaction:Init] :: ClientInput tx -> tx
Recover :: TxIdType tx -> ClientInput tx
[$sel:recoverTxId:Init] :: ClientInput tx -> TxIdType tx
Decommit :: tx -> ClientInput tx
[$sel:decommitTx:Init] :: ClientInput tx -> tx
Close :: ClientInput tx
Contest :: ClientInput tx
Fanout :: ClientInput tx
SideLoadSnapshot :: ConfirmedSnapshot tx -> ClientInput tx
[$sel:snapshot:Init] :: ClientInput tx -> ConfirmedSnapshot tx
instance GHC.Generics.Generic (Hydra.API.ClientInput.ClientInput tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Classes.Eq (Hydra.API.ClientInput.ClientInput tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Show.Show (Hydra.API.ClientInput.ClientInput tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.API.ClientInput.ClientInput tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.API.ClientInput.ClientInput tx)
instance (Test.QuickCheck.Arbitrary.Arbitrary tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Tx.IsTx.TxIdType tx), Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Tx.IsTx.UTxOType tx), Hydra.Tx.IsTx.IsTx tx) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.API.ClientInput.ClientInput tx)
instance (Test.QuickCheck.Arbitrary.Arbitrary tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Tx.IsTx.TxIdType tx), Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Tx.IsTx.UTxOType tx), Hydra.Tx.IsTx.IsTx tx) => Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary (Hydra.API.ClientInput.ClientInput tx)


-- | <a>Projection</a> module exposes the handle which is our
--   implementation of projections from the CQRS terminology.
--   
--   Projections allow us to easily tailor the needs of different API
--   clients (related to our <tt>ServerOutput</tt> messages) and enable us
--   to more easily implement future user needs.
--   
--   This module provides abstract interface for serving different data
--   from the API endpoints and abstracts over the internal implementation
--   (in this case a <a>TVar</a>).
--   
--   What we serve from the API server is <a>TimedServerOutputs</a> and
--   <a>Projection</a> allows us to transform these outputs and add more
--   (stateful) information (like the <a>HeadStatus</a> model).
--   
--   <a>Projection</a>s always need to use a function in form of `(model
--   -&gt; event -&gt; model)` where depending on event we are currently
--   dealing with we might want to alter our existing model.
module Hydra.API.Projection

-- | <a>Projection</a> type used to alter/project the API output to suit
--   the client needs.
data Projection stm event model
Projection :: stm model -> (event -> stm ()) -> Projection stm event model
[$sel:getLatest:Projection] :: Projection stm event model -> stm model
[$sel:update:Projection] :: Projection stm event model -> event -> stm ()

-- | Create a <a>Projection</a> handle that knows how to:
--   
--   <ul>
--   <li>get the latest model state</li>
--   <li>update the model using a projection function</li>
--   </ul>
mkProjection :: MonadSTM m => model -> (model -> event -> model) -> m (Projection (STM m) event model)


-- | Specifies the <i>Head-Chain Interaction</i> part of the protocol
--   
--   Incoming and outgoing on-chain transactions are modelled respectively
--   as <a>OnChainTx</a> and <a>PostChainTx</a> which are data type that
--   abstracts away the details of the structure of the transaction.
module Hydra.Chain

-- | Hardcoded limit for commit tx on mainnet
maxMainnetLovelace :: Coin

-- | Hardcoded limit for maximum number of parties in a head protocol The
--   value is obtained from calculating the costs of running the scripts
--   and on-chan validators (see <tt>computeCollectComCost</tt>
--   <tt>computeAbortCost</tt>). A too high enough number would be detected
--   by property and acceptance tests.
maximumNumberOfParties :: Int

-- | Data type used to post transactions on chain. It holds everything to
--   construct corresponding Head protocol transactions.
data PostChainTx tx
InitTx :: [OnChainId] -> HeadParameters -> PostChainTx tx
[$sel:participants:InitTx] :: PostChainTx tx -> [OnChainId]
[$sel:headParameters:InitTx] :: PostChainTx tx -> HeadParameters
AbortTx :: UTxOType tx -> HeadSeed -> PostChainTx tx
[$sel:utxo:InitTx] :: PostChainTx tx -> UTxOType tx
[$sel:headSeed:InitTx] :: PostChainTx tx -> HeadSeed
CollectComTx :: UTxOType tx -> HeadId -> HeadParameters -> PostChainTx tx
[$sel:utxo:InitTx] :: PostChainTx tx -> UTxOType tx
[$sel:headId:InitTx] :: PostChainTx tx -> HeadId
[$sel:headParameters:InitTx] :: PostChainTx tx -> HeadParameters
IncrementTx :: HeadId -> HeadParameters -> ConfirmedSnapshot tx -> TxIdType tx -> PostChainTx tx
[$sel:headId:InitTx] :: PostChainTx tx -> HeadId
[$sel:headParameters:InitTx] :: PostChainTx tx -> HeadParameters
[$sel:incrementingSnapshot:InitTx] :: PostChainTx tx -> ConfirmedSnapshot tx
[$sel:depositTxId:InitTx] :: PostChainTx tx -> TxIdType tx
RecoverTx :: HeadId -> TxIdType tx -> ChainSlot -> UTxOType tx -> PostChainTx tx
[$sel:headId:InitTx] :: PostChainTx tx -> HeadId
[$sel:recoverTxId:InitTx] :: PostChainTx tx -> TxIdType tx
[$sel:deadline:InitTx] :: PostChainTx tx -> ChainSlot
[$sel:recoverUTxO:InitTx] :: PostChainTx tx -> UTxOType tx
DecrementTx :: HeadId -> HeadParameters -> ConfirmedSnapshot tx -> PostChainTx tx
[$sel:headId:InitTx] :: PostChainTx tx -> HeadId
[$sel:headParameters:InitTx] :: PostChainTx tx -> HeadParameters
[$sel:decrementingSnapshot:InitTx] :: PostChainTx tx -> ConfirmedSnapshot tx
CloseTx :: HeadId -> HeadParameters -> SnapshotVersion -> ConfirmedSnapshot tx -> PostChainTx tx
[$sel:headId:InitTx] :: PostChainTx tx -> HeadId
[$sel:headParameters:InitTx] :: PostChainTx tx -> HeadParameters
[$sel:openVersion:InitTx] :: PostChainTx tx -> SnapshotVersion
[$sel:closingSnapshot:InitTx] :: PostChainTx tx -> ConfirmedSnapshot tx
ContestTx :: HeadId -> HeadParameters -> SnapshotVersion -> ConfirmedSnapshot tx -> PostChainTx tx
[$sel:headId:InitTx] :: PostChainTx tx -> HeadId
[$sel:headParameters:InitTx] :: PostChainTx tx -> HeadParameters
[$sel:openVersion:InitTx] :: PostChainTx tx -> SnapshotVersion
[$sel:contestingSnapshot:InitTx] :: PostChainTx tx -> ConfirmedSnapshot tx
FanoutTx :: UTxOType tx -> Maybe (UTxOType tx) -> Maybe (UTxOType tx) -> HeadSeed -> UTCTime -> PostChainTx tx
[$sel:utxo:InitTx] :: PostChainTx tx -> UTxOType tx
[$sel:utxoToCommit:InitTx] :: PostChainTx tx -> Maybe (UTxOType tx)
[$sel:utxoToDecommit:InitTx] :: PostChainTx tx -> Maybe (UTxOType tx)
[$sel:headSeed:InitTx] :: PostChainTx tx -> HeadSeed
[$sel:contestationDeadline:InitTx] :: PostChainTx tx -> UTCTime

-- | Describes transactions as seen on chain. Holds as minimal information
--   as possible to simplify observing the chain.
data OnChainTx tx
OnInitTx :: HeadId -> HeadSeed -> HeadParameters -> [OnChainId] -> OnChainTx tx
[$sel:headId:OnInitTx] :: OnChainTx tx -> HeadId
[$sel:headSeed:OnInitTx] :: OnChainTx tx -> HeadSeed
[$sel:headParameters:OnInitTx] :: OnChainTx tx -> HeadParameters
[$sel:participants:OnInitTx] :: OnChainTx tx -> [OnChainId]
OnCommitTx :: HeadId -> Party -> UTxOType tx -> OnChainTx tx
[$sel:headId:OnInitTx] :: OnChainTx tx -> HeadId
[$sel:party:OnInitTx] :: OnChainTx tx -> Party
[$sel:committed:OnInitTx] :: OnChainTx tx -> UTxOType tx
OnAbortTx :: HeadId -> OnChainTx tx
[$sel:headId:OnInitTx] :: OnChainTx tx -> HeadId
OnCollectComTx :: HeadId -> OnChainTx tx
[$sel:headId:OnInitTx] :: OnChainTx tx -> HeadId
OnDepositTx :: HeadId -> TxIdType tx -> UTxOType tx -> UTCTime -> UTCTime -> OnChainTx tx
[$sel:headId:OnInitTx] :: OnChainTx tx -> HeadId
[$sel:depositTxId:OnInitTx] :: OnChainTx tx -> TxIdType tx
[$sel:deposited:OnInitTx] :: OnChainTx tx -> UTxOType tx
[$sel:created:OnInitTx] :: OnChainTx tx -> UTCTime
[$sel:deadline:OnInitTx] :: OnChainTx tx -> UTCTime
OnRecoverTx :: HeadId -> TxIdType tx -> UTxOType tx -> OnChainTx tx
[$sel:headId:OnInitTx] :: OnChainTx tx -> HeadId
[$sel:recoveredTxId:OnInitTx] :: OnChainTx tx -> TxIdType tx
[$sel:recoveredUTxO:OnInitTx] :: OnChainTx tx -> UTxOType tx
OnIncrementTx :: HeadId -> SnapshotVersion -> TxIdType tx -> OnChainTx tx
[$sel:headId:OnInitTx] :: OnChainTx tx -> HeadId
[$sel:newVersion:OnInitTx] :: OnChainTx tx -> SnapshotVersion
[$sel:depositTxId:OnInitTx] :: OnChainTx tx -> TxIdType tx
OnDecrementTx :: HeadId -> SnapshotVersion -> UTxOType tx -> OnChainTx tx
[$sel:headId:OnInitTx] :: OnChainTx tx -> HeadId
[$sel:newVersion:OnInitTx] :: OnChainTx tx -> SnapshotVersion
[$sel:distributedUTxO:OnInitTx] :: OnChainTx tx -> UTxOType tx
OnCloseTx :: HeadId -> SnapshotNumber -> UTCTime -> OnChainTx tx
[$sel:headId:OnInitTx] :: OnChainTx tx -> HeadId
[$sel:snapshotNumber:OnInitTx] :: OnChainTx tx -> SnapshotNumber
[$sel:contestationDeadline:OnInitTx] :: OnChainTx tx -> UTCTime
OnContestTx :: HeadId -> SnapshotNumber -> UTCTime -> OnChainTx tx
[$sel:headId:OnInitTx] :: OnChainTx tx -> HeadId
[$sel:snapshotNumber:OnInitTx] :: OnChainTx tx -> SnapshotNumber
[$sel:contestationDeadline:OnInitTx] :: OnChainTx tx -> UTCTime
OnFanoutTx :: HeadId -> UTxOType tx -> OnChainTx tx
[$sel:headId:OnInitTx] :: OnChainTx tx -> HeadId
[$sel:fanoutUTxO:OnInitTx] :: OnChainTx tx -> UTxOType tx

-- | Exceptions thrown by <a>$sel:postTx:Chain</a>.
data PostTxError tx
NoSeedInput :: PostTxError tx
InvalidSeed :: HeadSeed -> PostTxError tx
[$sel:headSeed:NoSeedInput] :: PostTxError tx -> HeadSeed
InvalidHeadId :: HeadId -> PostTxError tx
[$sel:headId:NoSeedInput] :: PostTxError tx -> HeadId
CannotFindOwnInitial :: UTxOType tx -> PostTxError tx
[$sel:knownUTxO:NoSeedInput] :: PostTxError tx -> UTxOType tx

-- | Committing byron addresses is not supported.
UnsupportedLegacyOutput :: Address ByronAddr -> PostTxError tx
[$sel:byronAddress:NoSeedInput] :: PostTxError tx -> Address ByronAddr
InvalidStateToPost :: PostChainTx tx -> ChainStateType tx -> PostTxError tx
[$sel:txTried:NoSeedInput] :: PostTxError tx -> PostChainTx tx
[$sel:chainState:NoSeedInput] :: PostTxError tx -> ChainStateType tx
NotEnoughFuel :: tx -> PostTxError tx
[$sel:failingTx:NoSeedInput] :: PostTxError tx -> tx
NoFuelUTXOFound :: tx -> PostTxError tx
[$sel:failingTx:NoSeedInput] :: PostTxError tx -> tx

-- | Script execution failed when finalizing a transaction in the wallet.
--   XXX: Ideally we want a cardano-api type with corresponding JSON
--   instance here. But the wallet still uses ledger types and we don't
--   want to copy the conversion from ledger
--   <tt>TransactionScriptFailure</tt> to the cardano-api
--   <tt>ScriptExecutionError</tt> type.
ScriptFailedInWallet :: Text -> Text -> tx -> PostTxError tx
[$sel:redeemerPtr:NoSeedInput] :: PostTxError tx -> Text
[$sel:failureReason:NoSeedInput] :: PostTxError tx -> Text
[$sel:failingTx:NoSeedInput] :: PostTxError tx -> tx

-- | A generic error happened when finalizing a transaction in the wallet.
InternalWalletError :: UTxOType tx -> Text -> tx -> PostTxError tx
[$sel:headUTxO:NoSeedInput] :: PostTxError tx -> UTxOType tx
[$sel:reason:NoSeedInput] :: PostTxError tx -> Text
[$sel:failingTx:NoSeedInput] :: PostTxError tx -> tx

-- | An error occurred when submitting a transaction to the cardano-node.
FailedToPostTx :: Text -> tx -> PostTxError tx
[$sel:failureReason:NoSeedInput] :: PostTxError tx -> Text
[$sel:failingTx:NoSeedInput] :: PostTxError tx -> tx

-- | User tried to commit more than <a>maxMainnetLovelace</a> hardcoded
--   limit on mainnet we keep track of both the hardcoded limit and what
--   the user originally tried to commit
CommittedTooMuchADAForMainnet :: Coin -> Coin -> PostTxError tx
[$sel:userCommittedLovelace:NoSeedInput] :: PostTxError tx -> Coin
[$sel:mainnetLimitLovelace:NoSeedInput] :: PostTxError tx -> Coin

-- | We can only draft commit tx for the user when in Initializing state
FailedToDraftTxNotInitializing :: PostTxError tx
FailedToConstructAbortTx :: PostTxError tx
FailedToConstructCloseTx :: PostTxError tx
FailedToConstructContestTx :: PostTxError tx
FailedToConstructCollectTx :: PostTxError tx
FailedToConstructDepositTx :: Text -> PostTxError tx
[$sel:failureReason:NoSeedInput] :: PostTxError tx -> Text
FailedToConstructRecoverTx :: Text -> PostTxError tx
[$sel:failureReason:NoSeedInput] :: PostTxError tx -> Text
FailedToConstructIncrementTx :: Text -> PostTxError tx
[$sel:failureReason:NoSeedInput] :: PostTxError tx -> Text
FailedToConstructDecrementTx :: Text -> PostTxError tx
[$sel:failureReason:NoSeedInput] :: PostTxError tx -> Text
FailedToConstructFanoutTx :: PostTxError tx
DepositTooLow :: Coin -> Coin -> PostTxError tx
[$sel:providedValue:NoSeedInput] :: PostTxError tx -> Coin
[$sel:minimumValue:NoSeedInput] :: PostTxError tx -> Coin

-- | A non empty sequence of chain states that can be rolled back. This is
--   expected to be constructed by using the smart constructor
--   <a>initHistory</a>.
data ChainStateHistory tx
UnsafeChainStateHistory :: NonEmpty (ChainStateType tx) -> ChainStateType tx -> ChainStateHistory tx
[$sel:history:UnsafeChainStateHistory] :: ChainStateHistory tx -> NonEmpty (ChainStateType tx)
[$sel:defaultChainState:UnsafeChainStateHistory] :: ChainStateHistory tx -> ChainStateType tx
currentState :: ChainStateHistory tx -> ChainStateType tx
pushNewState :: ChainStateType tx -> ChainStateHistory tx -> ChainStateHistory tx
initHistory :: ChainStateType tx -> ChainStateHistory tx
rollbackHistory :: IsChainState tx => ChainSlot -> ChainStateHistory tx -> ChainStateHistory tx

-- | Handle to interface with the main chain network
data Chain tx m
Chain :: ChainStateType tx -> (MonadThrow m => PostChainTx tx -> m ()) -> (MonadThrow m => HeadId -> CommitBlueprintTx tx -> m (Either (PostTxError tx) tx)) -> (MonadThrow m => HeadId -> PParams LedgerEra -> CommitBlueprintTx tx -> UTCTime -> m (Either (PostTxError tx) tx)) -> (MonadThrow m => tx -> m ()) -> Chain tx m

-- | Provide an initial chain state that may be evolved through
--   <a>ChainEvent</a>.
[$sel:mkChainState:Chain] :: Chain tx m -> ChainStateType tx

-- | Construct and send a transaction to the main chain corresponding to
--   the given <a>PostChainTx</a> description. This function is not
--   expected to block, so it is only responsible for submitting, but it
--   should validate the created transaction against a reasonable local
--   view of the chain and throw an exception when invalid.
--   
--   Does at least throw <a>PostTxError</a>.
[$sel:postTx:Chain] :: Chain tx m -> MonadThrow m => PostChainTx tx -> m ()

-- | Create a commit transaction using user provided utxos (zero or many)
--   and a _blueprint_ transaction which spends these outputs. Errors are
--   handled at the call site.
[$sel:draftCommitTx:Chain] :: Chain tx m -> MonadThrow m => HeadId -> CommitBlueprintTx tx -> m (Either (PostTxError tx) tx)

-- | Create a deposit transaction using user provided utxos (zero or many)
--   , _blueprint_ transaction which spends these outputs and a deadline
--   for their inclusion into L2. Errors are handled at the call site.
[$sel:draftDepositTx:Chain] :: Chain tx m -> MonadThrow m => HeadId -> PParams LedgerEra -> CommitBlueprintTx tx -> UTCTime -> m (Either (PostTxError tx) tx)

-- | Submit a cardano transaction.
--   
--   Throws at least <a>PostTxError</a>.
--   
--   XXX: While technically they could be any of 'PostTxError tx', only
--   <a>FailedToPostTx</a> errors are expected here.
[$sel:submitTx:Chain] :: Chain tx m -> MonadThrow m => tx -> m ()
data ChainEvent tx

-- | Indicates a head protocol transaction has been observed.
Observation :: OnChainTx tx -> ChainStateType tx -> ChainEvent tx
[$sel:observedTx:Observation] :: ChainEvent tx -> OnChainTx tx
[$sel:newChainState:Observation] :: ChainEvent tx -> ChainStateType tx
Rollback :: ChainStateType tx -> ChainEvent tx
[$sel:rolledBackChainState:Observation] :: ChainEvent tx -> ChainStateType tx

-- | Indicate time has advanced on the chain.
--   
--   NOTE: While the type does not guarantee that the UTCTime and ChainSlot
--   are consistent the alternative would be provide the means to do the
--   conversion. For Cardano, this would be a systemStart and eraHistory..
--   which is annoying and if it's kept in the chain layer, it would mean
--   another round trip / state to keep there.
Tick :: UTCTime -> ChainSlot -> ChainEvent tx
[$sel:chainTime:Observation] :: ChainEvent tx -> UTCTime
[$sel:chainSlot:Observation] :: ChainEvent tx -> ChainSlot

-- | Event to re-ingest errors from <a>$sel:postTx:Chain</a> for further
--   processing.
PostTxError :: PostChainTx tx -> PostTxError tx -> Maybe tx -> ChainEvent tx
[$sel:postChainTx:Observation] :: ChainEvent tx -> PostChainTx tx
[$sel:postTxError:Observation] :: ChainEvent tx -> PostTxError tx
[$sel:failingTx:Observation] :: ChainEvent tx -> Maybe tx

-- | A callback indicating a 'ChainEvent tx' happened. Most importantly the
--   <a>Observation</a> of a relevant Hydra transaction.
type ChainCallback tx m = ChainEvent tx -> m ()

-- | A type tying both posting and observing transactions into a single
--   <i>Component</i>.
type ChainComponent tx m a = ChainCallback tx m -> (Chain tx m -> m a) -> m a
instance GHC.Generics.Generic (Hydra.Chain.PostChainTx tx)
instance GHC.Generics.Generic (Hydra.Chain.OnChainTx tx)
instance GHC.Generics.Generic (Hydra.Chain.PostTxError tx)
instance GHC.Generics.Generic (Hydra.Chain.ChainStateHistory tx)
instance GHC.Generics.Generic (Hydra.Chain.ChainEvent tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Classes.Eq (Hydra.Chain.PostChainTx tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Show.Show (Hydra.Chain.PostChainTx tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.PostChainTx tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.PostChainTx tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Classes.Eq (Hydra.Chain.OnChainTx tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Show.Show (Hydra.Chain.OnChainTx tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.OnChainTx tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Classes.Eq (Hydra.Chain.PostTxError tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Show.Show (Hydra.Chain.PostTxError tx)
instance Hydra.Chain.ChainState.IsChainState tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.PostTxError tx)
instance Hydra.Chain.ChainState.IsChainState tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.PostTxError tx)
instance GHC.Classes.Eq (Hydra.Chain.ChainState.ChainStateType tx) => GHC.Classes.Eq (Hydra.Chain.ChainStateHistory tx)
instance GHC.Show.Show (Hydra.Chain.ChainState.ChainStateType tx) => GHC.Show.Show (Hydra.Chain.ChainStateHistory tx)
instance (Hydra.Tx.IsTx.IsTx tx, Hydra.Chain.ChainState.IsChainState tx) => GHC.Classes.Eq (Hydra.Chain.ChainEvent tx)
instance (Hydra.Tx.IsTx.IsTx tx, Hydra.Chain.ChainState.IsChainState tx) => GHC.Show.Show (Hydra.Chain.ChainEvent tx)
instance (Hydra.Tx.IsTx.IsTx tx, Hydra.Chain.ChainState.IsChainState tx) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.ChainEvent tx)
instance (Hydra.Tx.IsTx.ArbitraryIsTx tx, Hydra.Chain.ChainState.IsChainState tx) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainEvent tx)
instance Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainState.ChainStateType tx) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainStateHistory tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Exception.Type.Exception (Hydra.Chain.PostTxError tx)
instance (Hydra.Tx.IsTx.ArbitraryIsTx tx, Hydra.Chain.ChainState.IsChainState tx) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.PostTxError tx)
instance Hydra.Tx.IsTx.ArbitraryIsTx tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.OnChainTx tx)
instance Hydra.Tx.IsTx.ArbitraryIsTx tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.PostChainTx tx)

module Hydra.Chain.Blockfrost.Client
data BlockfrostException
TimeoutOnUTxO :: TxId -> BlockfrostException
FailedToDecodeAddress :: Text -> BlockfrostException
ByronAddressNotSupported :: BlockfrostException
FailedUTxOForHash :: Text -> BlockfrostException
FailedEraHistory :: BlockfrostException
AssetNameMissing :: BlockfrostException
DeserialiseError :: Text -> BlockfrostException
DecodeError :: Text -> BlockfrostException
BlockfrostAPIError :: Text -> BlockfrostException
newtype APIBlockfrostError
BlockfrostError :: BlockfrostException -> APIBlockfrostError
data BlockfrostConversion
BlockfrostConversion :: NonNegativeInterval -> UnitInterval -> UnitInterval -> NonNegativeInterval -> NonNegativeInterval -> UnitInterval -> UnitInterval -> UnitInterval -> UnitInterval -> UnitInterval -> UnitInterval -> UnitInterval -> UnitInterval -> UnitInterval -> UnitInterval -> UnitInterval -> UnitInterval -> UnitInterval -> UnitInterval -> UnitInterval -> Quantity -> Quantity -> Quantity -> Coin -> Integer -> Quantity -> NonNegativeInterval -> BlockfrostConversion
[$sel:a0:BlockfrostConversion] :: BlockfrostConversion -> NonNegativeInterval
[$sel:rho:BlockfrostConversion] :: BlockfrostConversion -> UnitInterval
[$sel:tau:BlockfrostConversion] :: BlockfrostConversion -> UnitInterval
[$sel:priceMemory:BlockfrostConversion] :: BlockfrostConversion -> NonNegativeInterval
[$sel:priceSteps:BlockfrostConversion] :: BlockfrostConversion -> NonNegativeInterval
[$sel:pvtMotionNoConfidence:BlockfrostConversion] :: BlockfrostConversion -> UnitInterval
[$sel:pvtCommitteeNormal:BlockfrostConversion] :: BlockfrostConversion -> UnitInterval
[$sel:pvtCommitteeNoConfidence:BlockfrostConversion] :: BlockfrostConversion -> UnitInterval
[$sel:pvtHardForkInitiation:BlockfrostConversion] :: BlockfrostConversion -> UnitInterval
[$sel:pvtPPSecurityGroup:BlockfrostConversion] :: BlockfrostConversion -> UnitInterval
[$sel:dvtMotionNoConfidence:BlockfrostConversion] :: BlockfrostConversion -> UnitInterval
[$sel:dvtCommitteeNormal:BlockfrostConversion] :: BlockfrostConversion -> UnitInterval
[$sel:dvtCommitteeNoConfidence:BlockfrostConversion] :: BlockfrostConversion -> UnitInterval
[$sel:dvtUpdateToConstitution:BlockfrostConversion] :: BlockfrostConversion -> UnitInterval
[$sel:dvtHardForkInitiation:BlockfrostConversion] :: BlockfrostConversion -> UnitInterval
[$sel:dvtPPNetworkGroup:BlockfrostConversion] :: BlockfrostConversion -> UnitInterval
[$sel:dvtPPEconomicGroup:BlockfrostConversion] :: BlockfrostConversion -> UnitInterval
[$sel:dvtPPTechnicalGroup:BlockfrostConversion] :: BlockfrostConversion -> UnitInterval
[$sel:dvtPPGovGroup:BlockfrostConversion] :: BlockfrostConversion -> UnitInterval
[$sel:dvtTreasuryWithdrawal:BlockfrostConversion] :: BlockfrostConversion -> UnitInterval
[$sel:committeeMinSize:BlockfrostConversion] :: BlockfrostConversion -> Quantity
[$sel:committeeMaxTermLength:BlockfrostConversion] :: BlockfrostConversion -> Quantity
[$sel:govActionLifetime:BlockfrostConversion] :: BlockfrostConversion -> Quantity
[$sel:govActionDeposit:BlockfrostConversion] :: BlockfrostConversion -> Coin
[$sel:drepDeposit:BlockfrostConversion] :: BlockfrostConversion -> Integer
[$sel:drepActivity:BlockfrostConversion] :: BlockfrostConversion -> Quantity
[$sel:minFeeRefScriptCostPerByte:BlockfrostConversion] :: BlockfrostConversion -> NonNegativeInterval

-- | Query the Blockfrost API for <a>Genesis</a>
queryGenesisParameters :: BlockfrostClientT IO Genesis

-- | Query for <a>TxIn</a>s in the search for outputs containing all the
--   reference scripts of the <a>ScriptRegistry</a>.
--   
--   This is implemented by repeated querying until we have all necessary
--   reference scripts as we do only know the transaction id, not the
--   indices.
--   
--   Can throw at least <tt>NewScriptRegistryException</tt> on failure.
queryScriptRegistry :: [TxId] -> BlockfrostClientT IO ScriptRegistry
queryEraHistory :: BlockfrostClientT IO EraHistory
queryProtocolParameters :: MonadIO m => BlockfrostClientT m (PParams LedgerEra)
queryStakePools :: BlockfrostClientT IO (Set PoolId)
querySystemStart :: BlockfrostClientT IO SystemStart
runBlockfrostM :: (MonadIO m, MonadThrow m) => Project -> BlockfrostClientT IO a -> m a
toCardanoNetworkId :: Integer -> NetworkId

-- | Query the Blockfrost API to get the <a>UTxO'</a> for <a>TxIn</a> and
--   convert to cardano <a>UTxO'</a>. FIXME: make blockfrost wait times
--   configurable.
queryUTxOByTxIn :: NetworkId -> [TxIn] -> BlockfrostClientT IO UTxO
scriptTypeToPlutusVersion :: ScriptType -> Maybe Language
toCardanoUTxO :: NetworkId -> TxIn -> Address -> Maybe ScriptHash -> Maybe DatumHash -> [Amount] -> Maybe InlineDatum -> BlockfrostClientT IO (UTxO' (TxOut ctx))
toCardanoValue :: [Amount] -> BlockfrostClientT IO Value
queryScript :: Text -> BlockfrostClientT IO (Maybe PlutusScript)
toCardanoTxOut :: NetworkId -> Text -> Value -> Maybe Text -> Maybe Text -> Maybe PlutusScript -> BlockfrostClientT IO (TxOut ctx)
toCardanoPoolId :: PoolId -> Hash StakePoolKey
toCardanoTxIn :: Text -> Integer -> TxIn
toCardanoAddress :: Text -> Maybe AddressInEra
toCardanoPolicyIdAndAssetName :: Text -> BlockfrostClientT IO (PolicyId, AssetName)
toCardanoGenesisParameters :: Genesis -> GenesisParameters ShelleyEra
submitTransaction :: MonadIO m => Tx -> BlockfrostClientT m TxHash

-- | Query the Blockfrost API for address UTxO and convert to cardano
--   <a>UTxO'</a>. NOTE: We accept the address list here to be compatible
--   with cardano-api but in fact this is a single address query always.
queryUTxO :: NetworkId -> [Address ShelleyAddr] -> BlockfrostClientT IO UTxO
queryUTxOFor :: VerificationKey PaymentKey -> BlockfrostClientT IO UTxO

-- | Query the Blockfrost API for <a>Genesis</a> and convert to cardano
--   <a>ChainPoint</a>.
queryTip :: BlockfrostClientT IO ChainPoint
awaitTransaction :: Tx -> VerificationKey PaymentKey -> BlockfrostClientT IO UTxO

-- | Await for specific UTxO at address - the one that is produced by the
--   given <a>TxId</a>.
awaitUTxO :: NetworkId -> [Address ShelleyAddr] -> TxId -> Int -> BlockfrostClientT IO UTxO
data () => Block
Block :: POSIXTime -> Maybe Integer -> BlockHash -> Maybe Slot -> Maybe Epoch -> Maybe Integer -> Text -> Integer -> Integer -> Maybe Lovelaces -> Maybe Lovelaces -> Maybe Text -> Maybe Text -> Maybe Quantity -> Maybe BlockHash -> Maybe BlockHash -> Integer -> Block
[$sel:_blockTime:Block] :: Block -> POSIXTime
[$sel:_blockHeight:Block] :: Block -> Maybe Integer
[$sel:_blockHash:Block] :: Block -> BlockHash
[$sel:_blockSlot:Block] :: Block -> Maybe Slot
[$sel:_blockEpoch:Block] :: Block -> Maybe Epoch
[$sel:_blockEpochSlot:Block] :: Block -> Maybe Integer
[$sel:_blockSlotLeader:Block] :: Block -> Text
[$sel:_blockSize:Block] :: Block -> Integer
[$sel:_blockTxCount:Block] :: Block -> Integer
[$sel:_blockOutput:Block] :: Block -> Maybe Lovelaces
[$sel:_blockFees:Block] :: Block -> Maybe Lovelaces
[$sel:_blockBlockVrf:Block] :: Block -> Maybe Text
[$sel:_blockOpCert:Block] :: Block -> Maybe Text
[$sel:_blockOpCertCounter:Block] :: Block -> Maybe Quantity
[$sel:_blockPreviousBlock:Block] :: Block -> Maybe BlockHash
[$sel:_blockNextBlock:Block] :: Block -> Maybe BlockHash
[$sel:_blockConfirmations:Block] :: Block -> Integer
newtype () => Slot
Slot :: Integer -> Slot
newtype () => BlockHash
BlockHash :: Text -> BlockHash
data () => BlockfrostClientT (m :: Type -> Type) a
data () => Genesis
Genesis :: Rational -> Integer -> Lovelaces -> Integer -> Integer -> POSIXTime -> Integer -> Integer -> Integer -> Integer -> Genesis
[$sel:_genesisActiveSlotsCoefficient:Genesis] :: Genesis -> Rational
[$sel:_genesisUpdateQuorum:Genesis] :: Genesis -> Integer
[$sel:_genesisMaxLovelaceSupply:Genesis] :: Genesis -> Lovelaces
[$sel:_genesisNetworkMagic:Genesis] :: Genesis -> Integer
[$sel:_genesisEpochLength:Genesis] :: Genesis -> Integer
[$sel:_genesisSystemStart:Genesis] :: Genesis -> POSIXTime
[$sel:_genesisSlotsPerKesPeriod:Genesis] :: Genesis -> Integer
[$sel:_genesisSlotLength:Genesis] :: Genesis -> Integer
[$sel:_genesisMaxKesEvolutions:Genesis] :: Genesis -> Integer
[$sel:_genesisSecurityParam:Genesis] :: Genesis -> Integer
data () => Project
newtype () => TransactionCBOR
TransactionCBOR :: Text -> TransactionCBOR
[$sel:_transactionCBORCbor:TransactionCBOR] :: TransactionCBOR -> Text
newtype () => TxHashCBOR
TxHashCBOR :: (TxHash, TransactionCBOR) -> TxHashCBOR
[$sel:getTxHashCBOR:TxHashCBOR] :: TxHashCBOR -> (TxHash, TransactionCBOR)

-- | <a>MonadError</a> analogue to the <a>try</a> function.
tryError :: MonadError e m => m a -> m (Either e a)
allPages :: Monad m => (Paged -> m [a]) -> m [a]
def :: Default a => a
getBlock :: MonadBlockfrost m => Either Integer BlockHash -> m Block
getBlockTxsCBOR' :: MonadBlockfrost m => Either Integer BlockHash -> Paged -> SortOrder -> m [TxHashCBOR]
getLedgerGenesis :: MonadBlockfrost m => m Genesis
listPools :: MonadBlockfrost m => m [PoolId]
projectFromFile :: FilePath -> IO Project
runBlockfrost :: Project -> BlockfrostClientT IO a -> IO (Either BlockfrostError a)
unBlockHash :: BlockHash -> Text
unSlot :: Slot -> Integer
instance GHC.Exception.Type.Exception Hydra.Chain.Blockfrost.Client.BlockfrostException
instance GHC.Show.Show Hydra.Chain.Blockfrost.Client.BlockfrostException
instance GHC.Exception.Type.Exception Hydra.Chain.Blockfrost.Client.APIBlockfrostError
instance GHC.Show.Show Hydra.Chain.Blockfrost.Client.APIBlockfrostError


-- | A basic cardano-node client that can talk to a local cardano-node.
--   
--   The idea of this module is to provide a Haskell interface on top of
--   cardano-cli's API, using cardano-api types.
module Hydra.Chain.CardanoClient
data QueryException
QueryAcquireException :: AcquiringFailure -> QueryException
QueryEraMismatchException :: EraMismatch -> QueryException
QueryUnsupportedNtcVersionException :: UnsupportedNtcVersionError -> QueryException
QueryProtocolParamsConversionException :: ProtocolParametersConversionError -> QueryException
QueryProtocolParamsEraNotSupported :: AnyCardanoEra -> QueryException
QueryProtocolParamsEncodingFailureOnEra :: AnyCardanoEra -> Text -> QueryException
QueryEraNotInCardanoModeFailure :: AnyCardanoEra -> QueryException
QueryNotShelleyBasedEraException :: AnyCardanoEra -> QueryException

-- | Handle interface for abstract querying of a cardano node.
data CardanoClient
CardanoClient :: ([Address ShelleyAddr] -> IO UTxO) -> NetworkId -> CardanoClient
[$sel:queryUTxOByAddress:CardanoClient] :: CardanoClient -> [Address ShelleyAddr] -> IO UTxO
[$sel:networkId:CardanoClient] :: CardanoClient -> NetworkId

-- | Construct a <a>CardanoClient</a> handle.
mkCardanoClient :: NetworkId -> SocketPath -> CardanoClient

-- | Submit a (signed) transaction to the node.
--   
--   Throws <a>SubmitTransactionException</a> if submission fails.
submitTransaction :: NetworkId -> SocketPath -> Tx -> IO ()

-- | Exceptions that <tt>can</tt> occur during a transaction submission.
--   
--   In principle, we can only encounter an <a>EraMismatch</a> at era
--   boundaries, when we try to submit a "next era" transaction as a
--   "current era" transaction, or vice-versa. Similarly,
--   <tt>TxValidationError</tt> shouldn't occur given that the transaction
--   was safely constructed through <tt>buildTransaction</tt>.
data SubmitTransactionException
SubmitEraMismatch :: EraMismatch -> SubmitTransactionException
SubmitTxValidationError :: TxValidationErrorInCardanoMode -> SubmitTransactionException

-- | Await until the given transaction is visible on-chain. Returns the
--   UTxO set produced by that transaction.
--   
--   Note that this function loops forever; hence, one probably wants to
--   couple it with a surrounding timeout.
awaitTransaction :: NetworkId -> SocketPath -> Tx -> IO UTxO

-- | Describes whether to query at the tip or at a specific point.
data QueryPoint
QueryTip :: QueryPoint
QueryAt :: ChainPoint -> QueryPoint

-- | Query the latest chain point aka "the tip".
queryTip :: NetworkId -> SocketPath -> IO ChainPoint

-- | Query the system start parameter at given point.
--   
--   Throws at least <a>QueryException</a> if query fails.
querySystemStart :: NetworkId -> SocketPath -> QueryPoint -> IO SystemStart

-- | Query the era history at given point.
--   
--   Throws at least <a>QueryException</a> if query fails.
queryEraHistory :: NetworkId -> SocketPath -> QueryPoint -> IO EraHistory

-- | Query the current epoch number.
--   
--   Throws at least <a>QueryException</a> if query fails.
queryEpochNo :: NetworkId -> SocketPath -> QueryPoint -> IO EpochNo

-- | Query the protocol parameters at given point and convert them to
--   Babbage era protocol parameters.
--   
--   Throws at least <a>QueryException</a> if query fails.
queryProtocolParameters :: NetworkId -> SocketPath -> QueryPoint -> IO (PParams LedgerEra)

-- | Query <a>GenesisParameters</a> at a given point.
--   
--   Throws at least <a>QueryException</a> if query fails.
queryGenesisParameters :: NetworkId -> SocketPath -> QueryPoint -> IO (GenesisParameters ShelleyEra)

-- | Query UTxO for all given addresses at given point.
--   
--   Throws at least <a>QueryException</a> if query fails.
queryUTxO :: NetworkId -> SocketPath -> QueryPoint -> [Address ShelleyAddr] -> IO UTxO
queryUTxOExpr :: ShelleyBasedEra era -> [Address ShelleyAddr] -> LocalStateQueryExpr b p QueryInMode r IO UTxO

-- | Query UTxO for given tx inputs at given point.
--   
--   Throws at least <a>QueryException</a> if query fails.
queryUTxOByTxIn :: NetworkId -> SocketPath -> QueryPoint -> [TxIn] -> IO UTxO
assumeShelleyBasedEraOrThrow :: MonadThrow m => CardanoEra era -> m (ShelleyBasedEra era)

-- | Query the whole UTxO from node at given point. Useful for debugging,
--   but should obviously not be used in production code.
--   
--   Throws at least <a>QueryException</a> if query fails.
queryUTxOWhole :: NetworkId -> SocketPath -> QueryPoint -> IO UTxO

-- | Query UTxO for the address of given verification key at point.
--   
--   Throws at least <a>QueryException</a> if query fails.
queryUTxOFor :: NetworkId -> SocketPath -> QueryPoint -> VerificationKey PaymentKey -> IO UTxO

-- | Query the current set of registered stake pools.
--   
--   Throws at least <a>QueryException</a> if query fails.
queryStakePools :: NetworkId -> SocketPath -> QueryPoint -> IO (Set PoolId)

-- | Monadic query expression to get current era.
queryCurrentEraExpr :: LocalStateQueryExpr b p QueryInMode r IO AnyCardanoEra

-- | Monadic query expression for a <a>QueryInShelleyBasedEra</a>.
queryInShelleyBasedEraExpr :: ShelleyBasedEra era -> QueryInShelleyBasedEra era a -> LocalStateQueryExpr b p QueryInMode r IO a

-- | Throws at least <a>QueryException</a> if query fails.
runQuery :: NetworkId -> SocketPath -> QueryPoint -> QueryInMode a -> IO a

-- | Throws at least <a>QueryException</a> if query fails.
runQueryExpr :: NetworkId -> SocketPath -> QueryPoint -> LocalStateQueryExpr BlockInMode ChainPoint QueryInMode () IO a -> IO a
throwOnEraMismatch :: MonadThrow m => Either EraMismatch a -> m a
throwOnUnsupportedNtcVersion :: MonadThrow m => Either UnsupportedNtcVersionError a -> m a
localNodeConnectInfo :: NetworkId -> SocketPath -> LocalNodeConnectInfo
cardanoModeParams :: ConsensusModeParams
instance GHC.Classes.Eq Hydra.Chain.CardanoClient.QueryException
instance GHC.Show.Show Hydra.Chain.CardanoClient.QueryException
instance GHC.Show.Show Hydra.Chain.CardanoClient.SubmitTransactionException
instance GHC.Generics.Generic Hydra.Chain.CardanoClient.QueryPoint
instance GHC.Show.Show Hydra.Chain.CardanoClient.QueryPoint
instance GHC.Classes.Eq Hydra.Chain.CardanoClient.QueryPoint
instance GHC.Exception.Type.Exception Hydra.Chain.CardanoClient.SubmitTransactionException
instance GHC.Exception.Type.Exception Hydra.Chain.CardanoClient.QueryException


-- | This module defines the types and functions for creating
--   <a>EventSource</a> and <a>EventSink</a> instances and is intended to
--   be used as an extension point.
--   
--   A single <a>EventSource</a> and zero or more <a>EventSink</a> handles
--   are used by the main <tt>HydraNode</tt> handle to load and send out
--   events.
--   
--   See <a>FileBased</a> for an example implementation and
--   <a>FileBasedSpec</a> for the corresponding test suite.
--   
--   Custom implementations should be located under Hydra.Events to avoid
--   conflicts.
module Hydra.Events
type EventId = Word64
class HasEventId a
getEventId :: HasEventId a => a -> EventId
newtype EventSource e m
EventSource :: (HasEventId e => ConduitT () e (ResourceT m) ()) -> EventSource e m

-- | Stream all events from the event source.
[$sel:sourceEvents:EventSource] :: EventSource e m -> HasEventId e => ConduitT () e (ResourceT m) ()

-- | Retrieve all events from the event source as a list.
getEvents :: (HasEventId e, MonadUnliftIO m) => EventSource e m -> m [e]
newtype EventSink e m
EventSink :: (HasEventId e => e -> m ()) -> EventSink e m

-- | Send a single event to the event sink.
[$sel:putEvent:EventSink] :: EventSink e m -> HasEventId e => e -> m ()

-- | Put a list of events to a list of event sinks in a round-robin
--   fashion.
putEventsToSinks :: (Monad m, HasEventId e) => [EventSink e m] -> [e] -> m ()
instance Hydra.Events.HasEventId GHC.Word.Word64

module Hydra.Events.Rotation
newtype RotationConfig
RotateAfter :: Natural -> RotationConfig
type LogId = EventId

-- | An EventSource and EventSink combined
data EventStore e m
EventStore :: EventSource e m -> EventSink e m -> (LogId -> e -> m ()) -> EventStore e m
[$sel:eventSource:EventStore] :: EventStore e m -> EventSource e m
[$sel:eventSink:EventStore] :: EventStore e m -> EventSink e m

-- | Rotate existing events into a given log id and start a new log from
--   given e.
[$sel:rotate:EventStore] :: EventStore e m -> LogId -> e -> m ()

-- | Creates an event store that rotates according to given config and
--   <tt>StateAggregate</tt>.
newRotatedEventStore :: (HasEventId e, MonadSTM m, MonadUnliftIO m, MonadTime m) => RotationConfig -> s -> (s -> e -> s) -> (s -> EventId -> UTCTime -> e) -> EventStore e m -> m (EventStore e m)

module Hydra.HeadLogic.State

-- | The main state of the Hydra protocol state machine. It holds both, the
--   overall protocol state, but also the off-chain
--   <a>CoordinatedHeadState</a>.
--   
--   Each of the sub-types (InitialState, OpenState, etc.) contain a
--   black-box <a>IdleState</a> corresponding to the <tt>ChainEvent</tt>
--   that has been observed leading to the state.
--   
--   Note that rollbacks are currently not fully handled in the head logic
--   and only this internal chain state gets replaced with the "rolled back
--   to" version.
--   
--   TODO: chainState would actually not be needed in the HeadState anymore
--   as we do not persist the <a>HeadState</a> and not access it in the
--   HeadLogic either.
data HeadState tx
Idle :: IdleState tx -> HeadState tx
Initial :: InitialState tx -> HeadState tx
Open :: OpenState tx -> HeadState tx
Closed :: ClosedState tx -> HeadState tx

-- | Update the chain state in any <a>HeadState</a>.
setChainState :: ChainStateType tx -> HeadState tx -> HeadState tx

-- | Get the chain state in any <a>HeadState</a>.
getChainState :: HeadState tx -> ChainStateType tx

-- | Get the head parameters in any <a>HeadState</a>.
getHeadParameters :: HeadState tx -> Maybe HeadParameters

-- | An <a>Idle</a> head only having a chain state with things seen on
--   chain so far.
newtype IdleState tx
IdleState :: ChainStateType tx -> IdleState tx
[$sel:chainState:IdleState] :: IdleState tx -> ChainStateType tx

-- | An <a>Initial</a> head which already has an identity and is collecting
--   commits.
data InitialState tx
InitialState :: HeadParameters -> PendingCommits -> Committed tx -> ChainStateType tx -> HeadId -> HeadSeed -> InitialState tx
[$sel:parameters:InitialState] :: InitialState tx -> HeadParameters
[$sel:pendingCommits:InitialState] :: InitialState tx -> PendingCommits
[$sel:committed:InitialState] :: InitialState tx -> Committed tx
[$sel:chainState:InitialState] :: InitialState tx -> ChainStateType tx
[$sel:headId:InitialState] :: InitialState tx -> HeadId
[$sel:headSeed:InitialState] :: InitialState tx -> HeadSeed
type PendingCommits = Set Party
type Committed tx = Map Party (UTxOType tx)

-- | An <a>Open</a> head with a <a>CoordinatedHeadState</a> tracking
--   off-chain transactions.
data OpenState tx
OpenState :: HeadParameters -> CoordinatedHeadState tx -> ChainStateType tx -> HeadId -> ChainSlot -> HeadSeed -> OpenState tx
[$sel:parameters:OpenState] :: OpenState tx -> HeadParameters
[$sel:coordinatedHeadState:OpenState] :: OpenState tx -> CoordinatedHeadState tx
[$sel:chainState:OpenState] :: OpenState tx -> ChainStateType tx
[$sel:headId:OpenState] :: OpenState tx -> HeadId
[$sel:currentSlot:OpenState] :: OpenState tx -> ChainSlot
[$sel:headSeed:OpenState] :: OpenState tx -> HeadSeed

-- | Off-chain state of the Coordinated Head protocol.
data CoordinatedHeadState tx
CoordinatedHeadState :: UTxOType tx -> [tx] -> !Map (TxIdType tx) tx -> ConfirmedSnapshot tx -> SeenSnapshot tx -> Map (TxIdType tx) (Deposit tx) -> Maybe (TxIdType tx) -> Maybe tx -> SnapshotVersion -> CoordinatedHeadState tx

-- | The latest UTxO resulting from applying
--   <a>$sel:localTxs:CoordinatedHeadState</a> to
--   <a>CoordinatedHeadState</a>. Spec: L̂
[$sel:localUTxO:CoordinatedHeadState] :: CoordinatedHeadState tx -> UTxOType tx

-- | List of transactions applied locally and pending inclusion in a
--   snapshot. Ordering in this list is important as transactions are added
--   in order of application. Spec: T̂
[$sel:localTxs:CoordinatedHeadState] :: CoordinatedHeadState tx -> [tx]

-- | Map containing all the transactions ever seen by this node and not yet
--   included in a snapshot. Spec: Tall
[$sel:allTxs:CoordinatedHeadState] :: CoordinatedHeadState tx -> !Map (TxIdType tx) tx

-- | The latest confirmed snapshot. Spec: S̅
[$sel:confirmedSnapshot:CoordinatedHeadState] :: CoordinatedHeadState tx -> ConfirmedSnapshot tx

-- | Last seen snapshot and signatures accumulator. Spec: Û, ŝ and Σ̂
[$sel:seenSnapshot:CoordinatedHeadState] :: CoordinatedHeadState tx -> SeenSnapshot tx

-- | Pending deposits as observed on chain. TODO: These should be actually
--   stored outside of the <a>HeadState</a> to allow recovery when a head
--   is not open. See
--   <a>https://github.com/cardano-scaling/hydra/issues/1812</a>
[$sel:pendingDeposits:CoordinatedHeadState] :: CoordinatedHeadState tx -> Map (TxIdType tx) (Deposit tx)

-- | Current/next deposit to incrementally commit. Spec: Uα TODO: update in
--   spec: Uα -&gt; tx^#α
[$sel:currentDepositTxId:CoordinatedHeadState] :: CoordinatedHeadState tx -> Maybe (TxIdType tx)

-- | Pending decommit transaction. Spec: txω
[$sel:decommitTx:CoordinatedHeadState] :: CoordinatedHeadState tx -> Maybe tx

-- | Last open state version as observed on chain. Spec: ̂v
[$sel:version:CoordinatedHeadState] :: CoordinatedHeadState tx -> SnapshotVersion

-- | Data structure to help in tracking whether we have seen or requested a
--   ReqSn already and if seen, the signatures we collected already.
data SeenSnapshot tx

-- | Never saw a ReqSn.
NoSeenSnapshot :: SeenSnapshot tx

-- | No snapshot in flight with last seen snapshot number as given.
LastSeenSnapshot :: SnapshotNumber -> SeenSnapshot tx
[$sel:lastSeen:NoSeenSnapshot] :: SeenSnapshot tx -> SnapshotNumber

-- | ReqSn was sent out and it should be considered already in flight.
RequestedSnapshot :: SnapshotNumber -> SnapshotNumber -> SeenSnapshot tx
[$sel:lastSeen:NoSeenSnapshot] :: SeenSnapshot tx -> SnapshotNumber
[$sel:requested:NoSeenSnapshot] :: SeenSnapshot tx -> SnapshotNumber

-- | ReqSn for given snapshot was received.
SeenSnapshot :: Snapshot tx -> Map Party (Signature (Snapshot tx)) -> SeenSnapshot tx
[$sel:snapshot:NoSeenSnapshot] :: SeenSnapshot tx -> Snapshot tx

-- | Collected signatures and so far.
[$sel:signatories:NoSeenSnapshot] :: SeenSnapshot tx -> Map Party (Signature (Snapshot tx))

-- | Get the last seen snapshot number given a <a>SeenSnapshot</a>.
seenSnapshotNumber :: SeenSnapshot tx -> SnapshotNumber

-- | A deposit tracked by the protocol. The <a>DepositStatus</a> determines
--   whether it may be used for an incremental commit or not.
data Deposit tx
Deposit :: HeadId -> UTxOType tx -> UTCTime -> UTCTime -> DepositStatus -> Deposit tx
[$sel:headId:Deposit] :: Deposit tx -> HeadId
[$sel:deposited:Deposit] :: Deposit tx -> UTxOType tx
[$sel:created:Deposit] :: Deposit tx -> UTCTime
[$sel:deadline:Deposit] :: Deposit tx -> UTCTime
[$sel:status:Deposit] :: Deposit tx -> DepositStatus
data DepositStatus
Inactive :: DepositStatus
Active :: DepositStatus
Expired :: DepositStatus

-- | An <a>Closed</a> head with an current candidate
--   <a>ConfirmedSnapshot</a>, which may be contested before the
--   <a>$sel:contestationDeadline:ClosedState</a>.
data ClosedState tx
ClosedState :: HeadParameters -> ConfirmedSnapshot tx -> UTCTime -> Bool -> ChainStateType tx -> HeadId -> HeadSeed -> SnapshotVersion -> ClosedState tx
[$sel:parameters:ClosedState] :: ClosedState tx -> HeadParameters
[$sel:confirmedSnapshot:ClosedState] :: ClosedState tx -> ConfirmedSnapshot tx
[$sel:contestationDeadline:ClosedState] :: ClosedState tx -> UTCTime

-- | Tracks whether we have informed clients already about being
--   <tt>ReadyToFanout</tt>.
[$sel:readyToFanoutSent:ClosedState] :: ClosedState tx -> Bool
[$sel:chainState:ClosedState] :: ClosedState tx -> ChainStateType tx
[$sel:headId:ClosedState] :: ClosedState tx -> HeadId
[$sel:headSeed:ClosedState] :: ClosedState tx -> HeadSeed
[$sel:version:ClosedState] :: ClosedState tx -> SnapshotVersion
instance GHC.Generics.Generic (Hydra.HeadLogic.State.IdleState tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.State.InitialState tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.State.SeenSnapshot tx)
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.HeadLogic.State.DepositStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.HeadLogic.State.DepositStatus
instance GHC.Show.Show Hydra.HeadLogic.State.DepositStatus
instance GHC.Classes.Eq Hydra.HeadLogic.State.DepositStatus
instance GHC.Generics.Generic Hydra.HeadLogic.State.DepositStatus
instance GHC.Generics.Generic (Hydra.HeadLogic.State.Deposit tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.State.CoordinatedHeadState tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.State.OpenState tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.State.ClosedState tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.State.HeadState tx)
instance (Hydra.Tx.IsTx.IsTx tx, GHC.Classes.Eq (Hydra.Chain.ChainState.ChainStateType tx)) => GHC.Classes.Eq (Hydra.HeadLogic.State.HeadState tx)
instance (Hydra.Tx.IsTx.IsTx tx, GHC.Show.Show (Hydra.Chain.ChainState.ChainStateType tx)) => GHC.Show.Show (Hydra.HeadLogic.State.HeadState tx)
instance (Hydra.Tx.IsTx.IsTx tx, Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.ChainState.ChainStateType tx)) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.State.HeadState tx)
instance (Hydra.Tx.IsTx.IsTx tx, Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.ChainState.ChainStateType tx)) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.State.HeadState tx)
instance GHC.Classes.Eq (Hydra.Chain.ChainState.ChainStateType tx) => GHC.Classes.Eq (Hydra.HeadLogic.State.IdleState tx)
instance GHC.Show.Show (Hydra.Chain.ChainState.ChainStateType tx) => GHC.Show.Show (Hydra.HeadLogic.State.IdleState tx)
instance Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.ChainState.ChainStateType tx) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.State.IdleState tx)
instance Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.ChainState.ChainStateType tx) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.State.IdleState tx)
instance (Hydra.Tx.IsTx.IsTx tx, GHC.Classes.Eq (Hydra.Chain.ChainState.ChainStateType tx)) => GHC.Classes.Eq (Hydra.HeadLogic.State.InitialState tx)
instance (Hydra.Tx.IsTx.IsTx tx, GHC.Show.Show (Hydra.Chain.ChainState.ChainStateType tx)) => GHC.Show.Show (Hydra.HeadLogic.State.InitialState tx)
instance (Hydra.Tx.IsTx.IsTx tx, Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.ChainState.ChainStateType tx)) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.State.InitialState tx)
instance (Hydra.Tx.IsTx.IsTx tx, Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.ChainState.ChainStateType tx)) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.State.InitialState tx)
instance (Hydra.Tx.IsTx.IsTx tx, GHC.Classes.Eq (Hydra.Chain.ChainState.ChainStateType tx)) => GHC.Classes.Eq (Hydra.HeadLogic.State.OpenState tx)
instance (Hydra.Tx.IsTx.IsTx tx, GHC.Show.Show (Hydra.Chain.ChainState.ChainStateType tx)) => GHC.Show.Show (Hydra.HeadLogic.State.OpenState tx)
instance (Hydra.Tx.IsTx.IsTx tx, Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.ChainState.ChainStateType tx)) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.State.OpenState tx)
instance (Hydra.Tx.IsTx.IsTx tx, Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.ChainState.ChainStateType tx)) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.State.OpenState tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Classes.Eq (Hydra.HeadLogic.State.CoordinatedHeadState tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Show.Show (Hydra.HeadLogic.State.CoordinatedHeadState tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.State.CoordinatedHeadState tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.State.CoordinatedHeadState tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Classes.Eq (Hydra.HeadLogic.State.SeenSnapshot tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Show.Show (Hydra.HeadLogic.State.SeenSnapshot tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.State.SeenSnapshot tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.State.SeenSnapshot tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Classes.Eq (Hydra.HeadLogic.State.Deposit tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Show.Show (Hydra.HeadLogic.State.Deposit tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.State.Deposit tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.State.Deposit tx)
instance (Hydra.Tx.IsTx.IsTx tx, GHC.Classes.Eq (Hydra.Chain.ChainState.ChainStateType tx)) => GHC.Classes.Eq (Hydra.HeadLogic.State.ClosedState tx)
instance (Hydra.Tx.IsTx.IsTx tx, GHC.Show.Show (Hydra.Chain.ChainState.ChainStateType tx)) => GHC.Show.Show (Hydra.HeadLogic.State.ClosedState tx)
instance (Hydra.Tx.IsTx.IsTx tx, Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.ChainState.ChainStateType tx)) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.State.ClosedState tx)
instance (Hydra.Tx.IsTx.IsTx tx, Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.ChainState.ChainStateType tx)) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.State.ClosedState tx)
instance (Hydra.Tx.IsTx.ArbitraryIsTx tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainState.ChainStateType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.State.HeadState tx)
instance (Hydra.Tx.IsTx.ArbitraryIsTx tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainState.ChainStateType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.State.ClosedState tx)
instance (Hydra.Tx.IsTx.ArbitraryIsTx tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainState.ChainStateType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.State.OpenState tx)
instance Hydra.Tx.IsTx.ArbitraryIsTx tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.State.CoordinatedHeadState tx)
instance Hydra.Tx.IsTx.ArbitraryIsTx tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.State.Deposit tx)
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.HeadLogic.State.DepositStatus
instance Hydra.Tx.IsTx.ArbitraryIsTx tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.State.SeenSnapshot tx)
instance (Hydra.Tx.IsTx.ArbitraryIsTx tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainState.ChainStateType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.State.InitialState tx)
instance Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Chain.ChainState.ChainStateType tx) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.State.IdleState tx)

module Hydra.Ledger

-- | Get the next chain slot. Use this instead of giving <a>Enum</a> or
--   <a>Num</a> instances to <a>ChainSlot</a>.
nextChainSlot :: ChainSlot -> ChainSlot

-- | An abstract interface for a <a>Ledger</a>. Allows to define mock /
--   simpler implementation for testing as well as limiting feature-envy
--   from the business logic by forcing a closed interface.
newtype Ledger tx
Ledger :: (ChainSlot -> UTxOType tx -> [tx] -> Either (tx, ValidationError) (UTxOType tx)) -> Ledger tx

-- | Apply a set of transaction to a given UTxO set. Returns the new UTxO
--   or validation failures returned from the ledger. TODO:
--   <a>ValidationError</a> should also include the UTxO, which is not
--   necessarily the same as the given UTxO after some transactions
[$sel:applyTransactions:Ledger] :: Ledger tx -> ChainSlot -> UTxOType tx -> [tx] -> Either (tx, ValidationError) (UTxOType tx)

-- | Collect applicable transactions and resulting UTxO. In contrast to
--   <a>$sel:applyTransactions:Ledger</a>, this functions continues on
--   validation errors.
collectTransactions :: Ledger tx -> ChainSlot -> UTxOType tx -> [tx] -> ([tx], UTxOType tx)

-- | Either valid or an error which we get from the ledger-specs tx
--   validation.
data ValidationResult
Valid :: ValidationResult
Invalid :: ValidationError -> ValidationResult
newtype ValidationError
ValidationError :: Text -> ValidationError
[$sel:reason:ValidationError] :: ValidationError -> Text
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Ledger.ValidationError
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Ledger.ValidationError
instance GHC.Generics.Generic Hydra.Ledger.ValidationError
instance GHC.Show.Show Hydra.Ledger.ValidationError
instance GHC.Classes.Eq Hydra.Ledger.ValidationError
instance GHC.Generics.Generic Hydra.Ledger.ValidationResult
instance GHC.Show.Show Hydra.Ledger.ValidationResult
instance GHC.Classes.Eq Hydra.Ledger.ValidationResult
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Ledger.ValidationError

module Hydra.Ledger.Cardano

-- | Utility function to "adjust" a <a>UTxO'</a> set given a <a>Tx</a>
--   
--   The inputs from the <a>Tx</a> are removed from the internal map of the
--   <a>UTxO'</a> and the outputs added, correctly indexed by the
--   <a>TxIn</a>. This function is useful to manually maintain a
--   <a>UTxO'</a> set without caring too much about the <a>Ledger</a>
--   rules.
adjustUTxO :: Tx -> UTxO -> UTxO

-- | Simple conversion from a generic slot to a specific local one.
fromChainSlot :: ChainSlot -> SlotNo

-- | Use the cardano-ledger as an in-hydra <a>Ledger</a>.
cardanoLedger :: Globals -> LedgerEnv LedgerEra -> Ledger Tx

-- | Create a new ledger env from given protocol parameters.
newLedgerEnv :: PParams LedgerEra -> LedgerEnv LedgerEra

-- | Build a zero-fee transaction which spends the first output owned by
--   given signing key and transfers it in full to given verification key.
mkTransferTx :: MonadFail m => NetworkId -> UTxO -> SigningKey PaymentKey -> VerificationKey PaymentKey -> m Tx

-- | Build a zero-fee payment transaction.
mkSimpleTx :: (TxIn, TxOut CtxUTxO) -> (AddressInEra, Value) -> SigningKey PaymentKey -> Either TxBodyError Tx

-- | Create a zero-fee, payment cardano transaction with validity range.
mkRangedTx :: (TxIn, TxOut CtxUTxO) -> (AddressInEra, Value) -> SigningKey PaymentKey -> (Maybe TxValidityLowerBound, Maybe TxValidityUpperBound) -> Either TxBodyError Tx

-- | Generates a sequence of simple "transfer" transactions for a single
--   key.
genSequenceOfSimplePaymentTransactions :: Gen (UTxO, [Tx])
genFixedSizeSequenceOfSimplePaymentTransactions :: Int -> Gen (UTxO, [Tx])
data () => ShelleyGenesis
ShelleyGenesis :: !UTCTime -> !Word32 -> !Network -> !PositiveUnitInterval -> !NonZero Word64 -> !EpochSize -> !Word64 -> !Word64 -> !NominalDiffTimeMicro -> !Word64 -> !Word64 -> !PParams ShelleyEra -> !Map (KeyHash 'Genesis) GenDelegPair -> ListMap Addr Coin -> ShelleyGenesisStaking -> ShelleyGenesis
[sgSystemStart] :: ShelleyGenesis -> !UTCTime
[sgNetworkMagic] :: ShelleyGenesis -> !Word32
[sgNetworkId] :: ShelleyGenesis -> !Network
[sgActiveSlotsCoeff] :: ShelleyGenesis -> !PositiveUnitInterval
[sgSecurityParam] :: ShelleyGenesis -> !NonZero Word64
[sgEpochLength] :: ShelleyGenesis -> !EpochSize
[sgSlotsPerKESPeriod] :: ShelleyGenesis -> !Word64
[sgMaxKESEvolutions] :: ShelleyGenesis -> !Word64
[sgSlotLength] :: ShelleyGenesis -> !NominalDiffTimeMicro
[sgUpdateQuorum] :: ShelleyGenesis -> !Word64
[sgMaxLovelaceSupply] :: ShelleyGenesis -> !Word64
[sgProtocolParams] :: ShelleyGenesis -> !PParams ShelleyEra
[sgGenDelegs] :: ShelleyGenesis -> !Map (KeyHash 'Genesis) GenDelegPair
[sgInitialFunds] :: ShelleyGenesis -> ListMap Addr Coin
[sgStaking] :: ShelleyGenesis -> ShelleyGenesisStaking
data () => Globals
data () => LedgerEnv era
type Tx = Tx Era
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Api.Internal.Hash.Hash Cardano.Api.Internal.Keys.Shelley.PaymentKey)


-- | Contains the a stateful interface to transaction construction and
--   observation.
--   
--   It defines the 'ChainStateType tx' to be used in the <a>Direct</a>
--   layer and it's constituents.
module Hydra.Chain.Direct.State

-- | A class for accessing the known <a>UTxO'</a> set in a type. This is
--   useful to get all the relevant UTxO for resolving transaction inputs.
class HasKnownUTxO a
getKnownUTxO :: HasKnownUTxO a => a -> UTxO

-- | The chain state used by the Hydra.Chain.Direct implementation. It
--   records the actual <a>ChainState</a> paired with a <a>ChainSlot</a>
--   (used to know up to which point to rewind on rollbacks).
data ChainStateAt
ChainStateAt :: UTxO -> Maybe ChainPoint -> ChainStateAt
[$sel:spendableUTxO:ChainStateAt] :: ChainStateAt -> UTxO
[$sel:recordedAt:ChainStateAt] :: ChainStateAt -> Maybe ChainPoint

-- | Get a generic <a>ChainSlot</a> from a Cardano <a>ChainPoint</a>. Slot
--   0 is used for the genesis point.
chainSlotFromPoint :: ChainPoint -> ChainSlot

-- | A definition of all transitions between <a>ChainState</a>s. Enumerable
--   and bounded to be used as labels for checking coverage.
data ChainTransition
Init :: ChainTransition
Abort :: ChainTransition
Commit :: ChainTransition
Collect :: ChainTransition
Increment :: ChainTransition
Decrement :: ChainTransition
Close :: ChainTransition
Contest :: ChainTransition
Fanout :: ChainTransition

-- | An enumeration of all possible on-chain states of a Hydra Head, where
--   each case stores the relevant information to construct &amp; observe
--   transactions to other states.
data ChainState

-- | The idle state does not contain any head-specific information and
--   exists to be used as a starting and terminal state.
Idle :: ChainState
Initial :: InitialState -> ChainState
Open :: OpenState -> ChainState
Closed :: ClosedState -> ChainState

-- | Defines the starting state of the direct chain layer.
initialChainState :: ChainStateType Tx

-- | Read-only chain-specific data. This is different to
--   <a>HydraContext</a> as it only contains data known to single peer.
data ChainContext
ChainContext :: NetworkId -> VerificationKey PaymentKey -> Party -> ScriptRegistry -> ChainContext
[$sel:networkId:ChainContext] :: ChainContext -> NetworkId
[$sel:ownVerificationKey:ChainContext] :: ChainContext -> VerificationKey PaymentKey
[$sel:ownParty:ChainContext] :: ChainContext -> Party
[$sel:scriptRegistry:ChainContext] :: ChainContext -> ScriptRegistry

-- | Representation of the Head output after an Init transaction.
data InitialThreadOutput
InitialThreadOutput :: (TxIn, TxOut CtxUTxO) -> ContestationPeriod -> [Party] -> InitialThreadOutput
[$sel:initialThreadUTxO:InitialThreadOutput] :: InitialThreadOutput -> (TxIn, TxOut CtxUTxO)
[$sel:initialContestationPeriod:InitialThreadOutput] :: InitialThreadOutput -> ContestationPeriod
[$sel:initialParties:InitialThreadOutput] :: InitialThreadOutput -> [Party]
data InitialState
InitialState :: InitialThreadOutput -> [(TxIn, TxOut CtxUTxO)] -> [(TxIn, TxOut CtxUTxO)] -> HeadId -> TxIn -> InitialState
[$sel:initialThreadOutput:InitialState] :: InitialState -> InitialThreadOutput
[$sel:initialInitials:InitialState] :: InitialState -> [(TxIn, TxOut CtxUTxO)]
[$sel:initialCommits:InitialState] :: InitialState -> [(TxIn, TxOut CtxUTxO)]
[$sel:headId:InitialState] :: InitialState -> HeadId
[$sel:seedTxIn:InitialState] :: InitialState -> TxIn
data OpenState
OpenState :: UTxO -> HeadId -> TxIn -> UTxOHash -> OpenState
[$sel:openUTxO:OpenState] :: OpenState -> UTxO
[$sel:headId:OpenState] :: OpenState -> HeadId
[$sel:seedTxIn:OpenState] :: OpenState -> TxIn
[$sel:openUtxoHash:OpenState] :: OpenState -> UTxOHash
data ClosedState
ClosedState :: UTxO -> HeadId -> TxIn -> UTCTime -> ClosedState
[$sel:closedUTxO:ClosedState] :: ClosedState -> UTxO
[$sel:headId:ClosedState] :: ClosedState -> HeadId
[$sel:seedTxIn:ClosedState] :: ClosedState -> TxIn
[$sel:contestationDeadline:ClosedState] :: ClosedState -> UTCTime

-- | Construct an init transaction given some general <a>ChainContext</a>,
--   the <a>HeadParameters</a> and a seed <a>TxIn</a> which will be spent.
initialize :: ChainContext -> TxIn -> [OnChainId] -> HeadParameters -> Tx

-- | Construct a commit transaction based on known, spendable UTxO and some
--   arbitrary UTxOs to commit. This does look for "our initial output" to
--   spend and check the given <a>UTxO'</a> to be compatible. Hence, this
--   function does fail if already committed or if the head is not
--   initializing.
--   
--   NOTE: This version of <a>commit</a> does only commit outputs which are
--   held by payment keys. For a variant which supports committing scripts,
--   see <a>commit'</a>.
commit :: ChainContext -> HeadId -> UTxO -> UTxO -> Either (PostTxError Tx) Tx

-- | Construct a commit transaction based on known, spendable UTxO and some
--   user UTxO inputs to commit. This does look for "our initial output" to
--   spend and check the given <a>UTxO'</a> to be compatible. Hence, this
--   function does fail if already committed or if the head is not
--   initializing.
--   
--   NOTE: A simpler variant only supporting pubkey outputs is
--   <a>commit</a>.
commit' :: ChainContext -> HeadId -> UTxO -> CommitBlueprintTx Tx -> Either (PostTxError Tx) Tx
rejectByronAddress :: UTxO -> Either (PostTxError Tx) ()
rejectMoreThanMainnetLimit :: NetworkId -> UTxO -> Either (PostTxError Tx) ()

-- | Construct a abort transaction based on known, spendable UTxO. This
--   function looks for head, initial and commit outputs to spend and it
--   will fail if we can't find the head output.
abort :: ChainContext -> TxIn -> UTxO -> UTxO -> Either AbortTxError Tx
data CollectTxError
InvalidHeadIdInCollect :: HeadId -> CollectTxError
[$sel:headId:InvalidHeadIdInCollect] :: CollectTxError -> HeadId
CannotFindHeadOutputToCollect :: CollectTxError

-- | Construct a collect transaction based on known, spendable UTxO. This
--   function looks for head output and commit outputs to spend and it will
--   fail if we can't find the head output.
collect :: ChainContext -> HeadId -> HeadParameters -> UTxO -> UTxO -> Either CollectTxError Tx
data IncrementTxError
InvalidHeadIdInIncrement :: HeadId -> IncrementTxError
[$sel:headId:InvalidHeadIdInIncrement] :: IncrementTxError -> HeadId
CannotFindHeadOutputInIncrement :: IncrementTxError
CannotFindDepositOutputInIncrement :: TxId -> IncrementTxError
[$sel:depositTxId:InvalidHeadIdInIncrement] :: IncrementTxError -> TxId
SnapshotMissingIncrementUTxO :: IncrementTxError
SnapshotIncrementUTxOIsNull :: IncrementTxError

-- | Construct a increment transaction spending the head and deposit
--   outputs in given <a>UTxO'</a>, and producing single head output for
--   pending <a>$sel:utxoToCommit:Snapshot</a> of given <a>Snapshot</a>.
increment :: ChainContext -> UTxO -> HeadId -> HeadParameters -> ConfirmedSnapshot Tx -> TxId -> SlotNo -> Either IncrementTxError Tx

-- | Possible errors when trying to construct decrement tx
data DecrementTxError
InvalidHeadIdInDecrement :: HeadId -> DecrementTxError
[$sel:headId:InvalidHeadIdInDecrement] :: DecrementTxError -> HeadId
CannotFindHeadOutputInDecrement :: DecrementTxError
DecrementValueNegative :: DecrementTxError
SnapshotDecrementUTxOIsNull :: DecrementTxError

-- | Construct a decrement transaction spending the head output in given
--   <a>UTxO'</a>, and producing outputs for all pending
--   <a>$sel:utxoToDecommit:Snapshot</a> of given <a>Snapshot</a>.
decrement :: ChainContext -> UTxO -> HeadId -> HeadParameters -> ConfirmedSnapshot Tx -> Either DecrementTxError Tx
data CloseTxError
InvalidHeadIdInClose :: HeadId -> CloseTxError
[$sel:headId:InvalidHeadIdInClose] :: CloseTxError -> HeadId
CannotFindHeadOutputToClose :: CloseTxError
BothCommitAndDecommitInClose :: CloseTxError
data RecoverTxError
InvalidHeadIdInRecover :: HeadId -> RecoverTxError
[$sel:headId:InvalidHeadIdInRecover] :: RecoverTxError -> HeadId
CannotFindDepositOutputToRecover :: TxId -> RecoverTxError
[$sel:depositTxId:InvalidHeadIdInRecover] :: RecoverTxError -> TxId
CannotFindDepositedOutputToRecover :: TxId -> RecoverTxError
[$sel:depositedTxId:InvalidHeadIdInRecover] :: RecoverTxError -> TxId

-- | Construct a recover transaction spending the deposit output and
--   producing outputs the user initially deposited.
recover :: ChainContext -> HeadId -> TxId -> UTxO -> SlotNo -> Either RecoverTxError Tx

-- | Construct a close transaction spending the head output in given
--   <a>UTxO'</a>, head parameters, and a confirmed snapshot. NOTE: Lower
--   and upper bound slot difference should not exceed contestation period.
close :: ChainContext -> UTxO -> HeadId -> HeadParameters -> SnapshotVersion -> ConfirmedSnapshot Tx -> SlotNo -> PointInTime -> Either CloseTxError Tx
data ContestTxError
InvalidHeadIdInContest :: HeadId -> ContestTxError
[$sel:headId:InvalidHeadIdInContest] :: ContestTxError -> HeadId
CannotFindHeadOutputToContest :: ContestTxError
MissingHeadDatumInContest :: ContestTxError
MissingHeadRedeemerInContest :: ContestTxError
WrongDatumInContest :: ContestTxError
FailedToConvertFromScriptDataInContest :: ContestTxError
BothCommitAndDecommitInContest :: ContestTxError

-- | Construct a contest transaction based on the <a>ClosedState</a> and a
--   confirmed snapshot. The given <a>PointInTime</a> will be used as an
--   upper validity bound and needs to be before the deadline.
contest :: ChainContext -> UTxO -> HeadId -> ContestationPeriod -> SnapshotVersion -> ConfirmedSnapshot Tx -> PointInTime -> Either ContestTxError Tx
data FanoutTxError
CannotFindHeadOutputToFanout :: FanoutTxError
MissingHeadDatumInFanout :: FanoutTxError
WrongDatumInFanout :: FanoutTxError
FailedToConvertFromScriptDataInFanout :: FanoutTxError
BothCommitAndDecommitInFanout :: FanoutTxError

-- | Construct a fanout transaction based on the <a>ClosedState</a> and
--   off-chain agreed <a>UTxO'</a> set to fan out.
fanout :: ChainContext -> UTxO -> TxIn -> UTxO -> Maybe UTxO -> Maybe UTxO -> SlotNo -> Either FanoutTxError Tx
utxoOfThisHead :: PolicyId -> UTxO -> UTxO

-- | Observe an init transition using a <a>InitialState</a> and
--   <a>observeInitTx</a>.
observeInit :: ChainContext -> [VerificationKey PaymentKey] -> Tx -> Either NotAnInitReason (OnChainTx Tx, InitialState)

-- | Observe an commit transition using a <a>InitialState</a> and
--   <a>observeCommitTx</a>. NOTE: This function is a bit fragile as it
--   assumes commit output on first output while the underlying
--   observeCommitTx could deal with commit outputs at any index. Only use
--   this function in tests and benchmarks.
observeCommit :: ChainContext -> InitialState -> Tx -> Maybe (OnChainTx Tx, InitialState)

-- | Observe an collect transition using a <a>InitialState</a> and
--   <a>observeCollectComTx</a>. This function checks the head id and
--   ignores if not relevant.
observeCollect :: InitialState -> Tx -> Maybe (OnChainTx Tx, OpenState)

-- | Observe a close transition using a <a>OpenState</a> and
--   <a>observeCloseTx</a>. This function checks the head id and ignores if
--   not relevant.
observeClose :: OpenState -> Tx -> Maybe (OnChainTx Tx, ClosedState)

-- | Maximum number of parties used in the generators.
maxGenParties :: Int

-- | Generate a <a>ChainContext</a> and <a>ChainState</a> within the known
--   limits above, along with a transaction that results in a transition
--   away from it.
genChainStateWithTx :: Gen (ChainContext, ChainState, UTxO, Tx, ChainTransition)

-- | Define some <tt>global</tt> context from which generators can pick
--   values for generation. This allows to write fairly independent
--   generators which however still make sense with one another within the
--   context of a head.
--   
--   For example, one can generate a head's _party_ from that global list,
--   whereas other functions may rely on all parties and thus, we need both
--   generation to be coherent.
--   
--   Do not use this in production code, but only for generating test data.
data HydraContext
HydraContext :: [VerificationKey PaymentKey] -> [SigningKey HydraKey] -> NetworkId -> ContestationPeriod -> ScriptRegistry -> HydraContext
[$sel:ctxVerificationKeys:HydraContext] :: HydraContext -> [VerificationKey PaymentKey]
[$sel:ctxHydraSigningKeys:HydraContext] :: HydraContext -> [SigningKey HydraKey]
[$sel:ctxNetworkId:HydraContext] :: HydraContext -> NetworkId
[$sel:ctxContestationPeriod:HydraContext] :: HydraContext -> ContestationPeriod
[$sel:ctxScriptRegistry:HydraContext] :: HydraContext -> ScriptRegistry
ctxParties :: HydraContext -> [Party]
ctxParticipants :: HydraContext -> [OnChainId]
ctxHeadParameters :: HydraContext -> HeadParameters

-- | Generate a <a>HydraContext</a> for a arbitrary number of parties,
--   bounded by given maximum.
genHydraContext :: Int -> Gen HydraContext

-- | Generate a <a>HydraContext</a> for a given number of parties.
genHydraContextFor :: Int -> Gen HydraContext

-- | Get all peer-specific <a>ChainContext</a>s from a <a>HydraContext</a>.
--   NOTE: This assumes that <a>HydraContext</a> has same length
--   <a>$sel:ctxVerificationKeys:HydraContext</a> and
--   <a>$sel:ctxHydraSigningKeys:HydraContext</a>. XXX: This is actually a
--   non-monadic function.
deriveChainContexts :: HydraContext -> Gen [ChainContext]

-- | Pick one of the participants and derive the peer-specific
--   <a>ChainContext</a> from a <a>HydraContext</a>. NOTE: This assumes
--   that <a>HydraContext</a> has same length
--   <a>$sel:ctxVerificationKeys:HydraContext</a> and
--   <a>$sel:ctxHydraSigningKeys:HydraContext</a>.
pickChainContext :: HydraContext -> Gen ChainContext
genStInitial :: HydraContext -> Gen (ChainContext, InitialState)
genInitTx :: HydraContext -> Gen Tx
genCommits :: HydraContext -> Tx -> Gen [Tx]
genCommits' :: Gen UTxO -> HydraContext -> Tx -> Gen [Tx]
genCommitFor :: VerificationKey PaymentKey -> Gen UTxO
genCommit :: Gen UTxO
genCollectComTx :: Gen (ChainContext, [UTxO], InitialState, UTxO, Tx)
genDepositTx :: Int -> Gen (HydraContext, OpenState, UTxO, Tx)
genRecoverTx :: Gen (UTxO, Tx)
genIncrementTx :: Int -> Gen (ChainContext, OpenState, UTxO, Tx)
genDecrementTx :: Int -> Gen (ChainContext, UTxO, OpenState, UTxO, Tx)
genCloseTx :: Int -> Gen (ChainContext, OpenState, UTxO, Tx, ConfirmedSnapshot Tx)
genContestTx :: Gen (HydraContext, PointInTime, ClosedState, UTxO, Tx)
genFanoutTx :: Int -> Gen (ChainContext, ClosedState, UTxO, Tx)
genStOpen :: HydraContext -> Gen (UTxO, OpenState)
genStClosed :: HydraContext -> UTxO -> Maybe UTxO -> Maybe UTxO -> Gen (SnapshotNumber, UTxO, Maybe UTxO, Maybe UTxO, ClosedState)
unsafeCommit :: HasCallStack => ChainContext -> HeadId -> UTxO -> UTxO -> Tx
unsafeAbort :: HasCallStack => ChainContext -> TxIn -> UTxO -> UTxO -> Tx
unsafeIncrement :: HasCallStack => ChainContext -> UTxO -> HeadId -> HeadParameters -> ConfirmedSnapshot Tx -> TxId -> SlotNo -> Tx
unsafeDecrement :: HasCallStack => ChainContext -> UTxO -> HeadId -> HeadParameters -> ConfirmedSnapshot Tx -> Tx

-- | Unsafe version of <a>close</a> that throws an error if the transaction
--   fails to build.
unsafeClose :: HasCallStack => ChainContext -> UTxO -> HeadId -> HeadParameters -> SnapshotVersion -> ConfirmedSnapshot Tx -> SlotNo -> PointInTime -> Tx
unsafeCollect :: ChainContext -> HeadId -> HeadParameters -> UTxO -> UTxO -> Tx

-- | Unsafe version of <a>contest</a> that throws an error if the
--   transaction fails to build.
unsafeContest :: HasCallStack => ChainContext -> UTxO -> HeadId -> ContestationPeriod -> SnapshotVersion -> ConfirmedSnapshot Tx -> PointInTime -> Tx
unsafeFanout :: HasCallStack => ChainContext -> UTxO -> TxIn -> UTxO -> Maybe UTxO -> Maybe UTxO -> SlotNo -> Tx
unsafeObserveInit :: HasCallStack => ChainContext -> [VerificationKey PaymentKey] -> Tx -> InitialState
unsafeObserveInitAndCommits :: HasCallStack => ChainContext -> [VerificationKey PaymentKey] -> Tx -> [Tx] -> ([UTxO], InitialState)
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Chain.Direct.State.ChainStateAt
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.Direct.State.ChainStateAt
instance GHC.Generics.Generic Hydra.Chain.Direct.State.ChainStateAt
instance GHC.Show.Show Hydra.Chain.Direct.State.ChainStateAt
instance GHC.Classes.Eq Hydra.Chain.Direct.State.ChainStateAt
instance GHC.Enum.Bounded Hydra.Chain.Direct.State.ChainTransition
instance GHC.Enum.Enum Hydra.Chain.Direct.State.ChainTransition
instance GHC.Show.Show Hydra.Chain.Direct.State.ChainTransition
instance GHC.Classes.Eq Hydra.Chain.Direct.State.ChainTransition
instance GHC.Generics.Generic Hydra.Chain.Direct.State.ChainContext
instance GHC.Show.Show Hydra.Chain.Direct.State.ChainContext
instance GHC.Classes.Eq Hydra.Chain.Direct.State.ChainContext
instance GHC.Generics.Generic Hydra.Chain.Direct.State.InitialThreadOutput
instance GHC.Show.Show Hydra.Chain.Direct.State.InitialThreadOutput
instance GHC.Classes.Eq Hydra.Chain.Direct.State.InitialThreadOutput
instance GHC.Generics.Generic Hydra.Chain.Direct.State.InitialState
instance GHC.Show.Show Hydra.Chain.Direct.State.InitialState
instance GHC.Classes.Eq Hydra.Chain.Direct.State.InitialState
instance GHC.Generics.Generic Hydra.Chain.Direct.State.OpenState
instance GHC.Show.Show Hydra.Chain.Direct.State.OpenState
instance GHC.Classes.Eq Hydra.Chain.Direct.State.OpenState
instance GHC.Generics.Generic Hydra.Chain.Direct.State.ClosedState
instance GHC.Show.Show Hydra.Chain.Direct.State.ClosedState
instance GHC.Classes.Eq Hydra.Chain.Direct.State.ClosedState
instance GHC.Generics.Generic Hydra.Chain.Direct.State.ChainState
instance GHC.Show.Show Hydra.Chain.Direct.State.ChainState
instance GHC.Classes.Eq Hydra.Chain.Direct.State.ChainState
instance GHC.Show.Show Hydra.Chain.Direct.State.CollectTxError
instance GHC.Show.Show Hydra.Chain.Direct.State.IncrementTxError
instance GHC.Show.Show Hydra.Chain.Direct.State.DecrementTxError
instance GHC.Show.Show Hydra.Chain.Direct.State.CloseTxError
instance GHC.Show.Show Hydra.Chain.Direct.State.RecoverTxError
instance GHC.Show.Show Hydra.Chain.Direct.State.ContestTxError
instance GHC.Show.Show Hydra.Chain.Direct.State.FanoutTxError
instance GHC.Show.Show Hydra.Chain.Direct.State.HydraContext
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Chain.Direct.State.HydraContext
instance Hydra.Chain.Direct.State.HasKnownUTxO Hydra.Chain.Direct.State.ChainState
instance Hydra.Chain.Direct.State.HasKnownUTxO Hydra.Chain.Direct.State.ClosedState
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Chain.Direct.State.OpenState
instance Hydra.Chain.Direct.State.HasKnownUTxO Hydra.Chain.Direct.State.OpenState
instance Hydra.Chain.Direct.State.HasKnownUTxO Hydra.Chain.Direct.State.InitialState
instance Hydra.Chain.Direct.State.HasKnownUTxO Hydra.Chain.Direct.State.ChainContext
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Chain.Direct.State.ChainContext
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Chain.Direct.State.ChainStateAt
instance Hydra.Chain.ChainState.IsChainState Hydra.Cardano.Api.Tx


-- | A mock implementation of a ledger using very simple UTxO transactions.
--   
--   These transactions have a very simplified representation of unspent
--   transaction outputs being just integers, but already have inputs and
--   outputs. Transactions are validated against the current state of the
--   ledger, so that one transaction could at some point be invalid, then
--   becomes valid because some inputs it consumes are now available.
--   
--   NOTE: There is no notion of time in this ledger, so transactions
--   validation will never depend on the L1 slot.
module Hydra.Ledger.Simple
type SimpleId = Integer

-- | Simple transaction. A transaction is a <a>SimpleId</a>, a list of
--   inputs and a list of outputs, and it has no time validity.
data SimpleTx
SimpleTx :: SimpleId -> UTxOType SimpleTx -> UTxOType SimpleTx -> SimpleTx
[$sel:txSimpleId:SimpleTx] :: SimpleTx -> SimpleId
[$sel:txInputs:SimpleTx] :: SimpleTx -> UTxOType SimpleTx
[$sel:txOutputs:SimpleTx] :: SimpleTx -> UTxOType SimpleTx

-- | A single output of a <a>SimpleTx</a> having an integer identity and
--   sole value.
newtype SimpleTxOut
SimpleTxOut :: Integer -> SimpleTxOut
[$sel:unSimpleTxOut:SimpleTxOut] :: SimpleTxOut -> Integer
newtype SimpleChainState
SimpleChainState :: ChainSlot -> SimpleChainState
[$sel:slot:SimpleChainState] :: SimpleChainState -> ChainSlot
simpleLedger :: Ledger SimpleTx
utxoRef :: Integer -> UTxOType SimpleTx
utxoRefs :: [Integer] -> UTxOType SimpleTx
aValidTx :: Integer -> SimpleTx
instance GHC.Show.Show Hydra.Ledger.Simple.SimpleTx
instance GHC.Generics.Generic Hydra.Ledger.Simple.SimpleTx
instance GHC.Classes.Ord Hydra.Ledger.Simple.SimpleTx
instance GHC.Classes.Eq Hydra.Ledger.Simple.SimpleTx
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Ledger.Simple.SimpleTxOut
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Ledger.Simple.SimpleTxOut
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Ledger.Simple.SimpleTxOut
instance GHC.Num.Num Hydra.Ledger.Simple.SimpleTxOut
instance GHC.Show.Show Hydra.Ledger.Simple.SimpleTxOut
instance GHC.Classes.Ord Hydra.Ledger.Simple.SimpleTxOut
instance GHC.Classes.Eq Hydra.Ledger.Simple.SimpleTxOut
instance GHC.Generics.Generic Hydra.Ledger.Simple.SimpleTxOut
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Ledger.Simple.SimpleChainState
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Ledger.Simple.SimpleChainState
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Ledger.Simple.SimpleChainState
instance GHC.Generics.Generic Hydra.Ledger.Simple.SimpleChainState
instance GHC.Show.Show Hydra.Ledger.Simple.SimpleChainState
instance GHC.Classes.Eq Hydra.Ledger.Simple.SimpleChainState
instance Hydra.Chain.ChainState.IsChainState Hydra.Ledger.Simple.SimpleTx
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Ledger.Simple.SimpleTxOut
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Ledger.Simple.SimpleTxOut
instance Hydra.Tx.IsTx.IsTx Hydra.Ledger.Simple.SimpleTx
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Ledger.Simple.SimpleTx
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Ledger.Simple.SimpleTx
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Ledger.Simple.SimpleTx
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Ledger.Simple.SimpleTx
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Ledger.Simple.SimpleTx


-- | Adapter module to the actual logging framework. All Hydra node
--   components implements <i>Structured logging</i> via
--   <a>contra-tracer</a> generic logging framework. All logs are output in
--   <a>JSON</a>.
module Hydra.Logging
newtype () => Tracer (m :: Type -> Type) a
Tracer :: (a -> m ()) -> Tracer (m :: Type -> Type) a
[runTracer] :: Tracer (m :: Type -> Type) a -> a -> m ()
natTracer :: (forall x. () => m x -> n x) -> Tracer m s -> Tracer n s
nullTracer :: forall (m :: Type -> Type) a. Applicative m => Tracer m a
traceWith :: Tracer m a -> a -> m ()
class () => ToObject a
toObject :: ToObject a => TracingVerbosity -> a -> Object
textTransformer :: ToObject a => a -> Object -> Text
data () => TracingVerbosity
MinimalVerbosity :: TracingVerbosity
NormalVerbosity :: TracingVerbosity
MaximalVerbosity :: TracingVerbosity
data Verbosity
Quiet :: Verbosity
Verbose :: Text -> Verbosity

-- | Provides logging metadata for entries.
data Envelope a
Envelope :: UTCTime -> Int -> Text -> a -> Envelope a
[$sel:timestamp:Envelope] :: Envelope a -> UTCTime
[$sel:threadId:Envelope] :: Envelope a -> Int
[$sel:namespace:Envelope] :: Envelope a -> Text
[$sel:message:Envelope] :: Envelope a -> a

-- | Start logging thread and acquire a <a>Tracer</a>. This tracer will
--   dump all messages on <tt>stdout</tt>, one message per line, formatted
--   as JSON. This tracer is wrapping <tt>msg</tt> into an <a>Envelope</a>
--   with metadata.
withTracer :: forall m msg a. (MonadIO m, MonadFork m, MonadTime m, ToJSON msg) => Verbosity -> (Tracer m msg -> IO a) -> IO a

-- | Start logging thread acquiring a <a>Tracer</a>, outputting JSON
--   formatted messages to some <a>Handle</a>. This tracer is wrapping
--   <tt>msg</tt> into an <a>Envelope</a> with metadata.
withTracerOutputTo :: forall m msg a. (MonadIO m, MonadFork m, MonadTime m, ToJSON msg) => Handle -> Text -> (Tracer m msg -> IO a) -> IO a

-- | Capture logs and output them to stdout when an exception was raised by
--   the given <tt>action</tt>. This tracer is wrapping <tt>msg</tt> into
--   an <a>Envelope</a> with metadata.
showLogsOnFailure :: (MonadSTM m, MonadCatch m, MonadFork m, MonadTime m, MonadSay m, ToJSON msg) => Text -> (Tracer m msg -> m a) -> m a
traceInTVar :: (MonadFork m, MonadTime m, MonadSTM m) => TVar m [Envelope msg] -> Text -> Tracer m msg
contramap :: Contravariant f => (a' -> a) -> f a -> f a'
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Logging.Verbosity
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Logging.Verbosity
instance GHC.Generics.Generic Hydra.Logging.Verbosity
instance GHC.Show.Show Hydra.Logging.Verbosity
instance GHC.Classes.Eq Hydra.Logging.Verbosity
instance GHC.Generics.Generic (Hydra.Logging.Envelope a)
instance GHC.Show.Show a => GHC.Show.Show (Hydra.Logging.Envelope a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hydra.Logging.Envelope a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Logging.Envelope a)
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Logging.Verbosity


-- | Companion tiny-wallet for the direct chain component. This module
--   provide some useful utilities to tracking the wallet's UTXO, and
--   accessing it
module Hydra.Chain.Direct.Wallet
type Address = Addr
type TxIn = TxIn
type TxOut = TxOut LedgerEra

-- | A <a>TinyWallet</a> is a small abstraction of a wallet with basic UTXO
--   management. The wallet is assumed to have only one address, and only
--   one UTXO at that address. It can sign transactions and keeps track of
--   its UTXO behind the scene.
--   
--   The wallet is connecting to the node initially and when asked to
--   <a>$sel:reset:TinyWallet</a>. Otherwise it can be fed blocks via
--   <a>$sel:update:TinyWallet</a> as the chain rolls forward.
data TinyWallet m
TinyWallet :: STM m (Map TxIn TxOut) -> STM m (Maybe TxIn) -> (Tx -> Tx) -> (UTxO -> Tx -> m (Either ErrCoverFee Tx)) -> m () -> (BlockHeader -> [Tx] -> m ()) -> TinyWallet m

-- | Return all known UTxO addressed to this wallet.
[$sel:getUTxO:TinyWallet] :: TinyWallet m -> STM m (Map TxIn TxOut)

-- | Returns the <i>seed input</i> This is the special input needed by
--   <tt>Direct</tt> chain component to initialise a head
[$sel:getSeedInput:TinyWallet] :: TinyWallet m -> STM m (Maybe TxIn)
[$sel:sign:TinyWallet] :: TinyWallet m -> Tx -> Tx
[$sel:coverFee:TinyWallet] :: TinyWallet m -> UTxO -> Tx -> m (Either ErrCoverFee Tx)

-- | Re-initializ wallet against the latest tip of the node and start to
--   ignore <a>$sel:update:TinyWallet</a> calls until reaching that tip.
[$sel:reset:TinyWallet] :: TinyWallet m -> m ()

-- | Update the wallet state given a block and list of txs. May be ignored
--   if wallet is still initializing.
[$sel:update:TinyWallet] :: TinyWallet m -> BlockHeader -> [Tx] -> m ()
data WalletInfoOnChain
WalletInfoOnChain :: Map TxIn TxOut -> SystemStart -> ChainPoint -> WalletInfoOnChain
[$sel:walletUTxO:WalletInfoOnChain] :: WalletInfoOnChain -> Map TxIn TxOut
[$sel:systemStart:WalletInfoOnChain] :: WalletInfoOnChain -> SystemStart

-- | Latest point on chain the wallet knows of.
[$sel:tip:WalletInfoOnChain] :: WalletInfoOnChain -> ChainPoint
type ChainQuery m = QueryPoint -> Address ShelleyAddr -> m WalletInfoOnChain

-- | Create a new tiny wallet handle.
newTinyWallet :: Tracer IO TinyWalletLog -> NetworkId -> (VerificationKey PaymentKey, SigningKey PaymentKey) -> ChainQuery IO -> IO (EpochInfo (Either Text)) -> IO (PParams ConwayEra) -> IO (TinyWallet IO)

-- | Apply a block to our wallet. Does nothing if the transaction does not
--   modify the UTXO set, or else, remove consumed utxos and add produced
--   ones.
--   
--   To determine whether a produced output is ours, we apply the given
--   function checking the output's address.
applyTxs :: [Tx] -> (Address -> Bool) -> Map TxIn TxOut -> Map TxIn TxOut
getTxId :: HashAnnotated (TxBody era) EraIndependentTxBody => AlonzoTx era -> TxId

-- | This are all the error that can happen during coverFee.
data ErrCoverFee
ErrNotEnoughFunds :: ChangeError -> ErrCoverFee
ErrNoFuelUTxOFound :: ErrCoverFee
ErrUnknownInput :: TxIn -> ErrCoverFee
[$sel:input:ErrNotEnoughFunds] :: ErrCoverFee -> TxIn
ErrScriptExecutionFailed :: Text -> Text -> ErrCoverFee
[$sel:redeemerPointer:ErrNotEnoughFunds] :: ErrCoverFee -> Text
[$sel:scriptFailure:ErrNotEnoughFunds] :: ErrCoverFee -> Text
ErrTranslationError :: ContextError LedgerEra -> ErrCoverFee
ErrConwayUpgradeError :: TxUpgradeError ConwayEra -> ErrCoverFee
data ChangeError
ChangeError :: Coin -> Coin -> ChangeError
[$sel:inputBalance:ChangeError] :: ChangeError -> Coin
[$sel:outputBalance:ChangeError] :: ChangeError -> Coin

-- | Cover fee for a transaction body using the given UTXO set. This
--   calculate necessary fees and augments inputs <i> outputs </i>
--   collateral accordingly to cover for the transaction cost and get the
--   change back.
--   
--   XXX: All call sites of this function use cardano-api types
coverFee_ :: forall era. (EraPlutusContext era, EraCertState era, AlonzoEraTx era, ScriptsNeeded era ~ AlonzoScriptsNeeded era, EraUTxO era, BabbageEraTxBody era) => PParams era -> SystemStart -> EpochInfo (Either Text) -> Map TxIn (TxOut era) -> Map TxIn (TxOut era) -> Tx era -> Either ErrCoverFee (Tx era)
findLargestUTxO :: EraTxOut era => Map TxIn (TxOut era) -> Maybe (TxIn, TxOut era)

-- | Estimate cost of script executions on the transaction. This is only an
--   estimates because the transaction isn't sealed at this point and
--   adding new elements to it like change outputs or script integrity hash
--   may increase that cost a little.
estimateScriptsCost :: forall era. (AlonzoEraTx era, EraPlutusContext era, ScriptsNeeded era ~ AlonzoScriptsNeeded era, EraUTxO era) => PParams era -> SystemStart -> EpochInfo (Either Text) -> Map TxIn (TxOut era) -> Tx era -> Either ErrCoverFee (Map (PlutusPurpose AsIx era) ExUnits)
data TinyWalletLog
BeginInitialize :: TinyWalletLog
EndInitialize :: UTxO -> ChainPoint -> TinyWalletLog
[$sel:initialUTxO:BeginInitialize] :: TinyWalletLog -> UTxO
[$sel:tip:BeginInitialize] :: TinyWalletLog -> ChainPoint
BeginUpdate :: ChainPoint -> TinyWalletLog
[$sel:point:BeginInitialize] :: TinyWalletLog -> ChainPoint
EndUpdate :: UTxO -> TinyWalletLog
[$sel:newUTxO:BeginInitialize] :: TinyWalletLog -> UTxO
SkipUpdate :: ChainPoint -> TinyWalletLog
[$sel:point:BeginInitialize] :: TinyWalletLog -> ChainPoint
instance GHC.Show.Show Hydra.Chain.Direct.Wallet.ChangeError
instance GHC.Show.Show Hydra.Chain.Direct.Wallet.ErrCoverFee
instance GHC.Show.Show Hydra.Chain.Direct.Wallet.TinyWalletLog
instance GHC.Generics.Generic Hydra.Chain.Direct.Wallet.TinyWalletLog
instance GHC.Classes.Eq Hydra.Chain.Direct.Wallet.TinyWalletLog
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.Direct.Wallet.TinyWalletLog


-- | Asynchronous messaging interface to the Hydra Network, e.g to other
--   Hydra nodes.
--   
--   Concrete implementations are provided by submodules. Import those
--   instead of this one if interested in actually configuring and running
--   a real network layer.
--   
--   Incoming and outgoing messages are modelled as <tt>Message</tt> data
--   type.
module Hydra.Network

-- | Interface from the application to the network layer.
newtype Network m msg
Network :: (msg -> m ()) -> Network m msg

-- | Send a <tt>msg</tt> to the whole configured hydra network including
--   ourselves.
[$sel:broadcast:Network] :: Network m msg -> msg -> m ()
data Host
Host :: Text -> PortNumber -> Host
[$sel:hostname:Host] :: Host -> Text
[$sel:port:Host] :: Host -> PortNumber
newtype ProtocolVersion
ProtocolVersion :: Natural -> ProtocolVersion

-- | Interface from network layer to the application. XXX: Reliably
--   delivering a message in the crash-recovery fault model is tricky.
--   According to "Introduction to Reliable and Secure Distributed
--   Programming" section "2.2.4 Crashes with recoveries" explains that
--   storing to stable storage and just pointing to stored events is a
--   better way.
data NetworkCallback msg m
NetworkCallback :: (msg -> m ()) -> (Connectivity -> m ()) -> NetworkCallback msg m

-- | The given <tt>msg</tt> was received from the network.
[$sel:deliver:NetworkCallback] :: NetworkCallback msg m -> msg -> m ()

-- | The given <a>Connectivity</a> event was observed by network.
[$sel:onConnectivity:NetworkCallback] :: NetworkCallback msg m -> Connectivity -> m ()

-- | A type tying both inbound and outbound messages sending in a single
--   <i>Component</i>.
--   
--   A <a>NetworkComponent</a> can have different inbound and outbound
--   message types.
type NetworkComponent m inbound outbound a = NetworkCallback inbound m -> (Network m outbound -> m a) -> m a
data Connectivity

-- | Individual peer appeared alive on network.
PeerConnected :: Host -> Connectivity
[$sel:peer:PeerConnected] :: Connectivity -> Host

-- | Individual peer disappeared from network (has not been seen active in
--   a while).
PeerDisconnected :: Host -> Connectivity
[$sel:peer:PeerConnected] :: Connectivity -> Host

-- | Connected to Hydra network.
NetworkConnected :: Connectivity

-- | Disconnected from Hydra network.
NetworkDisconnected :: Connectivity
VersionMismatch :: ProtocolVersion -> Maybe ProtocolVersion -> Connectivity
[$sel:ourVersion:PeerConnected] :: Connectivity -> ProtocolVersion
[$sel:theirVersion:PeerConnected] :: Connectivity -> Maybe ProtocolVersion
ClusterIDMismatch :: Text -> Connectivity
[$sel:clusterPeers:PeerConnected] :: Connectivity -> Text

-- | Configuration for a <tt>Node</tt> network layer.
data NetworkConfiguration
NetworkConfiguration :: FilePath -> SigningKey HydraKey -> [Party] -> Host -> Host -> [Host] -> NodeId -> WhichEtcd -> NetworkConfiguration

-- | Persistence directory
[$sel:persistenceDir:NetworkConfiguration] :: NetworkConfiguration -> FilePath

-- | This node's signing key. This is used to sign messages sent to peers.
[$sel:signingKey:NetworkConfiguration] :: NetworkConfiguration -> SigningKey HydraKey

-- | The list of peers <a>Party</a> known to this node.
[$sel:otherParties:NetworkConfiguration] :: NetworkConfiguration -> [Party]

-- | Address to listen on for incoming connections.
[$sel:listen:NetworkConfiguration] :: NetworkConfiguration -> Host

-- | Address to advertise to peers.
[$sel:advertise:NetworkConfiguration] :: NetworkConfiguration -> Host

-- | Addresses and ports of remote peers.
[$sel:peers:NetworkConfiguration] :: NetworkConfiguration -> [Host]

-- | This node's id.
[$sel:nodeId:NetworkConfiguration] :: NetworkConfiguration -> NodeId

-- | Whether to use the system etcd (on the path) or the embedded one.
[$sel:whichEtcd:NetworkConfiguration] :: NetworkConfiguration -> WhichEtcd
data WhichEtcd
EmbeddedEtcd :: WhichEtcd
SystemEtcd :: WhichEtcd
newtype NodeId
NodeId :: Text -> NodeId
[$sel:nodeId:NodeId] :: NodeId -> Text
readHost :: MonadFail m => String -> m Host
readPort :: MonadFail m => String -> m PortNumber
showHost :: Host -> String
data () => IP
data () => PortNumber
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Network.WhichEtcd
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Network.WhichEtcd
instance GHC.Generics.Generic Hydra.Network.WhichEtcd
instance GHC.Show.Show Hydra.Network.WhichEtcd
instance GHC.Classes.Eq Hydra.Network.WhichEtcd
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Network.NodeId
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Network.NodeId
instance GHC.Classes.Ord Hydra.Network.NodeId
instance GHC.Read.Read Hydra.Network.NodeId
instance Data.String.IsString Hydra.Network.NodeId
instance GHC.Show.Show Hydra.Network.NodeId
instance GHC.Classes.Eq Hydra.Network.NodeId
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Network.Host
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Network.Host
instance GHC.Classes.Eq Hydra.Network.Host
instance GHC.Generics.Generic Hydra.Network.Host
instance GHC.Classes.Ord Hydra.Network.Host
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Network.ProtocolVersion
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Network.ProtocolVersion
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Network.ProtocolVersion
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Network.ProtocolVersion
instance GHC.Classes.Ord Hydra.Network.ProtocolVersion
instance GHC.Generics.Generic Hydra.Network.ProtocolVersion
instance GHC.Show.Show Hydra.Network.ProtocolVersion
instance GHC.Classes.Eq Hydra.Network.ProtocolVersion
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Network.Connectivity
instance GHC.Show.Show Hydra.Network.Connectivity
instance GHC.Classes.Eq Hydra.Network.Connectivity
instance GHC.Generics.Generic Hydra.Network.Connectivity
instance Data.Aeson.Types.ToJSON.ToJSON Data.IP.Addr.IP
instance Data.Aeson.Types.FromJSON.FromJSON Data.IP.Addr.IP
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Network.Connectivity
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Network.ProtocolVersion
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Network.Host
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Network.Host
instance GHC.Show.Show Hydra.Network.Host
instance GHC.Read.Read Hydra.Network.Host
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Network.Host
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Network.NodeId
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Network.WhichEtcd
instance Data.Aeson.Types.ToJSON.ToJSON Network.Socket.Types.PortNumber
instance Data.Aeson.Types.FromJSON.FromJSON Network.Socket.Types.PortNumber
instance Test.QuickCheck.Arbitrary.Arbitrary Network.Socket.Types.PortNumber

module Hydra.API.APIServerLog
data APIServerLog
APIServerStarted :: PortNumber -> APIServerLog
[$sel:listeningPort:APIServerStarted] :: APIServerLog -> PortNumber
NewAPIConnection :: APIServerLog
APIOutputSent :: Value -> APIServerLog
[$sel:sentOutput:APIServerStarted] :: APIServerLog -> Value
APIInputReceived :: Value -> APIServerLog
[$sel:receivedInput:APIServerStarted] :: APIServerLog -> Value
APIInvalidInput :: String -> Text -> APIServerLog
[$sel:reason:APIServerStarted] :: APIServerLog -> String
[$sel:inputReceived:APIServerStarted] :: APIServerLog -> Text
APIConnectionError :: String -> APIServerLog
[$sel:reason:APIServerStarted] :: APIServerLog -> String
APIHTTPRequestReceived :: Method -> PathInfo -> APIServerLog
[$sel:method:APIServerStarted] :: APIServerLog -> Method
[$sel:path:APIServerStarted] :: APIServerLog -> PathInfo
APITransactionSubmitted :: String -> APIServerLog
[$sel:submittedTxId:APIServerStarted] :: APIServerLog -> String

-- | New type wrapper to define JSON instances.
newtype PathInfo
PathInfo :: ByteString -> PathInfo

-- | New type wrapper to define JSON instances.
--   
--   NOTE: We are not using http-types <tt>StdMethod</tt> as we do not want
--   to be constrained in terms of logging and accept any method in a
--   <tt>Request</tt>.
newtype Method
Method :: ByteString -> Method
instance GHC.Show.Show Hydra.API.APIServerLog.PathInfo
instance GHC.Classes.Eq Hydra.API.APIServerLog.PathInfo
instance GHC.Show.Show Hydra.API.APIServerLog.Method
instance GHC.Classes.Eq Hydra.API.APIServerLog.Method
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.API.APIServerLog.APIServerLog
instance GHC.Generics.Generic Hydra.API.APIServerLog.APIServerLog
instance GHC.Show.Show Hydra.API.APIServerLog.APIServerLog
instance GHC.Classes.Eq Hydra.API.APIServerLog.APIServerLog
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.API.APIServerLog.Method
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.API.APIServerLog.PathInfo


-- | A <a>NetworkComponent</a> that handles authentication of sent and
--   received messages.
--   
--   This "middleware" uses <a>HydraKey</a> keys for signing own messages
--   and verifying others', providing <a>Authenticated</a> messages to
--   consumers.
module Hydra.Network.Authenticate

-- | Represents a signed message over the network. Becomes valid once its
--   receivers verify it against its other peers verification keys.
--   Messages are signed and turned into authenticated messages before
--   broadcasting them to other peers.
data Signed msg
Signed :: msg -> Signature msg -> Party -> Signed msg
[$sel:payload:Signed] :: Signed msg -> msg
[$sel:signature:Signed] :: Signed msg -> Signature msg
[$sel:party:Signed] :: Signed msg -> Party
data Authenticated msg
Authenticated :: msg -> Party -> Authenticated msg
[$sel:payload:Authenticated] :: Authenticated msg -> msg
[$sel:party:Authenticated] :: Authenticated msg -> Party

-- | Middleware used to sign messages before broadcasting them to other
--   peers and verify signed messages upon receiving. Only verified
--   messages are pushed downstream to the internal network for the node to
--   consume and process. Non-verified messages get discarded.
withAuthentication :: (SignableRepresentation inbound, ToJSON inbound, SignableRepresentation outbound) => Tracer m AuthLog -> SigningKey HydraKey -> [Party] -> NetworkComponent m (Signed inbound) (Signed outbound) a -> NetworkComponent m (Authenticated inbound) outbound a

-- | Smart constructor for <a>MessageDropped</a>
mkAuthLog :: (ToJSON msg, Show signature) => msg -> signature -> Party -> AuthLog
data AuthLog
MessageDropped :: Text -> Text -> Party -> AuthLog
[$sel:message:MessageDropped] :: AuthLog -> Text
[$sel:signature:MessageDropped] :: AuthLog -> Text
[$sel:party:MessageDropped] :: AuthLog -> Party
instance GHC.Generics.Generic (Hydra.Network.Authenticate.Signed msg)
instance GHC.Show.Show msg => GHC.Show.Show (Hydra.Network.Authenticate.Signed msg)
instance GHC.Classes.Eq msg => GHC.Classes.Eq (Hydra.Network.Authenticate.Signed msg)
instance GHC.Generics.Generic (Hydra.Network.Authenticate.Authenticated msg)
instance GHC.Show.Show msg => GHC.Show.Show (Hydra.Network.Authenticate.Authenticated msg)
instance GHC.Classes.Eq msg => GHC.Classes.Eq (Hydra.Network.Authenticate.Authenticated msg)
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Network.Authenticate.AuthLog
instance GHC.Generics.Generic Hydra.Network.Authenticate.AuthLog
instance GHC.Show.Show Hydra.Network.Authenticate.AuthLog
instance GHC.Classes.Eq Hydra.Network.Authenticate.AuthLog
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Network.Authenticate.AuthLog
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Network.Authenticate.AuthLog
instance (Test.QuickCheck.Arbitrary.Arbitrary msg, Cardano.Crypto.Util.SignableRepresentation msg) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Network.Authenticate.Signed msg)
instance Cardano.Binary.ToCBOR.ToCBOR msg => Cardano.Binary.ToCBOR.ToCBOR (Hydra.Network.Authenticate.Signed msg)
instance Cardano.Binary.FromCBOR.FromCBOR msg => Cardano.Binary.FromCBOR.FromCBOR (Hydra.Network.Authenticate.Signed msg)

module Hydra.Network.Message
data NetworkEvent msg
ConnectivityEvent :: Connectivity -> NetworkEvent msg
ReceivedMessage :: Party -> msg -> NetworkEvent msg
[$sel:sender:ConnectivityEvent] :: NetworkEvent msg -> Party
[$sel:msg:ConnectivityEvent] :: NetworkEvent msg -> msg
data Message tx
ReqTx :: tx -> Message tx
[$sel:transaction:ReqTx] :: Message tx -> tx
ReqSn :: SnapshotVersion -> SnapshotNumber -> [TxIdType tx] -> Maybe tx -> Maybe (TxIdType tx) -> Message tx
[$sel:snapshotVersion:ReqTx] :: Message tx -> SnapshotVersion
[$sel:snapshotNumber:ReqTx] :: Message tx -> SnapshotNumber
[$sel:transactionIds:ReqTx] :: Message tx -> [TxIdType tx]
[$sel:decommitTx:ReqTx] :: Message tx -> Maybe tx
[$sel:depositTxId:ReqTx] :: Message tx -> Maybe (TxIdType tx)
AckSn :: Signature (Snapshot tx) -> SnapshotNumber -> Message tx
[$sel:signed:ReqTx] :: Message tx -> Signature (Snapshot tx)
[$sel:snapshotNumber:ReqTx] :: Message tx -> SnapshotNumber
ReqDec :: tx -> Message tx
[$sel:transaction:ReqTx] :: Message tx -> tx
instance Data.Aeson.Types.ToJSON.ToJSON msg => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Network.Message.NetworkEvent msg)
instance GHC.Generics.Generic (Hydra.Network.Message.NetworkEvent msg)
instance GHC.Show.Show msg => GHC.Show.Show (Hydra.Network.Message.NetworkEvent msg)
instance GHC.Classes.Eq msg => GHC.Classes.Eq (Hydra.Network.Message.NetworkEvent msg)
instance GHC.Generics.Generic (Hydra.Network.Message.Message tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Classes.Eq (Hydra.Network.Message.Message tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Show.Show (Hydra.Network.Message.Message tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Network.Message.Message tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.Network.Message.Message tx)
instance Hydra.Tx.IsTx.ArbitraryIsTx tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Network.Message.Message tx)
instance Hydra.Tx.IsTx.ArbitraryIsTx tx => Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary (Hydra.Network.Message.Message tx)
instance (Cardano.Binary.ToCBOR.ToCBOR tx, Cardano.Binary.ToCBOR.ToCBOR (Hydra.Tx.IsTx.UTxOType tx), Cardano.Binary.ToCBOR.ToCBOR (Hydra.Tx.IsTx.TxIdType tx)) => Cardano.Binary.ToCBOR.ToCBOR (Hydra.Network.Message.Message tx)
instance (Cardano.Binary.FromCBOR.FromCBOR tx, Cardano.Binary.FromCBOR.FromCBOR (Hydra.Tx.IsTx.UTxOType tx), Cardano.Binary.FromCBOR.FromCBOR (Hydra.Tx.IsTx.TxIdType tx)) => Cardano.Binary.FromCBOR.FromCBOR (Hydra.Network.Message.Message tx)
instance Hydra.Tx.IsTx.IsTx tx => Cardano.Crypto.Util.SignableRepresentation (Hydra.Network.Message.Message tx)
instance Test.QuickCheck.Arbitrary.Arbitrary msg => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Network.Message.NetworkEvent msg)

module Hydra.HeadLogic.Input
type TTL = Natural

-- | Inputs that are processed by the head logic (the "core").
--   Corresponding to each of the "shell" layers, we distinguish between
--   inputs from the client, the network and the chain.
data Input tx

-- | Input received from clients via the <a>Hydra.API</a>.
ClientInput :: ClientInput tx -> Input tx
[$sel:clientInput:ClientInput] :: Input tx -> ClientInput tx

-- | Input received from peers via a <a>Hydra.Network</a>.
--   
--   <ul>
--   <li><a>$sel:ttl:ClientInput</a> is a simple counter that's decreased
--   every time the event is reenqueued due to a wait. It's default value
--   is <tt>defaultTTL</tt></li>
--   </ul>
NetworkInput :: TTL -> NetworkEvent (Message tx) -> Input tx
[$sel:ttl:ClientInput] :: Input tx -> TTL
[$sel:networkEvent:ClientInput] :: Input tx -> NetworkEvent (Message tx)

-- | Input received from the chain via a <a>Hydra.Chain</a>.
ChainInput :: ChainEvent tx -> Input tx
[$sel:chainEvent:ClientInput] :: Input tx -> ChainEvent tx
instance GHC.Generics.Generic (Hydra.HeadLogic.Input.Input tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Classes.Eq (Hydra.HeadLogic.Input.Input tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Show.Show (Hydra.HeadLogic.Input.Input tx)
instance Hydra.Chain.ChainState.IsChainState tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Input.Input tx)
instance (Hydra.Tx.IsTx.ArbitraryIsTx tx, Hydra.Chain.ChainState.IsChainState tx) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.Input.Input tx)


-- | Error types used in the Hydra.HeadLogic module.
module Hydra.HeadLogic.Error
data LogicError tx
UnhandledInput :: Input tx -> HeadState tx -> LogicError tx
[$sel:input:UnhandledInput] :: LogicError tx -> Input tx
[$sel:currentHeadState:UnhandledInput] :: LogicError tx -> HeadState tx
RequireFailed :: RequirementFailure tx -> LogicError tx
[$sel:requirementFailure:UnhandledInput] :: LogicError tx -> RequirementFailure tx
AssertionFailed :: Text -> LogicError tx
[$sel:message:UnhandledInput] :: LogicError tx -> Text
NotOurHead :: HeadId -> HeadId -> LogicError tx
[$sel:ourHeadId:UnhandledInput] :: LogicError tx -> HeadId
[$sel:otherHeadId:UnhandledInput] :: LogicError tx -> HeadId
SideLoadSnapshotFailed :: SideLoadRequirementFailure tx -> LogicError tx
[$sel:sideLoadRequirementFailure:UnhandledInput] :: LogicError tx -> SideLoadRequirementFailure tx
data RequirementFailure tx
ReqSnNumberInvalid :: SnapshotNumber -> SnapshotNumber -> RequirementFailure tx
[$sel:requestedSn:ReqSnNumberInvalid] :: RequirementFailure tx -> SnapshotNumber
[$sel:lastSeenSn:ReqSnNumberInvalid] :: RequirementFailure tx -> SnapshotNumber
ReqSvNumberInvalid :: SnapshotVersion -> SnapshotVersion -> RequirementFailure tx
[$sel:requestedSv:ReqSnNumberInvalid] :: RequirementFailure tx -> SnapshotVersion
[$sel:lastSeenSv:ReqSnNumberInvalid] :: RequirementFailure tx -> SnapshotVersion
ReqSnNotLeader :: SnapshotNumber -> Party -> RequirementFailure tx
[$sel:requestedSn:ReqSnNumberInvalid] :: RequirementFailure tx -> SnapshotNumber
[$sel:leader:ReqSnNumberInvalid] :: RequirementFailure tx -> Party
ReqSnDecommitNotSettled :: RequirementFailure tx
ReqSnCommitNotSettled :: RequirementFailure tx
InvalidMultisignature :: Text -> [VerificationKey HydraKey] -> RequirementFailure tx
[$sel:multisig:ReqSnNumberInvalid] :: RequirementFailure tx -> Text
[$sel:vkeys:ReqSnNumberInvalid] :: RequirementFailure tx -> [VerificationKey HydraKey]
SnapshotAlreadySigned :: [Party] -> Party -> RequirementFailure tx
[$sel:knownSignatures:ReqSnNumberInvalid] :: RequirementFailure tx -> [Party]
[$sel:receivedSignature:ReqSnNumberInvalid] :: RequirementFailure tx -> Party
AckSnNumberInvalid :: SnapshotNumber -> SnapshotNumber -> RequirementFailure tx
[$sel:requestedSn:ReqSnNumberInvalid] :: RequirementFailure tx -> SnapshotNumber
[$sel:lastSeenSn:ReqSnNumberInvalid] :: RequirementFailure tx -> SnapshotNumber
SnapshotDoesNotApply :: SnapshotNumber -> TxIdType tx -> ValidationError -> RequirementFailure tx
[$sel:requestedSn:ReqSnNumberInvalid] :: RequirementFailure tx -> SnapshotNumber
[$sel:txid:ReqSnNumberInvalid] :: RequirementFailure tx -> TxIdType tx
[$sel:error:ReqSnNumberInvalid] :: RequirementFailure tx -> ValidationError
NoMatchingDeposit :: RequirementFailure tx
RequestedDepositExpired :: TxIdType tx -> RequirementFailure tx
[$sel:depositTxId:ReqSnNumberInvalid] :: RequirementFailure tx -> TxIdType tx
data SideLoadRequirementFailure tx
SideLoadInitialSnapshotMismatch :: SideLoadRequirementFailure tx
SideLoadSnNumberInvalid :: SnapshotNumber -> SnapshotNumber -> SideLoadRequirementFailure tx
[$sel:requestedSn:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> SnapshotNumber
[$sel:lastSeenSn:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> SnapshotNumber
SideLoadSvNumberInvalid :: SnapshotVersion -> SnapshotVersion -> SideLoadRequirementFailure tx
[$sel:requestedSv:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> SnapshotVersion
[$sel:lastSeenSv:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> SnapshotVersion
SideLoadUTxOToCommitInvalid :: Maybe (UTxOType tx) -> Maybe (UTxOType tx) -> SideLoadRequirementFailure tx
[$sel:requestedSc:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> Maybe (UTxOType tx)
[$sel:lastSeenSc:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> Maybe (UTxOType tx)
SideLoadUTxOToDecommitInvalid :: Maybe (UTxOType tx) -> Maybe (UTxOType tx) -> SideLoadRequirementFailure tx
[$sel:requestedSd:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> Maybe (UTxOType tx)
[$sel:lastSeenSd:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> Maybe (UTxOType tx)
SideLoadInvalidMultisignature :: Text -> [VerificationKey HydraKey] -> SideLoadRequirementFailure tx
[$sel:multisig:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> Text
[$sel:vkeys:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> [VerificationKey HydraKey]
instance GHC.Generics.Generic (Hydra.HeadLogic.Error.RequirementFailure tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.Error.SideLoadRequirementFailure tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.Error.LogicError tx)
instance (GHC.Classes.Eq (Hydra.HeadLogic.State.HeadState tx), GHC.Classes.Eq (Hydra.HeadLogic.Input.Input tx), GHC.Classes.Eq (Hydra.HeadLogic.Error.RequirementFailure tx), GHC.Classes.Eq (Hydra.HeadLogic.Error.SideLoadRequirementFailure tx)) => GHC.Classes.Eq (Hydra.HeadLogic.Error.LogicError tx)
instance (GHC.Show.Show (Hydra.HeadLogic.State.HeadState tx), GHC.Show.Show (Hydra.HeadLogic.Input.Input tx), GHC.Show.Show (Hydra.HeadLogic.Error.RequirementFailure tx), GHC.Show.Show (Hydra.HeadLogic.Error.SideLoadRequirementFailure tx)) => GHC.Show.Show (Hydra.HeadLogic.Error.LogicError tx)
instance (Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.State.HeadState tx), Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Input.Input tx), Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Error.RequirementFailure tx), Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Error.SideLoadRequirementFailure tx)) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Error.LogicError tx)
instance GHC.Classes.Eq (Hydra.Tx.IsTx.TxIdType tx) => GHC.Classes.Eq (Hydra.HeadLogic.Error.RequirementFailure tx)
instance GHC.Show.Show (Hydra.Tx.IsTx.TxIdType tx) => GHC.Show.Show (Hydra.HeadLogic.Error.RequirementFailure tx)
instance Data.Aeson.Types.ToJSON.ToJSON (Hydra.Tx.IsTx.TxIdType tx) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Error.RequirementFailure tx)
instance GHC.Classes.Eq (Hydra.Tx.IsTx.UTxOType tx) => GHC.Classes.Eq (Hydra.HeadLogic.Error.SideLoadRequirementFailure tx)
instance GHC.Show.Show (Hydra.Tx.IsTx.UTxOType tx) => GHC.Show.Show (Hydra.HeadLogic.Error.SideLoadRequirementFailure tx)
instance Data.Aeson.Types.ToJSON.ToJSON (Hydra.Tx.IsTx.UTxOType tx) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Error.SideLoadRequirementFailure tx)

module Hydra.Node.ApiTransactionTimeout

-- | A new type wrapped period of time to be used in API transaction
--   timeout.
newtype ApiTransactionTimeout
ApiTransactionTimeout :: NominalDiffTime -> ApiTransactionTimeout
[$sel:apiTransactionTimeoutNominalDiffTime:ApiTransactionTimeout] :: ApiTransactionTimeout -> NominalDiffTime
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Node.ApiTransactionTimeout.ApiTransactionTimeout
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Node.ApiTransactionTimeout.ApiTransactionTimeout
instance GHC.Real.Real Hydra.Node.ApiTransactionTimeout.ApiTransactionTimeout
instance GHC.Enum.Enum Hydra.Node.ApiTransactionTimeout.ApiTransactionTimeout
instance GHC.Num.Num Hydra.Node.ApiTransactionTimeout.ApiTransactionTimeout
instance GHC.Read.Read Hydra.Node.ApiTransactionTimeout.ApiTransactionTimeout
instance GHC.Show.Show Hydra.Node.ApiTransactionTimeout.ApiTransactionTimeout
instance GHC.Classes.Ord Hydra.Node.ApiTransactionTimeout.ApiTransactionTimeout
instance GHC.Classes.Eq Hydra.Node.ApiTransactionTimeout.ApiTransactionTimeout
instance GHC.Real.Integral Hydra.Node.ApiTransactionTimeout.ApiTransactionTimeout
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Node.ApiTransactionTimeout.ApiTransactionTimeout

module Hydra.Node.DepositPeriod

-- | A new type wrapped period of time to be used in deposit validity.
newtype DepositPeriod
DepositPeriod :: NominalDiffTime -> DepositPeriod
[$sel:toNominalDiffTime:DepositPeriod] :: DepositPeriod -> NominalDiffTime
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Node.DepositPeriod.DepositPeriod
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Node.DepositPeriod.DepositPeriod
instance GHC.Real.Real Hydra.Node.DepositPeriod.DepositPeriod
instance GHC.Enum.Enum Hydra.Node.DepositPeriod.DepositPeriod
instance GHC.Num.Num Hydra.Node.DepositPeriod.DepositPeriod
instance GHC.Read.Read Hydra.Node.DepositPeriod.DepositPeriod
instance GHC.Show.Show Hydra.Node.DepositPeriod.DepositPeriod
instance GHC.Classes.Ord Hydra.Node.DepositPeriod.DepositPeriod
instance GHC.Classes.Eq Hydra.Node.DepositPeriod.DepositPeriod
instance GHC.Real.Integral Hydra.Node.DepositPeriod.DepositPeriod
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Node.DepositPeriod.DepositPeriod


-- | Template haskell expression to embed executables.
module Hydra.Node.EmbedTH

-- | Template haskell expression to find and embed an executable with given
--   name.
embedExecutable :: String -> Q Exp


-- | Implements a Hydra network component using <a>etcd</a>.
--   
--   While implementing a basic broadcast protocol over a distributed
--   key-value store is quite an overkill, the <a>Raft</a> consensus of
--   etcd provides our application with a crash-recovery fault-tolerant
--   "atomic broadcast" out-of-the-box. As a nice side-effect, the network
--   layer becomes very introspectable, while it would also support
--   features like TLS or service discovery.
--   
--   The component installs, starts and configures an
--   <a>$sel:etcd:EtcdLog</a> instance and connects to it using a GRPC
--   client. We can only write and read from the cluster while connected to
--   the majority cluster.
--   
--   Broadcasting is implemented using <tt>put</tt> to some well-known key,
--   while message delivery is done by using <tt>watch</tt> on the same
--   <tt>msg</tt> prefix. We keep a last known revision, also stored on
--   disk, to start <tt>watch</tt> with that revision (+1) and only deliver
--   messages that were not seen before. In case we are not connected to
--   our <a>$sel:etcd:EtcdLog</a> instance or not enough peers (= on a
--   minority cluster), we retry sending, but also store messages to
--   broadcast in a <a>PersistentQueue</a>, which makes the node resilient
--   against crashes while sending. TODO: Is this needed? performance
--   limitation?
--   
--   Connectivity and compatibility with other nodes on the cluster is
--   tracked using the key-value service as well:
--   
--   <ul>
--   <li>network connectivity is determined by being able to fetch the
--   member list</li>
--   <li>peer connectivity is tracked (best effort, not authorized) using
--   an entry at 'alive-&lt;advertise&gt;' keys with individual leases and
--   repeated keep-alives</li>
--   <li>each node compare-and-swaps its <a>$sel:version:EtcdLog</a> into a
--   key of the same name to check compatibility (not updatable)</li>
--   </ul>
--   
--   Note that the etcd cluster is configured to compact revisions down to
--   1000 every 5 minutes. This prevents infinite growth of the key-value
--   store, but also limits how long a node can be disconnected without
--   missing out. 1000 should be more than enough for our use-case as the
--   Hydra protocol will not advance unless all participants are present.
module Hydra.Network.Etcd

-- | Concrete network component that broadcasts messages to an etcd cluster
--   and listens for incoming messages.
withEtcdNetwork :: (ToCBOR msg, FromCBOR msg, Eq msg) => Tracer IO EtcdLog -> ProtocolVersion -> NetworkConfiguration -> NetworkComponent IO msg msg ()

-- | Return the path of the etcd binary. Will either install it first, or
--   just assume there is one available on the system path.
getEtcdBinary :: FilePath -> WhichEtcd -> IO FilePath

-- | Install the embedded <a>$sel:etcd:EtcdLog</a> binary to given file
--   path.
installEtcd :: FilePath -> IO ()

-- | Check and write version on etcd cluster. This will retry until we are
--   on a majority cluster and succeed. If the version does not match a
--   corresponding <a>Connectivity</a> message is sent via
--   <a>NetworkCallback</a>.
checkVersion :: Tracer IO EtcdLog -> Connection -> ProtocolVersion -> NetworkCallback msg IO -> IO ()

-- | Broadcast messages from a queue to the etcd cluster.
--   
--   TODO: retrying on failure even needed? Retries on failure to
--   <a>putMessage</a> in case we are on a minority cluster.
broadcastMessages :: (ToCBOR msg, Eq msg) => Tracer IO EtcdLog -> Connection -> Host -> PersistentQueue IO msg -> IO ()

-- | Broadcast a message to the etcd cluster.
putMessage :: ToCBOR msg => Connection -> Host -> msg -> IO ()

-- | Fetch and wait for messages from the etcd cluster.
waitMessages :: FromCBOR msg => Tracer IO EtcdLog -> Connection -> FilePath -> NetworkCallback msg IO -> IO ()
getLastKnownRevision :: MonadIO m => FilePath -> m Natural
putLastKnownRevision :: MonadIO m => FilePath -> Natural -> m ()

-- | Write a well-known key to indicate being alive, keep it alive using a
--   lease and poll other peers entries to yield connectivity events. While
--   doing so, overall network connectivity is determined from the ability
--   to read/write to the cluster.
pollConnectivity :: Tracer IO EtcdLog -> Connection -> Host -> NetworkCallback msg IO -> IO ()

-- | Add context to the <a>grpcErrorMessage</a> of any <a>GrpcException</a>
--   raised.
withGrpcContext :: MonadCatch m => Text -> m a -> m a

-- | Like <tt>withProcessTerm</tt>, but sends first SIGINT and only SIGTERM
--   if not stopped within 5 seconds.
withProcessInterrupt :: (MonadIO m, MonadThrow m) => ProcessConfig stdin stdout stderr -> (Process stdin stdout stderr -> m a) -> m a
data PersistentQueue m a
PersistentQueue :: TBQueue m (Natural, a) -> TVar m Natural -> FilePath -> PersistentQueue m a
[$sel:queue:PersistentQueue] :: PersistentQueue m a -> TBQueue m (Natural, a)
[$sel:nextIx:PersistentQueue] :: PersistentQueue m a -> TVar m Natural
[$sel:directory:PersistentQueue] :: PersistentQueue m a -> FilePath

-- | Create a new persistent queue at file path and given capacity.
newPersistentQueue :: (MonadSTM m, MonadIO m, FromCBOR a, MonadCatch m, MonadFail m) => FilePath -> Natural -> m (PersistentQueue m a)

-- | Write a value to the queue, blocking if the queue is full.
writePersistentQueue :: (ToCBOR a, MonadSTM m, MonadIO m) => PersistentQueue m a -> a -> m ()

-- | Get the next value from the queue without removing it, blocking if the
--   queue is empty.
peekPersistentQueue :: MonadSTM m => PersistentQueue m a -> m a

-- | Remove an element from the queue if it matches the given item. Use
--   <a>peekPersistentQueue</a> to wait for next items before popping it.
popPersistentQueue :: (MonadSTM m, MonadIO m, Eq a) => PersistentQueue m a -> a -> m ()
data EtcdLog
EtcdLog :: Value -> EtcdLog
[$sel:etcd:EtcdLog] :: EtcdLog -> Value
Reconnecting :: EtcdLog
BroadcastFailed :: Text -> EtcdLog
[$sel:reason:EtcdLog] :: EtcdLog -> Text
FailedToDecodeLog :: Text -> Text -> EtcdLog
[$sel:log:EtcdLog] :: EtcdLog -> Text
[$sel:reason:EtcdLog] :: EtcdLog -> Text
FailedToDecodeValue :: Text -> Text -> Text -> EtcdLog
[$sel:key:EtcdLog] :: EtcdLog -> Text
[$sel:value:EtcdLog] :: EtcdLog -> Text
[$sel:reason:EtcdLog] :: EtcdLog -> Text
CreatedLease :: Int64 -> EtcdLog
[$sel:leaseId:EtcdLog] :: EtcdLog -> Int64
LowLeaseTTL :: DiffTime -> EtcdLog
[$sel:ttlRemaining:EtcdLog] :: EtcdLog -> DiffTime
NoKeepAliveResponse :: EtcdLog
MatchingProtocolVersion :: ProtocolVersion -> EtcdLog
[$sel:version:EtcdLog] :: EtcdLog -> ProtocolVersion
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Network.Etcd.EtcdLog
instance GHC.Generics.Generic Hydra.Network.Etcd.EtcdLog
instance GHC.Show.Show Hydra.Network.Etcd.EtcdLog
instance GHC.Classes.Eq Hydra.Network.Etcd.EtcdLog

module Hydra.Node.Environment
data Environment
Environment :: Party -> SigningKey HydraKey -> [Party] -> [OnChainId] -> ContestationPeriod -> DepositPeriod -> Text -> Environment

-- | This is the p_i from the paper
[$sel:party:Environment] :: Environment -> Party
[$sel:signingKey:Environment] :: Environment -> SigningKey HydraKey
[$sel:otherParties:Environment] :: Environment -> [Party]
[$sel:participants:Environment] :: Environment -> [OnChainId]
[$sel:contestationPeriod:Environment] :: Environment -> ContestationPeriod
[$sel:depositPeriod:Environment] :: Environment -> DepositPeriod

-- | Configured peers for the network layer, used for comparison on etcd
--   errors.
[$sel:configuredPeers:Environment] :: Environment -> Text

-- | Make <a>HeadParameters</a> that are consistent with the given
--   <a>Environment</a>.
mkHeadParameters :: Environment -> HeadParameters
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Node.Environment.Environment
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Node.Environment.Environment
instance GHC.Classes.Eq Hydra.Node.Environment.Environment
instance GHC.Show.Show Hydra.Node.Environment.Environment
instance GHC.Generics.Generic Hydra.Node.Environment.Environment
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Node.Environment.Environment
instance Hydra.Tx.Party.HasParty Hydra.Node.Environment.Environment

module Hydra.API.ServerOutput

-- | The type of messages sent to clients by the <a>Server</a>.
data TimedServerOutput tx
TimedServerOutput :: ServerOutput tx -> Natural -> UTCTime -> TimedServerOutput tx
[$sel:output:TimedServerOutput] :: TimedServerOutput tx -> ServerOutput tx
[$sel:seq:TimedServerOutput] :: TimedServerOutput tx -> Natural
[$sel:time:TimedServerOutput] :: TimedServerOutput tx -> UTCTime
data DecommitInvalidReason tx
DecommitTxInvalid :: UTxOType tx -> ValidationError -> DecommitInvalidReason tx
[$sel:localUTxO:DecommitTxInvalid] :: DecommitInvalidReason tx -> UTxOType tx
[$sel:validationError:DecommitTxInvalid] :: DecommitInvalidReason tx -> ValidationError
DecommitAlreadyInFlight :: TxIdType tx -> DecommitInvalidReason tx
[$sel:otherDecommitTxId:DecommitTxInvalid] :: DecommitInvalidReason tx -> TxIdType tx

-- | Individual messages as produced by the <a>HeadLogic</a> in the
--   <tt>ClientEffect</tt>.
data ClientMessage tx
CommandFailed :: ClientInput tx -> HeadState tx -> ClientMessage tx
[$sel:clientInput:CommandFailed] :: ClientMessage tx -> ClientInput tx
[$sel:state:CommandFailed] :: ClientMessage tx -> HeadState tx
PostTxOnChainFailed :: PostChainTx tx -> PostTxError tx -> ClientMessage tx
[$sel:postChainTx:CommandFailed] :: ClientMessage tx -> PostChainTx tx
[$sel:postTxError:CommandFailed] :: ClientMessage tx -> PostTxError tx

-- | A friendly welcome message which tells a client something about the
--   node. Currently used for knowing what signing key the server uses (it
--   only knows one), <a>HeadStatus</a> and optionally (if
--   <a>HeadIsOpen</a> or <a>SnapshotConfirmed</a> message is emitted)
--   UTxO's present in the Hydra Head.
data Greetings tx
Greetings :: Party -> HeadStatus -> Maybe HeadId -> Maybe (UTxOType tx) -> String -> Environment -> Greetings tx
[$sel:me:Greetings] :: Greetings tx -> Party
[$sel:headStatus:Greetings] :: Greetings tx -> HeadStatus
[$sel:hydraHeadId:Greetings] :: Greetings tx -> Maybe HeadId
[$sel:snapshotUtxo:Greetings] :: Greetings tx -> Maybe (UTxOType tx)
[$sel:hydraNodeVersion:Greetings] :: Greetings tx -> String
[$sel:env:Greetings] :: Greetings tx -> Environment
data InvalidInput
InvalidInput :: String -> Text -> InvalidInput
[$sel:reason:InvalidInput] :: InvalidInput -> String
[$sel:input:InvalidInput] :: InvalidInput -> Text
data ServerOutput tx
NetworkConnected :: ServerOutput tx
NetworkDisconnected :: ServerOutput tx
NetworkVersionMismatch :: ProtocolVersion -> Maybe ProtocolVersion -> ServerOutput tx
[$sel:ourVersion:NetworkConnected] :: ServerOutput tx -> ProtocolVersion
[$sel:theirVersion:NetworkConnected] :: ServerOutput tx -> Maybe ProtocolVersion
NetworkClusterIDMismatch :: Text -> Text -> ServerOutput tx
[$sel:clusterPeers:NetworkConnected] :: ServerOutput tx -> Text
[$sel:misconfiguredPeers:NetworkConnected] :: ServerOutput tx -> Text
PeerConnected :: Host -> ServerOutput tx
[$sel:peer:NetworkConnected] :: ServerOutput tx -> Host
PeerDisconnected :: Host -> ServerOutput tx
[$sel:peer:NetworkConnected] :: ServerOutput tx -> Host
HeadIsInitializing :: HeadId -> [Party] -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:parties:NetworkConnected] :: ServerOutput tx -> [Party]
Committed :: HeadId -> Party -> UTxOType tx -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:party:NetworkConnected] :: ServerOutput tx -> Party
[$sel:utxo:NetworkConnected] :: ServerOutput tx -> UTxOType tx
HeadIsOpen :: HeadId -> UTxOType tx -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:utxo:NetworkConnected] :: ServerOutput tx -> UTxOType tx
HeadIsClosed :: HeadId -> SnapshotNumber -> UTCTime -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:snapshotNumber:NetworkConnected] :: ServerOutput tx -> SnapshotNumber

-- | Nominal deadline until which contest can be submitted and after which
--   fanout is possible. NOTE: Use this only for informational purpose and
--   wait for <a>ReadyToFanout</a> instead before sending <tt>Fanout</tt>
--   as the ledger of our cardano-node might not have progressed
--   sufficiently in time yet and we do not re-submit transactions (yet).
[$sel:contestationDeadline:NetworkConnected] :: ServerOutput tx -> UTCTime
HeadIsContested :: HeadId -> SnapshotNumber -> UTCTime -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:snapshotNumber:NetworkConnected] :: ServerOutput tx -> SnapshotNumber

-- | Nominal deadline until which contest can be submitted and after which
--   fanout is possible. NOTE: Use this only for informational purpose and
--   wait for <a>ReadyToFanout</a> instead before sending <tt>Fanout</tt>
--   as the ledger of our cardano-node might not have progressed
--   sufficiently in time yet and we do not re-submit transactions (yet).
[$sel:contestationDeadline:NetworkConnected] :: ServerOutput tx -> UTCTime
ReadyToFanout :: HeadId -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
HeadIsAborted :: HeadId -> UTxOType tx -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:utxo:NetworkConnected] :: ServerOutput tx -> UTxOType tx
HeadIsFinalized :: HeadId -> UTxOType tx -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:utxo:NetworkConnected] :: ServerOutput tx -> UTxOType tx

-- | Given transaction has been seen as valid in the Head. It is expected
--   to eventually be part of a <a>SnapshotConfirmed</a>.
TxValid :: HeadId -> TxIdType tx -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:transactionId:NetworkConnected] :: ServerOutput tx -> TxIdType tx

-- | Given transaction was not not applicable to the given UTxO in time and
--   has been dropped.
TxInvalid :: HeadId -> UTxOType tx -> tx -> ValidationError -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:utxo:NetworkConnected] :: ServerOutput tx -> UTxOType tx
[$sel:transaction:NetworkConnected] :: ServerOutput tx -> tx
[$sel:validationError:NetworkConnected] :: ServerOutput tx -> ValidationError

-- | Given snapshot was confirmed and included transactions can be
--   considered final.
SnapshotConfirmed :: HeadId -> Snapshot tx -> MultiSignature (Snapshot tx) -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:snapshot:NetworkConnected] :: ServerOutput tx -> Snapshot tx
[$sel:signatures:NetworkConnected] :: ServerOutput tx -> MultiSignature (Snapshot tx)
IgnoredHeadInitializing :: HeadId -> ContestationPeriod -> [Party] -> [OnChainId] -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:contestationPeriod:NetworkConnected] :: ServerOutput tx -> ContestationPeriod
[$sel:parties:NetworkConnected] :: ServerOutput tx -> [Party]
[$sel:participants:NetworkConnected] :: ServerOutput tx -> [OnChainId]
DecommitRequested :: HeadId -> tx -> UTxOType tx -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:decommitTx:NetworkConnected] :: ServerOutput tx -> tx
[$sel:utxoToDecommit:NetworkConnected] :: ServerOutput tx -> UTxOType tx
DecommitInvalid :: HeadId -> tx -> DecommitInvalidReason tx -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:decommitTx:NetworkConnected] :: ServerOutput tx -> tx
[$sel:decommitInvalidReason:NetworkConnected] :: ServerOutput tx -> DecommitInvalidReason tx
DecommitApproved :: HeadId -> TxIdType tx -> UTxOType tx -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:decommitTxId:NetworkConnected] :: ServerOutput tx -> TxIdType tx
[$sel:utxoToDecommit:NetworkConnected] :: ServerOutput tx -> UTxOType tx
DecommitFinalized :: HeadId -> UTxOType tx -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:distributedUTxO:NetworkConnected] :: ServerOutput tx -> UTxOType tx
CommitRecorded :: HeadId -> UTxOType tx -> TxIdType tx -> UTCTime -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:utxoToCommit:NetworkConnected] :: ServerOutput tx -> UTxOType tx
[$sel:pendingDeposit:NetworkConnected] :: ServerOutput tx -> TxIdType tx
[$sel:deadline:NetworkConnected] :: ServerOutput tx -> UTCTime
DepositActivated :: HeadId -> TxIdType tx -> UTCTime -> UTCTime -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:depositTxId:NetworkConnected] :: ServerOutput tx -> TxIdType tx
[$sel:deadline:NetworkConnected] :: ServerOutput tx -> UTCTime
[$sel:chainTime:NetworkConnected] :: ServerOutput tx -> UTCTime
DepositExpired :: HeadId -> TxIdType tx -> UTCTime -> UTCTime -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:depositTxId:NetworkConnected] :: ServerOutput tx -> TxIdType tx
[$sel:deadline:NetworkConnected] :: ServerOutput tx -> UTCTime
[$sel:chainTime:NetworkConnected] :: ServerOutput tx -> UTCTime
CommitApproved :: HeadId -> UTxOType tx -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:utxoToCommit:NetworkConnected] :: ServerOutput tx -> UTxOType tx
CommitFinalized :: HeadId -> TxIdType tx -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:depositTxId:NetworkConnected] :: ServerOutput tx -> TxIdType tx
CommitRecovered :: HeadId -> UTxOType tx -> TxIdType tx -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:recoveredUTxO:NetworkConnected] :: ServerOutput tx -> UTxOType tx
[$sel:recoveredTxId:NetworkConnected] :: ServerOutput tx -> TxIdType tx

-- | Snapshot was side-loaded, and the included transactions can be
--   considered final. The local state has been reset, meaning pending
--   transactions were pruned. Any signing round has been discarded, and
--   the snapshot leader has changed accordingly.
SnapshotSideLoaded :: HeadId -> SnapshotNumber -> ServerOutput tx
[$sel:headId:NetworkConnected] :: ServerOutput tx -> HeadId
[$sel:snapshotNumber:NetworkConnected] :: ServerOutput tx -> SnapshotNumber
EventLogRotated :: ServerOutput tx

-- | Whether or not to include full UTxO in server outputs.
data WithUTxO
WithUTxO :: WithUTxO
WithoutUTxO :: WithUTxO

-- | Whether or not to filter transaction server outputs by given address.
data WithAddressedTx
WithAddressedTx :: Text -> WithAddressedTx
WithoutAddressedTx :: WithAddressedTx
data ServerOutputConfig
ServerOutputConfig :: WithUTxO -> WithAddressedTx -> ServerOutputConfig
[$sel:utxoInSnapshot:ServerOutputConfig] :: ServerOutputConfig -> WithUTxO
[$sel:addressInTx:ServerOutputConfig] :: ServerOutputConfig -> WithAddressedTx

-- | Replaces the json encoded tx field with it's cbor representation.
--   
--   NOTE: we deliberately pattern match on all <a>ServerOutput</a>
--   constructors in <tt>handleTxOutput</tt> so that we don't forget to
--   update this function if they change.
prepareServerOutput :: IsChainState tx => ServerOutputConfig -> TimedServerOutput tx -> ByteString
removeSnapshotUTxO :: ByteString -> ByteString
handleUtxoInclusion :: ServerOutputConfig -> (a -> a) -> a -> a

-- | All possible Hydra states displayed in the API server outputs.
data HeadStatus
Idle :: HeadStatus
Initializing :: HeadStatus
Open :: HeadStatus
Closed :: HeadStatus
FanoutPossible :: HeadStatus

-- | All information needed to distinguish behavior of the commit endpoint.
data CommitInfo
CannotCommit :: CommitInfo
NormalCommit :: HeadId -> CommitInfo
IncrementalCommit :: HeadId -> CommitInfo

-- | Get latest confirmed snapshot UTxO from <a>HeadState</a>.
getSnapshotUtxo :: Monoid (UTxOType tx) => HeadState tx -> Maybe (UTxOType tx)

-- | Get latest seen snapshot from <a>HeadState</a>.
getSeenSnapshot :: HeadState tx -> SeenSnapshot tx

-- | Get latest confirmed snapshot from <a>HeadState</a>.
getConfirmedSnapshot :: IsChainState tx => HeadState tx -> Maybe (ConfirmedSnapshot tx)
instance GHC.Generics.Generic (Hydra.API.ServerOutput.DecommitInvalidReason tx)
instance GHC.Generics.Generic (Hydra.API.ServerOutput.ClientMessage tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Show.Show (Hydra.API.ServerOutput.ClientMessage tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Classes.Eq (Hydra.API.ServerOutput.ClientMessage tx)
instance GHC.Generics.Generic Hydra.API.ServerOutput.InvalidInput
instance GHC.Show.Show Hydra.API.ServerOutput.InvalidInput
instance GHC.Classes.Eq Hydra.API.ServerOutput.InvalidInput
instance GHC.Generics.Generic (Hydra.API.ServerOutput.ServerOutput tx)
instance GHC.Generics.Generic (Hydra.API.ServerOutput.TimedServerOutput tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Show.Show (Hydra.API.ServerOutput.TimedServerOutput tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Classes.Eq (Hydra.API.ServerOutput.TimedServerOutput tx)
instance GHC.Show.Show Hydra.API.ServerOutput.WithUTxO
instance GHC.Classes.Eq Hydra.API.ServerOutput.WithUTxO
instance GHC.Show.Show Hydra.API.ServerOutput.WithAddressedTx
instance GHC.Classes.Eq Hydra.API.ServerOutput.WithAddressedTx
instance GHC.Show.Show Hydra.API.ServerOutput.ServerOutputConfig
instance GHC.Classes.Eq Hydra.API.ServerOutput.ServerOutputConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.API.ServerOutput.HeadStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.API.ServerOutput.HeadStatus
instance GHC.Generics.Generic Hydra.API.ServerOutput.HeadStatus
instance GHC.Show.Show Hydra.API.ServerOutput.HeadStatus
instance GHC.Classes.Eq Hydra.API.ServerOutput.HeadStatus
instance GHC.Generics.Generic (Hydra.API.ServerOutput.Greetings tx)
instance (GHC.Classes.Eq (Hydra.Tx.IsTx.TxIdType tx), GHC.Classes.Eq (Hydra.Tx.IsTx.UTxOType tx)) => GHC.Classes.Eq (Hydra.API.ServerOutput.DecommitInvalidReason tx)
instance (GHC.Show.Show (Hydra.Tx.IsTx.TxIdType tx), GHC.Show.Show (Hydra.Tx.IsTx.UTxOType tx)) => GHC.Show.Show (Hydra.API.ServerOutput.DecommitInvalidReason tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Classes.Eq (Hydra.API.ServerOutput.Greetings tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Show.Show (Hydra.API.ServerOutput.Greetings tx)
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.API.ServerOutput.InvalidInput
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.API.ServerOutput.InvalidInput
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Classes.Eq (Hydra.API.ServerOutput.ServerOutput tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Show.Show (Hydra.API.ServerOutput.ServerOutput tx)
instance Hydra.Chain.ChainState.IsChainState tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.API.ServerOutput.ServerOutput tx)
instance Hydra.Chain.ChainState.IsChainState tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.API.ServerOutput.ServerOutput tx)
instance Hydra.Chain.ChainState.IsChainState tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.API.ServerOutput.Greetings tx)
instance Hydra.Chain.ChainState.IsChainState tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.API.ServerOutput.Greetings tx)
instance Hydra.Tx.IsTx.ArbitraryIsTx tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.API.ServerOutput.Greetings tx)
instance (Hydra.Tx.IsTx.ArbitraryIsTx tx, Hydra.Chain.ChainState.IsChainState tx) => Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary (Hydra.API.ServerOutput.Greetings tx)
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.API.ServerOutput.HeadStatus
instance Test.QuickCheck.Arbitrary.Arbitrary (Hydra.API.ServerOutput.ServerOutput tx) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.API.ServerOutput.TimedServerOutput tx)
instance Hydra.Chain.ChainState.IsChainState tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.API.ServerOutput.TimedServerOutput tx)
instance Hydra.Chain.ChainState.IsChainState tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.API.ServerOutput.TimedServerOutput tx)
instance Hydra.Tx.IsTx.ArbitraryIsTx tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.API.ServerOutput.ServerOutput tx)
instance (Hydra.Tx.IsTx.ArbitraryIsTx tx, Hydra.Chain.ChainState.IsChainState tx) => Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary (Hydra.API.ServerOutput.ServerOutput tx)
instance Hydra.Chain.ChainState.IsChainState tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.API.ServerOutput.ClientMessage tx)
instance Hydra.Chain.ChainState.IsChainState tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.API.ServerOutput.ClientMessage tx)
instance (Hydra.Chain.ChainState.IsChainState tx, Hydra.Tx.IsTx.ArbitraryIsTx tx) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.API.ServerOutput.ClientMessage tx)
instance (Data.Aeson.Types.ToJSON.ToJSON (Hydra.Tx.IsTx.TxIdType tx), Data.Aeson.Types.ToJSON.ToJSON (Hydra.Tx.IsTx.UTxOType tx)) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.API.ServerOutput.DecommitInvalidReason tx)
instance (Data.Aeson.Types.FromJSON.FromJSON (Hydra.Tx.IsTx.TxIdType tx), Data.Aeson.Types.FromJSON.FromJSON (Hydra.Tx.IsTx.UTxOType tx)) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.API.ServerOutput.DecommitInvalidReason tx)
instance Hydra.Tx.IsTx.ArbitraryIsTx tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.API.ServerOutput.DecommitInvalidReason tx)

module Hydra.HeadLogic.Outcome

-- | Analogous to inputs, the pure head logic "core" can have effects
--   emitted to the "shell" layers and we distinguish the same: effects
--   onto the client, the network and the chain.
data Effect tx

-- | Effect to be handled by the <a>Hydra.API</a>, results in sending this
--   <a>ClientMessage</a>.
ClientEffect :: ClientMessage tx -> Effect tx
[$sel:clientMessage:ClientEffect] :: Effect tx -> ClientMessage tx

-- | Effect to be handled by a <a>Hydra.Network</a>, results in a
--   <a>broadcast</a>.
NetworkEffect :: Message tx -> Effect tx
[$sel:message:ClientEffect] :: Effect tx -> Message tx

-- | Effect to be handled by a <a>Hydra.Chain</a>, results in a
--   <a>postTx</a>.
OnChainEffect :: PostChainTx tx -> Effect tx
[$sel:postChainTx:ClientEffect] :: Effect tx -> PostChainTx tx

-- | Head state changed event. These events represent all the internal
--   state changes, get persisted and processed in an event sourcing
--   manner.
data StateChanged tx
NetworkConnected :: StateChanged tx
NetworkDisconnected :: StateChanged tx
PeerConnected :: Host -> StateChanged tx
[$sel:peer:NetworkConnected] :: StateChanged tx -> Host
PeerDisconnected :: Host -> StateChanged tx
[$sel:peer:NetworkConnected] :: StateChanged tx -> Host
NetworkVersionMismatch :: ProtocolVersion -> Maybe ProtocolVersion -> StateChanged tx
[$sel:ourVersion:NetworkConnected] :: StateChanged tx -> ProtocolVersion
[$sel:theirVersion:NetworkConnected] :: StateChanged tx -> Maybe ProtocolVersion
NetworkClusterIDMismatch :: Text -> Text -> StateChanged tx
[$sel:clusterPeers:NetworkConnected] :: StateChanged tx -> Text
[$sel:misconfiguredPeers:NetworkConnected] :: StateChanged tx -> Text
HeadInitialized :: HeadParameters -> ChainStateType tx -> HeadId -> HeadSeed -> [Party] -> StateChanged tx
[$sel:parameters:NetworkConnected] :: StateChanged tx -> HeadParameters
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:headSeed:NetworkConnected] :: StateChanged tx -> HeadSeed
[$sel:parties:NetworkConnected] :: StateChanged tx -> [Party]
CommittedUTxO :: HeadId -> Party -> UTxOType tx -> ChainStateType tx -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:party:NetworkConnected] :: StateChanged tx -> Party
[$sel:committedUTxO:NetworkConnected] :: StateChanged tx -> UTxOType tx
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
HeadAborted :: HeadId -> UTxOType tx -> ChainStateType tx -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:utxo:NetworkConnected] :: StateChanged tx -> UTxOType tx
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
HeadOpened :: HeadId -> ChainStateType tx -> UTxOType tx -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
[$sel:initialUTxO:NetworkConnected] :: StateChanged tx -> UTxOType tx
TransactionReceived :: tx -> StateChanged tx
[$sel:tx:NetworkConnected] :: StateChanged tx -> tx
TransactionAppliedToLocalUTxO :: HeadId -> tx -> UTxOType tx -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:tx:NetworkConnected] :: StateChanged tx -> tx
[$sel:newLocalUTxO:NetworkConnected] :: StateChanged tx -> UTxOType tx
SnapshotRequestDecided :: SnapshotNumber -> StateChanged tx
[$sel:snapshotNumber:NetworkConnected] :: StateChanged tx -> SnapshotNumber

-- | A snapshot was requested by some party. NOTE: We deliberately already
--   include an updated local ledger state to not need a ledger to
--   interpret this event.
SnapshotRequested :: Snapshot tx -> [TxIdType tx] -> UTxOType tx -> [tx] -> Maybe (TxIdType tx) -> StateChanged tx
[$sel:snapshot:NetworkConnected] :: StateChanged tx -> Snapshot tx
[$sel:requestedTxIds:NetworkConnected] :: StateChanged tx -> [TxIdType tx]
[$sel:newLocalUTxO:NetworkConnected] :: StateChanged tx -> UTxOType tx
[$sel:newLocalTxs:NetworkConnected] :: StateChanged tx -> [tx]
[$sel:newCurrentDepositTxId:NetworkConnected] :: StateChanged tx -> Maybe (TxIdType tx)
PartySignedSnapshot :: Snapshot tx -> Party -> Signature (Snapshot tx) -> StateChanged tx
[$sel:snapshot:NetworkConnected] :: StateChanged tx -> Snapshot tx
[$sel:party:NetworkConnected] :: StateChanged tx -> Party
[$sel:signature:NetworkConnected] :: StateChanged tx -> Signature (Snapshot tx)
SnapshotConfirmed :: HeadId -> Snapshot tx -> MultiSignature (Snapshot tx) -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:snapshot:NetworkConnected] :: StateChanged tx -> Snapshot tx
[$sel:signatures:NetworkConnected] :: StateChanged tx -> MultiSignature (Snapshot tx)
DepositRecorded :: ChainStateType tx -> HeadId -> TxIdType tx -> UTxOType tx -> UTCTime -> UTCTime -> StateChanged tx
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:depositTxId:NetworkConnected] :: StateChanged tx -> TxIdType tx
[$sel:deposited:NetworkConnected] :: StateChanged tx -> UTxOType tx
[$sel:created:NetworkConnected] :: StateChanged tx -> UTCTime
[$sel:deadline:NetworkConnected] :: StateChanged tx -> UTCTime
DepositActivated :: TxIdType tx -> UTCTime -> Deposit tx -> StateChanged tx
[$sel:depositTxId:NetworkConnected] :: StateChanged tx -> TxIdType tx
[$sel:chainTime:NetworkConnected] :: StateChanged tx -> UTCTime
[$sel:deposit:NetworkConnected] :: StateChanged tx -> Deposit tx
DepositExpired :: TxIdType tx -> UTCTime -> Deposit tx -> StateChanged tx
[$sel:depositTxId:NetworkConnected] :: StateChanged tx -> TxIdType tx
[$sel:chainTime:NetworkConnected] :: StateChanged tx -> UTCTime
[$sel:deposit:NetworkConnected] :: StateChanged tx -> Deposit tx
DepositRecovered :: ChainStateType tx -> HeadId -> TxIdType tx -> UTxOType tx -> StateChanged tx
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:depositTxId:NetworkConnected] :: StateChanged tx -> TxIdType tx
[$sel:recovered:NetworkConnected] :: StateChanged tx -> UTxOType tx
CommitApproved :: HeadId -> UTxOType tx -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:utxoToCommit:NetworkConnected] :: StateChanged tx -> UTxOType tx
CommitFinalized :: ChainStateType tx -> HeadId -> SnapshotVersion -> TxIdType tx -> StateChanged tx
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:newVersion:NetworkConnected] :: StateChanged tx -> SnapshotVersion
[$sel:depositTxId:NetworkConnected] :: StateChanged tx -> TxIdType tx
DecommitRecorded :: HeadId -> tx -> UTxOType tx -> UTxOType tx -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:decommitTx:NetworkConnected] :: StateChanged tx -> tx
[$sel:newLocalUTxO:NetworkConnected] :: StateChanged tx -> UTxOType tx
[$sel:utxoToDecommit:NetworkConnected] :: StateChanged tx -> UTxOType tx
DecommitApproved :: HeadId -> TxIdType tx -> UTxOType tx -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:decommitTxId:NetworkConnected] :: StateChanged tx -> TxIdType tx
[$sel:utxoToDecommit:NetworkConnected] :: StateChanged tx -> UTxOType tx
DecommitInvalid :: HeadId -> tx -> DecommitInvalidReason tx -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:decommitTx:NetworkConnected] :: StateChanged tx -> tx
[$sel:decommitInvalidReason:NetworkConnected] :: StateChanged tx -> DecommitInvalidReason tx
DecommitFinalized :: ChainStateType tx -> HeadId -> UTxOType tx -> SnapshotVersion -> StateChanged tx
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:distributedUTxO:NetworkConnected] :: StateChanged tx -> UTxOType tx
[$sel:newVersion:NetworkConnected] :: StateChanged tx -> SnapshotVersion
HeadClosed :: HeadId -> SnapshotNumber -> ChainStateType tx -> UTCTime -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:snapshotNumber:NetworkConnected] :: StateChanged tx -> SnapshotNumber
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
[$sel:contestationDeadline:NetworkConnected] :: StateChanged tx -> UTCTime
HeadContested :: HeadId -> ChainStateType tx -> UTCTime -> SnapshotNumber -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
[$sel:contestationDeadline:NetworkConnected] :: StateChanged tx -> UTCTime
[$sel:snapshotNumber:NetworkConnected] :: StateChanged tx -> SnapshotNumber
HeadIsReadyToFanout :: HeadId -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
HeadFannedOut :: HeadId -> UTxOType tx -> ChainStateType tx -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:utxo:NetworkConnected] :: StateChanged tx -> UTxOType tx
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
ChainRolledBack :: ChainStateType tx -> StateChanged tx
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
TickObserved :: ChainSlot -> StateChanged tx
[$sel:chainSlot:NetworkConnected] :: StateChanged tx -> ChainSlot
IgnoredHeadInitializing :: HeadId -> ContestationPeriod -> [Party] -> [OnChainId] -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:contestationPeriod:NetworkConnected] :: StateChanged tx -> ContestationPeriod
[$sel:parties:NetworkConnected] :: StateChanged tx -> [Party]
[$sel:participants:NetworkConnected] :: StateChanged tx -> [OnChainId]
TxInvalid :: HeadId -> UTxOType tx -> tx -> ValidationError -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:utxo:NetworkConnected] :: StateChanged tx -> UTxOType tx
[$sel:transaction:NetworkConnected] :: StateChanged tx -> tx
[$sel:validationError:NetworkConnected] :: StateChanged tx -> ValidationError
LocalStateCleared :: HeadId -> SnapshotNumber -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:snapshotNumber:NetworkConnected] :: StateChanged tx -> SnapshotNumber
Checkpoint :: HeadState tx -> StateChanged tx
[$sel:state:NetworkConnected] :: StateChanged tx -> HeadState tx
genStateChanged :: (ArbitraryIsTx tx, IsChainState tx) => Environment -> Gen (StateChanged tx)
data Outcome tx

-- | Continue with the given state updates and side effects.
Continue :: [StateChanged tx] -> [Effect tx] -> Outcome tx
[$sel:stateChanges:Continue] :: Outcome tx -> [StateChanged tx]
[$sel:effects:Continue] :: Outcome tx -> [Effect tx]

-- | Wait for some condition to be met with optional state updates.
Wait :: WaitReason tx -> [StateChanged tx] -> Outcome tx
[$sel:reason:Continue] :: Outcome tx -> WaitReason tx
[$sel:stateChanges:Continue] :: Outcome tx -> [StateChanged tx]

-- | Processing resulted in an error.
Error :: LogicError tx -> Outcome tx
[$sel:error:Continue] :: Outcome tx -> LogicError tx
noop :: Outcome tx
wait :: WaitReason tx -> Outcome tx
newState :: StateChanged tx -> Outcome tx
cause :: Effect tx -> Outcome tx
causes :: [Effect tx] -> Outcome tx
changes :: [StateChanged tx] -> Outcome tx
data WaitReason tx
WaitOnNotApplicableTx :: ValidationError -> WaitReason tx
[$sel:validationError:WaitOnNotApplicableTx] :: WaitReason tx -> ValidationError
WaitOnSnapshotNumber :: SnapshotNumber -> WaitReason tx
[$sel:waitingForNumber:WaitOnNotApplicableTx] :: WaitReason tx -> SnapshotNumber
WaitOnSnapshotVersion :: SnapshotVersion -> WaitReason tx
[$sel:waitingForVersion:WaitOnNotApplicableTx] :: WaitReason tx -> SnapshotVersion
WaitOnSeenSnapshot :: WaitReason tx
WaitOnTxs :: [TxIdType tx] -> WaitReason tx
[$sel:waitingForTxIds:WaitOnNotApplicableTx] :: WaitReason tx -> [TxIdType tx]
WaitOnContestationDeadline :: WaitReason tx
WaitOnNotApplicableDecommitTx :: DecommitInvalidReason tx -> WaitReason tx
[$sel:notApplicableReason:WaitOnNotApplicableTx] :: WaitReason tx -> DecommitInvalidReason tx
WaitOnUnresolvedCommit :: UTxOType tx -> WaitReason tx
[$sel:commitUTxO:WaitOnNotApplicableTx] :: WaitReason tx -> UTxOType tx
WaitOnUnresolvedDecommit :: tx -> WaitReason tx
[$sel:decommitTx:WaitOnNotApplicableTx] :: WaitReason tx -> tx
WaitOnDepositObserved :: TxIdType tx -> WaitReason tx
[$sel:depositTxId:WaitOnNotApplicableTx] :: WaitReason tx -> TxIdType tx
WaitOnDepositActivation :: TxIdType tx -> WaitReason tx
[$sel:depositTxId:WaitOnNotApplicableTx] :: WaitReason tx -> TxIdType tx
instance GHC.Generics.Generic (Hydra.HeadLogic.Outcome.Effect tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.Outcome.StateChanged tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.Outcome.WaitReason tx)
instance GHC.Generics.Generic (Hydra.HeadLogic.Outcome.Outcome tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Classes.Eq (Hydra.HeadLogic.Outcome.Effect tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Show.Show (Hydra.HeadLogic.Outcome.Effect tx)
instance Hydra.Chain.ChainState.IsChainState tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Outcome.Effect tx)
instance (Hydra.Chain.ChainState.IsChainState tx, Hydra.Tx.IsTx.IsTx tx, GHC.Classes.Eq (Hydra.HeadLogic.State.HeadState tx), GHC.Classes.Eq (Hydra.Chain.ChainState.ChainStateType tx)) => GHC.Classes.Eq (Hydra.HeadLogic.Outcome.StateChanged tx)
instance (Hydra.Chain.ChainState.IsChainState tx, Hydra.Tx.IsTx.IsTx tx, GHC.Show.Show (Hydra.HeadLogic.State.HeadState tx), GHC.Show.Show (Hydra.Chain.ChainState.ChainStateType tx)) => GHC.Show.Show (Hydra.HeadLogic.Outcome.StateChanged tx)
instance (Hydra.Chain.ChainState.IsChainState tx, Hydra.Tx.IsTx.IsTx tx, Data.Aeson.Types.ToJSON.ToJSON (Hydra.Chain.ChainState.ChainStateType tx)) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Outcome.StateChanged tx)
instance (Hydra.Chain.ChainState.IsChainState tx, Hydra.Tx.IsTx.IsTx tx, Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.State.HeadState tx), Data.Aeson.Types.FromJSON.FromJSON (Hydra.Chain.ChainState.ChainStateType tx)) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.Outcome.StateChanged tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Classes.Eq (Hydra.HeadLogic.Outcome.Outcome tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Show.Show (Hydra.HeadLogic.Outcome.Outcome tx)
instance Hydra.Chain.ChainState.IsChainState tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Outcome.Outcome tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Classes.Eq (Hydra.HeadLogic.Outcome.WaitReason tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Show.Show (Hydra.HeadLogic.Outcome.WaitReason tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.Outcome.WaitReason tx)
instance GHC.Base.Semigroup (Hydra.HeadLogic.Outcome.Outcome tx)
instance (Hydra.Tx.IsTx.ArbitraryIsTx tx, Hydra.Chain.ChainState.IsChainState tx) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.Outcome.StateChanged tx)
instance (Hydra.Tx.IsTx.ArbitraryIsTx tx, Hydra.Chain.ChainState.IsChainState tx) => Test.QuickCheck.Arbitrary.ADT.ToADTArbitrary (Hydra.HeadLogic.Outcome.StateChanged tx)


-- | Implements the Head Protocol's <i>state machine</i> as <i>pure
--   functions</i> in an event sourced manner.
--   
--   More specifically, the <a>update</a> will handle <a>Input</a>s (or
--   rather "commands" in event sourcing speak) and convert that into a
--   list of side-<a>Effect</a>s and <a>StateChanged</a> events, which in
--   turn are <a>aggregate</a>d into a single <a>HeadState</a>.
--   
--   As the specification is using a more imperative way of specifying the
--   protocol behavior, one would find the decision logic in <a>update</a>
--   while state updates can be found in the corresponding <a>aggregate</a>
--   branch.
module Hydra.HeadLogic

-- | Handles inputs and converts them into <a>StateChanged</a> events along
--   with <a>Effect</a>s, in case it is processed successfully. Later, the
--   Node will <a>aggregate</a> the events, resulting in a new
--   <a>HeadState</a>.
update :: IsChainState tx => Environment -> Ledger tx -> HeadState tx -> Input tx -> Outcome tx

-- | Reflect <a>StateChanged</a> events onto the <a>HeadState</a>
--   aggregate.
aggregate :: IsChainState tx => HeadState tx -> StateChanged tx -> HeadState tx
onConnectionEvent :: Text -> Connectivity -> Outcome tx
aggregateChainStateHistory :: IsChainState tx => ChainStateHistory tx -> StateChanged tx -> ChainStateHistory tx
aggregateState :: IsChainState tx => HeadState tx -> Outcome tx -> HeadState tx
isLeader :: HeadParameters -> Party -> SnapshotNumber -> Bool

-- | Client request to init the head. This leads to an init transaction on
--   chain, containing the head parameters.
--   
--   <b>Transition</b>: <a>IdleState</a> → <a>IdleState</a>
onIdleClientInit :: Environment -> Outcome tx

-- | Observe an init transaction, initialize parameters in an
--   <a>InitialState</a> and notify clients that they can now commit.
--   
--   <b>Transition</b>: <a>IdleState</a> → <a>InitialState</a>
onIdleChainInitTx :: Environment -> ChainStateType tx -> HeadId -> HeadSeed -> HeadParameters -> [OnChainId] -> Outcome tx

-- | Observe a commit transaction and record the committed UTxO in the
--   state. Also, if this is the last commit to be observed, post a
--   collect-com transaction on-chain.
--   
--   <b>Transition</b>: <a>InitialState</a> → <a>InitialState</a>
onInitialChainCommitTx :: Monoid (UTxOType tx) => InitialState tx -> ChainStateType tx -> Party -> UTxOType tx -> Outcome tx

-- | Client request to abort the head. This leads to an abort transaction
--   on chain, reimbursing already committed UTxOs.
--   
--   <b>Transition</b>: <a>InitialState</a> → <a>InitialState</a>
onInitialClientAbort :: Monoid (UTxOType tx) => InitialState tx -> Outcome tx

-- | Observe an abort transaction by switching the state and notifying
--   clients about it.
--   
--   <b>Transition</b>: <a>InitialState</a> → <a>IdleState</a>
onInitialChainAbortTx :: Monoid (UTxOType tx) => ChainStateType tx -> Committed tx -> HeadId -> Outcome tx

-- | Observe a collectCom transaction. We initialize the <a>OpenState</a>
--   using the head parameters from <a>IdleState</a> and construct an
--   <a>InitialSnapshot</a> holding <tt>u0</tt> from the committed UTxOs.
--   
--   <b>Transition</b>: <a>InitialState</a> → <a>OpenState</a>
onInitialChainCollectTx :: IsChainState tx => InitialState tx -> ChainStateType tx -> Outcome tx

-- | Client request to ingest a new transaction into the head.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>OpenState</a>
onOpenClientNewTx :: tx -> Outcome tx

-- | Process a transaction request (<a>ReqTx</a>) from a party.
--   
--   We apply this transaction to the seen utxo (ledger state). If not
--   applicable, we wait and retry later. If it applies, this yields an
--   updated seen ledger state. Then, we check whether we are the leader
--   for the next snapshot and emit a snapshot request <a>ReqSn</a>
--   including this transaction if needed.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>OpenState</a>
onOpenNetworkReqTx :: IsTx tx => Environment -> Ledger tx -> OpenState tx -> TTL -> tx -> Outcome tx

-- | Process a snapshot request (<a>ReqSn</a>) from party.
--   
--   This checks that s is the next snapshot number and that the party is
--   responsible for leading that snapshot. Then, we potentially wait until
--   the previous snapshot is confirmed (no snapshot is in flight), before
--   we apply (or wait until applicable) the requested transactions to the
--   last confirmed snapshot. Only then, we start tracking this new "seen"
--   snapshot, compute a signature of it and send the corresponding
--   <a>AckSn</a> to all parties. Finally, the pending transaction set gets
--   pruned to only contain still applicable transactions.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>OpenState</a>
onOpenNetworkReqSn :: IsTx tx => Environment -> Ledger tx -> OpenState tx -> Party -> SnapshotVersion -> SnapshotNumber -> [TxIdType tx] -> Maybe tx -> Maybe (TxIdType tx) -> Outcome tx

-- | Process a snapshot acknowledgement (<a>AckSn</a>) from a party.
--   
--   We do require that the is from the last seen or next expected
--   snapshot, and potentially wait wait for the corresponding <a>ReqSn</a>
--   before proceeding. If the party hasn't sent us a signature yet, we
--   store it. Once a signature from each party has been collected, we
--   aggregate a multi-signature and verify it is correct. If everything is
--   fine, the snapshot can be considered as the latest confirmed one.
--   Similar to processing a <a>ReqTx</a>, we check whether we are leading
--   the next snapshot and craft a corresponding <a>ReqSn</a> if needed.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>OpenState</a>
onOpenNetworkAckSn :: IsTx tx => Environment -> OpenState tx -> Party -> Signature (Snapshot tx) -> SnapshotNumber -> Outcome tx

-- | Client request to recover deposited UTxO.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>OpenState</a>
onOpenClientRecover :: IsTx tx => HeadId -> ChainSlot -> CoordinatedHeadState tx -> TxIdType tx -> Outcome tx

-- | Client request to decommit UTxO from the head.
--   
--   Only possible if there is no decommit _in flight_ and if the tx
--   applies cleanly to the local ledger state.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>OpenState</a>
onOpenClientDecommit :: IsTx tx => HeadId -> Ledger tx -> ChainSlot -> CoordinatedHeadState tx -> tx -> Outcome tx

-- | Process the request <a>ReqDec</a> to decommit something from the Open
--   head.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>OpenState</a>
--   
--   When node receives <a>ReqDec</a> network message it should: - Check
--   there is no decommit in flight: - Alter it's state to record what is
--   to be decommitted - Issue a server output <tt>DecommitRequested</tt>
--   with the relevant utxo - Issue a <a>ReqSn</a> since all parties need
--   to agree in order for decommit to be taken out of a Head. - Check if
--   we are the leader
onOpenNetworkReqDec :: IsTx tx => Environment -> Ledger tx -> TTL -> OpenState tx -> tx -> Outcome tx

-- | Process the chain (and time) advancing in an open head.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>OpenState</a>
--   
--   This is primarily used to track deposits and either drop them or
--   request snapshots for inclusion.
onOpenChainTick :: IsTx tx => Environment -> OpenState tx -> UTCTime -> Outcome tx

-- | Observe a increment transaction. If the outputs match the ones of the
--   pending commit UTxO, then we consider the deposit/increment finalized,
--   and remove the increment UTxO from
--   <a>$sel:pendingDeposits:CoordinatedHeadState</a> from the local state.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>OpenState</a>
onOpenChainIncrementTx :: OpenState tx -> ChainStateType tx -> SnapshotVersion -> TxIdType tx -> Outcome tx

-- | Observe a decrement transaction. If the outputs match the ones of the
--   pending decommit tx, then we consider the decommit finalized, and
--   remove the decommit tx in flight.
--   
--   Finally, if the client observing happens to be the leader, then a new
--   ReqSn is broadcasted.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>OpenState</a>
onOpenChainDecrementTx :: OpenState tx -> ChainStateType tx -> SnapshotVersion -> UTxOType tx -> Outcome tx

-- | Client request to close the head. This leads to a close transaction on
--   chain using the latest confirmed snaphshot of the <a>OpenState</a>.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>OpenState</a>
onOpenClientClose :: OpenState tx -> Outcome tx

-- | Observe a close transaction. If the closed snapshot number is smaller
--   than our last confirmed, we post a contest transaction. Also, we do
--   schedule a notification for clients to fanout at the deadline.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>ClosedState</a>
onOpenChainCloseTx :: OpenState tx -> ChainStateType tx -> SnapshotNumber -> UTCTime -> Outcome tx

-- | Client request to side load confirmed snapshot.
--   
--   Note this is not covered by the spec as it is not reachable from an
--   organic use of the protocol.
--   
--   It must not have any effects outside of a neutral modification of the
--   state to: * something it was before (in the case of the initial
--   snapshot). * something it would be using side communication (in the
--   case of a confirmed snapshot).
--   
--   Besides the above, it is expected to work very much like the confirmed
--   snapshot.
--   
--   <b>Transition</b>: <a>OpenState</a> → <a>OpenState</a>
onOpenClientSideLoadSnapshot :: IsTx tx => OpenState tx -> ConfirmedSnapshot tx -> Outcome tx

-- | Observe a contest transaction. If the contested snapshot number is
--   smaller than our last confirmed snapshot, we post a contest
--   transaction.
--   
--   <b>Transition</b>: <a>ClosedState</a> → <a>ClosedState</a>
onClosedChainContestTx :: ClosedState tx -> ChainStateType tx -> SnapshotNumber -> UTCTime -> Outcome tx

-- | Client request to fanout leads to a fanout transaction on chain using
--   the latest confirmed snapshot from <a>ClosedState</a>.
--   
--   <b>Transition</b>: <a>ClosedState</a> → <a>ClosedState</a>
onClosedClientFanout :: ClosedState tx -> Outcome tx

-- | Observe a fanout transaction by finalize the head state and notifying
--   clients about it.
--   
--   <b>Transition</b>: <a>ClosedState</a> → <a>IdleState</a>
onClosedChainFanoutTx :: ClosedState tx -> ChainStateType tx -> UTxOType tx -> Outcome tx

-- | Inputs that are processed by the head logic (the "core").
--   Corresponding to each of the "shell" layers, we distinguish between
--   inputs from the client, the network and the chain.
data Input tx

-- | Input received from clients via the <a>Hydra.API</a>.
ClientInput :: ClientInput tx -> Input tx
[$sel:clientInput:ClientInput] :: Input tx -> ClientInput tx

-- | Input received from peers via a <a>Hydra.Network</a>.
--   
--   <ul>
--   <li><a>$sel:ttl:ClientInput</a> is a simple counter that's decreased
--   every time the event is reenqueued due to a wait. It's default value
--   is <tt>defaultTTL</tt></li>
--   </ul>
NetworkInput :: TTL -> NetworkEvent (Message tx) -> Input tx
[$sel:ttl:ClientInput] :: Input tx -> TTL
[$sel:networkEvent:ClientInput] :: Input tx -> NetworkEvent (Message tx)

-- | Input received from the chain via a <a>Hydra.Chain</a>.
ChainInput :: ChainEvent tx -> Input tx
[$sel:chainEvent:ClientInput] :: Input tx -> ChainEvent tx
type TTL = Natural
data LogicError tx
UnhandledInput :: Input tx -> HeadState tx -> LogicError tx
[$sel:input:UnhandledInput] :: LogicError tx -> Input tx
[$sel:currentHeadState:UnhandledInput] :: LogicError tx -> HeadState tx
RequireFailed :: RequirementFailure tx -> LogicError tx
[$sel:requirementFailure:UnhandledInput] :: LogicError tx -> RequirementFailure tx
AssertionFailed :: Text -> LogicError tx
[$sel:message:UnhandledInput] :: LogicError tx -> Text
NotOurHead :: HeadId -> HeadId -> LogicError tx
[$sel:ourHeadId:UnhandledInput] :: LogicError tx -> HeadId
[$sel:otherHeadId:UnhandledInput] :: LogicError tx -> HeadId
SideLoadSnapshotFailed :: SideLoadRequirementFailure tx -> LogicError tx
[$sel:sideLoadRequirementFailure:UnhandledInput] :: LogicError tx -> SideLoadRequirementFailure tx
data RequirementFailure tx
ReqSnNumberInvalid :: SnapshotNumber -> SnapshotNumber -> RequirementFailure tx
[$sel:requestedSn:ReqSnNumberInvalid] :: RequirementFailure tx -> SnapshotNumber
[$sel:lastSeenSn:ReqSnNumberInvalid] :: RequirementFailure tx -> SnapshotNumber
ReqSvNumberInvalid :: SnapshotVersion -> SnapshotVersion -> RequirementFailure tx
[$sel:requestedSv:ReqSnNumberInvalid] :: RequirementFailure tx -> SnapshotVersion
[$sel:lastSeenSv:ReqSnNumberInvalid] :: RequirementFailure tx -> SnapshotVersion
ReqSnNotLeader :: SnapshotNumber -> Party -> RequirementFailure tx
[$sel:requestedSn:ReqSnNumberInvalid] :: RequirementFailure tx -> SnapshotNumber
[$sel:leader:ReqSnNumberInvalid] :: RequirementFailure tx -> Party
ReqSnDecommitNotSettled :: RequirementFailure tx
ReqSnCommitNotSettled :: RequirementFailure tx
InvalidMultisignature :: Text -> [VerificationKey HydraKey] -> RequirementFailure tx
[$sel:multisig:ReqSnNumberInvalid] :: RequirementFailure tx -> Text
[$sel:vkeys:ReqSnNumberInvalid] :: RequirementFailure tx -> [VerificationKey HydraKey]
SnapshotAlreadySigned :: [Party] -> Party -> RequirementFailure tx
[$sel:knownSignatures:ReqSnNumberInvalid] :: RequirementFailure tx -> [Party]
[$sel:receivedSignature:ReqSnNumberInvalid] :: RequirementFailure tx -> Party
AckSnNumberInvalid :: SnapshotNumber -> SnapshotNumber -> RequirementFailure tx
[$sel:requestedSn:ReqSnNumberInvalid] :: RequirementFailure tx -> SnapshotNumber
[$sel:lastSeenSn:ReqSnNumberInvalid] :: RequirementFailure tx -> SnapshotNumber
SnapshotDoesNotApply :: SnapshotNumber -> TxIdType tx -> ValidationError -> RequirementFailure tx
[$sel:requestedSn:ReqSnNumberInvalid] :: RequirementFailure tx -> SnapshotNumber
[$sel:txid:ReqSnNumberInvalid] :: RequirementFailure tx -> TxIdType tx
[$sel:error:ReqSnNumberInvalid] :: RequirementFailure tx -> ValidationError
NoMatchingDeposit :: RequirementFailure tx
RequestedDepositExpired :: TxIdType tx -> RequirementFailure tx
[$sel:depositTxId:ReqSnNumberInvalid] :: RequirementFailure tx -> TxIdType tx
data SideLoadRequirementFailure tx
SideLoadInitialSnapshotMismatch :: SideLoadRequirementFailure tx
SideLoadSnNumberInvalid :: SnapshotNumber -> SnapshotNumber -> SideLoadRequirementFailure tx
[$sel:requestedSn:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> SnapshotNumber
[$sel:lastSeenSn:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> SnapshotNumber
SideLoadSvNumberInvalid :: SnapshotVersion -> SnapshotVersion -> SideLoadRequirementFailure tx
[$sel:requestedSv:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> SnapshotVersion
[$sel:lastSeenSv:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> SnapshotVersion
SideLoadUTxOToCommitInvalid :: Maybe (UTxOType tx) -> Maybe (UTxOType tx) -> SideLoadRequirementFailure tx
[$sel:requestedSc:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> Maybe (UTxOType tx)
[$sel:lastSeenSc:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> Maybe (UTxOType tx)
SideLoadUTxOToDecommitInvalid :: Maybe (UTxOType tx) -> Maybe (UTxOType tx) -> SideLoadRequirementFailure tx
[$sel:requestedSd:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> Maybe (UTxOType tx)
[$sel:lastSeenSd:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> Maybe (UTxOType tx)
SideLoadInvalidMultisignature :: Text -> [VerificationKey HydraKey] -> SideLoadRequirementFailure tx
[$sel:multisig:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> Text
[$sel:vkeys:SideLoadInitialSnapshotMismatch] :: SideLoadRequirementFailure tx -> [VerificationKey HydraKey]

-- | The main state of the Hydra protocol state machine. It holds both, the
--   overall protocol state, but also the off-chain
--   <a>CoordinatedHeadState</a>.
--   
--   Each of the sub-types (InitialState, OpenState, etc.) contain a
--   black-box <a>IdleState</a> corresponding to the <tt>ChainEvent</tt>
--   that has been observed leading to the state.
--   
--   Note that rollbacks are currently not fully handled in the head logic
--   and only this internal chain state gets replaced with the "rolled back
--   to" version.
--   
--   TODO: chainState would actually not be needed in the HeadState anymore
--   as we do not persist the <a>HeadState</a> and not access it in the
--   HeadLogic either.
data HeadState tx
Idle :: IdleState tx -> HeadState tx
Initial :: InitialState tx -> HeadState tx
Open :: OpenState tx -> HeadState tx
Closed :: ClosedState tx -> HeadState tx

-- | A deposit tracked by the protocol. The <a>DepositStatus</a> determines
--   whether it may be used for an incremental commit or not.
data Deposit tx
Deposit :: HeadId -> UTxOType tx -> UTCTime -> UTCTime -> DepositStatus -> Deposit tx
[$sel:headId:Deposit] :: Deposit tx -> HeadId
[$sel:deposited:Deposit] :: Deposit tx -> UTxOType tx
[$sel:created:Deposit] :: Deposit tx -> UTCTime
[$sel:deadline:Deposit] :: Deposit tx -> UTCTime
[$sel:status:Deposit] :: Deposit tx -> DepositStatus

-- | An <a>Idle</a> head only having a chain state with things seen on
--   chain so far.
newtype IdleState tx
IdleState :: ChainStateType tx -> IdleState tx
[$sel:chainState:IdleState] :: IdleState tx -> ChainStateType tx

-- | An <a>Closed</a> head with an current candidate
--   <a>ConfirmedSnapshot</a>, which may be contested before the
--   <a>$sel:contestationDeadline:ClosedState</a>.
data ClosedState tx
ClosedState :: HeadParameters -> ConfirmedSnapshot tx -> UTCTime -> Bool -> ChainStateType tx -> HeadId -> HeadSeed -> SnapshotVersion -> ClosedState tx
[$sel:parameters:ClosedState] :: ClosedState tx -> HeadParameters
[$sel:confirmedSnapshot:ClosedState] :: ClosedState tx -> ConfirmedSnapshot tx
[$sel:contestationDeadline:ClosedState] :: ClosedState tx -> UTCTime

-- | Tracks whether we have informed clients already about being
--   <tt>ReadyToFanout</tt>.
[$sel:readyToFanoutSent:ClosedState] :: ClosedState tx -> Bool
[$sel:chainState:ClosedState] :: ClosedState tx -> ChainStateType tx
[$sel:headId:ClosedState] :: ClosedState tx -> HeadId
[$sel:headSeed:ClosedState] :: ClosedState tx -> HeadSeed
[$sel:version:ClosedState] :: ClosedState tx -> SnapshotVersion

-- | An <a>Initial</a> head which already has an identity and is collecting
--   commits.
data InitialState tx
InitialState :: HeadParameters -> PendingCommits -> Committed tx -> ChainStateType tx -> HeadId -> HeadSeed -> InitialState tx
[$sel:parameters:InitialState] :: InitialState tx -> HeadParameters
[$sel:pendingCommits:InitialState] :: InitialState tx -> PendingCommits
[$sel:committed:InitialState] :: InitialState tx -> Committed tx
[$sel:chainState:InitialState] :: InitialState tx -> ChainStateType tx
[$sel:headId:InitialState] :: InitialState tx -> HeadId
[$sel:headSeed:InitialState] :: InitialState tx -> HeadSeed

-- | An <a>Open</a> head with a <a>CoordinatedHeadState</a> tracking
--   off-chain transactions.
data OpenState tx
OpenState :: HeadParameters -> CoordinatedHeadState tx -> ChainStateType tx -> HeadId -> ChainSlot -> HeadSeed -> OpenState tx
[$sel:parameters:OpenState] :: OpenState tx -> HeadParameters
[$sel:coordinatedHeadState:OpenState] :: OpenState tx -> CoordinatedHeadState tx
[$sel:chainState:OpenState] :: OpenState tx -> ChainStateType tx
[$sel:headId:OpenState] :: OpenState tx -> HeadId
[$sel:currentSlot:OpenState] :: OpenState tx -> ChainSlot
[$sel:headSeed:OpenState] :: OpenState tx -> HeadSeed

-- | Data structure to help in tracking whether we have seen or requested a
--   ReqSn already and if seen, the signatures we collected already.
data SeenSnapshot tx

-- | Never saw a ReqSn.
NoSeenSnapshot :: SeenSnapshot tx

-- | No snapshot in flight with last seen snapshot number as given.
LastSeenSnapshot :: SnapshotNumber -> SeenSnapshot tx
[$sel:lastSeen:NoSeenSnapshot] :: SeenSnapshot tx -> SnapshotNumber

-- | ReqSn was sent out and it should be considered already in flight.
RequestedSnapshot :: SnapshotNumber -> SnapshotNumber -> SeenSnapshot tx
[$sel:lastSeen:NoSeenSnapshot] :: SeenSnapshot tx -> SnapshotNumber
[$sel:requested:NoSeenSnapshot] :: SeenSnapshot tx -> SnapshotNumber

-- | ReqSn for given snapshot was received.
SeenSnapshot :: Snapshot tx -> Map Party (Signature (Snapshot tx)) -> SeenSnapshot tx
[$sel:snapshot:NoSeenSnapshot] :: SeenSnapshot tx -> Snapshot tx

-- | Collected signatures and so far.
[$sel:signatories:NoSeenSnapshot] :: SeenSnapshot tx -> Map Party (Signature (Snapshot tx))
type Committed tx = Map Party (UTxOType tx)

-- | Off-chain state of the Coordinated Head protocol.
data CoordinatedHeadState tx
CoordinatedHeadState :: UTxOType tx -> [tx] -> !Map (TxIdType tx) tx -> ConfirmedSnapshot tx -> SeenSnapshot tx -> Map (TxIdType tx) (Deposit tx) -> Maybe (TxIdType tx) -> Maybe tx -> SnapshotVersion -> CoordinatedHeadState tx

-- | The latest UTxO resulting from applying
--   <a>$sel:localTxs:CoordinatedHeadState</a> to
--   <a>CoordinatedHeadState</a>. Spec: L̂
[$sel:localUTxO:CoordinatedHeadState] :: CoordinatedHeadState tx -> UTxOType tx

-- | List of transactions applied locally and pending inclusion in a
--   snapshot. Ordering in this list is important as transactions are added
--   in order of application. Spec: T̂
[$sel:localTxs:CoordinatedHeadState] :: CoordinatedHeadState tx -> [tx]

-- | Map containing all the transactions ever seen by this node and not yet
--   included in a snapshot. Spec: Tall
[$sel:allTxs:CoordinatedHeadState] :: CoordinatedHeadState tx -> !Map (TxIdType tx) tx

-- | The latest confirmed snapshot. Spec: S̅
[$sel:confirmedSnapshot:CoordinatedHeadState] :: CoordinatedHeadState tx -> ConfirmedSnapshot tx

-- | Last seen snapshot and signatures accumulator. Spec: Û, ŝ and Σ̂
[$sel:seenSnapshot:CoordinatedHeadState] :: CoordinatedHeadState tx -> SeenSnapshot tx

-- | Pending deposits as observed on chain. TODO: These should be actually
--   stored outside of the <a>HeadState</a> to allow recovery when a head
--   is not open. See
--   <a>https://github.com/cardano-scaling/hydra/issues/1812</a>
[$sel:pendingDeposits:CoordinatedHeadState] :: CoordinatedHeadState tx -> Map (TxIdType tx) (Deposit tx)

-- | Current/next deposit to incrementally commit. Spec: Uα TODO: update in
--   spec: Uα -&gt; tx^#α
[$sel:currentDepositTxId:CoordinatedHeadState] :: CoordinatedHeadState tx -> Maybe (TxIdType tx)

-- | Pending decommit transaction. Spec: txω
[$sel:decommitTx:CoordinatedHeadState] :: CoordinatedHeadState tx -> Maybe tx

-- | Last open state version as observed on chain. Spec: ̂v
[$sel:version:CoordinatedHeadState] :: CoordinatedHeadState tx -> SnapshotVersion
data DepositStatus
Inactive :: DepositStatus
Active :: DepositStatus
Expired :: DepositStatus
type PendingCommits = Set Party

-- | Get the chain state in any <a>HeadState</a>.
getChainState :: HeadState tx -> ChainStateType tx

-- | Get the last seen snapshot number given a <a>SeenSnapshot</a>.
seenSnapshotNumber :: SeenSnapshot tx -> SnapshotNumber

-- | Update the chain state in any <a>HeadState</a>.
setChainState :: ChainStateType tx -> HeadState tx -> HeadState tx

-- | Analogous to inputs, the pure head logic "core" can have effects
--   emitted to the "shell" layers and we distinguish the same: effects
--   onto the client, the network and the chain.
data Effect tx

-- | Effect to be handled by the <a>Hydra.API</a>, results in sending this
--   <a>ClientMessage</a>.
ClientEffect :: ClientMessage tx -> Effect tx
[$sel:clientMessage:ClientEffect] :: Effect tx -> ClientMessage tx

-- | Effect to be handled by a <a>Hydra.Network</a>, results in a
--   <a>broadcast</a>.
NetworkEffect :: Message tx -> Effect tx
[$sel:message:ClientEffect] :: Effect tx -> Message tx

-- | Effect to be handled by a <a>Hydra.Chain</a>, results in a
--   <a>postTx</a>.
OnChainEffect :: PostChainTx tx -> Effect tx
[$sel:postChainTx:ClientEffect] :: Effect tx -> PostChainTx tx
data Outcome tx

-- | Continue with the given state updates and side effects.
Continue :: [StateChanged tx] -> [Effect tx] -> Outcome tx
[$sel:stateChanges:Continue] :: Outcome tx -> [StateChanged tx]
[$sel:effects:Continue] :: Outcome tx -> [Effect tx]

-- | Wait for some condition to be met with optional state updates.
Wait :: WaitReason tx -> [StateChanged tx] -> Outcome tx
[$sel:reason:Continue] :: Outcome tx -> WaitReason tx
[$sel:stateChanges:Continue] :: Outcome tx -> [StateChanged tx]

-- | Processing resulted in an error.
Error :: LogicError tx -> Outcome tx
[$sel:error:Continue] :: Outcome tx -> LogicError tx

-- | Head state changed event. These events represent all the internal
--   state changes, get persisted and processed in an event sourcing
--   manner.
data StateChanged tx
NetworkConnected :: StateChanged tx
NetworkDisconnected :: StateChanged tx
PeerConnected :: Host -> StateChanged tx
[$sel:peer:NetworkConnected] :: StateChanged tx -> Host
PeerDisconnected :: Host -> StateChanged tx
[$sel:peer:NetworkConnected] :: StateChanged tx -> Host
NetworkVersionMismatch :: ProtocolVersion -> Maybe ProtocolVersion -> StateChanged tx
[$sel:ourVersion:NetworkConnected] :: StateChanged tx -> ProtocolVersion
[$sel:theirVersion:NetworkConnected] :: StateChanged tx -> Maybe ProtocolVersion
NetworkClusterIDMismatch :: Text -> Text -> StateChanged tx
[$sel:clusterPeers:NetworkConnected] :: StateChanged tx -> Text
[$sel:misconfiguredPeers:NetworkConnected] :: StateChanged tx -> Text
HeadInitialized :: HeadParameters -> ChainStateType tx -> HeadId -> HeadSeed -> [Party] -> StateChanged tx
[$sel:parameters:NetworkConnected] :: StateChanged tx -> HeadParameters
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:headSeed:NetworkConnected] :: StateChanged tx -> HeadSeed
[$sel:parties:NetworkConnected] :: StateChanged tx -> [Party]
CommittedUTxO :: HeadId -> Party -> UTxOType tx -> ChainStateType tx -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:party:NetworkConnected] :: StateChanged tx -> Party
[$sel:committedUTxO:NetworkConnected] :: StateChanged tx -> UTxOType tx
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
HeadAborted :: HeadId -> UTxOType tx -> ChainStateType tx -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:utxo:NetworkConnected] :: StateChanged tx -> UTxOType tx
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
HeadOpened :: HeadId -> ChainStateType tx -> UTxOType tx -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
[$sel:initialUTxO:NetworkConnected] :: StateChanged tx -> UTxOType tx
TransactionReceived :: tx -> StateChanged tx
[$sel:tx:NetworkConnected] :: StateChanged tx -> tx
TransactionAppliedToLocalUTxO :: HeadId -> tx -> UTxOType tx -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:tx:NetworkConnected] :: StateChanged tx -> tx
[$sel:newLocalUTxO:NetworkConnected] :: StateChanged tx -> UTxOType tx
SnapshotRequestDecided :: SnapshotNumber -> StateChanged tx
[$sel:snapshotNumber:NetworkConnected] :: StateChanged tx -> SnapshotNumber

-- | A snapshot was requested by some party. NOTE: We deliberately already
--   include an updated local ledger state to not need a ledger to
--   interpret this event.
SnapshotRequested :: Snapshot tx -> [TxIdType tx] -> UTxOType tx -> [tx] -> Maybe (TxIdType tx) -> StateChanged tx
[$sel:snapshot:NetworkConnected] :: StateChanged tx -> Snapshot tx
[$sel:requestedTxIds:NetworkConnected] :: StateChanged tx -> [TxIdType tx]
[$sel:newLocalUTxO:NetworkConnected] :: StateChanged tx -> UTxOType tx
[$sel:newLocalTxs:NetworkConnected] :: StateChanged tx -> [tx]
[$sel:newCurrentDepositTxId:NetworkConnected] :: StateChanged tx -> Maybe (TxIdType tx)
PartySignedSnapshot :: Snapshot tx -> Party -> Signature (Snapshot tx) -> StateChanged tx
[$sel:snapshot:NetworkConnected] :: StateChanged tx -> Snapshot tx
[$sel:party:NetworkConnected] :: StateChanged tx -> Party
[$sel:signature:NetworkConnected] :: StateChanged tx -> Signature (Snapshot tx)
SnapshotConfirmed :: HeadId -> Snapshot tx -> MultiSignature (Snapshot tx) -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:snapshot:NetworkConnected] :: StateChanged tx -> Snapshot tx
[$sel:signatures:NetworkConnected] :: StateChanged tx -> MultiSignature (Snapshot tx)
DepositRecorded :: ChainStateType tx -> HeadId -> TxIdType tx -> UTxOType tx -> UTCTime -> UTCTime -> StateChanged tx
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:depositTxId:NetworkConnected] :: StateChanged tx -> TxIdType tx
[$sel:deposited:NetworkConnected] :: StateChanged tx -> UTxOType tx
[$sel:created:NetworkConnected] :: StateChanged tx -> UTCTime
[$sel:deadline:NetworkConnected] :: StateChanged tx -> UTCTime
DepositActivated :: TxIdType tx -> UTCTime -> Deposit tx -> StateChanged tx
[$sel:depositTxId:NetworkConnected] :: StateChanged tx -> TxIdType tx
[$sel:chainTime:NetworkConnected] :: StateChanged tx -> UTCTime
[$sel:deposit:NetworkConnected] :: StateChanged tx -> Deposit tx
DepositExpired :: TxIdType tx -> UTCTime -> Deposit tx -> StateChanged tx
[$sel:depositTxId:NetworkConnected] :: StateChanged tx -> TxIdType tx
[$sel:chainTime:NetworkConnected] :: StateChanged tx -> UTCTime
[$sel:deposit:NetworkConnected] :: StateChanged tx -> Deposit tx
DepositRecovered :: ChainStateType tx -> HeadId -> TxIdType tx -> UTxOType tx -> StateChanged tx
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:depositTxId:NetworkConnected] :: StateChanged tx -> TxIdType tx
[$sel:recovered:NetworkConnected] :: StateChanged tx -> UTxOType tx
CommitApproved :: HeadId -> UTxOType tx -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:utxoToCommit:NetworkConnected] :: StateChanged tx -> UTxOType tx
CommitFinalized :: ChainStateType tx -> HeadId -> SnapshotVersion -> TxIdType tx -> StateChanged tx
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:newVersion:NetworkConnected] :: StateChanged tx -> SnapshotVersion
[$sel:depositTxId:NetworkConnected] :: StateChanged tx -> TxIdType tx
DecommitRecorded :: HeadId -> tx -> UTxOType tx -> UTxOType tx -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:decommitTx:NetworkConnected] :: StateChanged tx -> tx
[$sel:newLocalUTxO:NetworkConnected] :: StateChanged tx -> UTxOType tx
[$sel:utxoToDecommit:NetworkConnected] :: StateChanged tx -> UTxOType tx
DecommitApproved :: HeadId -> TxIdType tx -> UTxOType tx -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:decommitTxId:NetworkConnected] :: StateChanged tx -> TxIdType tx
[$sel:utxoToDecommit:NetworkConnected] :: StateChanged tx -> UTxOType tx
DecommitInvalid :: HeadId -> tx -> DecommitInvalidReason tx -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:decommitTx:NetworkConnected] :: StateChanged tx -> tx
[$sel:decommitInvalidReason:NetworkConnected] :: StateChanged tx -> DecommitInvalidReason tx
DecommitFinalized :: ChainStateType tx -> HeadId -> UTxOType tx -> SnapshotVersion -> StateChanged tx
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:distributedUTxO:NetworkConnected] :: StateChanged tx -> UTxOType tx
[$sel:newVersion:NetworkConnected] :: StateChanged tx -> SnapshotVersion
HeadClosed :: HeadId -> SnapshotNumber -> ChainStateType tx -> UTCTime -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:snapshotNumber:NetworkConnected] :: StateChanged tx -> SnapshotNumber
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
[$sel:contestationDeadline:NetworkConnected] :: StateChanged tx -> UTCTime
HeadContested :: HeadId -> ChainStateType tx -> UTCTime -> SnapshotNumber -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
[$sel:contestationDeadline:NetworkConnected] :: StateChanged tx -> UTCTime
[$sel:snapshotNumber:NetworkConnected] :: StateChanged tx -> SnapshotNumber
HeadIsReadyToFanout :: HeadId -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
HeadFannedOut :: HeadId -> UTxOType tx -> ChainStateType tx -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:utxo:NetworkConnected] :: StateChanged tx -> UTxOType tx
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
ChainRolledBack :: ChainStateType tx -> StateChanged tx
[$sel:chainState:NetworkConnected] :: StateChanged tx -> ChainStateType tx
TickObserved :: ChainSlot -> StateChanged tx
[$sel:chainSlot:NetworkConnected] :: StateChanged tx -> ChainSlot
IgnoredHeadInitializing :: HeadId -> ContestationPeriod -> [Party] -> [OnChainId] -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:contestationPeriod:NetworkConnected] :: StateChanged tx -> ContestationPeriod
[$sel:parties:NetworkConnected] :: StateChanged tx -> [Party]
[$sel:participants:NetworkConnected] :: StateChanged tx -> [OnChainId]
TxInvalid :: HeadId -> UTxOType tx -> tx -> ValidationError -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:utxo:NetworkConnected] :: StateChanged tx -> UTxOType tx
[$sel:transaction:NetworkConnected] :: StateChanged tx -> tx
[$sel:validationError:NetworkConnected] :: StateChanged tx -> ValidationError
LocalStateCleared :: HeadId -> SnapshotNumber -> StateChanged tx
[$sel:headId:NetworkConnected] :: StateChanged tx -> HeadId
[$sel:snapshotNumber:NetworkConnected] :: StateChanged tx -> SnapshotNumber
Checkpoint :: HeadState tx -> StateChanged tx
[$sel:state:NetworkConnected] :: StateChanged tx -> HeadState tx
data WaitReason tx
WaitOnNotApplicableTx :: ValidationError -> WaitReason tx
[$sel:validationError:WaitOnNotApplicableTx] :: WaitReason tx -> ValidationError
WaitOnSnapshotNumber :: SnapshotNumber -> WaitReason tx
[$sel:waitingForNumber:WaitOnNotApplicableTx] :: WaitReason tx -> SnapshotNumber
WaitOnSnapshotVersion :: SnapshotVersion -> WaitReason tx
[$sel:waitingForVersion:WaitOnNotApplicableTx] :: WaitReason tx -> SnapshotVersion
WaitOnSeenSnapshot :: WaitReason tx
WaitOnTxs :: [TxIdType tx] -> WaitReason tx
[$sel:waitingForTxIds:WaitOnNotApplicableTx] :: WaitReason tx -> [TxIdType tx]
WaitOnContestationDeadline :: WaitReason tx
WaitOnNotApplicableDecommitTx :: DecommitInvalidReason tx -> WaitReason tx
[$sel:notApplicableReason:WaitOnNotApplicableTx] :: WaitReason tx -> DecommitInvalidReason tx
WaitOnUnresolvedCommit :: UTxOType tx -> WaitReason tx
[$sel:commitUTxO:WaitOnNotApplicableTx] :: WaitReason tx -> UTxOType tx
WaitOnUnresolvedDecommit :: tx -> WaitReason tx
[$sel:decommitTx:WaitOnNotApplicableTx] :: WaitReason tx -> tx
WaitOnDepositObserved :: TxIdType tx -> WaitReason tx
[$sel:depositTxId:WaitOnNotApplicableTx] :: WaitReason tx -> TxIdType tx
WaitOnDepositActivation :: TxIdType tx -> WaitReason tx
[$sel:depositTxId:WaitOnNotApplicableTx] :: WaitReason tx -> TxIdType tx
cause :: Effect tx -> Outcome tx
causes :: [Effect tx] -> Outcome tx
changes :: [StateChanged tx] -> Outcome tx
newState :: StateChanged tx -> Outcome tx
noop :: Outcome tx
wait :: WaitReason tx -> Outcome tx

module Hydra.HeadLogic.StateEvent

-- | A state change event with an event id that is the common entity to be
--   loaded from an <tt>EventSource</tt> and sent to <tt>EventSink</tt>s.
data StateEvent tx
StateEvent :: EventId -> StateChanged tx -> UTCTime -> StateEvent tx
[$sel:eventId:StateEvent] :: StateEvent tx -> EventId
[$sel:stateChanged:StateEvent] :: StateEvent tx -> StateChanged tx
[$sel:time:StateEvent] :: StateEvent tx -> UTCTime
genStateEvent :: StateChanged tx -> Gen (StateEvent tx)
mkCheckpoint :: HeadState tx -> EventId -> UTCTime -> StateEvent tx
instance GHC.Generics.Generic (Hydra.HeadLogic.StateEvent.StateEvent tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Show.Show (Hydra.HeadLogic.StateEvent.StateEvent tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Classes.Eq (Hydra.HeadLogic.StateEvent.StateEvent tx)
instance Hydra.Chain.ChainState.IsChainState tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.HeadLogic.StateEvent.StateEvent tx)
instance Hydra.Chain.ChainState.IsChainState tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.HeadLogic.StateEvent.StateEvent tx)
instance Hydra.Events.HasEventId (Hydra.HeadLogic.StateEvent.StateEvent tx)
instance (Hydra.Tx.IsTx.ArbitraryIsTx tx, Hydra.Chain.ChainState.IsChainState tx) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.HeadLogic.StateEvent.StateEvent tx)

module Hydra.API.ServerOutputFilter
newtype ServerOutputFilter tx
ServerOutputFilter :: (TimedServerOutput tx -> Text -> Bool) -> ServerOutputFilter tx
[$sel:txContainsAddr:ServerOutputFilter] :: ServerOutputFilter tx -> TimedServerOutput tx -> Text -> Bool
serverOutputFilter :: ServerOutputFilter Tx
matchingAddr :: Text -> Tx -> Bool

module Hydra.API.HTTPServer
newtype DraftCommitTxResponse tx
DraftCommitTxResponse :: tx -> DraftCommitTxResponse tx
[$sel:commitTx:DraftCommitTxResponse] :: DraftCommitTxResponse tx -> tx
data DraftCommitTxRequest tx
SimpleCommitRequest :: UTxOType tx -> DraftCommitTxRequest tx
[$sel:utxoToCommit:SimpleCommitRequest] :: DraftCommitTxRequest tx -> UTxOType tx
FullCommitRequest :: tx -> UTxOType tx -> DraftCommitTxRequest tx
[$sel:blueprintTx:SimpleCommitRequest] :: DraftCommitTxRequest tx -> tx
[$sel:utxo:SimpleCommitRequest] :: DraftCommitTxRequest tx -> UTxOType tx
newtype SubmitTxRequest tx
SubmitTxRequest :: tx -> SubmitTxRequest tx
[$sel:txToSubmit:SubmitTxRequest] :: SubmitTxRequest tx -> tx
data TransactionSubmitted
TransactionSubmitted :: TransactionSubmitted
newtype SideLoadSnapshotRequest tx
SideLoadSnapshotRequest :: ConfirmedSnapshot tx -> SideLoadSnapshotRequest tx
[$sel:snapshot:SideLoadSnapshotRequest] :: SideLoadSnapshotRequest tx -> ConfirmedSnapshot tx

-- | Request to submit a transaction to the head
newtype SubmitL2TxRequest tx
SubmitL2TxRequest :: tx -> SubmitL2TxRequest tx
[$sel:submitL2Tx:SubmitL2TxRequest] :: SubmitL2TxRequest tx -> tx

-- | Response for transaction submission
data SubmitL2TxResponse

-- | Transaction was included in a confirmed snapshot
SubmitTxConfirmed :: Integer -> SubmitL2TxResponse

-- | Transaction was rejected due to validation errors
SubmitTxInvalidResponse :: Text -> SubmitL2TxResponse

-- | Transaction was accepted but not yet confirmed
SubmitTxSubmitted :: SubmitL2TxResponse
jsonContent :: ResponseHeaders

-- | Hydra HTTP server
httpApp :: forall tx. IsChainState tx => Tracer IO APIServerLog -> Chain tx IO -> Environment -> PParams LedgerEra -> IO (HeadState tx) -> IO CommitInfo -> IO [TxIdType tx] -> (ClientInput tx -> IO ()) -> ApiTransactionTimeout -> TChan (Either (TimedServerOutput tx) (ClientMessage tx)) -> Application

-- | Handle request to obtain a draft commit tx.
handleDraftCommitUtxo :: forall tx. IsChainState tx => Environment -> PParams LedgerEra -> Chain tx IO -> IO CommitInfo -> ByteString -> IO Response

-- | Handle request to recover a pending deposit.
handleRecoverCommitUtxo :: forall tx. IsChainState tx => (ClientInput tx -> IO ()) -> Text -> ByteString -> IO Response

-- | Handle request to submit a cardano transaction.
handleSubmitUserTx :: forall tx. FromJSON tx => Chain tx IO -> ByteString -> IO Response
handleDecommit :: forall tx. FromJSON tx => (ClientInput tx -> IO ()) -> ByteString -> IO Response

-- | Handle request to side load confirmed snapshot.
handleSideLoadSnapshot :: forall tx. IsChainState tx => (ClientInput tx -> IO ()) -> ByteString -> IO Response

-- | Handle request to submit a transaction to the head.
handleSubmitL2Tx :: forall tx. IsChainState tx => (ClientInput tx -> IO ()) -> ApiTransactionTimeout -> TChan (Either (TimedServerOutput tx) (ClientMessage tx)) -> ByteString -> IO Response
badRequest :: IsChainState tx => PostTxError tx -> Response
notFound :: Response
okJSON :: ToJSON a => a -> Response
instance GHC.Generics.Generic (Hydra.API.HTTPServer.DraftCommitTxResponse tx)
instance GHC.Generics.Generic (Hydra.API.HTTPServer.DraftCommitTxRequest tx)
instance Data.Aeson.Types.FromJSON.FromJSON tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.API.HTTPServer.SubmitTxRequest tx)
instance Data.Aeson.Types.ToJSON.ToJSON tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.API.HTTPServer.SubmitTxRequest tx)
instance Test.QuickCheck.Arbitrary.Arbitrary tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.API.HTTPServer.SubmitTxRequest tx)
instance GHC.Show.Show tx => GHC.Show.Show (Hydra.API.HTTPServer.SubmitTxRequest tx)
instance GHC.Classes.Eq tx => GHC.Classes.Eq (Hydra.API.HTTPServer.SubmitTxRequest tx)
instance GHC.Generics.Generic Hydra.API.HTTPServer.TransactionSubmitted
instance GHC.Show.Show Hydra.API.HTTPServer.TransactionSubmitted
instance GHC.Classes.Eq Hydra.API.HTTPServer.TransactionSubmitted
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.API.HTTPServer.SideLoadSnapshotRequest tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.API.HTTPServer.SideLoadSnapshotRequest tx)
instance GHC.Generics.Generic (Hydra.API.HTTPServer.SideLoadSnapshotRequest tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Show.Show (Hydra.API.HTTPServer.SideLoadSnapshotRequest tx)
instance Hydra.Tx.IsTx.IsTx tx => GHC.Classes.Eq (Hydra.API.HTTPServer.SideLoadSnapshotRequest tx)
instance Data.Aeson.Types.FromJSON.FromJSON tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.API.HTTPServer.SubmitL2TxRequest tx)
instance Data.Aeson.Types.ToJSON.ToJSON tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.API.HTTPServer.SubmitL2TxRequest tx)
instance Test.QuickCheck.Arbitrary.Arbitrary tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.API.HTTPServer.SubmitL2TxRequest tx)
instance GHC.Show.Show tx => GHC.Show.Show (Hydra.API.HTTPServer.SubmitL2TxRequest tx)
instance GHC.Classes.Eq tx => GHC.Classes.Eq (Hydra.API.HTTPServer.SubmitL2TxRequest tx)
instance GHC.Generics.Generic Hydra.API.HTTPServer.SubmitL2TxResponse
instance GHC.Show.Show Hydra.API.HTTPServer.SubmitL2TxResponse
instance GHC.Classes.Eq Hydra.API.HTTPServer.SubmitL2TxResponse
instance GHC.Show.Show tx => GHC.Show.Show (Hydra.API.HTTPServer.DraftCommitTxResponse tx)
instance (GHC.Classes.Eq tx, GHC.Classes.Eq (Hydra.Tx.IsTx.UTxOType tx)) => GHC.Classes.Eq (Hydra.API.HTTPServer.DraftCommitTxRequest tx)
instance (GHC.Show.Show tx, GHC.Show.Show (Hydra.Tx.IsTx.UTxOType tx)) => GHC.Show.Show (Hydra.API.HTTPServer.DraftCommitTxRequest tx)
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.API.HTTPServer.SubmitL2TxResponse
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.API.HTTPServer.SubmitL2TxResponse
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.API.HTTPServer.SubmitL2TxResponse
instance (Test.QuickCheck.Arbitrary.Arbitrary tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Tx.IsTx.UTxOType tx), Hydra.Tx.IsTx.IsTx tx) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.API.HTTPServer.SideLoadSnapshotRequest tx)
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.API.HTTPServer.TransactionSubmitted
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.API.HTTPServer.TransactionSubmitted
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.API.HTTPServer.TransactionSubmitted
instance (Data.Aeson.Types.ToJSON.ToJSON tx, Data.Aeson.Types.ToJSON.ToJSON (Hydra.Tx.IsTx.UTxOType tx)) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.API.HTTPServer.DraftCommitTxRequest tx)
instance (Data.Aeson.Types.FromJSON.FromJSON tx, Data.Aeson.Types.FromJSON.FromJSON (Hydra.Tx.IsTx.UTxOType tx)) => Data.Aeson.Types.FromJSON.FromJSON (Hydra.API.HTTPServer.DraftCommitTxRequest tx)
instance (Test.QuickCheck.Arbitrary.Arbitrary tx, Test.QuickCheck.Arbitrary.Arbitrary (Hydra.Tx.IsTx.UTxOType tx)) => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.API.HTTPServer.DraftCommitTxRequest tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.API.HTTPServer.DraftCommitTxResponse tx)
instance Hydra.Tx.IsTx.IsTx tx => Data.Aeson.Types.FromJSON.FromJSON (Hydra.API.HTTPServer.DraftCommitTxResponse tx)
instance Test.QuickCheck.Arbitrary.Arbitrary tx => Test.QuickCheck.Arbitrary.Arbitrary (Hydra.API.HTTPServer.DraftCommitTxResponse tx)


-- | The general input queue from which the Hydra head is fed with inputs.
module Hydra.Node.InputQueue

-- | The single, required queue in the system from which a hydra head is
--   "fed". NOTE(SN): this probably should be bounded and include proper
--   logging NOTE(SN): handle pattern, but likely not required as there is
--   no need for an alternative implementation
data InputQueue m e
InputQueue :: (e -> m ()) -> (DiffTime -> Queued e -> m ()) -> m (Queued e) -> m Bool -> InputQueue m e
[$sel:enqueue:InputQueue] :: InputQueue m e -> e -> m ()
[$sel:reenqueue:InputQueue] :: InputQueue m e -> DiffTime -> Queued e -> m ()
[$sel:dequeue:InputQueue] :: InputQueue m e -> m (Queued e)
[$sel:isEmpty:InputQueue] :: InputQueue m e -> m Bool
data Queued a
Queued :: Word64 -> a -> Queued a
[$sel:queuedId:Queued] :: Queued a -> Word64
[$sel:queuedItem:Queued] :: Queued a -> a
createInputQueue :: (MonadDelay m, MonadAsync m, MonadLabelledSTM m) => m (InputQueue m e)


-- | Concrete <a>Network</a> stack used in a hydra-node.
--   
--   This module provides a <a>withNetwork</a> function which is the
--   composition of several layers in order to provide various
--   capabilities:
--   
--   <ul>
--   <li><a>withAuthentication</a> handles messages' authentication and
--   signature verification</li>
--   <li><a>withEtcdNetwork</a> uses an <tt>etcd</tt> cluster to implement
--   reliable broadcast</li>
--   </ul>
--   
--   The following diagram details the various types of messages each layer
--   is exchanging with its predecessors and successors.
--   
--   <pre>
--             ▲
--             │                        │
--         Authenticated msg           msg
--             │                        │
--             │                        │
--   ┌─────────┼────────────────────────▼──────┐
--   │                                         │
--   │               Authenticate              │
--   │                                         │
--   └─────────▲────────────────────────┼──────┘
--             │                        │
--             │                        │
--            msg                      msg
--             │                        │
--   ┌─────────┼────────────────────────▼──────┐
--   │                                         │
--   │                   Etcd                  │
--   │                                         │
--   └─────────▲────────────────────────┼──────┘
--             │                        │
--             │        (bytes)         │
--             │                        ▼
--   </pre>
module Hydra.Node.Network

-- | Configuration for a <tt>Node</tt> network layer.
data NetworkConfiguration
NetworkConfiguration :: FilePath -> SigningKey HydraKey -> [Party] -> Host -> Host -> [Host] -> NodeId -> WhichEtcd -> NetworkConfiguration

-- | Persistence directory
[$sel:persistenceDir:NetworkConfiguration] :: NetworkConfiguration -> FilePath

-- | This node's signing key. This is used to sign messages sent to peers.
[$sel:signingKey:NetworkConfiguration] :: NetworkConfiguration -> SigningKey HydraKey

-- | The list of peers <a>Party</a> known to this node.
[$sel:otherParties:NetworkConfiguration] :: NetworkConfiguration -> [Party]

-- | Address to listen on for incoming connections.
[$sel:listen:NetworkConfiguration] :: NetworkConfiguration -> Host

-- | Address to advertise to peers.
[$sel:advertise:NetworkConfiguration] :: NetworkConfiguration -> Host

-- | Addresses and ports of remote peers.
[$sel:peers:NetworkConfiguration] :: NetworkConfiguration -> [Host]

-- | This node's id.
[$sel:nodeId:NetworkConfiguration] :: NetworkConfiguration -> NodeId

-- | Whether to use the system etcd (on the path) or the embedded one.
[$sel:whichEtcd:NetworkConfiguration] :: NetworkConfiguration -> WhichEtcd

-- | Starts the network layer of a node, passing configured
--   <tt>Network</tt> to its continuation.
withNetwork :: forall tx. IsTx tx => Tracer IO NetworkLog -> NetworkConfiguration -> NetworkComponent IO (Authenticated (Message tx)) (Message tx) ()
data NetworkLog
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Node.Network.NetworkLog
instance GHC.Generics.Generic Hydra.Node.Network.NetworkLog
instance GHC.Show.Show Hydra.Node.Network.NetworkLog
instance GHC.Classes.Eq Hydra.Node.Network.NetworkLog


-- | Structured errors related to configuration mismatch.
--   
--   When we start a <a>Node</a> we need to do sanity checks between what's
--   provided as parameters to the node and what's persisted.
module Hydra.Node.ParameterMismatch

-- | Exception used to indicate command line options not matching the
--   persisted state.
newtype ParameterMismatch
ParameterMismatch :: [ParamMismatch] -> ParameterMismatch
data ParamMismatch
ContestationPeriodMismatch :: ContestationPeriod -> ContestationPeriod -> ParamMismatch
[$sel:loadedCp:ContestationPeriodMismatch] :: ParamMismatch -> ContestationPeriod
[$sel:configuredCp:ContestationPeriodMismatch] :: ParamMismatch -> ContestationPeriod
PartiesMismatch :: [Party] -> [Party] -> ParamMismatch
[$sel:loadedParties:ContestationPeriodMismatch] :: ParamMismatch -> [Party]
[$sel:configuredParties:ContestationPeriodMismatch] :: ParamMismatch -> [Party]
SavedNetworkPartiesInconsistent :: Int -> ParamMismatch
[$sel:numberOfParties:ContestationPeriodMismatch] :: ParamMismatch -> Int
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Node.ParameterMismatch.ParamMismatch
instance GHC.Show.Show Hydra.Node.ParameterMismatch.ParamMismatch
instance GHC.Classes.Eq Hydra.Node.ParameterMismatch.ParamMismatch
instance GHC.Generics.Generic Hydra.Node.ParameterMismatch.ParamMismatch
instance GHC.Exception.Type.Exception Hydra.Node.ParameterMismatch.ParameterMismatch
instance GHC.Show.Show Hydra.Node.ParameterMismatch.ParameterMismatch
instance GHC.Classes.Eq Hydra.Node.ParameterMismatch.ParameterMismatch

module Hydra.Node.Util
readKeyPair :: FilePath -> IO (VerificationKey PaymentKey, SigningKey PaymentKey)
readFileTextEnvelopeThrow :: HasTextEnvelope a => FilePath -> IO a


-- | Handles to save/load files across the hydra-node. We use a simple JSON
--   encoding and two modes of operation to store things: Full and
--   Incremental.
module Hydra.Persistence
newtype PersistenceException
PersistenceException :: String -> PersistenceException

-- | Handle to save and load files to/from disk using JSON encoding.
data Persistence a m
Persistence :: (ToJSON a => a -> m ()) -> (FromJSON a => m (Maybe a)) -> Persistence a m
[$sel:save:Persistence] :: Persistence a m -> ToJSON a => a -> m ()
[$sel:load:Persistence] :: Persistence a m -> FromJSON a => m (Maybe a)

-- | Initialize persistence handle for given type <tt>a</tt> at given file
--   path.
createPersistence :: (MonadIO m, MonadThrow m) => FilePath -> m (Persistence a m)

-- | Handle to save incrementally and load files to/from disk using JSON
--   encoding.
data PersistenceIncremental a m
PersistenceIncremental :: (ToJSON a => a -> m ()) -> (FromJSON a => ConduitT () a (ResourceT m) ()) -> PersistenceIncremental a m
[$sel:append:PersistenceIncremental] :: PersistenceIncremental a m -> ToJSON a => a -> m ()

-- | Stream all elements from the file.
[$sel:source:PersistenceIncremental] :: PersistenceIncremental a m -> FromJSON a => ConduitT () a (ResourceT m) ()

-- | Load all elements from persistence into a list. XXX: Deprecate this to
--   avoid large memory usage.
loadAll :: (FromJSON a, MonadUnliftIO m) => PersistenceIncremental a m -> m [a]

-- | Initialize persistence handle for given type <tt>a</tt> at given file
--   path.
--   
--   This instance of <a>PersistenceIncremental</a> is "thread-safe" in the
--   sense that it prevents appending while a source is still running
--   (while ResourceT is still not fully unwrapped.
createPersistenceIncremental :: forall a m. (MonadUnliftIO m, MonadThrow m, FromJSON a) => FilePath -> m (PersistenceIncremental a m)
instance GHC.Show.Show Hydra.Persistence.PersistenceException
instance GHC.Classes.Eq Hydra.Persistence.PersistenceException
instance GHC.Exception.Type.Exception Hydra.Persistence.PersistenceException


-- | A file-based event source and sink using JSON encoding.
--   
--   This is currently used as the main event source and sink in the
--   hydra-node.
module Hydra.Events.FileBased

-- | A basic file based event source and sink defined using a rotated
--   <a>PersistenceIncremental</a> handle.
mkFileBasedEventStore :: (ToJSON e, FromJSON e, HasEventId e) => FilePath -> PersistenceIncremental e IO -> IO (EventStore e IO)

module Hydra.NetworkVersions
hydraNodeVersion :: Version
networkVersions :: ByteString
parseNetworkTxIds :: forall m. MonadFail m => Version -> String -> m [TxId]

module Hydra.Options
data Command
Run :: RunOptions -> Command
Publish :: PublishOptions -> Command
GenHydraKey :: GenerateKeyPair -> Command
data ChainBackendOptions
Direct :: DirectOptions -> ChainBackendOptions
Blockfrost :: BlockfrostOptions -> ChainBackendOptions
newtype BlockfrostOptions
BlockfrostOptions :: FilePath -> BlockfrostOptions

-- | Path to the blockfrost project file
[$sel:projectPath:BlockfrostOptions] :: BlockfrostOptions -> FilePath
data CardanoChainConfig
CardanoChainConfig :: [TxId] -> FilePath -> [FilePath] -> Maybe ChainPoint -> ContestationPeriod -> DepositPeriod -> ChainBackendOptions -> CardanoChainConfig

-- | Identifier of transaction holding the hydra scripts to use.
[$sel:hydraScriptsTxId:CardanoChainConfig] :: CardanoChainConfig -> [TxId]

-- | Path to the cardano signing key of the internal wallet.
[$sel:cardanoSigningKey:CardanoChainConfig] :: CardanoChainConfig -> FilePath

-- | Paths to other node's verification keys.
[$sel:cardanoVerificationKeys:CardanoChainConfig] :: CardanoChainConfig -> [FilePath]

-- | Point at which to start following the chain.
[$sel:startChainFrom:CardanoChainConfig] :: CardanoChainConfig -> Maybe ChainPoint
[$sel:contestationPeriod:CardanoChainConfig] :: CardanoChainConfig -> ContestationPeriod
[$sel:depositPeriod:CardanoChainConfig] :: CardanoChainConfig -> DepositPeriod
[$sel:chainBackendOptions:CardanoChainConfig] :: CardanoChainConfig -> ChainBackendOptions
data DirectOptions
DirectOptions :: NetworkId -> SocketPath -> DirectOptions

-- | Network identifier to which we expect to connect.
[$sel:networkId:DirectOptions] :: DirectOptions -> NetworkId

-- | Path to a domain socket used to connect to the server.
[$sel:nodeSocket:DirectOptions] :: DirectOptions -> SocketPath
data OfflineChainConfig
OfflineChainConfig :: HeadSeed -> FilePath -> Maybe FilePath -> OfflineChainConfig

-- | Manually provided seed of the offline head.
[$sel:offlineHeadSeed:OfflineChainConfig] :: OfflineChainConfig -> HeadSeed

-- | Path to a json encoded starting <tt>UTxO</tt> for the offline-mode
--   head.
[$sel:initialUTxOFile:OfflineChainConfig] :: OfflineChainConfig -> FilePath

-- | Path to a shelley genesis file with slot lengths used by the
--   offline-mode chain.
[$sel:ledgerGenesisFile:OfflineChainConfig] :: OfflineChainConfig -> Maybe FilePath
data RunOptions
RunOptions :: Verbosity -> NodeId -> Host -> Maybe Host -> [Host] -> IP -> PortNumber -> Maybe FilePath -> Maybe FilePath -> Maybe PortNumber -> FilePath -> [FilePath] -> FilePath -> Maybe Natural -> ChainConfig -> LedgerConfig -> WhichEtcd -> ApiTransactionTimeout -> RunOptions
[$sel:verbosity:RunOptions] :: RunOptions -> Verbosity
[$sel:nodeId:RunOptions] :: RunOptions -> NodeId
[$sel:listen:RunOptions] :: RunOptions -> Host
[$sel:advertise:RunOptions] :: RunOptions -> Maybe Host
[$sel:peers:RunOptions] :: RunOptions -> [Host]
[$sel:apiHost:RunOptions] :: RunOptions -> IP
[$sel:apiPort:RunOptions] :: RunOptions -> PortNumber
[$sel:tlsCertPath:RunOptions] :: RunOptions -> Maybe FilePath
[$sel:tlsKeyPath:RunOptions] :: RunOptions -> Maybe FilePath
[$sel:monitoringPort:RunOptions] :: RunOptions -> Maybe PortNumber
[$sel:hydraSigningKey:RunOptions] :: RunOptions -> FilePath
[$sel:hydraVerificationKeys:RunOptions] :: RunOptions -> [FilePath]
[$sel:persistenceDir:RunOptions] :: RunOptions -> FilePath
[$sel:persistenceRotateAfter:RunOptions] :: RunOptions -> Maybe Natural
[$sel:chainConfig:RunOptions] :: RunOptions -> ChainConfig
[$sel:ledgerConfig:RunOptions] :: RunOptions -> LedgerConfig
[$sel:whichEtcd:RunOptions] :: RunOptions -> WhichEtcd
[$sel:apiTransactionTimeout:RunOptions] :: RunOptions -> ApiTransactionTimeout
data ChainConfig
Offline :: OfflineChainConfig -> ChainConfig
Cardano :: CardanoChainConfig -> ChainConfig
data InvalidOptions
MaximumNumberOfPartiesExceeded :: InvalidOptions
CardanoAndHydraKeysMismatch :: InvalidOptions
newtype LedgerConfig
CardanoLedgerConfig :: FilePath -> LedgerConfig
[$sel:cardanoLedgerProtocolParametersFile:CardanoLedgerConfig] :: LedgerConfig -> FilePath
newtype GenerateKeyPair
GenerateKeyPair :: FilePath -> GenerateKeyPair
[$sel:outputFile:GenerateKeyPair] :: GenerateKeyPair -> FilePath
data PublishOptions
PublishOptions :: ChainBackendOptions -> FilePath -> PublishOptions
[$sel:chainBackendOptions:PublishOptions] :: PublishOptions -> ChainBackendOptions
[$sel:publishSigningKey:PublishOptions] :: PublishOptions -> FilePath
data BlockfrostChainConfig
BlockfrostChainConfig :: FilePath -> FilePath -> [TxId] -> BlockfrostChainConfig

-- | Path to the blockfrost project file
[$sel:projectPath:BlockfrostChainConfig] :: BlockfrostChainConfig -> FilePath

-- | Path to the cardano signing key of the internal wallet.
[$sel:cardanoSigningKey:BlockfrostChainConfig] :: BlockfrostChainConfig -> FilePath

-- | Identifier of transaction holding the hydra scripts to use.
[$sel:hydraScriptsTxId:BlockfrostChainConfig] :: BlockfrostChainConfig -> [TxId]

-- | Convert an <tt>Options</tt> instance into the corresponding list of
--   command-line arguments.
--   
--   This is useful in situations where one wants to programmatically
--   define <tt>Options</tt>, providing some measure of type safety,
--   without having to juggle with strings.
toArgs :: RunOptions -> [String]
defaultContestationPeriod :: ContestationPeriod
defaultDepositPeriod :: DepositPeriod

-- | Validate cmd line arguments for hydra-node and check if they make
--   sense before actually running the node. Rules we apply: - Check if
--   number of parties is bigger than our hardcoded limit (by looking at
--   loaded hydra or cardano keys and comparing it to the
--   <a>maximumNumberOfParties</a>) - Check that number of loaded hydra
--   keys match with the number of loaded cardano keys (by comparing
--   lengths of the two lists)
validateRunOptions :: RunOptions -> Either InvalidOptions ()
genChainPoint :: Gen ChainPoint
commandParser :: Parser Command

-- | Parser for running the cardano-node with all its <a>RunOptions</a>.
runOptionsParser :: Parser RunOptions
publishOptionsParser :: Parser PublishOptions
outputFileParser :: Parser FilePath

-- | Default options as they should also be provided by
--   <a>runOptionsParser</a>.
defaultPublishOptions :: PublishOptions
defaultDirectOptions :: DirectOptions
chainBackendOptionsParser :: Parser ChainBackendOptions
cardanoSigningKeyFileParser :: Parser FilePath
genFilePath :: String -> Gen FilePath
genDirPath :: Gen FilePath

-- | Default options as they should also be provided by
--   <a>runOptionsParser</a>.
defaultRunOptions :: RunOptions
defaultCardanoChainConfig :: CardanoChainConfig
defaultLedgerConfig :: LedgerConfig
verbosityParser :: Parser Verbosity
nodeIdParser :: Parser NodeId
listenParser :: Parser Host
advertiseParser :: Parser Host
peerParser :: Parser Host
apiHostParser :: Parser IP
apiPortParser :: Parser PortNumber
tlsCertPathParser :: Parser FilePath
tlsKeyPathParser :: Parser FilePath
monitoringPortParser :: Parser PortNumber
hydraSigningKeyFileParser :: Parser FilePath
hydraVerificationKeyFileParser :: Parser FilePath
persistenceDirParser :: Parser FilePath
persistenceRotateAfterParser :: Parser Natural
chainConfigParser :: Parser ChainConfig
ledgerConfigParser :: Parser LedgerConfig
whichEtcdParser :: Parser WhichEtcd
apiTransactionTimeoutParser :: Parser ApiTransactionTimeout
cardanoChainConfigParser :: Parser CardanoChainConfig
offlineChainConfigParser :: Parser OfflineChainConfig
networkIdParser :: Parser NetworkId
nodeSocketParser :: Parser SocketPath
blockfrostProjectPathParser :: Parser FilePath
cardanoLedgerProtocolParametersParser :: Parser FilePath
offlineHeadSeedParser :: Parser HeadSeed
initialUTxOFileParser :: Parser FilePath
ledgerGenesisFileParser :: Parser (Maybe FilePath)
hydraScriptsTxIdsParser :: Parser [TxId]
hydraScriptsTxIdParser :: Parser TxId
hydraScriptsDefaultParser :: Parser [TxId]
cardanoVerificationKeyFileParser :: Parser FilePath
startChainFromParser :: Parser ChainPoint
contestationPeriodParser :: Parser ContestationPeriod
depositPeriodParser :: Parser DepositPeriod
defaultApiTransactionTimeout :: ApiTransactionTimeout
hydraNodeCommand :: ParserInfo Command

-- | Parse command-line arguments into a <tt>Option</tt> or exit with
--   failure and error message.
parseHydraCommand :: IO Command

-- | Pure parsing of <tt>Option</tt> from a list of arguments.
parseHydraCommandFromArgs :: [String] -> ParserResult Command
toArgApiPort :: PortNumber -> [String]
toArgNetworkId :: NetworkId -> [String]
toArgNodeSocket :: SocketPath -> [String]
data () => ParserResult a
Success :: a -> ParserResult a
Failure :: ParserFailure ParserHelp -> ParserResult a
CompletionInvoked :: CompletionResult -> ParserResult a
renderFailure :: ParserFailure ParserHelp -> String -> (String, ExitCode)
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Options.DirectOptions
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Options.DirectOptions
instance GHC.Classes.Eq Hydra.Options.DirectOptions
instance GHC.Show.Show Hydra.Options.DirectOptions
instance GHC.Generics.Generic Hydra.Options.DirectOptions
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Options.BlockfrostOptions
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Options.BlockfrostOptions
instance GHC.Classes.Eq Hydra.Options.BlockfrostOptions
instance GHC.Show.Show Hydra.Options.BlockfrostOptions
instance GHC.Generics.Generic Hydra.Options.BlockfrostOptions
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Options.ChainBackendOptions
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Options.ChainBackendOptions
instance GHC.Classes.Eq Hydra.Options.ChainBackendOptions
instance GHC.Show.Show Hydra.Options.ChainBackendOptions
instance GHC.Generics.Generic Hydra.Options.ChainBackendOptions
instance GHC.Generics.Generic Hydra.Options.PublishOptions
instance GHC.Classes.Eq Hydra.Options.PublishOptions
instance GHC.Show.Show Hydra.Options.PublishOptions
instance GHC.Show.Show Hydra.Options.GenerateKeyPair
instance GHC.Classes.Eq Hydra.Options.GenerateKeyPair
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Options.LedgerConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Options.LedgerConfig
instance GHC.Generics.Generic Hydra.Options.LedgerConfig
instance GHC.Show.Show Hydra.Options.LedgerConfig
instance GHC.Classes.Eq Hydra.Options.LedgerConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Options.OfflineChainConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Options.OfflineChainConfig
instance GHC.Generics.Generic Hydra.Options.OfflineChainConfig
instance GHC.Show.Show Hydra.Options.OfflineChainConfig
instance GHC.Classes.Eq Hydra.Options.OfflineChainConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Options.CardanoChainConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Options.CardanoChainConfig
instance GHC.Generics.Generic Hydra.Options.CardanoChainConfig
instance GHC.Show.Show Hydra.Options.CardanoChainConfig
instance GHC.Classes.Eq Hydra.Options.CardanoChainConfig
instance GHC.Generics.Generic Hydra.Options.ChainConfig
instance GHC.Show.Show Hydra.Options.ChainConfig
instance GHC.Classes.Eq Hydra.Options.ChainConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Options.RunOptions
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Options.RunOptions
instance GHC.Generics.Generic Hydra.Options.RunOptions
instance GHC.Show.Show Hydra.Options.RunOptions
instance GHC.Classes.Eq Hydra.Options.RunOptions
instance GHC.Classes.Eq Hydra.Options.Command
instance GHC.Show.Show Hydra.Options.Command
instance GHC.Generics.Generic Hydra.Options.BlockfrostChainConfig
instance GHC.Show.Show Hydra.Options.BlockfrostChainConfig
instance GHC.Classes.Eq Hydra.Options.BlockfrostChainConfig
instance GHC.Show.Show Hydra.Options.InvalidOptions
instance GHC.Classes.Eq Hydra.Options.InvalidOptions
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Options.RunOptions
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Options.ChainConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Options.ChainConfig
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Options.ChainConfig
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Options.LedgerConfig
instance Test.QuickCheck.Arbitrary.Arbitrary Data.IP.Addr.IP

module Hydra.Utils
genHydraKeys :: GenerateKeyPair -> IO (Either (FileError ()) ())
readJsonFileThrow :: (Value -> Parser a) -> FilePath -> IO a

module Hydra.Chain.Offline

-- | Derived <a>HeadId</a> of offline head from a <a>HeadSeed</a>.
offlineHeadId :: HeadSeed -> HeadId
newtype InitialUTxOParseException
InitialUTxOParseException :: String -> InitialUTxOParseException

-- | Load the given genesis file or use defaults specific to the offline
--   mode. Throws: <a>InitialUTxOParseException</a> if the initial UTXO
--   file could not be parsed.
loadGenesisFile :: Maybe FilePath -> IO (GenesisParameters ShelleyEra)
withOfflineChain :: OfflineChainConfig -> Party -> [Party] -> ChainStateHistory Tx -> ChainComponent Tx IO a
tickForever :: GenesisParameters ShelleyEra -> (ChainEvent Tx -> IO ()) -> IO ()
instance GHC.Show.Show Hydra.Chain.Offline.InitialUTxOParseException
instance GHC.Exception.Type.Exception Hydra.Chain.Offline.InitialUTxOParseException

module Hydra.Chain.Backend
blockfrostProjectPath :: FilePath
class ChainBackend a
queryGenesisParameters :: (ChainBackend a, MonadIO m, MonadThrow m) => a -> m (GenesisParameters ShelleyEra)
queryScriptRegistry :: (ChainBackend a, MonadIO m, MonadThrow m) => a -> [TxId] -> m ScriptRegistry
queryNetworkId :: (ChainBackend a, MonadIO m, MonadThrow m) => a -> m NetworkId
queryTip :: (ChainBackend a, MonadIO m, MonadThrow m) => a -> m ChainPoint
queryUTxO :: (ChainBackend a, MonadIO m, MonadThrow m) => a -> [Address ShelleyAddr] -> m UTxO
queryUTxOByTxIn :: (ChainBackend a, MonadIO m, MonadThrow m) => a -> [TxIn] -> m UTxO
queryEraHistory :: (ChainBackend a, MonadIO m, MonadThrow m) => a -> QueryPoint -> m EraHistory
querySystemStart :: (ChainBackend a, MonadIO m, MonadThrow m) => a -> QueryPoint -> m SystemStart
queryProtocolParameters :: (ChainBackend a, MonadIO m, MonadThrow m) => a -> QueryPoint -> m (PParams LedgerEra)
queryStakePools :: (ChainBackend a, MonadIO m, MonadThrow m) => a -> QueryPoint -> m (Set PoolId)
queryUTxOFor :: (ChainBackend a, MonadIO m, MonadThrow m) => a -> QueryPoint -> VerificationKey PaymentKey -> m UTxO
submitTransaction :: (ChainBackend a, MonadIO m, MonadThrow m) => a -> Tx -> m ()
awaitTransaction :: (ChainBackend a, MonadIO m, MonadThrow m) => a -> Tx -> VerificationKey PaymentKey -> m UTxO
getOptions :: ChainBackend a => a -> ChainBackendOptions
getBlockTime :: ChainBackend a => a -> (MonadIO m, MonadThrow m) => m NominalDiffTime
buildTransaction :: ChainBackend backend => backend -> AddressInEra -> UTxO -> [TxIn] -> [TxOut CtxTx] -> IO (Either (TxBodyErrorAutoBalance Era) Tx)

-- | Construct a simple payment consuming some inputs and producing some
--   outputs (no certificates or withdrawals involved).
--   
--   On success, the returned transaction is fully balanced. On error,
--   return <a>TxBodyErrorAutoBalance</a>.
buildTransactionWithPParams :: ChainBackend backend => PParams LedgerEra -> backend -> AddressInEra -> UTxO -> [TxIn] -> [TxOut CtxTx] -> IO (Either (TxBodyErrorAutoBalance Era) Tx)
buildTransactionWithPParams' :: PParams LedgerEra -> SystemStart -> EraHistory -> Set PoolId -> AddressInEra -> UTxO -> [TxIn] -> [TxOut CtxTx] -> Either (TxBodyErrorAutoBalance Era) Tx
buildTransactionWithBody :: PParams LedgerEra -> SystemStart -> EraHistory -> Set PoolId -> AddressInEra -> TxBodyContent BuildTx -> UTxO -> Either (TxBodyErrorAutoBalance Era) Tx


-- | A data-type to keep track of reference Hydra scripts published
--   on-chain, and needed to construct transactions leveraging reference
--   inputs.
module Hydra.Chain.ScriptRegistry

-- | Query for <a>TxIn</a>s in the search for outputs containing all the
--   reference scripts of the <a>ScriptRegistry</a>.
--   
--   This is implemented by repeated querying until we have all necessary
--   reference scripts as we do only know the transaction id, not the
--   indices.
--   
--   Can throw at least <tt>NewScriptRegistryException</tt> on failure.
queryScriptRegistry :: (MonadIO m, MonadThrow m, ChainBackend backend) => backend -> [TxId] -> m ScriptRegistry
publishHydraScripts :: ChainBackend backend => backend -> SigningKey PaymentKey -> IO [TxId]

-- | Exception raised when building the script publishing transactions.
newtype PublishScriptException
FailedToBuildPublishingTx :: TxBodyErrorAutoBalance Era -> PublishScriptException

-- | Builds a chain of script publishing transactions. Throws:
--   PublishScriptException
buildScriptPublishingTxs :: MonadThrow m => PParams LedgerEra -> SystemStart -> NetworkId -> EraHistory -> Set PoolId -> UTxO -> SigningKey PaymentKey -> m [Tx]
instance GHC.Exception.Type.Exception Hydra.Chain.ScriptRegistry.PublishScriptException
instance GHC.Show.Show Hydra.Chain.ScriptRegistry.PublishScriptException


-- | Module to deal with time in direct cardano chain layer. Defines the
--   type for a <a>PointInTime</a> and a means to acquire one via a
--   <a>TimeHandle</a> and <a>queryTimeHandle</a>.
module Hydra.Chain.Direct.TimeHandle
data TimeHandle
TimeHandle :: Either Text PointInTime -> (UTCTime -> Either Text SlotNo) -> (SlotNo -> Either Text UTCTime) -> TimeHandle

-- | Get the current <a>PointInTime</a>
[$sel:currentPointInTime:TimeHandle] :: TimeHandle -> Either Text PointInTime

-- | Lookup slot number given a <a>UTCTime</a>. This will fail if the time
--   is outside the "safe zone".
[$sel:slotFromUTCTime:TimeHandle] :: TimeHandle -> UTCTime -> Either Text SlotNo

-- | Convert a slot number to a <a>UTCTime</a> using the stored epoch info.
--   This will fail if the slot is outside the "safe zone".
[$sel:slotToUTCTime:TimeHandle] :: TimeHandle -> SlotNo -> Either Text UTCTime
data TimeHandleParams
TimeHandleParams :: SystemStart -> EraHistory -> SlotNo -> SlotNo -> TimeHandleParams
[$sel:systemStart:TimeHandleParams] :: TimeHandleParams -> SystemStart
[$sel:eraHistory:TimeHandleParams] :: TimeHandleParams -> EraHistory
[$sel:horizonSlot:TimeHandleParams] :: TimeHandleParams -> SlotNo
[$sel:currentSlot:TimeHandleParams] :: TimeHandleParams -> SlotNo

-- | Generate consistent values for <a>SystemStart</a> and
--   <a>EraHistory</a> which has a horizon at the returned SlotNo as well
--   as some UTCTime before that
genTimeParams :: Gen TimeHandleParams

-- | Construct a time handle using current slot and given chain parameters.
--   See <a>queryTimeHandle</a> to create one by querying a cardano-node.
mkTimeHandle :: HasCallStack => SlotNo -> SystemStart -> EraHistory -> TimeHandle

-- | Query the chain for system start and era history before constructing a
--   <a>TimeHandle</a> using the slot at the tip of the network.
queryTimeHandle :: ChainBackend backend => backend -> IO TimeHandle
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Chain.Direct.TimeHandle.TimeHandle


-- | Provide infrastructure-independent "handlers" for posting transactions
--   and following the chain.
--   
--   This module encapsulates the transformation logic between cardano
--   transactions and <tt>HydraNode</tt> abstractions <a>PostChainTx</a>
--   and <a>OnChainTx</a>, and maintenance of on-chain relevant state.
module Hydra.Chain.Direct.Handlers

-- | Handle of a mutable local chain state that is kept in the direct chain
--   layer.
data LocalChainState m tx
LocalChainState :: STM m (ChainStateType tx) -> (ChainStateType tx -> STM m ()) -> (ChainSlot -> STM m (ChainStateType tx)) -> STM m (ChainStateHistory tx) -> LocalChainState m tx
[$sel:getLatest:LocalChainState] :: LocalChainState m tx -> STM m (ChainStateType tx)
[$sel:pushNew:LocalChainState] :: LocalChainState m tx -> ChainStateType tx -> STM m ()
[$sel:rollback:LocalChainState] :: LocalChainState m tx -> ChainSlot -> STM m (ChainStateType tx)
[$sel:history:LocalChainState] :: LocalChainState m tx -> STM m (ChainStateHistory tx)

-- | Initialize a new local chain state from a given chain state history.
newLocalChainState :: forall m tx. (MonadSTM m, IsChainState tx) => ChainStateHistory tx -> m (LocalChainState m tx)

-- | A callback used to actually submit a transaction to the chain.
type SubmitTx m = Tx -> m ()

-- | A way to acquire a <a>TimeHandle</a>
type GetTimeHandle m = m TimeHandle

-- | Create a <a>Chain</a> component for posting "real" cardano
--   transactions.
--   
--   This component does not actually interact with a cardano-node, but
--   creates cardano transactions from <a>PostChainTx</a> transactions
--   emitted by a <tt>HydraNode</tt>, balancing and signing them using
--   given <a>TinyWallet</a>, before handing it off to the given
--   <a>SubmitTx</a> callback. There is also a <tt>draftTx</tt> option for
--   drafting a commit tx on behalf of the user using their selected utxo.
--   
--   NOTE: Given the constraints on <tt>m</tt> this function should work
--   within <tt>IOSim</tt> and does not require any actual <a>IO</a> to
--   happen which makes it highly suitable for simulations and testing.
mkChain :: (MonadSTM m, MonadThrow (STM m)) => Tracer m CardanoChainLog -> GetTimeHandle m -> TinyWallet m -> ChainContext -> LocalChainState m Tx -> SubmitTx m -> Chain Tx m
rejectLowDeposits :: PParams LedgerEra -> UTxO -> Either (PostTxError Tx) ()

-- | Balance and sign the given partial transaction.
finalizeTx :: MonadThrow m => TinyWallet m -> ChainContext -> UTxO -> UTxO -> Tx -> m Tx

-- | A <i>handler</i> that takes care of following the chain.
data ChainSyncHandler m
ChainSyncHandler :: (BlockHeader -> [Tx] -> m ()) -> (ChainPoint -> m ()) -> ChainSyncHandler m
[$sel:onRollForward:ChainSyncHandler] :: ChainSyncHandler m -> BlockHeader -> [Tx] -> m ()
[$sel:onRollBackward:ChainSyncHandler] :: ChainSyncHandler m -> ChainPoint -> m ()

-- | Conversion of a slot number to a time failed. This can be usually be
--   considered an internal error and may be happening because the used era
--   history is too old.
data TimeConversionException
TimeConversionException :: SlotNo -> Text -> TimeConversionException
[$sel:slotNo:TimeConversionException] :: TimeConversionException -> SlotNo
[$sel:reason:TimeConversionException] :: TimeConversionException -> Text

-- | Creates a <a>ChainSyncHandler</a> that can notify the given
--   <tt>callback</tt> of events happening on-chain.
--   
--   This forms the other half of a <tt>ChainComponent</tt> along with
--   <a>mkChain</a> but is decoupled from actual interactions with the
--   chain.
--   
--   A <a>TimeHandle</a> is needed to do `SlotNo -&gt; POSIXTime`
--   conversions for <a>Tick</a> events.
--   
--   Throws <a>TimeConversionException</a> when a received block's
--   <a>SlotNo</a> cannot be converted to a <a>UTCTime</a> with the given
--   <a>TimeHandle</a>.
chainSyncHandler :: forall m. (MonadSTM m, MonadThrow m) => Tracer m CardanoChainLog -> ChainCallback Tx m -> GetTimeHandle m -> ChainContext -> LocalChainState m Tx -> ChainSyncHandler m
convertObservation :: TimeHandle -> HeadObservation -> Maybe (OnChainTx Tx)
prepareTxToPost :: forall m. (MonadSTM m, MonadThrow (STM m)) => TimeHandle -> TinyWallet m -> ChainContext -> UTxOType Tx -> PostChainTx Tx -> STM m Tx

-- | Maximum delay we put on the upper bound of transactions to fit into a
--   block. NOTE: This is highly depending on the network. If the security
--   parameter and epoch length result in a short horizon, this is
--   problematic.
maxGraceTime :: NominalDiffTime
data CardanoChainLog
ToPost :: PostChainTx Tx -> CardanoChainLog
[$sel:toPost:ToPost] :: CardanoChainLog -> PostChainTx Tx
PostingTx :: TxId -> CardanoChainLog
[$sel:txId:ToPost] :: CardanoChainLog -> TxId
PostedTx :: TxId -> CardanoChainLog
[$sel:txId:ToPost] :: CardanoChainLog -> TxId
PostingFailed :: Tx -> PostTxError Tx -> CardanoChainLog
[$sel:tx:ToPost] :: CardanoChainLog -> Tx
[$sel:postTxError:ToPost] :: CardanoChainLog -> PostTxError Tx
RolledForward :: ChainPoint -> [TxId] -> CardanoChainLog
[$sel:point:ToPost] :: CardanoChainLog -> ChainPoint
[$sel:receivedTxIds:ToPost] :: CardanoChainLog -> [TxId]
RolledBackward :: ChainPoint -> CardanoChainLog
[$sel:point:ToPost] :: CardanoChainLog -> ChainPoint
Wallet :: TinyWalletLog -> CardanoChainLog
instance GHC.Exception.Type.Exception Hydra.Chain.Direct.Handlers.TimeConversionException
instance GHC.Show.Show Hydra.Chain.Direct.Handlers.TimeConversionException
instance GHC.Classes.Eq Hydra.Chain.Direct.Handlers.TimeConversionException
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Chain.Direct.Handlers.CardanoChainLog
instance GHC.Generics.Generic Hydra.Chain.Direct.Handlers.CardanoChainLog
instance GHC.Show.Show Hydra.Chain.Direct.Handlers.CardanoChainLog
instance GHC.Classes.Eq Hydra.Chain.Direct.Handlers.CardanoChainLog


-- | Chain component implementation which uses directly the Node-to-Client
--   protocols to submit "hand-rolled" transactions.
module Hydra.Chain.Direct
newtype () => NetworkMagic
NetworkMagic :: Word32 -> NetworkMagic
newtype DirectBackend
DirectBackend :: DirectOptions -> DirectBackend
[$sel:options:DirectBackend] :: DirectBackend -> DirectOptions

-- | The block type used in the node-to-client protocols.
type BlockType = BlockInMode
data DirectConnectException
DirectConnectException :: IOException -> SocketPath -> NetworkId -> DirectConnectException
[$sel:ioException:DirectConnectException] :: DirectConnectException -> IOException
[$sel:nodeSocket:DirectConnectException] :: DirectConnectException -> SocketPath
[$sel:networkId:DirectConnectException] :: DirectConnectException -> NetworkId

-- | Thrown when the user-provided custom point of intersection is unknown
--   to the local node. This may happen if users shut down their node
--   quickly after starting them and hold on a not-so-stable point of the
--   chain. When they turn the node back on, that point may no longer exist
--   on the network if a fork with deeper roots has been adopted in the
--   meantime.
newtype IntersectionNotFoundException
IntersectionNotFound :: ChainPoint -> IntersectionNotFoundException
[$sel:requestedPoint:IntersectionNotFound] :: IntersectionNotFoundException -> ChainPoint
data EraNotSupportedException
EraNotSupportedAnymore :: Text -> EraNotSupportedException
[$sel:otherEraName:EraNotSupportedAnymore] :: EraNotSupportedException -> Text
EraNotSupportedYet :: Text -> EraNotSupportedException
[$sel:otherEraName:EraNotSupportedAnymore] :: EraNotSupportedException -> Text
withDirectChain :: DirectBackend -> Tracer IO CardanoChainLog -> CardanoChainConfig -> ChainContext -> TinyWallet IO -> ChainStateHistory Tx -> ChainComponent Tx IO a
chainSyncClient :: forall m. (MonadSTM m, MonadThrow m) => ChainSyncHandler m -> TinyWallet m -> ChainPoint -> ChainSyncClient BlockType ChainPoint ChainTip m ()
txSubmissionClient :: forall m. (MonadSTM m, MonadDelay m) => Tracer m CardanoChainLog -> TQueue m (Tx, TMVar m (Maybe (PostTxError Tx))) -> LocalTxSubmissionClient TxInMode TxValidationErrorInCardanoMode m ()
instance GHC.Show.Show Hydra.Chain.Direct.DirectBackend
instance GHC.Classes.Eq Hydra.Chain.Direct.DirectBackend
instance GHC.Show.Show Hydra.Chain.Direct.DirectConnectException
instance GHC.Show.Show Hydra.Chain.Direct.IntersectionNotFoundException
instance GHC.Show.Show Hydra.Chain.Direct.EraNotSupportedException
instance GHC.Exception.Type.Exception Hydra.Chain.Direct.EraNotSupportedException
instance GHC.Exception.Type.Exception Hydra.Chain.Direct.IntersectionNotFoundException
instance GHC.Exception.Type.Exception Hydra.Chain.Direct.DirectConnectException
instance Hydra.Chain.Backend.ChainBackend Hydra.Chain.Direct.DirectBackend

module Hydra.Chain.Blockfrost
newtype BlockfrostBackend
BlockfrostBackend :: BlockfrostOptions -> BlockfrostBackend
[$sel:options:BlockfrostBackend] :: BlockfrostBackend -> BlockfrostOptions
withBlockfrostChain :: BlockfrostBackend -> Tracer IO CardanoChainLog -> CardanoChainConfig -> ChainContext -> TinyWallet IO -> ChainStateHistory Tx -> ChainComponent Tx IO a
newtype BlockfrostConnectException
BlockfrostConnectException :: IOException -> BlockfrostConnectException
[$sel:ioException:BlockfrostConnectException] :: BlockfrostConnectException -> IOException
blockfrostChain :: (MonadIO m, MonadCatch m, MonadAsync m, MonadDelay m) => Tracer m CardanoChainLog -> TQueue m (Tx, TMVar m (Maybe (PostTxError Tx))) -> Project -> ChainPoint -> ChainSyncHandler m -> TinyWallet m -> m ()
blockfrostChainFollow :: forall m. (MonadIO m, MonadCatch m, MonadSTM m, MonadDelay m) => Tracer m CardanoChainLog -> Project -> ChainPoint -> ChainSyncHandler m -> TinyWallet m -> m ()
rollForward :: (MonadIO m, MonadThrow m) => Tracer m CardanoChainLog -> Project -> ChainSyncHandler m -> TinyWallet m -> Integer -> BlockHash -> m BlockHash
blockfrostSubmissionClient :: forall m. (MonadIO m, MonadDelay m, MonadSTM m) => Project -> Tracer m CardanoChainLog -> TQueue m (Tx, TMVar m (Maybe (PostTxError Tx))) -> m ()
toChainPoint :: Block -> ChainPoint
data APIBlockfrostError
BlockfrostError :: Text -> APIBlockfrostError
DecodeError :: Text -> APIBlockfrostError
NotEnoughBlockConfirmations :: BlockHash -> APIBlockfrostError
MissingBlockNo :: BlockHash -> APIBlockfrostError
MissingBlockSlot :: Maybe Slot -> APIBlockfrostError
MissingNextBlockHash :: BlockHash -> APIBlockfrostError
isRetryable :: APIBlockfrostError -> Bool
toTx :: MonadThrow m => TransactionCBOR -> m Tx
fromChainPoint :: ChainPoint -> Text -> BlockHash
instance GHC.Show.Show Hydra.Chain.Blockfrost.BlockfrostBackend
instance GHC.Classes.Eq Hydra.Chain.Blockfrost.BlockfrostBackend
instance GHC.Show.Show Hydra.Chain.Blockfrost.BlockfrostConnectException
instance GHC.Exception.Type.Exception Hydra.Chain.Blockfrost.APIBlockfrostError
instance GHC.Show.Show Hydra.Chain.Blockfrost.APIBlockfrostError
instance GHC.Exception.Type.Exception Hydra.Chain.Blockfrost.BlockfrostConnectException
instance Hydra.Chain.Backend.ChainBackend Hydra.Chain.Blockfrost.BlockfrostBackend

module Hydra.Chain.Cardano
withCardanoChain :: forall a. Tracer IO CardanoChainLog -> CardanoChainConfig -> Party -> ChainStateHistory Tx -> ChainComponent Tx IO a

-- | Build the <a>ChainContext</a> from a <tt>ChainConfig</tt> and
--   additional information.
loadChainContext :: forall backend. ChainBackend backend => backend -> CardanoChainConfig -> Party -> IO ChainContext
mkTinyWallet :: forall backend. ChainBackend backend => backend -> Tracer IO CardanoChainLog -> CardanoChainConfig -> IO (TinyWallet IO)

module Hydra.API.WSServer
wsApp :: forall tx. IsChainState tx => Environment -> Party -> Tracer IO APIServerLog -> ConduitT () (TimedServerOutput tx) (ResourceT IO) () -> (ClientInput tx -> IO ()) -> Projection STM (StateChanged tx) (HeadState tx) -> Projection STM (StateChanged tx) (Maybe HeadId) -> TChan (Either (TimedServerOutput tx) (ClientMessage tx)) -> ServerOutputFilter tx -> PendingConnection -> IO ()

-- | Get the content of <a>$sel:headStatus:Greetings</a> field in
--   <a>Greetings</a> message from the full <a>HeadState</a>.
getHeadStatus :: HeadState tx -> HeadStatus

module Hydra.API.Server

-- | Handle to provide a means for sending server outputs to clients.
newtype Server tx m
Server :: (ClientMessage tx -> m ()) -> Server tx m

-- | Send some output to all connected clients.
[$sel:sendMessage:Server] :: Server tx m -> ClientMessage tx -> m ()
data APIServerConfig
APIServerConfig :: IP -> PortNumber -> Maybe FilePath -> Maybe FilePath -> ApiTransactionTimeout -> APIServerConfig
[$sel:host:APIServerConfig] :: APIServerConfig -> IP
[$sel:port:APIServerConfig] :: APIServerConfig -> PortNumber
[$sel:tlsCertPath:APIServerConfig] :: APIServerConfig -> Maybe FilePath
[$sel:tlsKeyPath:APIServerConfig] :: APIServerConfig -> Maybe FilePath
[$sel:apiTransactionTimeout:APIServerConfig] :: APIServerConfig -> ApiTransactionTimeout
withAPIServer :: forall tx. IsChainState tx => APIServerConfig -> Environment -> Party -> EventSource (StateEvent tx) IO -> Tracer IO APIServerLog -> Chain tx IO -> PParams LedgerEra -> ServerOutputFilter tx -> (ClientInput tx -> IO ()) -> ((EventSink (StateEvent tx) IO, Server tx IO) -> IO ()) -> IO ()

-- | An <a>IOException</a> with more <a>IP</a> and <a>PortNumber</a> added
--   as context.
data RunServerException
RunServerException :: IOException -> IP -> PortNumber -> RunServerException
[$sel:ioException:RunServerException] :: RunServerException -> IOException
[$sel:host:RunServerException] :: RunServerException -> IP
[$sel:port:RunServerException] :: RunServerException -> PortNumber
type NotifyServerRunning = IO ()
type WaitForServer = IO ()

-- | Setup notification and waiter to ensure that something only runs after
--   the server is actually listening.
setupServerNotification :: IO (NotifyServerRunning, WaitForServer)

-- | Defines the subset of <a>StateEvent</a> that should be sent as
--   <a>TimedServerOutput</a> to clients.
mkTimedServerOutputFromStateEvent :: IsTx tx => StateEvent tx -> Maybe (TimedServerOutput tx)

-- | Projection to obtain the list of pending deposits.
projectPendingDeposits :: IsTx tx => [TxIdType tx] -> StateChanged tx -> [TxIdType tx]

-- | Projection to obtain <a>CommitInfo</a> needed to draft commit
--   transactions. NOTE: We only want to project <a>HeadId</a> when the
--   Head is in the <tt>Initializing</tt> state since this is when Head
--   parties need to commit some funds.
projectCommitInfo :: CommitInfo -> StateChanged tx -> CommitInfo

-- | Projection to obtain the <a>HeadId</a> needed to draft a commit
--   transaction. NOTE: We only want to project <a>HeadId</a> when the Head
--   is in the <tt>Initializing</tt> state since this is when Head parties
--   need to commit some funds.
projectInitializingHeadId :: Maybe HeadId -> StateChanged tx -> Maybe HeadId
instance GHC.Show.Show Hydra.API.Server.RunServerException
instance GHC.Exception.Type.Exception Hydra.API.Server.RunServerException


-- | Top-level module to run a single Hydra node.
--   
--   Checkout <a>Hydra Documentation</a> for some details about the overall
--   architecture of the <tt>Node</tt>.
module Hydra.Node

-- | Initialize the <a>Environment</a> from command line options.
initEnvironment :: RunOptions -> IO Environment

-- | Checks that command line options match a given <a>HeadState</a>. This
--   function takes <a>Environment</a> because it is derived from
--   <a>RunOptions</a> via <a>initEnvironment</a>.
--   
--   Throws: <a>ParameterMismatch</a> when state not matching the
--   environment.
checkHeadState :: MonadThrow m => Tracer m (HydraNodeLog tx) -> Environment -> HeadState tx -> m ()

-- | A draft version of the <a>HydraNode</a> that holds state, but is not
--   yet connected (see <a>connect</a>). This is commonly created by the
--   <a>hydrate</a> smart constructor.
data DraftHydraNode tx m
DraftHydraNode :: Tracer m (HydraNodeLog tx) -> Environment -> Ledger tx -> NodeState tx m -> InputQueue m (Input tx) -> EventSource (StateEvent tx) m -> [EventSink (StateEvent tx) m] -> ChainStateHistory tx -> DraftHydraNode tx m
[$sel:tracer:DraftHydraNode] :: DraftHydraNode tx m -> Tracer m (HydraNodeLog tx)
[$sel:env:DraftHydraNode] :: DraftHydraNode tx m -> Environment
[$sel:ledger:DraftHydraNode] :: DraftHydraNode tx m -> Ledger tx
[$sel:nodeState:DraftHydraNode] :: DraftHydraNode tx m -> NodeState tx m
[$sel:inputQueue:DraftHydraNode] :: DraftHydraNode tx m -> InputQueue m (Input tx)
[$sel:eventSource:DraftHydraNode] :: DraftHydraNode tx m -> EventSource (StateEvent tx) m
[$sel:eventSinks:DraftHydraNode] :: DraftHydraNode tx m -> [EventSink (StateEvent tx) m]
[$sel:chainStateHistory:DraftHydraNode] :: DraftHydraNode tx m -> ChainStateHistory tx

-- | Hydrate a <a>DraftHydraNode</a> by loading events from source,
--   re-aggregate node state and sending events to sinks while doing so.
hydrate :: (IsChainState tx, MonadDelay m, MonadLabelledSTM m, MonadAsync m, MonadThrow m, MonadUnliftIO m) => Tracer m (HydraNodeLog tx) -> Environment -> Ledger tx -> ChainStateType tx -> EventStore (StateEvent tx) m -> [EventSink (StateEvent tx) m] -> m (DraftHydraNode tx m)
wireChainInput :: DraftHydraNode tx m -> ChainEvent tx -> m ()
wireClientInput :: DraftHydraNode tx m -> ClientInput tx -> m ()
wireNetworkInput :: DraftHydraNode tx m -> NetworkCallback (Authenticated (Message tx)) m

-- | Create a network input with corresponding default ttl from given
--   sender.
mkNetworkInput :: Party -> Message tx -> Input tx

-- | Connect chain, network and API to a hydrated <a>DraftHydraNode</a> to
--   get a fully connected <a>HydraNode</a>.
connect :: Monad m => Chain tx m -> Network m (Message tx) -> Server tx m -> DraftHydraNode tx m -> m (HydraNode tx m)

-- | Fully connected hydra node with everything wired in.
data HydraNode tx m
HydraNode :: Tracer m (HydraNodeLog tx) -> Environment -> Ledger tx -> NodeState tx m -> InputQueue m (Input tx) -> EventSource (StateEvent tx) m -> [EventSink (StateEvent tx) m] -> Chain tx m -> Network m (Message tx) -> Server tx m -> HydraNode tx m
[$sel:tracer:HydraNode] :: HydraNode tx m -> Tracer m (HydraNodeLog tx)
[$sel:env:HydraNode] :: HydraNode tx m -> Environment
[$sel:ledger:HydraNode] :: HydraNode tx m -> Ledger tx
[$sel:nodeState:HydraNode] :: HydraNode tx m -> NodeState tx m
[$sel:inputQueue:HydraNode] :: HydraNode tx m -> InputQueue m (Input tx)
[$sel:eventSource:HydraNode] :: HydraNode tx m -> EventSource (StateEvent tx) m
[$sel:eventSinks:HydraNode] :: HydraNode tx m -> [EventSink (StateEvent tx) m]
[$sel:oc:HydraNode] :: HydraNode tx m -> Chain tx m
[$sel:hn:HydraNode] :: HydraNode tx m -> Network m (Message tx)
[$sel:server:HydraNode] :: HydraNode tx m -> Server tx m
runHydraNode :: (MonadCatch m, MonadAsync m, MonadTime m, IsChainState tx) => HydraNode tx m -> m ()
stepHydraNode :: (MonadCatch m, MonadAsync m, MonadTime m, IsChainState tx) => HydraNode tx m -> m ()

-- | The maximum number of times to re-enqueue a network messages upon
--   <a>Wait</a>. outcome.
defaultTTL :: TTL

-- | The maximum number of times to re-enqueue <a>ReqTx</a> and
--   <a>ReqDec</a> network messages upon <a>Wait</a>.
defaultTxTTL :: TTL

-- | The time to wait between re-enqueuing a <a>Wait</a> outcome.
waitDelay :: DiffTime

-- | Monadic interface around <a>update</a>.
processNextInput :: IsChainState tx => HydraNode tx m -> Input tx -> STM m (Outcome tx)
processStateChanges :: (MonadSTM m, MonadTime m) => HydraNode tx m -> [StateChanged tx] -> m ()
processEffects :: (MonadAsync m, MonadCatch m, IsChainState tx) => HydraNode tx m -> Tracer m (HydraNodeLog tx) -> Word64 -> [Effect tx] -> m ()

-- | Handle to access and modify the state in the Hydra Node.
data NodeState tx m
NodeState :: (forall a. (HeadState tx -> (a, HeadState tx)) -> STM m a) -> STM m (HeadState tx) -> STM m EventId -> NodeState tx m
[$sel:modifyHeadState:NodeState] :: NodeState tx m -> forall a. (HeadState tx -> (a, HeadState tx)) -> STM m a
[$sel:queryHeadState:NodeState] :: NodeState tx m -> STM m (HeadState tx)
[$sel:getNextEventId:NodeState] :: NodeState tx m -> STM m EventId

-- | Initialize a new <a>NodeState</a>.
createNodeState :: MonadLabelledSTM m => Maybe EventId -> HeadState tx -> m (NodeState tx m)
data HydraNodeLog tx
BeginInput :: Party -> Word64 -> Input tx -> HydraNodeLog tx
[$sel:by:BeginInput] :: HydraNodeLog tx -> Party
[$sel:inputId:BeginInput] :: HydraNodeLog tx -> Word64
[$sel:input:BeginInput] :: HydraNodeLog tx -> Input tx
EndInput :: Party -> Word64 -> HydraNodeLog tx
[$sel:by:BeginInput] :: HydraNodeLog tx -> Party
[$sel:inputId:BeginInput] :: HydraNodeLog tx -> Word64
BeginEffect :: Party -> Word64 -> Word32 -> Effect tx -> HydraNodeLog tx
[$sel:by:BeginInput] :: HydraNodeLog tx -> Party
[$sel:inputId:BeginInput] :: HydraNodeLog tx -> Word64
[$sel:effectId:BeginInput] :: HydraNodeLog tx -> Word32
[$sel:effect:BeginInput] :: HydraNodeLog tx -> Effect tx
EndEffect :: Party -> Word64 -> Word32 -> HydraNodeLog tx
[$sel:by:BeginInput] :: HydraNodeLog tx -> Party
[$sel:inputId:BeginInput] :: HydraNodeLog tx -> Word64
[$sel:effectId:BeginInput] :: HydraNodeLog tx -> Word32
LogicOutcome :: Party -> Outcome tx -> HydraNodeLog tx
[$sel:by:BeginInput] :: HydraNodeLog tx -> Party
[$sel:outcome:BeginInput] :: HydraNodeLog tx -> Outcome tx
DroppedFromQueue :: Word64 -> Input tx -> HydraNodeLog tx
[$sel:inputId:BeginInput] :: HydraNodeLog tx -> Word64
[$sel:input:BeginInput] :: HydraNodeLog tx -> Input tx
LoadingState :: HydraNodeLog tx
LoadedState :: Last EventId -> HeadState tx -> HydraNodeLog tx
[$sel:lastEventId:BeginInput] :: HydraNodeLog tx -> Last EventId
[$sel:headState:BeginInput] :: HydraNodeLog tx -> HeadState tx
ReplayingState :: HydraNodeLog tx
Misconfiguration :: [ParamMismatch] -> HydraNodeLog tx
[$sel:misconfigurationErrors:BeginInput] :: HydraNodeLog tx -> [ParamMismatch]
instance GHC.Generics.Generic (Hydra.Node.HydraNodeLog tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Classes.Eq (Hydra.Node.HydraNodeLog tx)
instance Hydra.Chain.ChainState.IsChainState tx => GHC.Show.Show (Hydra.Node.HydraNodeLog tx)
instance Hydra.Chain.ChainState.IsChainState tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Node.HydraNodeLog tx)
instance Hydra.Tx.Party.HasParty (Hydra.Node.DraftHydraNode tx m)


-- | Aggregates all tracing messages in a single type.
--   
--   This module provides a central point where top-level traced messages
--   are grouped. This is useful for traces consumers that will need to do
--   something specific depending on various tracing messages, eg.
--   monitoring and metrics collection.
module Hydra.Logging.Messages
data HydraLog tx
DirectChain :: CardanoChainLog -> HydraLog tx
[$sel:directChain:DirectChain] :: HydraLog tx -> CardanoChainLog
APIServer :: APIServerLog -> HydraLog tx
[$sel:api:DirectChain] :: HydraLog tx -> APIServerLog
Network :: NetworkLog -> HydraLog tx
[$sel:network:DirectChain] :: HydraLog tx -> NetworkLog
Node :: HydraNodeLog tx -> HydraLog tx
[$sel:node:DirectChain] :: HydraLog tx -> HydraNodeLog tx
NodeOptions :: RunOptions -> HydraLog tx
[$sel:runOptions:DirectChain] :: HydraLog tx -> RunOptions
EnteringMainloop :: HydraLog tx
instance GHC.Generics.Generic (Hydra.Logging.Messages.HydraLog tx)
instance GHC.Classes.Eq (Hydra.Node.HydraNodeLog tx) => GHC.Classes.Eq (Hydra.Logging.Messages.HydraLog tx)
instance GHC.Show.Show (Hydra.Node.HydraNodeLog tx) => GHC.Show.Show (Hydra.Logging.Messages.HydraLog tx)
instance Data.Aeson.Types.ToJSON.ToJSON (Hydra.Node.HydraNodeLog tx) => Data.Aeson.Types.ToJSON.ToJSON (Hydra.Logging.Messages.HydraLog tx)


-- | Provides Prometheus-based metrics server based on <a>Tracer</a>
--   collection.
--   
--   To add a new metric, one needs to:
--   
--   <ul>
--   <li>Add a <a>MetricDefinition</a> to the <a>allMetrics</a> list,
--   providing a unique <a>Name</a>, the relevant constructor for the
--   <a>Metric</a> value and a registration function,</li>
--   <li>Update the <a>monitor</a> function to Handle relevant
--   <a>HydraLog</a> entries and update underlying Prometheus metrics
--   store. Nested helpers are provided to increase a <tt>Counter</tt> by
--   one (<tt>tick</tt>) and to <a>observe</a> some value in an
--   <tt>Histogram</tt>.</li>
--   </ul>
module Hydra.Logging.Monitoring

-- | Wraps a monadic action using a <a>Tracer</a> and capture metrics based
--   on traces. Given a <tt>portNumber</tt>, this wrapper starts a
--   Prometheus-compliant server on this port. This is a no-op if given
--   <a>Nothing</a>. This function is not polymorphic over the type of
--   messages because it needs to understand them in order to provide
--   meaningful metrics.
withMonitoring :: (MonadIO m, MonadAsync m, IsTx tx, MonadMonotonicTime m) => Maybe PortNumber -> Tracer m (HydraLog tx) -> (Tracer m (HydraLog tx) -> m ()) -> m ()

module Hydra.Node.Run
data ConfigurationException
ConfigurationException :: ProtocolParametersConversionError -> ConfigurationException
InvalidOptionException :: InvalidOptions -> ConfigurationException
run :: RunOptions -> IO ()
getGlobalsForChain :: ChainConfig -> IO Globals
data GlobalsTranslationException
GlobalsTranslationException :: GlobalsTranslationException

-- | Create new L2 ledger <a>Globals</a> from <a>GenesisParameters</a>.
--   
--   Throws at least <a>GlobalsTranslationException</a>
newGlobals :: MonadThrow m => GenesisParameters ShelleyEra -> m Globals
instance GHC.Show.Show Hydra.Node.Run.ConfigurationException
instance GHC.Show.Show Hydra.Node.Run.GlobalsTranslationException
instance GHC.Classes.Eq Hydra.Node.Run.GlobalsTranslationException
instance GHC.Exception.Type.Exception Hydra.Node.Run.GlobalsTranslationException
instance GHC.Exception.Type.Exception Hydra.Node.Run.ConfigurationException
